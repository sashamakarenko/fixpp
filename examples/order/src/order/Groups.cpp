// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <order/Groups.h>

namespace order
{

// start of Groups.cxx

// Generated

// -------------------------------------- getMessageName -------------------------------
const char * GroupLegStipulations::getMessageName(){
     return "LegStipulations";
}

const char * GroupNestedPartySubIDs::getMessageName(){
     return "NestedPartySubIDs";
}

const char * GroupNestedPartyIDs::getMessageName(){
     return "NestedPartyIDs";
}

const char * GroupLegs::getMessageName(){
     return "Legs";
}

// -------------------------------------- constructor ----------------------------------------
GroupLegStipulations::GroupLegStipulations(){

}

GroupNestedPartySubIDs::GroupNestedPartySubIDs(){

}

GroupNestedPartyIDs::GroupNestedPartyIDs(){

     groupsNestedPartySubIDs.assign( 10, {} );

}

GroupLegs::GroupLegs(){

     groupsLegStipulations.assign( 10, {} );

     groupsNestedPartyIDs.assign( 10, {} );

}

// ---------------------------------- getFieldDepth ---------------------------------
GetDepthMethod GroupLegStipulations::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartySubIDs::groupGetDepthMethods[] = {
   nullptr };

GetDepthMethod GroupNestedPartyIDs::groupGetDepthMethods[] = {
   GroupNestedPartySubIDs::getFieldDepth,
   nullptr };

GetDepthMethod GroupLegs::groupGetDepthMethods[] = {
   GroupLegStipulations::getFieldDepth,
   GroupNestedPartyIDs::getFieldDepth,
   nullptr };

FieldDepth GroupLegStipulations::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegStipulationType::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegStipulationValue::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartySubIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartySubID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartySubIDType::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupNestedPartyIDs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldNestedPartyID::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldNestedPartyIDSource::RAW_TAG :
     case FieldNestedPartyRole::RAW_TAG :
     case FieldNoNestedPartySubIDs::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth GroupLegs::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldLegSymbol::RAW_TAG :
     ret.isFirstInGroup = true;
     [[fallthrough]];
     case FieldLegSide::RAW_TAG :
     case FieldLegQty::RAW_TAG :
     case FieldNoLegStipulations::RAW_TAG :
     case FieldLegPositionEffect::RAW_TAG :
     case FieldNoNestedPartyIDs::RAW_TAG :
     case FieldLegRefID::RAW_TAG :
     case FieldLegPrice::RAW_TAG :
     case FieldLegLastPx::RAW_TAG :

     case 0: 
     ret.depth = 0;
     return ret;
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

// ---------------------------------- getFieldValue ---------------------------------
const char * GroupLegStipulations::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegStipulationType::TAG : return fieldLegStipulationType.offset > 0 ? _fixPtr + fieldLegStipulationType.offset : nullptr;
     case FieldLegStipulationValue::TAG : return fieldLegStipulationValue.offset > 0 ? _fixPtr + fieldLegStipulationValue.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartySubIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartySubID::TAG : return fieldNestedPartySubID.offset > 0 ? _fixPtr + fieldNestedPartySubID.offset : nullptr;
     case FieldNestedPartySubIDType::TAG : return fieldNestedPartySubIDType.offset > 0 ? _fixPtr + fieldNestedPartySubIDType.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldNestedPartyID::TAG : return fieldNestedPartyID.offset > 0 ? _fixPtr + fieldNestedPartyID.offset : nullptr;
     case FieldNestedPartyIDSource::TAG : return fieldNestedPartyIDSource.offset > 0 ? _fixPtr + fieldNestedPartyIDSource.offset : nullptr;
     case FieldNestedPartyRole::TAG : return fieldNestedPartyRole.offset > 0 ? _fixPtr + fieldNestedPartyRole.offset : nullptr;
     case FieldNoNestedPartySubIDs::TAG : return fieldNoNestedPartySubIDs.offset > 0 ? _fixPtr + fieldNoNestedPartySubIDs.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

const char * GroupLegs::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldLegSymbol::TAG : return fieldLegSymbol.offset > 0 ? _fixPtr + fieldLegSymbol.offset : nullptr;
     case FieldLegSide::TAG : return fieldLegSide.offset > 0 ? _fixPtr + fieldLegSide.offset : nullptr;
     case FieldLegQty::TAG : return fieldLegQty.offset > 0 ? _fixPtr + fieldLegQty.offset : nullptr;
     case FieldNoLegStipulations::TAG : return fieldNoLegStipulations.offset > 0 ? _fixPtr + fieldNoLegStipulations.offset : nullptr;
     case FieldLegPositionEffect::TAG : return fieldLegPositionEffect.offset > 0 ? _fixPtr + fieldLegPositionEffect.offset : nullptr;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0 ? _fixPtr + fieldNoNestedPartyIDs.offset : nullptr;
     case FieldLegRefID::TAG : return fieldLegRefID.offset > 0 ? _fixPtr + fieldLegRefID.offset : nullptr;
     case FieldLegPrice::TAG : return fieldLegPrice.offset > 0 ? _fixPtr + fieldLegPrice.offset : nullptr;
     case FieldLegLastPx::TAG : return fieldLegLastPx.offset > 0 ? _fixPtr + fieldLegLastPx.offset : nullptr;

     default : return nullptr; 
   }
   return nullptr;
}

// ---------------------------------- isFieldSet ---------------------------------
bool GroupLegStipulations::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldLegStipulationType::TAG : return fieldLegStipulationType.offset > 0 ;
     case FieldLegStipulationValue::TAG : return fieldLegStipulationValue.offset > 0;

     default : return false; 
   }
   return false;
}

bool GroupNestedPartySubIDs::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldNestedPartySubID::TAG : return fieldNestedPartySubID.offset > 0 ;
     case FieldNestedPartySubIDType::TAG : return fieldNestedPartySubIDType.offset > 0;

     default : return false; 
   }
   return false;
}

bool GroupNestedPartyIDs::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldNestedPartyID::TAG : return fieldNestedPartyID.offset > 0 ;
     case FieldNestedPartyIDSource::TAG : return fieldNestedPartyIDSource.offset > 0;
     case FieldNestedPartyRole::TAG : return fieldNestedPartyRole.offset > 0;
     case FieldNoNestedPartySubIDs::TAG : return fieldNoNestedPartySubIDs.offset > 0;

     default : return false; 
   }
   return false;
}

bool GroupLegs::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldLegSymbol::TAG : return fieldLegSymbol.offset > 0 ;
     case FieldLegSide::TAG : return fieldLegSide.offset > 0;
     case FieldLegQty::TAG : return fieldLegQty.offset > 0;
     case FieldNoLegStipulations::TAG : return fieldNoLegStipulations.offset > 0;
     case FieldLegPositionEffect::TAG : return fieldLegPositionEffect.offset > 0;
     case FieldNoNestedPartyIDs::TAG : return fieldNoNestedPartyIDs.offset > 0;
     case FieldLegRefID::TAG : return fieldLegRefID.offset > 0;
     case FieldLegPrice::TAG : return fieldLegPrice.offset > 0;
     case FieldLegLastPx::TAG : return fieldLegLastPx.offset > 0;

     default : return false; 
   }
   return false;
}

// ---------------------------------- getKnownFields ---------------------------------
namespace {
const std::vector<unsigned> LegStipulations_knownFields = { FieldLegStipulationType::TAG
, FieldLegStipulationValue::TAG
};

const std::vector<unsigned> NestedPartySubIDs_knownFields = { FieldNestedPartySubID::TAG
, FieldNestedPartySubIDType::TAG
};

const std::vector<unsigned> NestedPartyIDs_knownFields = { FieldNestedPartyID::TAG
, FieldNestedPartyIDSource::TAG
, FieldNestedPartyRole::TAG
, FieldNoNestedPartySubIDs::TAG
};

const std::vector<unsigned> Legs_knownFields = { FieldLegSymbol::TAG
, FieldLegSide::TAG
, FieldLegQty::TAG
, FieldNoLegStipulations::TAG
, FieldLegPositionEffect::TAG
, FieldNoNestedPartyIDs::TAG
, FieldLegRefID::TAG
, FieldLegPrice::TAG
, FieldLegLastPx::TAG
};

}

const std::vector<unsigned> & GroupLegStipulations::getKnownFields(){ return LegStipulations_knownFields; }

const std::vector<unsigned> & GroupNestedPartySubIDs::getKnownFields(){ return NestedPartySubIDs_knownFields; }

const std::vector<unsigned> & GroupNestedPartyIDs::getKnownFields(){ return NestedPartyIDs_knownFields; }

const std::vector<unsigned> & GroupLegs::getKnownFields(){ return Legs_knownFields; }
// end of Groups.cxx

} // namespace order
