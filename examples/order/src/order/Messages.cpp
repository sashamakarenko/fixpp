// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <vector>
#include <set>

#include <order/Messages.h>

namespace order
{

// start of Messages.cxx

// Generated

// -------------------------- getMessageName getMessageType -------------------------

const std::string EMPTY_STRING;

const char * MessageHeader::getMessageName(){
     return "Header";
}

const std::string & MessageHeader::getMessageType(){
     return EMPTY_STRING;
}


const char * MessageNewOrderSingle::getMessageName(){
     return "NewOrderSingle";
}

const std::string & MessageNewOrderSingle::getMessageType(){
     return MsgTypeEnums::NEW_ORDER_SINGLE.str;
}


const char * MessageExecutionReport::getMessageName(){
     return "ExecutionReport";
}

const std::string & MessageExecutionReport::getMessageType(){
     return MsgTypeEnums::EXECUTION_REPORT.str;
}


// ---------------------------------- fields ---------------------------------

GetDepthMethod MessageHeader::groupGetDepthMethods[] = {
  nullptr };

GetDepthMethod MessageNewOrderSingle::groupGetDepthMethods[] = {
  nullptr };

GetDepthMethod MessageExecutionReport::groupGetDepthMethods[] = {
  GroupLegs::getFieldDepth,
  nullptr };


FieldDepth MessageHeader::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldBeginString::RAW_TAG :
     case FieldBodyLength::RAW_TAG :
     case FieldMsgType::RAW_TAG :
     case FieldSenderCompID::RAW_TAG :
     case FieldTargetCompID::RAW_TAG :
     case FieldMsgSeqNum::RAW_TAG :
     case FieldSendingTime::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth MessageNewOrderSingle::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldClOrdID::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldSymbol::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldQtyType::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldOrdType::RAW_TAG :
     case FieldPrice::RAW_TAG :
     case FieldStopPx::RAW_TAG :
     case FieldTransactTime::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}

FieldDepth MessageExecutionReport::getFieldDepth( raw_tag_t tag ){
   FieldDepth ret;
   switch( tag ){
     case FieldOrderID::RAW_TAG :
     case FieldClOrdID::RAW_TAG :
     case FieldOrigClOrdID::RAW_TAG :
     case FieldExecID::RAW_TAG :
     case FieldExecType::RAW_TAG :
     case FieldOrdStatus::RAW_TAG :
     case FieldOrdRejReason::RAW_TAG :
     case FieldAccount::RAW_TAG :
     case FieldSymbol::RAW_TAG :
     case FieldSecurityID::RAW_TAG :
     case FieldSecurityType::RAW_TAG :
     case FieldText::RAW_TAG :
     case FieldProduct::RAW_TAG :
     case FieldSide::RAW_TAG :
     case FieldQtyType::RAW_TAG :
     case FieldOrderQty::RAW_TAG :
     case FieldOrdType::RAW_TAG :
     case FieldPriceType::RAW_TAG :
     case FieldPrice::RAW_TAG :
     case FieldStopPx::RAW_TAG :
     case FieldCurrency::RAW_TAG :
     case FieldTimeInForce::RAW_TAG :
     case FieldExecInst::RAW_TAG :
     case FieldLastQty::RAW_TAG :
     case FieldLastPx::RAW_TAG :
     case FieldLeavesQty::RAW_TAG :
     case FieldAvgPx::RAW_TAG :
     case FieldCumQty::RAW_TAG :
     case FieldNoLegs::RAW_TAG :
     case FieldCheckSum::RAW_TAG :
     ret.depth = 0; 
     return ret; 
   }
   for( auto m : groupGetDepthMethods ) if( m ){
     FieldDepth gdepth = (*m)( tag ); 
     if( gdepth.depth >= 0 ) { return gdepth.inc(); }
   }
   return ret;
}


// ---------------------------------- getFieldValue ---------------------------------

const char * MessageHeader::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldBeginString::TAG : return fieldBeginString.offset > 0 ? _fixPtr + fieldBeginString.offset : nullptr;
     case FieldBodyLength::TAG : return fieldBodyLength.offset > 0 ? _fixPtr + fieldBodyLength.offset : nullptr;
     case FieldMsgType::TAG : return fieldMsgType.offset > 0 ? _fixPtr + fieldMsgType.offset : nullptr;
     case FieldSenderCompID::TAG : return fieldSenderCompID.offset > 0 ? _fixPtr + fieldSenderCompID.offset : nullptr;
     case FieldTargetCompID::TAG : return fieldTargetCompID.offset > 0 ? _fixPtr + fieldTargetCompID.offset : nullptr;
     case FieldMsgSeqNum::TAG : return fieldMsgSeqNum.offset > 0 ? _fixPtr + fieldMsgSeqNum.offset : nullptr;
     case FieldSendingTime::TAG : return fieldSendingTime.offset > 0 ? _fixPtr + fieldSendingTime.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0 ? _fixPtr + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}

const char * MessageNewOrderSingle::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0 ? _fixPtr + fieldClOrdID.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset > 0 ? _fixPtr + fieldAccount.offset : nullptr;
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldQtyType::TAG : return fieldQtyType.offset > 0 ? _fixPtr + fieldQtyType.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0 ? _fixPtr + fieldOrderQty.offset : nullptr;
     case FieldOrdType::TAG : return fieldOrdType.offset > 0 ? _fixPtr + fieldOrdType.offset : nullptr;
     case FieldPrice::TAG : return fieldPrice.offset > 0 ? _fixPtr + fieldPrice.offset : nullptr;
     case FieldStopPx::TAG : return fieldStopPx.offset > 0 ? _fixPtr + fieldStopPx.offset : nullptr;
     case FieldTransactTime::TAG : return fieldTransactTime.offset > 0 ? _fixPtr + fieldTransactTime.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0 ? _fixPtr + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}

const char * MessageExecutionReport::getFieldValue( unsigned tag ) const {
   if( _fixPtr == nullptr ) return nullptr;
   switch( tag ){
     case FieldOrderID::TAG : return fieldOrderID.offset > 0 ? _fixPtr + fieldOrderID.offset : nullptr;
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0 ? _fixPtr + fieldClOrdID.offset : nullptr;
     case FieldOrigClOrdID::TAG : return fieldOrigClOrdID.offset > 0 ? _fixPtr + fieldOrigClOrdID.offset : nullptr;
     case FieldExecID::TAG : return fieldExecID.offset > 0 ? _fixPtr + fieldExecID.offset : nullptr;
     case FieldExecType::TAG : return fieldExecType.offset > 0 ? _fixPtr + fieldExecType.offset : nullptr;
     case FieldOrdStatus::TAG : return fieldOrdStatus.offset > 0 ? _fixPtr + fieldOrdStatus.offset : nullptr;
     case FieldOrdRejReason::TAG : return fieldOrdRejReason.offset > 0 ? _fixPtr + fieldOrdRejReason.offset : nullptr;
     case FieldAccount::TAG : return fieldAccount.offset > 0 ? _fixPtr + fieldAccount.offset : nullptr;
     case FieldSymbol::TAG : return fieldSymbol.offset > 0 ? _fixPtr + fieldSymbol.offset : nullptr;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0 ? _fixPtr + fieldSecurityID.offset : nullptr;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0 ? _fixPtr + fieldSecurityType.offset : nullptr;
     case FieldText::TAG : return fieldText.offset > 0 ? _fixPtr + fieldText.offset : nullptr;
     case FieldProduct::TAG : return fieldProduct.offset > 0 ? _fixPtr + fieldProduct.offset : nullptr;
     case FieldSide::TAG : return fieldSide.offset > 0 ? _fixPtr + fieldSide.offset : nullptr;
     case FieldQtyType::TAG : return fieldQtyType.offset > 0 ? _fixPtr + fieldQtyType.offset : nullptr;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0 ? _fixPtr + fieldOrderQty.offset : nullptr;
     case FieldOrdType::TAG : return fieldOrdType.offset > 0 ? _fixPtr + fieldOrdType.offset : nullptr;
     case FieldPriceType::TAG : return fieldPriceType.offset > 0 ? _fixPtr + fieldPriceType.offset : nullptr;
     case FieldPrice::TAG : return fieldPrice.offset > 0 ? _fixPtr + fieldPrice.offset : nullptr;
     case FieldStopPx::TAG : return fieldStopPx.offset > 0 ? _fixPtr + fieldStopPx.offset : nullptr;
     case FieldCurrency::TAG : return fieldCurrency.offset > 0 ? _fixPtr + fieldCurrency.offset : nullptr;
     case FieldTimeInForce::TAG : return fieldTimeInForce.offset > 0 ? _fixPtr + fieldTimeInForce.offset : nullptr;
     case FieldExecInst::TAG : return fieldExecInst.offset > 0 ? _fixPtr + fieldExecInst.offset : nullptr;
     case FieldLastQty::TAG : return fieldLastQty.offset > 0 ? _fixPtr + fieldLastQty.offset : nullptr;
     case FieldLastPx::TAG : return fieldLastPx.offset > 0 ? _fixPtr + fieldLastPx.offset : nullptr;
     case FieldLeavesQty::TAG : return fieldLeavesQty.offset > 0 ? _fixPtr + fieldLeavesQty.offset : nullptr;
     case FieldAvgPx::TAG : return fieldAvgPx.offset > 0 ? _fixPtr + fieldAvgPx.offset : nullptr;
     case FieldCumQty::TAG : return fieldCumQty.offset > 0 ? _fixPtr + fieldCumQty.offset : nullptr;
     case FieldNoLegs::TAG : return fieldNoLegs.offset > 0 ? _fixPtr + fieldNoLegs.offset : nullptr;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0 ? _fixPtr + fieldCheckSum.offset : nullptr; 
     default : return nullptr; 
   }
   return nullptr;
}


// ---------------------------------- isFieldSet ---------------------------------

bool MessageHeader::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldBeginString::TAG : return fieldBeginString.offset > 0;
     case FieldBodyLength::TAG : return fieldBodyLength.offset > 0;
     case FieldMsgType::TAG : return fieldMsgType.offset > 0;
     case FieldSenderCompID::TAG : return fieldSenderCompID.offset > 0;
     case FieldTargetCompID::TAG : return fieldTargetCompID.offset > 0;
     case FieldMsgSeqNum::TAG : return fieldMsgSeqNum.offset > 0;
     case FieldSendingTime::TAG : return fieldSendingTime.offset > 0;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0; 
     default : return false; 
   }
   return false;
}

bool MessageNewOrderSingle::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0;
     case FieldAccount::TAG : return fieldAccount.offset > 0;
     case FieldSymbol::TAG : return fieldSymbol.offset > 0;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0;
     case FieldSide::TAG : return fieldSide.offset > 0;
     case FieldQtyType::TAG : return fieldQtyType.offset > 0;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0;
     case FieldOrdType::TAG : return fieldOrdType.offset > 0;
     case FieldPrice::TAG : return fieldPrice.offset > 0;
     case FieldStopPx::TAG : return fieldStopPx.offset > 0;
     case FieldTransactTime::TAG : return fieldTransactTime.offset > 0;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0; 
     default : return false; 
   }
   return false;
}

bool MessageExecutionReport::isFieldSet( unsigned tag ) const {
   if( _fixPtr == nullptr ) return false;
   switch( tag ){
     case FieldOrderID::TAG : return fieldOrderID.offset > 0;
     case FieldClOrdID::TAG : return fieldClOrdID.offset > 0;
     case FieldOrigClOrdID::TAG : return fieldOrigClOrdID.offset > 0;
     case FieldExecID::TAG : return fieldExecID.offset > 0;
     case FieldExecType::TAG : return fieldExecType.offset > 0;
     case FieldOrdStatus::TAG : return fieldOrdStatus.offset > 0;
     case FieldOrdRejReason::TAG : return fieldOrdRejReason.offset > 0;
     case FieldAccount::TAG : return fieldAccount.offset > 0;
     case FieldSymbol::TAG : return fieldSymbol.offset > 0;
     case FieldSecurityID::TAG : return fieldSecurityID.offset > 0;
     case FieldSecurityType::TAG : return fieldSecurityType.offset > 0;
     case FieldText::TAG : return fieldText.offset > 0;
     case FieldProduct::TAG : return fieldProduct.offset > 0;
     case FieldSide::TAG : return fieldSide.offset > 0;
     case FieldQtyType::TAG : return fieldQtyType.offset > 0;
     case FieldOrderQty::TAG : return fieldOrderQty.offset > 0;
     case FieldOrdType::TAG : return fieldOrdType.offset > 0;
     case FieldPriceType::TAG : return fieldPriceType.offset > 0;
     case FieldPrice::TAG : return fieldPrice.offset > 0;
     case FieldStopPx::TAG : return fieldStopPx.offset > 0;
     case FieldCurrency::TAG : return fieldCurrency.offset > 0;
     case FieldTimeInForce::TAG : return fieldTimeInForce.offset > 0;
     case FieldExecInst::TAG : return fieldExecInst.offset > 0;
     case FieldLastQty::TAG : return fieldLastQty.offset > 0;
     case FieldLastPx::TAG : return fieldLastPx.offset > 0;
     case FieldLeavesQty::TAG : return fieldLeavesQty.offset > 0;
     case FieldAvgPx::TAG : return fieldAvgPx.offset > 0;
     case FieldCumQty::TAG : return fieldCumQty.offset > 0;
     case FieldNoLegs::TAG : return fieldNoLegs.offset > 0;
     case FieldCheckSum::TAG : return fieldCheckSum.offset > 0; 
     default : return false; 
   }
   return false;
}


// ---------------------------------- getKnownFields ---------------------------------
namespace {

const std::vector<tag_t> Header_knownFields = {
FieldBeginString::TAG,
FieldBodyLength::TAG,
FieldMsgType::TAG,
FieldSenderCompID::TAG,
FieldTargetCompID::TAG,
FieldMsgSeqNum::TAG,
FieldSendingTime::TAG,
FieldCheckSum::TAG };

const std::vector<tag_t> NewOrderSingle_knownFields = {
FieldClOrdID::TAG,
FieldAccount::TAG,
FieldSymbol::TAG,
FieldSecurityID::TAG,
FieldSide::TAG,
FieldQtyType::TAG,
FieldOrderQty::TAG,
FieldOrdType::TAG,
FieldPrice::TAG,
FieldStopPx::TAG,
FieldTransactTime::TAG,
FieldCheckSum::TAG };

const std::vector<tag_t> ExecutionReport_knownFields = {
FieldOrderID::TAG,
FieldClOrdID::TAG,
FieldOrigClOrdID::TAG,
FieldExecID::TAG,
FieldExecType::TAG,
FieldOrdStatus::TAG,
FieldOrdRejReason::TAG,
FieldAccount::TAG,
FieldSymbol::TAG,
FieldSecurityID::TAG,
FieldSecurityType::TAG,
FieldText::TAG,
FieldProduct::TAG,
FieldSide::TAG,
FieldQtyType::TAG,
FieldOrderQty::TAG,
FieldOrdType::TAG,
FieldPriceType::TAG,
FieldPrice::TAG,
FieldStopPx::TAG,
FieldCurrency::TAG,
FieldTimeInForce::TAG,
FieldExecInst::TAG,
FieldLastQty::TAG,
FieldLastPx::TAG,
FieldLeavesQty::TAG,
FieldAvgPx::TAG,
FieldCumQty::TAG,
FieldNoLegs::TAG,
FieldCheckSum::TAG };

}


const std::vector<tag_t> & MessageHeader::getKnownFields(){ return Header_knownFields; }

const std::vector<tag_t> & MessageNewOrderSingle::getKnownFields(){ return NewOrderSingle_knownFields; }

const std::vector<tag_t> & MessageExecutionReport::getKnownFields(){ return ExecutionReport_knownFields; }


GetDepthMethod getTagDepthMethodByRawMsgType( raw_enum_t rawMsgType ){
  switch( rawMsgType ){

   case MsgTypeRaw__ :
     return MessageHeader::getFieldDepth;

   case MsgTypeRaw_NEW_ORDER_SINGLE :
     return MessageNewOrderSingle::getFieldDepth;

   case MsgTypeRaw_EXECUTION_REPORT :
     return MessageExecutionReport::getFieldDepth;
  }
  return nullptr;
}


// -------------------------------------- ParserDispatcher ----------------------------------------


const char * ParserDispatcher::parseAndDipatch( const char * buf, unsigned len, bool resetMessage )
{
    if( resetMessage )
    {
        _msgHeader.reset();
    }
    offset_t pos = _msgHeader.scan( buf, len );

    unsigned bodyLength = _msgHeader.getBodyLength();
    const char * endOfMessage = _msgHeader.ptrToMsgType() + bodyLength + 4; // 7 for checkSum - 3 for msg type tag
    if( endOfMessage - buf > (std::ptrdiff_t)len )
    {
        return nullptr;
    }

    const raw_enum_t msgType = toRawEnum( _msgHeader.ptrToMsgType() );
    if( ignoreMessage( msgType ) )
    {
      return endOfMessage;
    }

    buf += pos;
    switch( msgType )
    {


// case-begin-_
// After generation one can sed this out if _ is not incoming message
      case MsgTypeRaw__ : {
       if( resetMessage ) _msgHeader.reset();
       pos = _msgHeader.scan( buf, len - pos );
       onMessage( _msgHeader );
       break;
      }
// case-end-_


// case-begin-NEW_ORDER_SINGLE
// After generation one can sed this out if NEW_ORDER_SINGLE is not incoming message
      case MsgTypeRaw_NEW_ORDER_SINGLE : {
       if( resetMessage ) _msgNewOrderSingle.reset();
       pos = _msgNewOrderSingle.scan( buf, len - pos );
       onMessage( _msgNewOrderSingle );
       break;
      }
// case-end-NEW_ORDER_SINGLE


// case-begin-EXECUTION_REPORT
// After generation one can sed this out if EXECUTION_REPORT is not incoming message
      case MsgTypeRaw_EXECUTION_REPORT : {
       if( resetMessage ) _msgExecutionReport.reset();
       pos = _msgExecutionReport.scan( buf, len - pos );
       onMessage( _msgExecutionReport );
       break;
      }
// case-end-EXECUTION_REPORT


      default:
        onUnknownMessage( msgType );
        return endOfMessage;
    }
    return buf + pos;
}

void ParserDispatcher::onMessage( MessageHeader & msg )
{
   unprocessedMessage( MsgTypeRaw__, msg ); 
   msg.reset(); 
}


void ParserDispatcher::onMessage( MessageNewOrderSingle & msg )
{
   unprocessedMessage( MsgTypeRaw_NEW_ORDER_SINGLE, msg ); 
   msg.reset(); 
}


void ParserDispatcher::onMessage( MessageExecutionReport & msg )
{
   unprocessedMessage( MsgTypeRaw_EXECUTION_REPORT, msg ); 
   msg.reset(); 
}


// end of Messages.cxx


ParserDispatcher::ParserDispatcher()
{
}

ParserDispatcher::~ParserDispatcher()
{
}

void ParserDispatcher::onUnknownMessage( raw_enum_t msgType )
{
}

bool ParserDispatcher::ignoreMessage( raw_enum_t msgType ) const
{
    return false;
}

void ParserDispatcher::unprocessedMessage( raw_enum_t msgType, MessageBase & msg )
{
}

std::set< raw_tag_t > headerRawTags =
{
// start of HeaderRaw.cxx
 FieldBeginString::RAW_TAG,
 FieldBodyLength::RAW_TAG,
 FieldMsgType::RAW_TAG,
 FieldSenderCompID::RAW_TAG,
 FieldTargetCompID::RAW_TAG,
 FieldMsgSeqNum::RAW_TAG,
 FieldSendingTime::RAW_TAG,
// end of HeaderRaw.cxx
};

const FixFormatStyle defaultStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = " ",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "",
    .tagNameStop        = "",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "",
    .unknownStop        = ""
};

const FixFormatStyle defaultVerticalStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " *",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "",
    .tagNameStop        = "",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "",
    .unknownStop        = ""
};

const FixFormatStyle ttyStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " \u2022",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "",
    .headerTagNameStop  = "",
    .tagNameStart       = "\e[1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "(",
    .tagValueStop       = ")",
    .equal              = "=",
    .valueStart         = "",
    .valueStop          = "",
    .enumStart          = "<",
    .enumStop           = ">",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

const FixFormatStyle ttyRgbStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "  ",
    .groupFirstField    = " \u2022",
    .fieldBegin         = " ",
    .fieldEnd           = "\n",
    .headerTagNameStart = "\e[33m",
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = "\e[33;1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "(\e[37;1m",
    .tagValueStop       = "\e[0m)",
    .equal              = " = ",
    .valueStart         = "\e[34;1m",
    .valueStop          = "\e[0m",
    .enumStart          = " \e[32m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

const FixFormatStyle ttyRgbSingleLineStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = "  ",
    .headerTagNameStart = "\e[33m",
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = "\e[33;1m",
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "<\e[37;1m",
    .tagValueStop       = "\e[0m>",
    .equal              = "=",
    .valueStart         = "\e[34;1m",
    .valueStop          = "\e[0m",
    .enumStart          = "/\e[32m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

// no tag names
const FixFormatStyle ttyRgbRawStyle =
{
    .messageBegin       = "",
    .messageEnd         = "",
    .indent             = "",
    .groupFirstField    = "",
    .fieldBegin         = "",
    .fieldEnd           = " ",
    .headerTagNameStart = nullptr,
    .headerTagNameStop  = "\e[0m",
    .tagNameStart       = nullptr,
    .tagNameStop        = "\e[0m",
    .tagValueStart      = "\e[93;1m",
    .tagValueStop       = "\e[0m",
    .equal              = "=",
    .valueStart         = "\e[37;1m",
    .valueStop          = "\e[0m",
    .enumStart          = "/\e[92m",
    .enumStop           = "\e[0m",
    .unknownStart       = "\e[31;1m",
    .unknownStop        = "\e[0m"
};

// msgTypePos = offset of 35=
unsigned parseMessageLength( const char * fix, unsigned & msgTypePos )
{
    unsigned bodyLengthPos = msgTypePos = FixBeginStringValue.size() + 5; // 8=| + 9=|
    return parseUInt( fix + bodyLengthPos, ++msgTypePos );
}


unsigned computeChecksum( const char * begin, const char * end )
{
    unsigned sum = 0;
    while( begin < end )
    {
        sum += (unsigned)*begin++;
    }
    return sum & 0xff;
}

const char * getEnumName( const char * fix, int valueOffset )
{
    if( valueOffset < 0 )
    {
        return nullptr;
    }

    offset_t pos = (offset_t)valueOffset;
    while( pos > 0 and fix[pos-1] != FIXPP_SOH )
    {
        --pos;
    }

    const raw_tag_t tag = loadRawTag( fix+pos, pos );
    if( tag == 0 )
    {
        return nullptr;
    }

    auto eit = RAW_TO_ENUM.find( tag );
    if( eit == RAW_TO_ENUM.end() )
    {
        return nullptr;
    }
    const FieldEnumsBase * enums = eit->second;
    raw_enum_t rawEnum = toRawEnum( fix + valueOffset );
    const char * enumName = enums->getEnumNameByRaw( rawEnum );
    return enumName;
}

std::ostream & fixToHuman( const char * fix, offset_t & pos, std::ostream & os, const FixFormatStyle & style, GetDepthMethod indentator )
{
    os << style.messageBegin;

    while( fix[pos] )
    {
        offset_t prev = pos;
        const raw_tag_t tag = loadRawTag( fix+pos, pos );

        if( tag == 0 )
        {
            os << style.unknownStart << "[bad tag at " << pos << "]" << style.unknownStop << style.messageEnd;
            return os;
        }

        os << style.fieldBegin;

        auto it = RAW_TAG_TO_NAME.find( tag );
        const FieldEnumsBase * enums = nullptr;
        if( it != RAW_TAG_TO_NAME.end() )
        {
            if( headerRawTags.find( tag ) != headerRawTags.end() )
            {
                if( style.headerTagNameStart )
                {
                    os << style.headerTagNameStart << it->second << style.headerTagNameStop;
                }
            }
            else
            {
                if( indentator and indentator != autoIndentFields )
                {
                    FieldDepth fd = (*indentator)( tag );
                    if( fd.isFirstInGroup )
                    {
                        for( int d = 1; d < fd.depth; ++d ) os << style.indent;
                        os << style.groupFirstField;
                    }
                    else
                    {
                        for( int d = 0; d < fd.depth; ++d ) os << style.indent;
                    }
                }
                if( style.tagNameStart )
                {
                    os << style.tagNameStart << it->second << style.tagNameStop;
                }
            }

            auto eit = RAW_TO_ENUM.find( tag );
            if( eit != RAW_TO_ENUM.end() )
            {
                enums = eit->second;
            }
        }
        else
        {
            os << style.unknownStart << " ?" << style.unknownStop;
        }

        // tag
        os << style.tagValueStart;
        while( fix[prev] != '=' )
        {
            os << fix[prev++];
        }
        os << style.tagValueStop << style.equal << style.valueStart;

        raw_enum_t rawEnum = toRawEnum( fix + pos );

        // value as is
        while( fix[pos] and fix[pos] != FIXPP_SOH )
        {
            os << fix[pos++];
        }

        os << style.valueStop;

        // enum
        if( enums and style.enumStart )
        {
            const char * enumName = enums->getEnumNameByRaw( rawEnum );
            if( enumName )
            {
                os << style.enumStart << enumName << style.enumStop;
            }
            else
            {
                os << style.unknownStart << " UNKNOWN" << style.unknownStop;
            }

            if( tag == FieldMsgType::RAW_TAG and indentator == autoIndentFields )
            {
                indentator = getTagDepthMethodByRawMsgType( rawEnum );
            }

        }

        os << style.fieldEnd;
        os.flush();

        ++pos;
        if( tag == FieldCheckSum::RAW_TAG )
        {
            break;
        }

    }
    os << style.messageEnd;
    return os;
}

} // namespace order

// gdb helper
extern "C" const char * fixppGetEnumName( const char * fix, int valueOffset )
{
    return order::getEnumName( fix, valueOffset );
}
