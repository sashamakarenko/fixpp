
// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <order/Groups.h>

namespace order
{

// start of GroupScanners.cxx

// Generated


// -------------------------------------- scan ----------------------------------------
offset_t GroupLegStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationValue)
     group->fieldLegStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     group->fieldNestedPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     group->fieldNestedPartyIDSource.offset = gpos;
     break;

   case FieldNestedPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyRole)
     group->fieldNestedPartyRole.offset = gpos;
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs)
     group->fieldNoNestedPartySubIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::scan( group->groupsNestedPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSide::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSide)
     group->fieldLegSide.offset = gpos;
     break;

   case FieldLegQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegQty)
     group->fieldLegQty.offset = gpos;
     break;

   case FieldNoLegStipulations::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegStipulations)
     group->fieldNoLegStipulations.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::scan( group->groupsLegStipulations, fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPositionEffect)
     group->fieldLegPositionEffect.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRefID)
     group->fieldLegRefID.offset = gpos;
     break;

   case FieldLegPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPrice)
     group->fieldLegPrice.offset = gpos;
     break;

   case FieldLegLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LegLastPx)
     group->fieldLegLastPx.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}


// -------------------------------------- scanSafely ----------------------------------------
offset_t GroupLegStipulations::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 groupCount = 0; 
bool keepScanning = true;
while( pos < (int)len and keepScanning ) {
   bool isGroupStart = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) break;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == 1 ) break;
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG :
     FIXPP_PRINT_FIELD(LegStipulationValue)
     if( group->fieldLegStipulationValue.offset < 0 ) group->fieldLegStipulationValue.offset = pos;
     else keepScanning = false;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 groupCount = 0; 
bool keepScanning = true;
while( pos < (int)len and keepScanning ) {
   bool isGroupStart = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) break;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == 1 ) break;
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     if( group->fieldNestedPartySubIDType.offset < 0 ) group->fieldNestedPartySubIDType.offset = pos;
     else keepScanning = false;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 groupCount = 0; 
bool keepScanning = true;
while( pos < (int)len and keepScanning ) {
   bool isGroupStart = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) break;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == 1 ) break;
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     if( group->fieldNestedPartyIDSource.offset < 0 ) group->fieldNestedPartyIDSource.offset = pos;
     else keepScanning = false;
     break;

   case FieldNestedPartyRole::RAW_TAG :
     FIXPP_PRINT_FIELD(NestedPartyRole)
     if( group->fieldNestedPartyRole.offset < 0 ) group->fieldNestedPartyRole.offset = pos;
     else keepScanning = false;
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs) 
     if( group->fieldNoNestedPartySubIDs.offset < 0 ){
       group->fieldNoNestedPartySubIDs.offset = pos;
       isGroupStart = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartySubIDs::scanSafely( group->groupsNestedPartySubIDs, fix+pos, len - pos, groupFound );
       if( (int)groupFound != groupExpected ) keepScanning = false;
       }
     } else keepScanning = false;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 const char * groupBuf = fix; 
 groupCount = 0; 
bool keepScanning = true;
while( pos < (int)len and keepScanning ) {
   bool isGroupStart = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) break;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == 1 ) break;
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSide::RAW_TAG :
     FIXPP_PRINT_FIELD(LegSide)
     if( group->fieldLegSide.offset < 0 ) group->fieldLegSide.offset = pos;
     else keepScanning = false;
     break;

   case FieldLegQty::RAW_TAG :
     FIXPP_PRINT_FIELD(LegQty)
     if( group->fieldLegQty.offset < 0 ) group->fieldLegQty.offset = pos;
     else keepScanning = false;
     break;

   case FieldNoLegStipulations::RAW_TAG :
     FIXPP_PRINT_FIELD(NoLegStipulations) 
     if( group->fieldNoLegStipulations.offset < 0 ){
       group->fieldNoLegStipulations.offset = pos;
       isGroupStart = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupLegStipulations::scanSafely( group->groupsLegStipulations, fix+pos, len - pos, groupFound );
       if( (int)groupFound != groupExpected ) keepScanning = false;
       }
     } else keepScanning = false;
     break;

   case FieldLegPositionEffect::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPositionEffect)
     if( group->fieldLegPositionEffect.offset < 0 ) group->fieldLegPositionEffect.offset = pos;
     else keepScanning = false;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     FIXPP_PRINT_FIELD(NoNestedPartyIDs) 
     if( group->fieldNoNestedPartyIDs.offset < 0 ){
       group->fieldNoNestedPartyIDs.offset = pos;
       isGroupStart = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartyIDs::scanSafely( group->groupsNestedPartyIDs, fix+pos, len - pos, groupFound );
       if( (int)groupFound != groupExpected ) keepScanning = false;
       }
     } else keepScanning = false;
     break;

   case FieldLegRefID::RAW_TAG :
     FIXPP_PRINT_FIELD(LegRefID)
     if( group->fieldLegRefID.offset < 0 ) group->fieldLegRefID.offset = pos;
     else keepScanning = false;
     break;

   case FieldLegPrice::RAW_TAG :
     FIXPP_PRINT_FIELD(LegPrice)
     if( group->fieldLegPrice.offset < 0 ) group->fieldLegPrice.offset = pos;
     else keepScanning = false;
     break;

   case FieldLegLastPx::RAW_TAG :
     FIXPP_PRINT_FIELD(LegLastPx)
     if( group->fieldLegLastPx.offset < 0 ) group->fieldLegLastPx.offset = pos;
     else keepScanning = false;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}


// -------------------------------------- skip ----------------------------------------
offset_t GroupLegStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     break;

   case FieldLegStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     break;

   case FieldNestedPartyRole::RAW_TAG :
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool isGroupStart = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     break;

   case FieldLegSide::RAW_TAG :
     break;

   case FieldLegQty::RAW_TAG :
     break;

   case FieldNoLegStipulations::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::skip( fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     isGroupStart = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     break;

   case FieldLegPrice::RAW_TAG :
     break;

   case FieldLegLastPx::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! isGroupStart ) gotoNextField( fix, pos );
 }
 return pos;
}


// -------------------------------------- reset ----------------------------------------
void GroupLegStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegStipulationValue.offset = -1;
}

void GroupNestedPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartySubIDType.offset = -1;
}

void GroupNestedPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartyIDSource.offset = -1;
     fieldNestedPartyRole.offset = -1;
     fieldNoNestedPartySubIDs.offset = -1;
     for( auto g = groupsNestedPartySubIDs.begin(); g != groupsNestedPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupLegs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSide.offset = -1;
     fieldLegQty.offset = -1;
     fieldNoLegStipulations.offset = -1;
     for( auto g = groupsLegStipulations.begin(); g != groupsLegStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegPositionEffect.offset = -1;
     fieldNoNestedPartyIDs.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegRefID.offset = -1;
     fieldLegPrice.offset = -1;
     fieldLegLastPx.offset = -1;
}
// end of GroupScanners.cxx

} // namespace order
