
// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <fix44/Groups.h>

namespace fix44
{

// start of GroupScanners.cxx

// Generated

// -------------------------------------- scan ----------------------------------------

offset_t GroupLegStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldLegStipulationType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStipulationValue)
     group->fieldLegStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupEvents::scan( Array & arr, const char * fix, unsigned len ){
 GroupEvents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldEventType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldEventType::RAW_TAG:
     FIXPP_PRINT_FIELD(EventType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldEventType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEventDate::RAW_TAG:
     FIXPP_PRINT_FIELD(EventDate)
     group->fieldEventDate.offset = gpos;
     break;

   case FieldEventPx::RAW_TAG:
     FIXPP_PRINT_FIELD(EventPx)
     group->fieldEventPx.offset = gpos;
     break;

   case FieldEventText::RAW_TAG:
     FIXPP_PRINT_FIELD(EventText)
     group->fieldEventText.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldLegSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityAltIDSource)
     group->fieldLegSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCapacities::scan( Array & arr, const char * fix, unsigned len ){
 GroupCapacities * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldOrderCapacity::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacity)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrderCapacity.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrderRestrictions::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderRestrictions)
     group->fieldOrderRestrictions.offset = gpos;
     break;

   case FieldOrderCapacityQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacityQty)
     group->fieldOrderCapacityQty.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested3PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNested3PartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartySubIDType)
     group->fieldNested3PartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(PartySubIDType)
     group->fieldPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested2PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNested2PartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartySubIDType)
     group->fieldNested2PartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested2PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNested2PartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyIDSource)
     group->fieldNested2PartyIDSource.offset = gpos;
     break;

   case FieldNested2PartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyRole)
     group->fieldNested2PartyRole.offset = gpos;
     break;

   case FieldNoNested2PartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested2PartySubIDs)
     group->fieldNoNested2PartySubIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartySubIDs::scan( group->groupsNested2PartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupHops::scan( Array & arr, const char * fix, unsigned len ){
 GroupHops * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldHopCompID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldHopCompID::RAW_TAG:
     FIXPP_PRINT_FIELD(HopCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldHopCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldHopSendingTime::RAW_TAG:
     FIXPP_PRINT_FIELD(HopSendingTime)
     group->fieldHopSendingTime.offset = gpos;
     break;

   case FieldHopRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(HopRefID)
     group->fieldHopRefID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCollInquiryQualifier::scan( Array & arr, const char * fix, unsigned len ){
 GroupCollInquiryQualifier * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldCollInquiryQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldCollInquiryQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(CollInquiryQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldCollInquiryQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyIDSource)
     group->fieldPartyIDSource.offset = gpos;
     break;

   case FieldPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyRole)
     group->fieldPartyRole.offset = gpos;
     break;

   case FieldNoPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartySubIDs)
     group->fieldNoPartySubIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartySubIDs::scan( group->groupsPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAllocs::scan( Array & arr, const char * fix, unsigned len ){
 GroupAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldAllocAccount::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAllocAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAllocAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocAcctIDSource)
     group->fieldAllocAcctIDSource.offset = gpos;
     break;

   case FieldAllocPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocPrice)
     group->fieldAllocPrice.offset = gpos;
     break;

   case FieldIndividualAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(IndividualAllocID)
     group->fieldIndividualAllocID.offset = gpos;
     break;

   case FieldIndividualAllocRejCode::RAW_TAG:
     FIXPP_PRINT_FIELD(IndividualAllocRejCode)
     group->fieldIndividualAllocRejCode.offset = gpos;
     break;

   case FieldAllocText::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocText)
     group->fieldAllocText.offset = gpos;
     break;

   case FieldEncodedAllocTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedAllocTextLen)
     group->fieldEncodedAllocTextLen.offset = gpos;
     break;

   case FieldEncodedAllocText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedAllocText)
     { group->fieldEncodedAllocText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedAllocTextLen()+1; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTradingSessions::scan( Array & arr, const char * fix, unsigned len ){
 GroupTradingSessions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldTradingSessionID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradingSessionID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityAltIDSource)
     group->fieldSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingSecurityAltID::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyingSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldUnderlyingSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltIDSource)
     group->fieldUnderlyingSecurityAltIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingStips::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyingStips * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldUnderlyingStipType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingStipType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStipType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingStipType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingStipValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStipValue)
     group->fieldUnderlyingStipValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyings::scan( Array & arr, const char * fix, unsigned len ){
 GroupUnderlyings * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldUnderlyingSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     group->fieldUnderlyingSymbolSfx.offset = gpos;
     break;

   case FieldUnderlyingSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     group->fieldUnderlyingSecurityID.offset = gpos;
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     group->fieldUnderlyingSecurityIDSource.offset = gpos;
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID)
     group->fieldNoUnderlyingSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::scan( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     group->fieldUnderlyingProduct.offset = gpos;
     break;

   case FieldUnderlyingCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     group->fieldUnderlyingCFICode.offset = gpos;
     break;

   case FieldUnderlyingSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     group->fieldUnderlyingSecurityType.offset = gpos;
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     group->fieldUnderlyingSecuritySubType.offset = gpos;
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     group->fieldUnderlyingMaturityDate.offset = gpos;
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     group->fieldUnderlyingPutOrCall.offset = gpos;
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     break;

   case FieldUnderlyingIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     group->fieldUnderlyingIssueDate.offset = gpos;
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     group->fieldUnderlyingRepurchaseRate.offset = gpos;
     break;

   case FieldUnderlyingFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     group->fieldUnderlyingFactor.offset = gpos;
     break;

   case FieldUnderlyingCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     group->fieldUnderlyingCreditRating.offset = gpos;
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     group->fieldUnderlyingInstrRegistry.offset = gpos;
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     group->fieldUnderlyingCountryOfIssue.offset = gpos;
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     group->fieldUnderlyingRedemptionDate.offset = gpos;
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     group->fieldUnderlyingStrikePrice.offset = gpos;
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     group->fieldUnderlyingStrikeCurrency.offset = gpos;
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     group->fieldUnderlyingOptAttribute.offset = gpos;
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     group->fieldUnderlyingContractMultiplier.offset = gpos;
     break;

   case FieldUnderlyingCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     group->fieldUnderlyingCouponRate.offset = gpos;
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     group->fieldUnderlyingSecurityExchange.offset = gpos;
     break;

   case FieldUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     group->fieldUnderlyingIssuer.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     { group->fieldEncodedUnderlyingIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingIssuerLen()+1; }
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     group->fieldUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     { group->fieldEncodedUnderlyingSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingSecurityDescLen()+1; }
     break;

   case FieldUnderlyingCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     group->fieldUnderlyingCPProgram.offset = gpos;
     break;

   case FieldUnderlyingCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     group->fieldUnderlyingCPRegType.offset = gpos;
     break;

   case FieldUnderlyingCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     group->fieldUnderlyingCurrency.offset = gpos;
     break;

   case FieldUnderlyingQty::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingQty)
     group->fieldUnderlyingQty.offset = gpos;
     break;

   case FieldUnderlyingPx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPx)
     group->fieldUnderlyingPx.offset = gpos;
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     group->fieldUnderlyingDirtyPrice.offset = gpos;
     break;

   case FieldUnderlyingEndPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     group->fieldUnderlyingEndPrice.offset = gpos;
     break;

   case FieldUnderlyingStartValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     group->fieldUnderlyingStartValue.offset = gpos;
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     group->fieldUnderlyingCurrentValue.offset = gpos;
     break;

   case FieldUnderlyingEndValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     group->fieldUnderlyingEndValue.offset = gpos;
     break;

   case FieldNoUnderlyingStips::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingStips)
     group->fieldNoUnderlyingStips.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::scan( group->groupsUnderlyingStips, fix+pos, len - pos );
     break;

   case FieldUnderlyingSettlPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSettlPrice)
     group->fieldUnderlyingSettlPrice.offset = gpos;
     break;

   case FieldUnderlyingSettlPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSettlPriceType)
     group->fieldUnderlyingSettlPriceType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStipulations::scan( Array & arr, const char * fix, unsigned len ){
 GroupStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldStipulationType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldStipulationType::RAW_TAG:
     FIXPP_PRINT_FIELD(StipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldStipulationValue::RAW_TAG:
     FIXPP_PRINT_FIELD(StipulationValue)
     group->fieldStipulationValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupOrders::scan( Array & arr, const char * fix, unsigned len ){
 GroupOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldClOrdID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     group->fieldSecondaryClOrdID.offset = gpos;
     break;

   case FieldListSeqNo::RAW_TAG:
     FIXPP_PRINT_FIELD(ListSeqNo)
     group->fieldListSeqNo.offset = gpos;
     break;

   case FieldClOrdLinkID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     group->fieldClOrdLinkID.offset = gpos;
     break;

   case FieldSettlInstMode::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstMode)
     group->fieldSettlInstMode.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     group->fieldTradeOriginationDate.offset = gpos;
     break;

   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     group->fieldTradeDate.offset = gpos;
     break;

   case FieldAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(Account)
     group->fieldAccount.offset = gpos;
     break;

   case FieldAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AcctIDSource)
     group->fieldAcctIDSource.offset = gpos;
     break;

   case FieldAccountType::RAW_TAG:
     FIXPP_PRINT_FIELD(AccountType)
     group->fieldAccountType.offset = gpos;
     break;

   case FieldDayBookingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(DayBookingInst)
     group->fieldDayBookingInst.offset = gpos;
     break;

   case FieldBookingUnit::RAW_TAG:
     FIXPP_PRINT_FIELD(BookingUnit)
     group->fieldBookingUnit.offset = gpos;
     break;

   case FieldAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocID)
     group->fieldAllocID.offset = gpos;
     break;

   case FieldPreallocMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(PreallocMethod)
     group->fieldPreallocMethod.offset = gpos;
     break;

   case FieldNoAllocs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoAllocs)
     group->fieldNoAllocs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupAllocs::scan( group->groupsAllocs, fix+pos, len - pos );
     break;

   case FieldSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlType)
     group->fieldSettlType.offset = gpos;
     break;

   case FieldSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate)
     group->fieldSettlDate.offset = gpos;
     break;

   case FieldCashMargin::RAW_TAG:
     FIXPP_PRINT_FIELD(CashMargin)
     group->fieldCashMargin.offset = gpos;
     break;

   case FieldClearingFeeIndicator::RAW_TAG:
     FIXPP_PRINT_FIELD(ClearingFeeIndicator)
     group->fieldClearingFeeIndicator.offset = gpos;
     break;

   case FieldHandlInst::RAW_TAG:
     FIXPP_PRINT_FIELD(HandlInst)
     group->fieldHandlInst.offset = gpos;
     break;

   case FieldExecInst::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecInst)
     group->fieldExecInst.offset = gpos;
     break;

   case FieldMinQty::RAW_TAG:
     FIXPP_PRINT_FIELD(MinQty)
     group->fieldMinQty.offset = gpos;
     break;

   case FieldMaxFloor::RAW_TAG:
     FIXPP_PRINT_FIELD(MaxFloor)
     group->fieldMaxFloor.offset = gpos;
     break;

   case FieldExDestination::RAW_TAG:
     FIXPP_PRINT_FIELD(ExDestination)
     group->fieldExDestination.offset = gpos;
     break;

   case FieldNoTradingSessions::RAW_TAG:
     FIXPP_PRINT_FIELD(NoTradingSessions)
     group->fieldNoTradingSessions.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupTradingSessions::scan( group->groupsTradingSessions, fix+pos, len - pos );
     break;

   case FieldProcessCode::RAW_TAG:
     FIXPP_PRINT_FIELD(ProcessCode)
     group->fieldProcessCode.offset = gpos;
     break;

   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     group->fieldSymbol.offset = gpos;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   case FieldNoUnderlyings::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyings)
     group->fieldNoUnderlyings.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::scan( group->groupsUnderlyings, fix+pos, len - pos );
     break;

   case FieldPrevClosePx::RAW_TAG:
     FIXPP_PRINT_FIELD(PrevClosePx)
     group->fieldPrevClosePx.offset = gpos;
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldSideValueInd::RAW_TAG:
     FIXPP_PRINT_FIELD(SideValueInd)
     group->fieldSideValueInd.offset = gpos;
     break;

   case FieldLocateReqd::RAW_TAG:
     FIXPP_PRINT_FIELD(LocateReqd)
     group->fieldLocateReqd.offset = gpos;
     break;

   case FieldTransactTime::RAW_TAG:
     FIXPP_PRINT_FIELD(TransactTime)
     group->fieldTransactTime.offset = gpos;
     break;

   case FieldNoStipulations::RAW_TAG:
     FIXPP_PRINT_FIELD(NoStipulations)
     group->fieldNoStipulations.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupStipulations::scan( group->groupsStipulations, fix+pos, len - pos );
     break;

   case FieldQtyType::RAW_TAG:
     FIXPP_PRINT_FIELD(QtyType)
     group->fieldQtyType.offset = gpos;
     break;

   case FieldOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty)
     group->fieldOrderQty.offset = gpos;
     break;

   case FieldCashOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(CashOrderQty)
     group->fieldCashOrderQty.offset = gpos;
     break;

   case FieldOrderPercent::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderPercent)
     group->fieldOrderPercent.offset = gpos;
     break;

   case FieldRoundingDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingDirection)
     group->fieldRoundingDirection.offset = gpos;
     break;

   case FieldRoundingModulus::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingModulus)
     group->fieldRoundingModulus.offset = gpos;
     break;

   case FieldOrdType::RAW_TAG:
     FIXPP_PRINT_FIELD(OrdType)
     group->fieldOrdType.offset = gpos;
     break;

   case FieldPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(PriceType)
     group->fieldPriceType.offset = gpos;
     break;

   case FieldPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(Price)
     group->fieldPrice.offset = gpos;
     break;

   case FieldStopPx::RAW_TAG:
     FIXPP_PRINT_FIELD(StopPx)
     group->fieldStopPx.offset = gpos;
     break;

   case FieldSpread::RAW_TAG:
     FIXPP_PRINT_FIELD(Spread)
     group->fieldSpread.offset = gpos;
     break;

   case FieldBenchmarkCurveCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurveCurrency)
     group->fieldBenchmarkCurveCurrency.offset = gpos;
     break;

   case FieldBenchmarkCurveName::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurveName)
     group->fieldBenchmarkCurveName.offset = gpos;
     break;

   case FieldBenchmarkCurvePoint::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurvePoint)
     group->fieldBenchmarkCurvePoint.offset = gpos;
     break;

   case FieldBenchmarkPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkPrice)
     group->fieldBenchmarkPrice.offset = gpos;
     break;

   case FieldBenchmarkPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkPriceType)
     group->fieldBenchmarkPriceType.offset = gpos;
     break;

   case FieldBenchmarkSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkSecurityID)
     group->fieldBenchmarkSecurityID.offset = gpos;
     break;

   case FieldBenchmarkSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkSecurityIDSource)
     group->fieldBenchmarkSecurityIDSource.offset = gpos;
     break;

   case FieldYieldType::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldType)
     group->fieldYieldType.offset = gpos;
     break;

   case FieldYield::RAW_TAG:
     FIXPP_PRINT_FIELD(Yield)
     group->fieldYield.offset = gpos;
     break;

   case FieldYieldCalcDate::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldCalcDate)
     group->fieldYieldCalcDate.offset = gpos;
     break;

   case FieldYieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionDate)
     group->fieldYieldRedemptionDate.offset = gpos;
     break;

   case FieldYieldRedemptionPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionPrice)
     group->fieldYieldRedemptionPrice.offset = gpos;
     break;

   case FieldYieldRedemptionPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionPriceType)
     group->fieldYieldRedemptionPriceType.offset = gpos;
     break;

   case FieldCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(Currency)
     group->fieldCurrency.offset = gpos;
     break;

   case FieldComplianceID::RAW_TAG:
     FIXPP_PRINT_FIELD(ComplianceID)
     group->fieldComplianceID.offset = gpos;
     break;

   case FieldSolicitedFlag::RAW_TAG:
     FIXPP_PRINT_FIELD(SolicitedFlag)
     group->fieldSolicitedFlag.offset = gpos;
     break;

   case FieldIOIID::RAW_TAG:
     FIXPP_PRINT_FIELD(IOIID)
     group->fieldIOIID.offset = gpos;
     break;

   case FieldQuoteID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteID)
     group->fieldQuoteID.offset = gpos;
     break;

   case FieldTimeInForce::RAW_TAG:
     FIXPP_PRINT_FIELD(TimeInForce)
     group->fieldTimeInForce.offset = gpos;
     break;

   case FieldEffectiveTime::RAW_TAG:
     FIXPP_PRINT_FIELD(EffectiveTime)
     group->fieldEffectiveTime.offset = gpos;
     break;

   case FieldExpireDate::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireDate)
     group->fieldExpireDate.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldGTBookingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(GTBookingInst)
     group->fieldGTBookingInst.offset = gpos;
     break;

   case FieldCommission::RAW_TAG:
     FIXPP_PRINT_FIELD(Commission)
     group->fieldCommission.offset = gpos;
     break;

   case FieldCommType::RAW_TAG:
     FIXPP_PRINT_FIELD(CommType)
     group->fieldCommType.offset = gpos;
     break;

   case FieldCommCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(CommCurrency)
     group->fieldCommCurrency.offset = gpos;
     break;

   case FieldFundRenewWaiv::RAW_TAG:
     FIXPP_PRINT_FIELD(FundRenewWaiv)
     group->fieldFundRenewWaiv.offset = gpos;
     break;

   case FieldOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacity)
     group->fieldOrderCapacity.offset = gpos;
     break;

   case FieldOrderRestrictions::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderRestrictions)
     group->fieldOrderRestrictions.offset = gpos;
     break;

   case FieldCustOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(CustOrderCapacity)
     group->fieldCustOrderCapacity.offset = gpos;
     break;

   case FieldForexReq::RAW_TAG:
     FIXPP_PRINT_FIELD(ForexReq)
     group->fieldForexReq.offset = gpos;
     break;

   case FieldSettlCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlCurrency)
     group->fieldSettlCurrency.offset = gpos;
     break;

   case FieldBookingType::RAW_TAG:
     FIXPP_PRINT_FIELD(BookingType)
     group->fieldBookingType.offset = gpos;
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     break;

   case FieldSettlDate2::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate2)
     group->fieldSettlDate2.offset = gpos;
     break;

   case FieldOrderQty2::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty2)
     group->fieldOrderQty2.offset = gpos;
     break;

   case FieldPrice2::RAW_TAG:
     FIXPP_PRINT_FIELD(Price2)
     group->fieldPrice2.offset = gpos;
     break;

   case FieldPositionEffect::RAW_TAG:
     FIXPP_PRINT_FIELD(PositionEffect)
     group->fieldPositionEffect.offset = gpos;
     break;

   case FieldCoveredOrUncovered::RAW_TAG:
     FIXPP_PRINT_FIELD(CoveredOrUncovered)
     group->fieldCoveredOrUncovered.offset = gpos;
     break;

   case FieldMaxShow::RAW_TAG:
     FIXPP_PRINT_FIELD(MaxShow)
     group->fieldMaxShow.offset = gpos;
     break;

   case FieldPegOffsetValue::RAW_TAG:
     FIXPP_PRINT_FIELD(PegOffsetValue)
     group->fieldPegOffsetValue.offset = gpos;
     break;

   case FieldPegMoveType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegMoveType)
     group->fieldPegMoveType.offset = gpos;
     break;

   case FieldPegOffsetType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegOffsetType)
     group->fieldPegOffsetType.offset = gpos;
     break;

   case FieldPegLimitType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegLimitType)
     group->fieldPegLimitType.offset = gpos;
     break;

   case FieldPegRoundDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(PegRoundDirection)
     group->fieldPegRoundDirection.offset = gpos;
     break;

   case FieldPegScope::RAW_TAG:
     FIXPP_PRINT_FIELD(PegScope)
     group->fieldPegScope.offset = gpos;
     break;

   case FieldDiscretionInst::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionInst)
     group->fieldDiscretionInst.offset = gpos;
     break;

   case FieldDiscretionOffsetValue::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionOffsetValue)
     group->fieldDiscretionOffsetValue.offset = gpos;
     break;

   case FieldDiscretionMoveType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionMoveType)
     group->fieldDiscretionMoveType.offset = gpos;
     break;

   case FieldDiscretionOffsetType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionOffsetType)
     group->fieldDiscretionOffsetType.offset = gpos;
     break;

   case FieldDiscretionLimitType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionLimitType)
     group->fieldDiscretionLimitType.offset = gpos;
     break;

   case FieldDiscretionRoundDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionRoundDirection)
     group->fieldDiscretionRoundDirection.offset = gpos;
     break;

   case FieldDiscretionScope::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionScope)
     group->fieldDiscretionScope.offset = gpos;
     break;

   case FieldTargetStrategy::RAW_TAG:
     FIXPP_PRINT_FIELD(TargetStrategy)
     group->fieldTargetStrategy.offset = gpos;
     break;

   case FieldTargetStrategyParameters::RAW_TAG:
     FIXPP_PRINT_FIELD(TargetStrategyParameters)
     group->fieldTargetStrategyParameters.offset = gpos;
     break;

   case FieldParticipationRate::RAW_TAG:
     FIXPP_PRINT_FIELD(ParticipationRate)
     group->fieldParticipationRate.offset = gpos;
     break;

   case FieldDesignation::RAW_TAG:
     FIXPP_PRINT_FIELD(Designation)
     group->fieldDesignation.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSettlPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartySubIDType)
     group->fieldSettlPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSettlPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyIDSource)
     group->fieldSettlPartyIDSource.offset = gpos;
     break;

   case FieldSettlPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyRole)
     group->fieldSettlPartyRole.offset = gpos;
     break;

   case FieldNoSettlPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSettlPartySubIDs)
     group->fieldNoSettlPartySubIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartySubIDs::scan( group->groupsSettlPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDlvyInst::scan( Array & arr, const char * fix, unsigned len ){
 GroupDlvyInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSettlInstSource::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstSource)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstSource.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDlvyInstType::RAW_TAG:
     FIXPP_PRINT_FIELD(DlvyInstType)
     group->fieldDlvyInstType.offset = gpos;
     break;

   case FieldNoSettlPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSettlPartyIDs)
     group->fieldNoSettlPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartyIDs::scan( group->groupsSettlPartyIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupClearingInstructions::scan( Array & arr, const char * fix, unsigned len ){
 GroupClearingInstructions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldClearingInstruction::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClearingInstruction::RAW_TAG:
     FIXPP_PRINT_FIELD(ClearingInstruction)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClearingInstruction.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNestedPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     group->fieldNestedPartySubIDType.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNestedPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     group->fieldNestedPartyIDSource.offset = gpos;
     break;

   case FieldNestedPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyRole)
     group->fieldNestedPartyRole.offset = gpos;
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs)
     group->fieldNoNestedPartySubIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::scan( group->groupsNestedPartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldLegSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSymbolSfx)
     group->fieldLegSymbolSfx.offset = gpos;
     break;

   case FieldLegSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityID)
     group->fieldLegSecurityID.offset = gpos;
     break;

   case FieldLegSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityIDSource)
     group->fieldLegSecurityIDSource.offset = gpos;
     break;

   case FieldNoLegSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegSecurityAltID)
     group->fieldNoLegSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegSecurityAltID::scan( group->groupsLegSecurityAltID, fix+pos, len - pos );
     break;

   case FieldLegProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(LegProduct)
     group->fieldLegProduct.offset = gpos;
     break;

   case FieldLegCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCFICode)
     group->fieldLegCFICode.offset = gpos;
     break;

   case FieldLegSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityType)
     group->fieldLegSecurityType.offset = gpos;
     break;

   case FieldLegSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecuritySubType)
     group->fieldLegSecuritySubType.offset = gpos;
     break;

   case FieldLegMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(LegMaturityMonthYear)
     group->fieldLegMaturityMonthYear.offset = gpos;
     break;

   case FieldLegMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegMaturityDate)
     group->fieldLegMaturityDate.offset = gpos;
     break;

   case FieldLegCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCouponPaymentDate)
     group->fieldLegCouponPaymentDate.offset = gpos;
     break;

   case FieldLegIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIssueDate)
     group->fieldLegIssueDate.offset = gpos;
     break;

   case FieldLegRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepoCollateralSecurityType)
     group->fieldLegRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldLegRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepurchaseTerm)
     group->fieldLegRepurchaseTerm.offset = gpos;
     break;

   case FieldLegRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepurchaseRate)
     group->fieldLegRepurchaseRate.offset = gpos;
     break;

   case FieldLegFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(LegFactor)
     group->fieldLegFactor.offset = gpos;
     break;

   case FieldLegCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCreditRating)
     group->fieldLegCreditRating.offset = gpos;
     break;

   case FieldLegInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(LegInstrRegistry)
     group->fieldLegInstrRegistry.offset = gpos;
     break;

   case FieldLegCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCountryOfIssue)
     group->fieldLegCountryOfIssue.offset = gpos;
     break;

   case FieldLegStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStateOrProvinceOfIssue)
     group->fieldLegStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLegLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegLocaleOfIssue)
     group->fieldLegLocaleOfIssue.offset = gpos;
     break;

   case FieldLegRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRedemptionDate)
     group->fieldLegRedemptionDate.offset = gpos;
     break;

   case FieldLegStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStrikePrice)
     group->fieldLegStrikePrice.offset = gpos;
     break;

   case FieldLegStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStrikeCurrency)
     group->fieldLegStrikeCurrency.offset = gpos;
     break;

   case FieldLegOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(LegOptAttribute)
     group->fieldLegOptAttribute.offset = gpos;
     break;

   case FieldLegContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(LegContractMultiplier)
     group->fieldLegContractMultiplier.offset = gpos;
     break;

   case FieldLegCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCouponRate)
     group->fieldLegCouponRate.offset = gpos;
     break;

   case FieldLegSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityExchange)
     group->fieldLegSecurityExchange.offset = gpos;
     break;

   case FieldLegIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIssuer)
     group->fieldLegIssuer.offset = gpos;
     break;

   case FieldEncodedLegIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegIssuerLen)
     group->fieldEncodedLegIssuerLen.offset = gpos;
     break;

   case FieldEncodedLegIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegIssuer)
     { group->fieldEncodedLegIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedLegIssuerLen()+1; }
     break;

   case FieldLegSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityDesc)
     group->fieldLegSecurityDesc.offset = gpos;
     break;

   case FieldEncodedLegSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegSecurityDescLen)
     group->fieldEncodedLegSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedLegSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegSecurityDesc)
     { group->fieldEncodedLegSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedLegSecurityDescLen()+1; }
     break;

   case FieldLegRatioQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRatioQty)
     group->fieldLegRatioQty.offset = gpos;
     break;

   case FieldLegSide::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSide)
     group->fieldLegSide.offset = gpos;
     break;

   case FieldLegCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCurrency)
     group->fieldLegCurrency.offset = gpos;
     break;

   case FieldLegPool::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPool)
     group->fieldLegPool.offset = gpos;
     break;

   case FieldLegDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegDatedDate)
     group->fieldLegDatedDate.offset = gpos;
     break;

   case FieldLegContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(LegContractSettlMonth)
     group->fieldLegContractSettlMonth.offset = gpos;
     break;

   case FieldLegInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegInterestAccrualDate)
     group->fieldLegInterestAccrualDate.offset = gpos;
     break;

   case FieldLegQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegQty)
     group->fieldLegQty.offset = gpos;
     break;

   case FieldLegSwapType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSwapType)
     group->fieldLegSwapType.offset = gpos;
     break;

   case FieldNoLegStipulations::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegStipulations)
     group->fieldNoLegStipulations.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::scan( group->groupsLegStipulations, fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPositionEffect)
     group->fieldLegPositionEffect.offset = gpos;
     break;

   case FieldLegCoveredOrUncovered::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCoveredOrUncovered)
     group->fieldLegCoveredOrUncovered.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRefID)
     group->fieldLegRefID.offset = gpos;
     break;

   case FieldLegPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPrice)
     group->fieldLegPrice.offset = gpos;
     break;

   case FieldLegSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlType)
     group->fieldLegSettlType.offset = gpos;
     break;

   case FieldLegSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlDate)
     group->fieldLegSettlDate.offset = gpos;
     break;

   case FieldLegLastPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LegLastPx)
     group->fieldLegLastPx.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteEntries::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   case FieldAgreementDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementDesc)
     group->fieldAgreementDesc.offset = gpos;
     break;

   case FieldAgreementID::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementID)
     group->fieldAgreementID.offset = gpos;
     break;

   case FieldAgreementDate::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementDate)
     group->fieldAgreementDate.offset = gpos;
     break;

   case FieldAgreementCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementCurrency)
     group->fieldAgreementCurrency.offset = gpos;
     break;

   case FieldTerminationType::RAW_TAG:
     FIXPP_PRINT_FIELD(TerminationType)
     group->fieldTerminationType.offset = gpos;
     break;

   case FieldStartDate::RAW_TAG:
     FIXPP_PRINT_FIELD(StartDate)
     group->fieldStartDate.offset = gpos;
     break;

   case FieldEndDate::RAW_TAG:
     FIXPP_PRINT_FIELD(EndDate)
     group->fieldEndDate.offset = gpos;
     break;

   case FieldDeliveryType::RAW_TAG:
     FIXPP_PRINT_FIELD(DeliveryType)
     group->fieldDeliveryType.offset = gpos;
     break;

   case FieldMarginRatio::RAW_TAG:
     FIXPP_PRINT_FIELD(MarginRatio)
     group->fieldMarginRatio.offset = gpos;
     break;

   case FieldNoUnderlyings::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyings)
     group->fieldNoUnderlyings.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::scan( group->groupsUnderlyings, fix+pos, len - pos );
     break;

   case FieldNoLegs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegs)
     group->fieldNoLegs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::scan( group->groupsLegs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteSets::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteSets * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldQuoteSetID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteSetID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteSetID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteSetID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     group->fieldUnderlyingSymbol.offset = gpos;
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     group->fieldUnderlyingSymbolSfx.offset = gpos;
     break;

   case FieldUnderlyingSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     group->fieldUnderlyingSecurityID.offset = gpos;
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     group->fieldUnderlyingSecurityIDSource.offset = gpos;
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID)
     group->fieldNoUnderlyingSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::scan( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     group->fieldUnderlyingProduct.offset = gpos;
     break;

   case FieldUnderlyingCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     group->fieldUnderlyingCFICode.offset = gpos;
     break;

   case FieldUnderlyingSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     group->fieldUnderlyingSecurityType.offset = gpos;
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     group->fieldUnderlyingSecuritySubType.offset = gpos;
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     group->fieldUnderlyingMaturityDate.offset = gpos;
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     group->fieldUnderlyingPutOrCall.offset = gpos;
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     break;

   case FieldUnderlyingIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     group->fieldUnderlyingIssueDate.offset = gpos;
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     group->fieldUnderlyingRepurchaseRate.offset = gpos;
     break;

   case FieldUnderlyingFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     group->fieldUnderlyingFactor.offset = gpos;
     break;

   case FieldUnderlyingCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     group->fieldUnderlyingCreditRating.offset = gpos;
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     group->fieldUnderlyingInstrRegistry.offset = gpos;
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     group->fieldUnderlyingCountryOfIssue.offset = gpos;
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     group->fieldUnderlyingRedemptionDate.offset = gpos;
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     group->fieldUnderlyingStrikePrice.offset = gpos;
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     group->fieldUnderlyingStrikeCurrency.offset = gpos;
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     group->fieldUnderlyingOptAttribute.offset = gpos;
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     group->fieldUnderlyingContractMultiplier.offset = gpos;
     break;

   case FieldUnderlyingCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     group->fieldUnderlyingCouponRate.offset = gpos;
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     group->fieldUnderlyingSecurityExchange.offset = gpos;
     break;

   case FieldUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     group->fieldUnderlyingIssuer.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     { group->fieldEncodedUnderlyingIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingIssuerLen()+1; }
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     group->fieldUnderlyingSecurityDesc.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     { group->fieldEncodedUnderlyingSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingSecurityDescLen()+1; }
     break;

   case FieldUnderlyingCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     group->fieldUnderlyingCPProgram.offset = gpos;
     break;

   case FieldUnderlyingCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     group->fieldUnderlyingCPRegType.offset = gpos;
     break;

   case FieldUnderlyingCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     group->fieldUnderlyingCurrency.offset = gpos;
     break;

   case FieldUnderlyingQty::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingQty)
     group->fieldUnderlyingQty.offset = gpos;
     break;

   case FieldUnderlyingPx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPx)
     group->fieldUnderlyingPx.offset = gpos;
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     group->fieldUnderlyingDirtyPrice.offset = gpos;
     break;

   case FieldUnderlyingEndPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     group->fieldUnderlyingEndPrice.offset = gpos;
     break;

   case FieldUnderlyingStartValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     group->fieldUnderlyingStartValue.offset = gpos;
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     group->fieldUnderlyingCurrentValue.offset = gpos;
     break;

   case FieldUnderlyingEndValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     group->fieldUnderlyingEndValue.offset = gpos;
     break;

   case FieldNoUnderlyingStips::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingStips)
     group->fieldNoUnderlyingStips.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::scan( group->groupsUnderlyingStips, fix+pos, len - pos );
     break;

   case FieldTotNoQuoteEntries::RAW_TAG:
     FIXPP_PRINT_FIELD(TotNoQuoteEntries)
     group->fieldTotNoQuoteEntries.offset = gpos;
     break;

   case FieldLastFragment::RAW_TAG:
     FIXPP_PRINT_FIELD(LastFragment)
     group->fieldLastFragment.offset = gpos;
     break;

   case FieldNoQuoteEntries::RAW_TAG:
     FIXPP_PRINT_FIELD(NoQuoteEntries)
     group->fieldNoQuoteEntries.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupQuoteEntries::scan( group->groupsQuoteEntries, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupSecurityTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSecurityType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartyIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupNested3PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldNested3PartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyIDSource)
     group->fieldNested3PartyIDSource.offset = gpos;
     break;

   case FieldNested3PartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyRole)
     group->fieldNested3PartyRole.offset = gpos;
     break;

   case FieldNoNested3PartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested3PartySubIDs)
     group->fieldNoNested3PartySubIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested3PartySubIDs::scan( group->groupsNested3PartySubIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPositions::scan( Array & arr, const char * fix, unsigned len ){
 GroupPositions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldPosType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosType::RAW_TAG:
     FIXPP_PRINT_FIELD(PosType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLongQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LongQty)
     group->fieldLongQty.offset = gpos;
     break;

   case FieldShortQty::RAW_TAG:
     FIXPP_PRINT_FIELD(ShortQty)
     group->fieldShortQty.offset = gpos;
     break;

   case FieldPosQtyStatus::RAW_TAG:
     FIXPP_PRINT_FIELD(PosQtyStatus)
     group->fieldPosQtyStatus.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAffectedOrders::scan( Array & arr, const char * fix, unsigned len ){
 GroupAffectedOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldOrigClOrdID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrigClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrigClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAffectedOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(AffectedOrderID)
     group->fieldAffectedOrderID.offset = gpos;
     break;

   case FieldAffectedSecondaryOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(AffectedSecondaryOrderID)
     group->fieldAffectedSecondaryOrderID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupExecs::scan( Array & arr, const char * fix, unsigned len ){
 GroupExecs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldLastQty::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLastQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LastQty)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLastQty.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldExecID::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecID)
     group->fieldExecID.offset = gpos;
     break;

   case FieldSecondaryExecID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryExecID)
     group->fieldSecondaryExecID.offset = gpos;
     break;

   case FieldLastPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LastPx)
     group->fieldLastPx.offset = gpos;
     break;

   case FieldLastParPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LastParPx)
     group->fieldLastParPx.offset = gpos;
     break;

   case FieldLastCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(LastCapacity)
     group->fieldLastCapacity.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMsgTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupMsgTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldRefMsgType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefMsgType::RAW_TAG:
     FIXPP_PRINT_FIELD(RefMsgType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefMsgType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMsgDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(MsgDirection)
     group->fieldMsgDirection.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidComponents::scan( Array & arr, const char * fix, unsigned len ){
 GroupBidComponents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldListID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldListID::RAW_TAG:
     FIXPP_PRINT_FIELD(ListID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldListID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     group->fieldTradingSessionID.offset = gpos;
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   case FieldNetGrossInd::RAW_TAG:
     FIXPP_PRINT_FIELD(NetGrossInd)
     group->fieldNetGrossInd.offset = gpos;
     break;

   case FieldSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlType)
     group->fieldSettlType.offset = gpos;
     break;

   case FieldSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate)
     group->fieldSettlDate.offset = gpos;
     break;

   case FieldAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(Account)
     group->fieldAccount.offset = gpos;
     break;

   case FieldAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AcctIDSource)
     group->fieldAcctIDSource.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlInst::scan( Array & arr, const char * fix, unsigned len ){
 GroupSettlInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSettlInstID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlInstTransType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstTransType)
     group->fieldSettlInstTransType.offset = gpos;
     break;

   case FieldSettlInstRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstRefID)
     group->fieldSettlInstRefID.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side)
     group->fieldSide.offset = gpos;
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldEffectiveTime::RAW_TAG:
     FIXPP_PRINT_FIELD(EffectiveTime)
     group->fieldEffectiveTime.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldLastUpdateTime::RAW_TAG:
     FIXPP_PRINT_FIELD(LastUpdateTime)
     group->fieldLastUpdateTime.offset = gpos;
     break;

   case FieldSettlDeliveryType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDeliveryType)
     group->fieldSettlDeliveryType.offset = gpos;
     break;

   case FieldStandInstDbType::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbType)
     group->fieldStandInstDbType.offset = gpos;
     break;

   case FieldStandInstDbName::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbName)
     group->fieldStandInstDbName.offset = gpos;
     break;

   case FieldStandInstDbID::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbID)
     group->fieldStandInstDbID.offset = gpos;
     break;

   case FieldNoDlvyInst::RAW_TAG:
     FIXPP_PRINT_FIELD(NoDlvyInst)
     group->fieldNoDlvyInst.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupDlvyInst::scan( group->groupsDlvyInst, fix+pos, len - pos );
     break;

   case FieldPaymentMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentMethod)
     group->fieldPaymentMethod.offset = gpos;
     break;

   case FieldPaymentRef::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentRef)
     group->fieldPaymentRef.offset = gpos;
     break;

   case FieldCardHolderName::RAW_TAG:
     FIXPP_PRINT_FIELD(CardHolderName)
     group->fieldCardHolderName.offset = gpos;
     break;

   case FieldCardNumber::RAW_TAG:
     FIXPP_PRINT_FIELD(CardNumber)
     group->fieldCardNumber.offset = gpos;
     break;

   case FieldCardStartDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CardStartDate)
     group->fieldCardStartDate.offset = gpos;
     break;

   case FieldCardExpDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CardExpDate)
     group->fieldCardExpDate.offset = gpos;
     break;

   case FieldCardIssNum::RAW_TAG:
     FIXPP_PRINT_FIELD(CardIssNum)
     group->fieldCardIssNum.offset = gpos;
     break;

   case FieldPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentDate)
     group->fieldPaymentDate.offset = gpos;
     break;

   case FieldPaymentRemitterID::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentRemitterID)
     group->fieldPaymentRemitterID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupInstrAttrib::scan( Array & arr, const char * fix, unsigned len ){
 GroupInstrAttrib * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldInstrAttribType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldInstrAttribType::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrAttribType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldInstrAttribType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldInstrAttribValue::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrAttribValue)
     group->fieldInstrAttribValue.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMiscFees::scan( Array & arr, const char * fix, unsigned len ){
 GroupMiscFees * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldMiscFeeAmt::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMiscFeeAmt::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeAmt)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMiscFeeAmt.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMiscFeeCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeCurr)
     group->fieldMiscFeeCurr.offset = gpos;
     break;

   case FieldMiscFeeType::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeType)
     group->fieldMiscFeeType.offset = gpos;
     break;

   case FieldMiscFeeBasis::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeBasis)
     group->fieldMiscFeeBasis.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteQualifiers::scan( Array & arr, const char * fix, unsigned len ){
 GroupQuoteQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldQuoteQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDistribInsts::scan( Array & arr, const char * fix, unsigned len ){
 GroupDistribInsts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldDistribPaymentMethod::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldDistribPaymentMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(DistribPaymentMethod)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldDistribPaymentMethod.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDistribPercentage::RAW_TAG:
     FIXPP_PRINT_FIELD(DistribPercentage)
     group->fieldDistribPercentage.offset = gpos;
     break;

   case FieldCashDistribCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribCurr)
     group->fieldCashDistribCurr.offset = gpos;
     break;

   case FieldCashDistribAgentName::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentName)
     group->fieldCashDistribAgentName.offset = gpos;
     break;

   case FieldCashDistribAgentCode::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentCode)
     group->fieldCashDistribAgentCode.offset = gpos;
     break;

   case FieldCashDistribAgentAcctNumber::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentAcctNumber)
     group->fieldCashDistribAgentAcctNumber.offset = gpos;
     break;

   case FieldCashDistribPayRef::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribPayRef)
     group->fieldCashDistribPayRef.offset = gpos;
     break;

   case FieldCashDistribAgentAcctName::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentAcctName)
     group->fieldCashDistribAgentAcctName.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrdRegTimestamps::scan( Array & arr, const char * fix, unsigned len ){
 GroupTrdRegTimestamps * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldTrdRegTimestamp::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTrdRegTimestamp::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestamp)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTrdRegTimestamp.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTrdRegTimestampType::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestampType)
     group->fieldTrdRegTimestampType.offset = gpos;
     break;

   case FieldTrdRegTimestampOrigin::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestampOrigin)
     group->fieldTrdRegTimestampOrigin.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAltMDSource::scan( Array & arr, const char * fix, unsigned len ){
 GroupAltMDSource * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldAltMDSourceID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAltMDSourceID::RAW_TAG:
     FIXPP_PRINT_FIELD(AltMDSourceID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAltMDSourceID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSides::scan( Array & arr, const char * fix, unsigned len ){
 GroupSides * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSide::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSide.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrigClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigClOrdID)
     group->fieldOrigClOrdID.offset = gpos;
     break;

   case FieldClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdID)
     group->fieldClOrdID.offset = gpos;
     break;

   case FieldSecondaryClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     group->fieldSecondaryClOrdID.offset = gpos;
     break;

   case FieldClOrdLinkID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     group->fieldClOrdLinkID.offset = gpos;
     break;

   case FieldOrigOrdModTime::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigOrdModTime)
     group->fieldOrigOrdModTime.offset = gpos;
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs)
     group->fieldNoPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::scan( group->groupsPartyIDs, fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     group->fieldTradeOriginationDate.offset = gpos;
     break;

   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     group->fieldTradeDate.offset = gpos;
     break;

   case FieldOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty)
     group->fieldOrderQty.offset = gpos;
     break;

   case FieldCashOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(CashOrderQty)
     group->fieldCashOrderQty.offset = gpos;
     break;

   case FieldOrderPercent::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderPercent)
     group->fieldOrderPercent.offset = gpos;
     break;

   case FieldRoundingDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingDirection)
     group->fieldRoundingDirection.offset = gpos;
     break;

   case FieldRoundingModulus::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingModulus)
     group->fieldRoundingModulus.offset = gpos;
     break;

   case FieldComplianceID::RAW_TAG:
     FIXPP_PRINT_FIELD(ComplianceID)
     group->fieldComplianceID.offset = gpos;
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRoutingIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupRoutingIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldRoutingType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRoutingType::RAW_TAG:
     FIXPP_PRINT_FIELD(RoutingType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRoutingType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRoutingID::RAW_TAG:
     FIXPP_PRINT_FIELD(RoutingID)
     group->fieldRoutingID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPosAmt::scan( Array & arr, const char * fix, unsigned len ){
 GroupPosAmt * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldPosAmtType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosAmtType::RAW_TAG:
     FIXPP_PRINT_FIELD(PosAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPosAmt::RAW_TAG:
     FIXPP_PRINT_FIELD(PosAmt)
     group->fieldPosAmt.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLinesOfText::scan( Array & arr, const char * fix, unsigned len ){
 GroupLinesOfText * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldText::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldText.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupIOIQualifiers::scan( Array & arr, const char * fix, unsigned len ){
 GroupIOIQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldIOIQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldIOIQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(IOIQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldIOIQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDates::scan( Array & arr, const char * fix, unsigned len ){
 GroupDates * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldTradeDate::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeDate.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTransactTime::RAW_TAG:
     FIXPP_PRINT_FIELD(TransactTime)
     group->fieldTransactTime.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntryTypes::scan( Array & arr, const char * fix, unsigned len ){
 GroupMDEntryTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldMDEntryType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRelatedSym::scan( Array & arr, const char * fix, unsigned len ){
 GroupRelatedSym * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContraBrokers::scan( Array & arr, const char * fix, unsigned len ){
 GroupContraBrokers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldContraBroker::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContraBroker::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraBroker)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContraBroker.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContraTrader::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTrader)
     group->fieldContraTrader.offset = gpos;
     break;

   case FieldContraTradeQty::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTradeQty)
     group->fieldContraTradeQty.offset = gpos;
     break;

   case FieldContraTradeTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTradeTime)
     group->fieldContraTradeTime.offset = gpos;
     break;

   case FieldContraLegRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraLegRefID)
     group->fieldContraLegRefID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrades::scan( Array & arr, const char * fix, unsigned len ){
 GroupTrades * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldTradeReportID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeReportID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeReportID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeReportID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryTradeReportID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryTradeReportID)
     group->fieldSecondaryTradeReportID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStrikes::scan( Array & arr, const char * fix, unsigned len ){
 GroupStrikes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     group->fieldSymbolSfx.offset = gpos;
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     group->fieldSecurityID.offset = gpos;
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource)
     group->fieldSecurityIDSource.offset = gpos;
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID)
     group->fieldNoSecurityAltID.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::scan( group->groupsSecurityAltID, fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product)
     group->fieldProduct.offset = gpos;
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     group->fieldCFICode.offset = gpos;
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     group->fieldSecurityType.offset = gpos;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     group->fieldSecuritySubType.offset = gpos;
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     group->fieldMaturityMonthYear.offset = gpos;
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     group->fieldMaturityDate.offset = gpos;
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall)
     group->fieldPutOrCall.offset = gpos;
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     group->fieldCouponPaymentDate.offset = gpos;
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     group->fieldIssueDate.offset = gpos;
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     group->fieldRepoCollateralSecurityType.offset = gpos;
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     group->fieldRepurchaseTerm.offset = gpos;
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     group->fieldRepurchaseRate.offset = gpos;
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     group->fieldFactor.offset = gpos;
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     group->fieldCreditRating.offset = gpos;
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     group->fieldInstrRegistry.offset = gpos;
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     group->fieldCountryOfIssue.offset = gpos;
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     group->fieldStateOrProvinceOfIssue.offset = gpos;
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     group->fieldLocaleOfIssue.offset = gpos;
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     group->fieldRedemptionDate.offset = gpos;
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     group->fieldStrikePrice.offset = gpos;
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     group->fieldStrikeCurrency.offset = gpos;
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     group->fieldOptAttribute.offset = gpos;
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     group->fieldContractMultiplier.offset = gpos;
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     group->fieldCouponRate.offset = gpos;
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     group->fieldSecurityExchange.offset = gpos;
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     group->fieldIssuer.offset = gpos;
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     group->fieldEncodedIssuerLen.offset = gpos;
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     group->fieldSecurityDesc.offset = gpos;
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     group->fieldEncodedSecurityDescLen.offset = gpos;
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     group->fieldPool.offset = gpos;
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     group->fieldContractSettlMonth.offset = gpos;
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram)
     group->fieldCPProgram.offset = gpos;
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     group->fieldCPRegType.offset = gpos;
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents)
     group->fieldNoEvents.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::scan( group->groupsEvents, fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     group->fieldDatedDate.offset = gpos;
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     group->fieldInterestAccrualDate.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidDescriptors::scan( Array & arr, const char * fix, unsigned len ){
 GroupBidDescriptors * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldBidDescriptorType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldBidDescriptorType::RAW_TAG:
     FIXPP_PRINT_FIELD(BidDescriptorType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldBidDescriptorType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldBidDescriptor::RAW_TAG:
     FIXPP_PRINT_FIELD(BidDescriptor)
     group->fieldBidDescriptor.offset = gpos;
     break;

   case FieldSideValueInd::RAW_TAG:
     FIXPP_PRINT_FIELD(SideValueInd)
     group->fieldSideValueInd.offset = gpos;
     break;

   case FieldLiquidityValue::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityValue)
     group->fieldLiquidityValue.offset = gpos;
     break;

   case FieldLiquidityNumSecurities::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityNumSecurities)
     group->fieldLiquidityNumSecurities.offset = gpos;
     break;

   case FieldLiquidityPctLow::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityPctLow)
     group->fieldLiquidityPctLow.offset = gpos;
     break;

   case FieldLiquidityPctHigh::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityPctHigh)
     group->fieldLiquidityPctHigh.offset = gpos;
     break;

   case FieldEFPTrackingError::RAW_TAG:
     FIXPP_PRINT_FIELD(EFPTrackingError)
     group->fieldEFPTrackingError.offset = gpos;
     break;

   case FieldFairValue::RAW_TAG:
     FIXPP_PRINT_FIELD(FairValue)
     group->fieldFairValue.offset = gpos;
     break;

   case FieldOutsideIndexPct::RAW_TAG:
     FIXPP_PRINT_FIELD(OutsideIndexPct)
     group->fieldOutsideIndexPct.offset = gpos;
     break;

   case FieldValueOfFutures::RAW_TAG:
     FIXPP_PRINT_FIELD(ValueOfFutures)
     group->fieldValueOfFutures.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCompIDs::scan( Array & arr, const char * fix, unsigned len ){
 GroupCompIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldRefCompID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefCompID::RAW_TAG:
     FIXPP_PRINT_FIELD(RefCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRefSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(RefSubID)
     group->fieldRefSubID.offset = gpos;
     break;

   case FieldLocationID::RAW_TAG:
     FIXPP_PRINT_FIELD(LocationID)
     group->fieldLocationID.offset = gpos;
     break;

   case FieldDeskID::RAW_TAG:
     FIXPP_PRINT_FIELD(DeskID)
     group->fieldDeskID.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegAllocs::scan( Array & arr, const char * fix, unsigned len ){
 GroupLegAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldLegAllocAccount::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegAllocAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegIndividualAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIndividualAllocID)
     group->fieldLegIndividualAllocID.offset = gpos;
     break;

   case FieldNoNested2PartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested2PartyIDs)
     group->fieldNoNested2PartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartyIDs::scan( group->groupsNested2PartyIDs, fix+pos, len - pos );
     break;

   case FieldLegAllocQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocQty)
     group->fieldLegAllocQty.offset = gpos;
     break;

   case FieldLegAllocAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocAcctIDSource)
     group->fieldLegAllocAcctIDSource.offset = gpos;
     break;

   case FieldLegSettlCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlCurrency)
     group->fieldLegSettlCurrency.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRegistDtls::scan( Array & arr, const char * fix, unsigned len ){
 GroupRegistDtls * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldRegistDtls::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRegistDtls::RAW_TAG:
     FIXPP_PRINT_FIELD(RegistDtls)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRegistDtls.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRegistEmail::RAW_TAG:
     FIXPP_PRINT_FIELD(RegistEmail)
     group->fieldRegistEmail.offset = gpos;
     break;

   case FieldMailingDtls::RAW_TAG:
     FIXPP_PRINT_FIELD(MailingDtls)
     group->fieldMailingDtls.offset = gpos;
     break;

   case FieldMailingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(MailingInst)
     group->fieldMailingInst.offset = gpos;
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs)
     group->fieldNoNestedPartyIDs.offset = gpos;
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::scan( group->groupsNestedPartyIDs, fix+pos, len - pos );
     break;

   case FieldOwnerType::RAW_TAG:
     FIXPP_PRINT_FIELD(OwnerType)
     group->fieldOwnerType.offset = gpos;
     break;

   case FieldDateOfBirth::RAW_TAG:
     FIXPP_PRINT_FIELD(DateOfBirth)
     group->fieldDateOfBirth.offset = gpos;
     break;

   case FieldInvestorCountryOfResidence::RAW_TAG:
     FIXPP_PRINT_FIELD(InvestorCountryOfResidence)
     group->fieldInvestorCountryOfResidence.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContAmts::scan( Array & arr, const char * fix, unsigned len ){
 GroupContAmts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldContAmtType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContAmtType::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContAmtValue::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtValue)
     group->fieldContAmtValue.offset = gpos;
     break;

   case FieldContAmtCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtCurr)
     group->fieldContAmtCurr.offset = gpos;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntries::scan( Array & arr, const char * fix, unsigned len ){
 GroupMDEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 if( loadRawTag( fix, gpos ) != FieldMDEntryType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
 unsigned groupCount = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMDEntryPx::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryPx)
     group->fieldMDEntryPx.offset = gpos;
     break;

   case FieldCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(Currency)
     group->fieldCurrency.offset = gpos;
     break;

   case FieldMDEntrySize::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntrySize)
     group->fieldMDEntrySize.offset = gpos;
     break;

   case FieldMDEntryDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryDate)
     group->fieldMDEntryDate.offset = gpos;
     break;

   case FieldMDEntryTime::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryTime)
     group->fieldMDEntryTime.offset = gpos;
     break;

   case FieldTickDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(TickDirection)
     group->fieldTickDirection.offset = gpos;
     break;

   case FieldMDMkt::RAW_TAG:
     FIXPP_PRINT_FIELD(MDMkt)
     group->fieldMDMkt.offset = gpos;
     break;

   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     group->fieldTradingSessionID.offset = gpos;
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     group->fieldTradingSessionSubID.offset = gpos;
     break;

   case FieldQuoteCondition::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteCondition)
     group->fieldQuoteCondition.offset = gpos;
     break;

   case FieldTradeCondition::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeCondition)
     group->fieldTradeCondition.offset = gpos;
     break;

   case FieldMDEntryOriginator::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryOriginator)
     group->fieldMDEntryOriginator.offset = gpos;
     break;

   case FieldLocationID::RAW_TAG:
     FIXPP_PRINT_FIELD(LocationID)
     group->fieldLocationID.offset = gpos;
     break;

   case FieldDeskID::RAW_TAG:
     FIXPP_PRINT_FIELD(DeskID)
     group->fieldDeskID.offset = gpos;
     break;

   case FieldOpenCloseSettlFlag::RAW_TAG:
     FIXPP_PRINT_FIELD(OpenCloseSettlFlag)
     group->fieldOpenCloseSettlFlag.offset = gpos;
     break;

   case FieldTimeInForce::RAW_TAG:
     FIXPP_PRINT_FIELD(TimeInForce)
     group->fieldTimeInForce.offset = gpos;
     break;

   case FieldExpireDate::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireDate)
     group->fieldExpireDate.offset = gpos;
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     group->fieldExpireTime.offset = gpos;
     break;

   case FieldMinQty::RAW_TAG:
     FIXPP_PRINT_FIELD(MinQty)
     group->fieldMinQty.offset = gpos;
     break;

   case FieldExecInst::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecInst)
     group->fieldExecInst.offset = gpos;
     break;

   case FieldSellerDays::RAW_TAG:
     FIXPP_PRINT_FIELD(SellerDays)
     group->fieldSellerDays.offset = gpos;
     break;

   case FieldOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderID)
     group->fieldOrderID.offset = gpos;
     break;

   case FieldQuoteEntryID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteEntryID)
     group->fieldQuoteEntryID.offset = gpos;
     break;

   case FieldMDEntryBuyer::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryBuyer)
     group->fieldMDEntryBuyer.offset = gpos;
     break;

   case FieldMDEntrySeller::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntrySeller)
     group->fieldMDEntrySeller.offset = gpos;
     break;

   case FieldNumberOfOrders::RAW_TAG:
     FIXPP_PRINT_FIELD(NumberOfOrders)
     group->fieldNumberOfOrders.offset = gpos;
     break;

   case FieldMDEntryPositionNo::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryPositionNo)
     group->fieldMDEntryPositionNo.offset = gpos;
     break;

   case FieldScope::RAW_TAG:
     FIXPP_PRINT_FIELD(Scope)
     group->fieldScope.offset = gpos;
     break;

   case FieldPriceDelta::RAW_TAG:
     FIXPP_PRINT_FIELD(PriceDelta)
     group->fieldPriceDelta.offset = gpos;
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     group->fieldText.offset = gpos;
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     group->fieldEncodedTextLen.offset = gpos;
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

// -------------------------------------- scanSafely ----------------------------------------

offset_t GroupLegStipulations::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupLegStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldLegStipulationType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegStipulationValue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStipulationValue)
     if( group->fieldLegStipulationValue.offset < 0 ) group->fieldLegStipulationValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupEvents::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupEvents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldEventType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldEventType::RAW_TAG:
     FIXPP_PRINT_FIELD(EventType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldEventType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEventDate::RAW_TAG:
     FIXPP_PRINT_FIELD(EventDate)
     if( group->fieldEventDate.offset < 0 ) group->fieldEventDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEventPx::RAW_TAG:
     FIXPP_PRINT_FIELD(EventPx)
     if( group->fieldEventPx.offset < 0 ) group->fieldEventPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEventText::RAW_TAG:
     FIXPP_PRINT_FIELD(EventText)
     if( group->fieldEventText.offset < 0 ) group->fieldEventText.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegSecurityAltID::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupLegSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldLegSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityAltIDSource)
     if( group->fieldLegSecurityAltIDSource.offset < 0 ) group->fieldLegSecurityAltIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCapacities::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupCapacities * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldOrderCapacity::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacity)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrderCapacity.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrderRestrictions::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderRestrictions) 
     if( group->fieldOrderRestrictions.offset < 0 ) {
       group->fieldOrderRestrictions.offset = gpos;
       if( OrderRestrictionsEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldOrderCapacityQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacityQty)
     if( group->fieldOrderCapacityQty.offset < 0 ) group->fieldOrderCapacityQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNested3PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNested3PartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartySubIDType)
     if( group->fieldNested3PartySubIDType.offset < 0 ) group->fieldNested3PartySubIDType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(PartySubIDType) 
     if( group->fieldPartySubIDType.offset < 0 ) {
       group->fieldPartySubIDType.offset = gpos;
       if( PartySubIDTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNested2PartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNested2PartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartySubIDType)
     if( group->fieldNested2PartySubIDType.offset < 0 ) group->fieldNested2PartySubIDType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested2PartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNested2PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNested2PartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested2PartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested2PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested2PartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyIDSource)
     if( group->fieldNested2PartyIDSource.offset < 0 ) group->fieldNested2PartyIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNested2PartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested2PartyRole)
     if( group->fieldNested2PartyRole.offset < 0 ) group->fieldNested2PartyRole.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNested2PartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested2PartySubIDs) 
     if( group->fieldNoNested2PartySubIDs.offset < 0 ){
       group->fieldNoNested2PartySubIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNested2PartySubIDs::scanSafely( group->groupsNested2PartySubIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupHops::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupHops * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldHopCompID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldHopCompID::RAW_TAG:
     FIXPP_PRINT_FIELD(HopCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldHopCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldHopSendingTime::RAW_TAG:
     FIXPP_PRINT_FIELD(HopSendingTime)
     if( group->fieldHopSendingTime.offset < 0 ) group->fieldHopSendingTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldHopRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(HopRefID)
     if( group->fieldHopRefID.offset < 0 ) group->fieldHopRefID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCollInquiryQualifier::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupCollInquiryQualifier * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldCollInquiryQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldCollInquiryQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(CollInquiryQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldCollInquiryQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyIDSource) 
     if( group->fieldPartyIDSource.offset < 0 ) {
       group->fieldPartyIDSource.offset = gpos;
       if( PartyIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(PartyRole) 
     if( group->fieldPartyRole.offset < 0 ) {
       group->fieldPartyRole.offset = gpos;
       if( PartyRoleEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartySubIDs) 
     if( group->fieldNoPartySubIDs.offset < 0 ){
       group->fieldNoPartySubIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupPartySubIDs::scanSafely( group->groupsPartySubIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAllocs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldAllocAccount::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedAllocText::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAllocAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAllocAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocAcctIDSource)
     if( group->fieldAllocAcctIDSource.offset < 0 ) group->fieldAllocAcctIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAllocPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocPrice)
     if( group->fieldAllocPrice.offset < 0 ) group->fieldAllocPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIndividualAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(IndividualAllocID)
     if( group->fieldIndividualAllocID.offset < 0 ) group->fieldIndividualAllocID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIndividualAllocRejCode::RAW_TAG:
     FIXPP_PRINT_FIELD(IndividualAllocRejCode)
     if( group->fieldIndividualAllocRejCode.offset < 0 ) group->fieldIndividualAllocRejCode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAllocText::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocText)
     if( group->fieldAllocText.offset < 0 ) group->fieldAllocText.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedAllocTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedAllocTextLen)
     if( group->fieldEncodedAllocTextLen.offset < 0 ) group->fieldEncodedAllocTextLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedAllocText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedAllocText)
     if( group->fieldEncodedAllocText.offset < 0 and group->fieldEncodedAllocTextLen.offset >= 0 ) { group->fieldEncodedAllocText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedAllocTextLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTradingSessions::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupTradingSessions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldTradingSessionID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradingSessionID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     if( group->fieldTradingSessionSubID.offset < 0 ) group->fieldTradingSessionSubID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityAltID::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityAltIDSource)
     if( group->fieldSecurityAltIDSource.offset < 0 ) group->fieldSecurityAltIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingSecurityAltID::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupUnderlyingSecurityAltID * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldUnderlyingSecurityAltID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSecurityAltID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSecurityAltIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityAltIDSource)
     if( group->fieldUnderlyingSecurityAltIDSource.offset < 0 ) group->fieldUnderlyingSecurityAltIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyingStips::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupUnderlyingStips * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldUnderlyingStipType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingStipType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStipType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingStipType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingStipValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStipValue)
     if( group->fieldUnderlyingStipValue.offset < 0 ) group->fieldUnderlyingStipValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupUnderlyings::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupUnderlyings * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldUnderlyingSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedUnderlyingSecurityDesc::RAW_TAG and tag != FieldEncodedUnderlyingIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldUnderlyingSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldUnderlyingSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     if( group->fieldUnderlyingSymbolSfx.offset < 0 ) group->fieldUnderlyingSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     if( group->fieldUnderlyingSecurityID.offset < 0 ) group->fieldUnderlyingSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     if( group->fieldUnderlyingSecurityIDSource.offset < 0 ) group->fieldUnderlyingSecurityIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID) 
     if( group->fieldNoUnderlyingSecurityAltID.offset < 0 ){
       group->fieldNoUnderlyingSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyingSecurityAltID::scanSafely( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     if( group->fieldUnderlyingProduct.offset < 0 ) group->fieldUnderlyingProduct.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     if( group->fieldUnderlyingCFICode.offset < 0 ) group->fieldUnderlyingCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     if( group->fieldUnderlyingSecurityType.offset < 0 ) group->fieldUnderlyingSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     if( group->fieldUnderlyingSecuritySubType.offset < 0 ) group->fieldUnderlyingSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     if( group->fieldUnderlyingMaturityMonthYear.offset < 0 ) group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     if( group->fieldUnderlyingMaturityDate.offset < 0 ) group->fieldUnderlyingMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     if( group->fieldUnderlyingPutOrCall.offset < 0 ) group->fieldUnderlyingPutOrCall.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     if( group->fieldUnderlyingCouponPaymentDate.offset < 0 ) group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     if( group->fieldUnderlyingIssueDate.offset < 0 ) group->fieldUnderlyingIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     if( group->fieldUnderlyingRepoCollateralSecurityType.offset < 0 ) group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     if( group->fieldUnderlyingRepurchaseTerm.offset < 0 ) group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     if( group->fieldUnderlyingRepurchaseRate.offset < 0 ) group->fieldUnderlyingRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     if( group->fieldUnderlyingFactor.offset < 0 ) group->fieldUnderlyingFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     if( group->fieldUnderlyingCreditRating.offset < 0 ) group->fieldUnderlyingCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     if( group->fieldUnderlyingInstrRegistry.offset < 0 ) group->fieldUnderlyingInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     if( group->fieldUnderlyingCountryOfIssue.offset < 0 ) group->fieldUnderlyingCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     if( group->fieldUnderlyingStateOrProvinceOfIssue.offset < 0 ) group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     if( group->fieldUnderlyingLocaleOfIssue.offset < 0 ) group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     if( group->fieldUnderlyingRedemptionDate.offset < 0 ) group->fieldUnderlyingRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     if( group->fieldUnderlyingStrikePrice.offset < 0 ) group->fieldUnderlyingStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     if( group->fieldUnderlyingStrikeCurrency.offset < 0 ) group->fieldUnderlyingStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     if( group->fieldUnderlyingOptAttribute.offset < 0 ) group->fieldUnderlyingOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     if( group->fieldUnderlyingContractMultiplier.offset < 0 ) group->fieldUnderlyingContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     if( group->fieldUnderlyingCouponRate.offset < 0 ) group->fieldUnderlyingCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     if( group->fieldUnderlyingSecurityExchange.offset < 0 ) group->fieldUnderlyingSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     if( group->fieldUnderlyingIssuer.offset < 0 ) group->fieldUnderlyingIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     if( group->fieldEncodedUnderlyingIssuerLen.offset < 0 ) group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     if( group->fieldEncodedUnderlyingIssuer.offset < 0 and group->fieldEncodedUnderlyingIssuerLen.offset >= 0 ) { group->fieldEncodedUnderlyingIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     if( group->fieldUnderlyingSecurityDesc.offset < 0 ) group->fieldUnderlyingSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     if( group->fieldEncodedUnderlyingSecurityDescLen.offset < 0 ) group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     if( group->fieldEncodedUnderlyingSecurityDesc.offset < 0 and group->fieldEncodedUnderlyingSecurityDescLen.offset >= 0 ) { group->fieldEncodedUnderlyingSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     if( group->fieldUnderlyingCPProgram.offset < 0 ) group->fieldUnderlyingCPProgram.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     if( group->fieldUnderlyingCPRegType.offset < 0 ) group->fieldUnderlyingCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     if( group->fieldUnderlyingCurrency.offset < 0 ) group->fieldUnderlyingCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingQty::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingQty)
     if( group->fieldUnderlyingQty.offset < 0 ) group->fieldUnderlyingQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingPx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPx)
     if( group->fieldUnderlyingPx.offset < 0 ) group->fieldUnderlyingPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     if( group->fieldUnderlyingDirtyPrice.offset < 0 ) group->fieldUnderlyingDirtyPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingEndPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     if( group->fieldUnderlyingEndPrice.offset < 0 ) group->fieldUnderlyingEndPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStartValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     if( group->fieldUnderlyingStartValue.offset < 0 ) group->fieldUnderlyingStartValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     if( group->fieldUnderlyingCurrentValue.offset < 0 ) group->fieldUnderlyingCurrentValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingEndValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     if( group->fieldUnderlyingEndValue.offset < 0 ) group->fieldUnderlyingEndValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyingStips::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingStips) 
     if( group->fieldNoUnderlyingStips.offset < 0 ){
       group->fieldNoUnderlyingStips.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyingStips::scanSafely( group->groupsUnderlyingStips, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSettlPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSettlPrice)
     if( group->fieldUnderlyingSettlPrice.offset < 0 ) group->fieldUnderlyingSettlPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSettlPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSettlPriceType)
     if( group->fieldUnderlyingSettlPriceType.offset < 0 ) group->fieldUnderlyingSettlPriceType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStipulations::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupStipulations * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldStipulationType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldStipulationType::RAW_TAG:
     FIXPP_PRINT_FIELD(StipulationType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldStipulationType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldStipulationValue::RAW_TAG:
     FIXPP_PRINT_FIELD(StipulationValue)
     if( group->fieldStipulationValue.offset < 0 ) group->fieldStipulationValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupOrders::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldClOrdID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedText::RAW_TAG and tag != FieldEncodedSecurityDesc::RAW_TAG and tag != FieldEncodedIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     if( group->fieldSecondaryClOrdID.offset < 0 ) group->fieldSecondaryClOrdID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldListSeqNo::RAW_TAG:
     FIXPP_PRINT_FIELD(ListSeqNo)
     if( group->fieldListSeqNo.offset < 0 ) group->fieldListSeqNo.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldClOrdLinkID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     if( group->fieldClOrdLinkID.offset < 0 ) group->fieldClOrdLinkID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSettlInstMode::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstMode) 
     if( group->fieldSettlInstMode.offset < 0 ) {
       group->fieldSettlInstMode.offset = gpos;
       if( SettlInstModeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs) 
     if( group->fieldNoPartyIDs.offset < 0 ){
       group->fieldNoPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupPartyIDs::scanSafely( group->groupsPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradeOriginationDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     if( group->fieldTradeOriginationDate.offset < 0 ) group->fieldTradeOriginationDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     if( group->fieldTradeDate.offset < 0 ) group->fieldTradeDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(Account)
     if( group->fieldAccount.offset < 0 ) group->fieldAccount.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AcctIDSource) 
     if( group->fieldAcctIDSource.offset < 0 ) {
       group->fieldAcctIDSource.offset = gpos;
       if( AcctIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldAccountType::RAW_TAG:
     FIXPP_PRINT_FIELD(AccountType) 
     if( group->fieldAccountType.offset < 0 ) {
       group->fieldAccountType.offset = gpos;
       if( AccountTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDayBookingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(DayBookingInst) 
     if( group->fieldDayBookingInst.offset < 0 ) {
       group->fieldDayBookingInst.offset = gpos;
       if( DayBookingInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldBookingUnit::RAW_TAG:
     FIXPP_PRINT_FIELD(BookingUnit) 
     if( group->fieldBookingUnit.offset < 0 ) {
       group->fieldBookingUnit.offset = gpos;
       if( BookingUnitEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(AllocID)
     if( group->fieldAllocID.offset < 0 ) group->fieldAllocID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPreallocMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(PreallocMethod) 
     if( group->fieldPreallocMethod.offset < 0 ) {
       group->fieldPreallocMethod.offset = gpos;
       if( PreallocMethodEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoAllocs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoAllocs) 
     if( group->fieldNoAllocs.offset < 0 ){
       group->fieldNoAllocs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupAllocs::scanSafely( group->groupsAllocs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlType) 
     if( group->fieldSettlType.offset < 0 ) {
       group->fieldSettlType.offset = gpos;
       if( SettlTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate)
     if( group->fieldSettlDate.offset < 0 ) group->fieldSettlDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashMargin::RAW_TAG:
     FIXPP_PRINT_FIELD(CashMargin) 
     if( group->fieldCashMargin.offset < 0 ) {
       group->fieldCashMargin.offset = gpos;
       if( CashMarginEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldClearingFeeIndicator::RAW_TAG:
     FIXPP_PRINT_FIELD(ClearingFeeIndicator) 
     if( group->fieldClearingFeeIndicator.offset < 0 ) {
       group->fieldClearingFeeIndicator.offset = gpos;
       if( ClearingFeeIndicatorEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldHandlInst::RAW_TAG:
     FIXPP_PRINT_FIELD(HandlInst) 
     if( group->fieldHandlInst.offset < 0 ) {
       group->fieldHandlInst.offset = gpos;
       if( HandlInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldExecInst::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecInst) 
     if( group->fieldExecInst.offset < 0 ) {
       group->fieldExecInst.offset = gpos;
       if( ExecInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMinQty::RAW_TAG:
     FIXPP_PRINT_FIELD(MinQty)
     if( group->fieldMinQty.offset < 0 ) group->fieldMinQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaxFloor::RAW_TAG:
     FIXPP_PRINT_FIELD(MaxFloor)
     if( group->fieldMaxFloor.offset < 0 ) group->fieldMaxFloor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExDestination::RAW_TAG:
     FIXPP_PRINT_FIELD(ExDestination)
     if( group->fieldExDestination.offset < 0 ) group->fieldExDestination.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoTradingSessions::RAW_TAG:
     FIXPP_PRINT_FIELD(NoTradingSessions) 
     if( group->fieldNoTradingSessions.offset < 0 ){
       group->fieldNoTradingSessions.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupTradingSessions::scanSafely( group->groupsTradingSessions, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProcessCode::RAW_TAG:
     FIXPP_PRINT_FIELD(ProcessCode) 
     if( group->fieldProcessCode.offset < 0 ) {
       group->fieldProcessCode.offset = gpos;
       if( ProcessCodeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group->fieldSymbol.offset < 0 ) group->fieldSymbol.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     if( group->fieldSymbolSfx.offset < 0 ) group->fieldSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     if( group->fieldSecurityID.offset < 0 ) group->fieldSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource) 
     if( group->fieldSecurityIDSource.offset < 0 ) {
       group->fieldSecurityIDSource.offset = gpos;
       if( SecurityIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID) 
     if( group->fieldNoSecurityAltID.offset < 0 ){
       group->fieldNoSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSecurityAltID::scanSafely( group->groupsSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType) 
     if( group->fieldSecurityType.offset < 0 ) {
       group->fieldSecurityType.offset = gpos;
       if( SecurityTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     if( group->fieldSecuritySubType.offset < 0 ) group->fieldSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     if( group->fieldMaturityMonthYear.offset < 0 ) group->fieldMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     if( group->fieldMaturityDate.offset < 0 ) group->fieldMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall) 
     if( group->fieldPutOrCall.offset < 0 ) {
       group->fieldPutOrCall.offset = gpos;
       if( PutOrCallEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     if( group->fieldCouponPaymentDate.offset < 0 ) group->fieldCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     if( group->fieldIssueDate.offset < 0 ) group->fieldIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     if( group->fieldRepoCollateralSecurityType.offset < 0 ) group->fieldRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     if( group->fieldRepurchaseTerm.offset < 0 ) group->fieldRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     if( group->fieldRepurchaseRate.offset < 0 ) group->fieldRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     if( group->fieldFactor.offset < 0 ) group->fieldFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     if( group->fieldCreditRating.offset < 0 ) group->fieldCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     if( group->fieldInstrRegistry.offset < 0 ) group->fieldInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     if( group->fieldCountryOfIssue.offset < 0 ) group->fieldCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     if( group->fieldStateOrProvinceOfIssue.offset < 0 ) group->fieldStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     if( group->fieldLocaleOfIssue.offset < 0 ) group->fieldLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     if( group->fieldRedemptionDate.offset < 0 ) group->fieldRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     if( group->fieldStrikePrice.offset < 0 ) group->fieldStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     if( group->fieldStrikeCurrency.offset < 0 ) group->fieldStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     if( group->fieldOptAttribute.offset < 0 ) group->fieldOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     if( group->fieldContractMultiplier.offset < 0 ) group->fieldContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     if( group->fieldCouponRate.offset < 0 ) group->fieldCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     if( group->fieldSecurityExchange.offset < 0 ) group->fieldSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     if( group->fieldIssuer.offset < 0 ) group->fieldIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     if( group->fieldEncodedIssuerLen.offset < 0 ) group->fieldEncodedIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     if( group->fieldEncodedIssuer.offset < 0 and group->fieldEncodedIssuerLen.offset >= 0 ) { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     if( group->fieldSecurityDesc.offset < 0 ) group->fieldSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     if( group->fieldEncodedSecurityDescLen.offset < 0 ) group->fieldEncodedSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     if( group->fieldEncodedSecurityDesc.offset < 0 and group->fieldEncodedSecurityDescLen.offset >= 0 ) { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     if( group->fieldPool.offset < 0 ) group->fieldPool.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     if( group->fieldContractSettlMonth.offset < 0 ) group->fieldContractSettlMonth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram) 
     if( group->fieldCPProgram.offset < 0 ) {
       group->fieldCPProgram.offset = gpos;
       if( CPProgramEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     if( group->fieldCPRegType.offset < 0 ) group->fieldCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents) 
     if( group->fieldNoEvents.offset < 0 ){
       group->fieldNoEvents.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupEvents::scanSafely( group->groupsEvents, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     if( group->fieldDatedDate.offset < 0 ) group->fieldDatedDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     if( group->fieldInterestAccrualDate.offset < 0 ) group->fieldInterestAccrualDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyings::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyings) 
     if( group->fieldNoUnderlyings.offset < 0 ){
       group->fieldNoUnderlyings.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyings::scanSafely( group->groupsUnderlyings, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPrevClosePx::RAW_TAG:
     FIXPP_PRINT_FIELD(PrevClosePx)
     if( group->fieldPrevClosePx.offset < 0 ) group->fieldPrevClosePx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side) 
     if( group->fieldSide.offset < 0 ) {
       group->fieldSide.offset = gpos;
       if( SideEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSideValueInd::RAW_TAG:
     FIXPP_PRINT_FIELD(SideValueInd) 
     if( group->fieldSideValueInd.offset < 0 ) {
       group->fieldSideValueInd.offset = gpos;
       if( SideValueIndEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldLocateReqd::RAW_TAG:
     FIXPP_PRINT_FIELD(LocateReqd) 
     if( group->fieldLocateReqd.offset < 0 ) {
       group->fieldLocateReqd.offset = gpos;
       if( LocateReqdEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTransactTime::RAW_TAG:
     FIXPP_PRINT_FIELD(TransactTime)
     if( group->fieldTransactTime.offset < 0 ) group->fieldTransactTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoStipulations::RAW_TAG:
     FIXPP_PRINT_FIELD(NoStipulations) 
     if( group->fieldNoStipulations.offset < 0 ){
       group->fieldNoStipulations.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupStipulations::scanSafely( group->groupsStipulations, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldQtyType::RAW_TAG:
     FIXPP_PRINT_FIELD(QtyType) 
     if( group->fieldQtyType.offset < 0 ) {
       group->fieldQtyType.offset = gpos;
       if( QtyTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty)
     if( group->fieldOrderQty.offset < 0 ) group->fieldOrderQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(CashOrderQty)
     if( group->fieldCashOrderQty.offset < 0 ) group->fieldCashOrderQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrderPercent::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderPercent)
     if( group->fieldOrderPercent.offset < 0 ) group->fieldOrderPercent.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRoundingDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingDirection) 
     if( group->fieldRoundingDirection.offset < 0 ) {
       group->fieldRoundingDirection.offset = gpos;
       if( RoundingDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldRoundingModulus::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingModulus)
     if( group->fieldRoundingModulus.offset < 0 ) group->fieldRoundingModulus.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrdType::RAW_TAG:
     FIXPP_PRINT_FIELD(OrdType) 
     if( group->fieldOrdType.offset < 0 ) {
       group->fieldOrdType.offset = gpos;
       if( OrdTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(PriceType) 
     if( group->fieldPriceType.offset < 0 ) {
       group->fieldPriceType.offset = gpos;
       if( PriceTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(Price)
     if( group->fieldPrice.offset < 0 ) group->fieldPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStopPx::RAW_TAG:
     FIXPP_PRINT_FIELD(StopPx)
     if( group->fieldStopPx.offset < 0 ) group->fieldStopPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSpread::RAW_TAG:
     FIXPP_PRINT_FIELD(Spread)
     if( group->fieldSpread.offset < 0 ) group->fieldSpread.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkCurveCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurveCurrency)
     if( group->fieldBenchmarkCurveCurrency.offset < 0 ) group->fieldBenchmarkCurveCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkCurveName::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurveName)
     if( group->fieldBenchmarkCurveName.offset < 0 ) group->fieldBenchmarkCurveName.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkCurvePoint::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkCurvePoint)
     if( group->fieldBenchmarkCurvePoint.offset < 0 ) group->fieldBenchmarkCurvePoint.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkPrice)
     if( group->fieldBenchmarkPrice.offset < 0 ) group->fieldBenchmarkPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkPriceType)
     if( group->fieldBenchmarkPriceType.offset < 0 ) group->fieldBenchmarkPriceType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkSecurityID)
     if( group->fieldBenchmarkSecurityID.offset < 0 ) group->fieldBenchmarkSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBenchmarkSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(BenchmarkSecurityIDSource)
     if( group->fieldBenchmarkSecurityIDSource.offset < 0 ) group->fieldBenchmarkSecurityIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldYieldType::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldType) 
     if( group->fieldYieldType.offset < 0 ) {
       group->fieldYieldType.offset = gpos;
       if( YieldTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldYield::RAW_TAG:
     FIXPP_PRINT_FIELD(Yield)
     if( group->fieldYield.offset < 0 ) group->fieldYield.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldYieldCalcDate::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldCalcDate)
     if( group->fieldYieldCalcDate.offset < 0 ) group->fieldYieldCalcDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldYieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionDate)
     if( group->fieldYieldRedemptionDate.offset < 0 ) group->fieldYieldRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldYieldRedemptionPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionPrice)
     if( group->fieldYieldRedemptionPrice.offset < 0 ) group->fieldYieldRedemptionPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldYieldRedemptionPriceType::RAW_TAG:
     FIXPP_PRINT_FIELD(YieldRedemptionPriceType)
     if( group->fieldYieldRedemptionPriceType.offset < 0 ) group->fieldYieldRedemptionPriceType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(Currency)
     if( group->fieldCurrency.offset < 0 ) group->fieldCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldComplianceID::RAW_TAG:
     FIXPP_PRINT_FIELD(ComplianceID)
     if( group->fieldComplianceID.offset < 0 ) group->fieldComplianceID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSolicitedFlag::RAW_TAG:
     FIXPP_PRINT_FIELD(SolicitedFlag) 
     if( group->fieldSolicitedFlag.offset < 0 ) {
       group->fieldSolicitedFlag.offset = gpos;
       if( SolicitedFlagEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldIOIID::RAW_TAG:
     FIXPP_PRINT_FIELD(IOIID)
     if( group->fieldIOIID.offset < 0 ) group->fieldIOIID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldQuoteID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteID)
     if( group->fieldQuoteID.offset < 0 ) group->fieldQuoteID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTimeInForce::RAW_TAG:
     FIXPP_PRINT_FIELD(TimeInForce) 
     if( group->fieldTimeInForce.offset < 0 ) {
       group->fieldTimeInForce.offset = gpos;
       if( TimeInForceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldEffectiveTime::RAW_TAG:
     FIXPP_PRINT_FIELD(EffectiveTime)
     if( group->fieldEffectiveTime.offset < 0 ) group->fieldEffectiveTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExpireDate::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireDate)
     if( group->fieldExpireDate.offset < 0 ) group->fieldExpireDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     if( group->fieldExpireTime.offset < 0 ) group->fieldExpireTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldGTBookingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(GTBookingInst) 
     if( group->fieldGTBookingInst.offset < 0 ) {
       group->fieldGTBookingInst.offset = gpos;
       if( GTBookingInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCommission::RAW_TAG:
     FIXPP_PRINT_FIELD(Commission)
     if( group->fieldCommission.offset < 0 ) group->fieldCommission.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCommType::RAW_TAG:
     FIXPP_PRINT_FIELD(CommType) 
     if( group->fieldCommType.offset < 0 ) {
       group->fieldCommType.offset = gpos;
       if( CommTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCommCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(CommCurrency)
     if( group->fieldCommCurrency.offset < 0 ) group->fieldCommCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFundRenewWaiv::RAW_TAG:
     FIXPP_PRINT_FIELD(FundRenewWaiv) 
     if( group->fieldFundRenewWaiv.offset < 0 ) {
       group->fieldFundRenewWaiv.offset = gpos;
       if( FundRenewWaivEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderCapacity) 
     if( group->fieldOrderCapacity.offset < 0 ) {
       group->fieldOrderCapacity.offset = gpos;
       if( OrderCapacityEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldOrderRestrictions::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderRestrictions) 
     if( group->fieldOrderRestrictions.offset < 0 ) {
       group->fieldOrderRestrictions.offset = gpos;
       if( OrderRestrictionsEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCustOrderCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(CustOrderCapacity) 
     if( group->fieldCustOrderCapacity.offset < 0 ) {
       group->fieldCustOrderCapacity.offset = gpos;
       if( CustOrderCapacityEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldForexReq::RAW_TAG:
     FIXPP_PRINT_FIELD(ForexReq) 
     if( group->fieldForexReq.offset < 0 ) {
       group->fieldForexReq.offset = gpos;
       if( ForexReqEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSettlCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlCurrency)
     if( group->fieldSettlCurrency.offset < 0 ) group->fieldSettlCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldBookingType::RAW_TAG:
     FIXPP_PRINT_FIELD(BookingType) 
     if( group->fieldBookingType.offset < 0 ) {
       group->fieldBookingType.offset = gpos;
       if( BookingTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     if( group->fieldText.offset < 0 ) group->fieldText.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     if( group->fieldEncodedTextLen.offset < 0 ) group->fieldEncodedTextLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     if( group->fieldEncodedText.offset < 0 and group->fieldEncodedTextLen.offset >= 0 ) { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSettlDate2::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate2)
     if( group->fieldSettlDate2.offset < 0 ) group->fieldSettlDate2.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrderQty2::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty2)
     if( group->fieldOrderQty2.offset < 0 ) group->fieldOrderQty2.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPrice2::RAW_TAG:
     FIXPP_PRINT_FIELD(Price2)
     if( group->fieldPrice2.offset < 0 ) group->fieldPrice2.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPositionEffect::RAW_TAG:
     FIXPP_PRINT_FIELD(PositionEffect) 
     if( group->fieldPositionEffect.offset < 0 ) {
       group->fieldPositionEffect.offset = gpos;
       if( PositionEffectEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCoveredOrUncovered::RAW_TAG:
     FIXPP_PRINT_FIELD(CoveredOrUncovered) 
     if( group->fieldCoveredOrUncovered.offset < 0 ) {
       group->fieldCoveredOrUncovered.offset = gpos;
       if( CoveredOrUncoveredEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMaxShow::RAW_TAG:
     FIXPP_PRINT_FIELD(MaxShow)
     if( group->fieldMaxShow.offset < 0 ) group->fieldMaxShow.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPegOffsetValue::RAW_TAG:
     FIXPP_PRINT_FIELD(PegOffsetValue)
     if( group->fieldPegOffsetValue.offset < 0 ) group->fieldPegOffsetValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPegMoveType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegMoveType) 
     if( group->fieldPegMoveType.offset < 0 ) {
       group->fieldPegMoveType.offset = gpos;
       if( PegMoveTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPegOffsetType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegOffsetType) 
     if( group->fieldPegOffsetType.offset < 0 ) {
       group->fieldPegOffsetType.offset = gpos;
       if( PegOffsetTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPegLimitType::RAW_TAG:
     FIXPP_PRINT_FIELD(PegLimitType) 
     if( group->fieldPegLimitType.offset < 0 ) {
       group->fieldPegLimitType.offset = gpos;
       if( PegLimitTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPegRoundDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(PegRoundDirection) 
     if( group->fieldPegRoundDirection.offset < 0 ) {
       group->fieldPegRoundDirection.offset = gpos;
       if( PegRoundDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPegScope::RAW_TAG:
     FIXPP_PRINT_FIELD(PegScope) 
     if( group->fieldPegScope.offset < 0 ) {
       group->fieldPegScope.offset = gpos;
       if( PegScopeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionInst::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionInst) 
     if( group->fieldDiscretionInst.offset < 0 ) {
       group->fieldDiscretionInst.offset = gpos;
       if( DiscretionInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionOffsetValue::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionOffsetValue)
     if( group->fieldDiscretionOffsetValue.offset < 0 ) group->fieldDiscretionOffsetValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDiscretionMoveType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionMoveType) 
     if( group->fieldDiscretionMoveType.offset < 0 ) {
       group->fieldDiscretionMoveType.offset = gpos;
       if( DiscretionMoveTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionOffsetType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionOffsetType) 
     if( group->fieldDiscretionOffsetType.offset < 0 ) {
       group->fieldDiscretionOffsetType.offset = gpos;
       if( DiscretionOffsetTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionLimitType::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionLimitType) 
     if( group->fieldDiscretionLimitType.offset < 0 ) {
       group->fieldDiscretionLimitType.offset = gpos;
       if( DiscretionLimitTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionRoundDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionRoundDirection) 
     if( group->fieldDiscretionRoundDirection.offset < 0 ) {
       group->fieldDiscretionRoundDirection.offset = gpos;
       if( DiscretionRoundDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDiscretionScope::RAW_TAG:
     FIXPP_PRINT_FIELD(DiscretionScope) 
     if( group->fieldDiscretionScope.offset < 0 ) {
       group->fieldDiscretionScope.offset = gpos;
       if( DiscretionScopeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTargetStrategy::RAW_TAG:
     FIXPP_PRINT_FIELD(TargetStrategy) 
     if( group->fieldTargetStrategy.offset < 0 ) {
       group->fieldTargetStrategy.offset = gpos;
       if( TargetStrategyEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTargetStrategyParameters::RAW_TAG:
     FIXPP_PRINT_FIELD(TargetStrategyParameters)
     if( group->fieldTargetStrategyParameters.offset < 0 ) group->fieldTargetStrategyParameters.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldParticipationRate::RAW_TAG:
     FIXPP_PRINT_FIELD(ParticipationRate)
     if( group->fieldParticipationRate.offset < 0 ) group->fieldParticipationRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDesignation::RAW_TAG:
     FIXPP_PRINT_FIELD(Designation)
     if( group->fieldDesignation.offset < 0 ) group->fieldDesignation.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSettlPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSettlPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedUnderlyingSecurityDesc::RAW_TAG and tag != FieldEncodedUnderlyingIssuer::RAW_TAG and tag != FieldEncodedAllocText::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartySubIDType)
     if( group->fieldSettlPartySubIDType.offset < 0 ) group->fieldSettlPartySubIDType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlPartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSettlPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSettlPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyIDSource)
     if( group->fieldSettlPartyIDSource.offset < 0 ) group->fieldSettlPartyIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSettlPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlPartyRole)
     if( group->fieldSettlPartyRole.offset < 0 ) group->fieldSettlPartyRole.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoSettlPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSettlPartySubIDs) 
     if( group->fieldNoSettlPartySubIDs.offset < 0 ){
       group->fieldNoSettlPartySubIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSettlPartySubIDs::scanSafely( group->groupsSettlPartySubIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDlvyInst::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupDlvyInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSettlInstSource::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstSource)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstSource.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDlvyInstType::RAW_TAG:
     FIXPP_PRINT_FIELD(DlvyInstType) 
     if( group->fieldDlvyInstType.offset < 0 ) {
       group->fieldDlvyInstType.offset = gpos;
       if( DlvyInstTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoSettlPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSettlPartyIDs) 
     if( group->fieldNoSettlPartyIDs.offset < 0 ){
       group->fieldNoSettlPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSettlPartyIDs::scanSafely( group->groupsSettlPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupClearingInstructions::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupClearingInstructions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldClearingInstruction::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldClearingInstruction::RAW_TAG:
     FIXPP_PRINT_FIELD(ClearingInstruction)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldClearingInstruction.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartySubIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNestedPartySubIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNestedPartySubID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartySubID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartySubID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartySubIDType::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartySubIDType)
     if( group->fieldNestedPartySubIDType.offset < 0 ) group->fieldNestedPartySubIDType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNestedPartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNestedPartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNestedPartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNestedPartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNestedPartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyIDSource)
     if( group->fieldNestedPartyIDSource.offset < 0 ) group->fieldNestedPartyIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNestedPartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(NestedPartyRole)
     if( group->fieldNestedPartyRole.offset < 0 ) group->fieldNestedPartyRole.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartySubIDs) 
     if( group->fieldNoNestedPartySubIDs.offset < 0 ){
       group->fieldNoNestedPartySubIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartySubIDs::scanSafely( group->groupsNestedPartySubIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupLegs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldLegSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedLegSecurityDesc::RAW_TAG and tag != FieldEncodedLegIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSymbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSymbolSfx)
     if( group->fieldLegSymbolSfx.offset < 0 ) group->fieldLegSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityID)
     if( group->fieldLegSecurityID.offset < 0 ) group->fieldLegSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityIDSource)
     if( group->fieldLegSecurityIDSource.offset < 0 ) group->fieldLegSecurityIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoLegSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegSecurityAltID) 
     if( group->fieldNoLegSecurityAltID.offset < 0 ){
       group->fieldNoLegSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupLegSecurityAltID::scanSafely( group->groupsLegSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(LegProduct)
     if( group->fieldLegProduct.offset < 0 ) group->fieldLegProduct.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCFICode)
     if( group->fieldLegCFICode.offset < 0 ) group->fieldLegCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityType)
     if( group->fieldLegSecurityType.offset < 0 ) group->fieldLegSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecuritySubType)
     if( group->fieldLegSecuritySubType.offset < 0 ) group->fieldLegSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(LegMaturityMonthYear)
     if( group->fieldLegMaturityMonthYear.offset < 0 ) group->fieldLegMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegMaturityDate)
     if( group->fieldLegMaturityDate.offset < 0 ) group->fieldLegMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCouponPaymentDate)
     if( group->fieldLegCouponPaymentDate.offset < 0 ) group->fieldLegCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIssueDate)
     if( group->fieldLegIssueDate.offset < 0 ) group->fieldLegIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepoCollateralSecurityType)
     if( group->fieldLegRepoCollateralSecurityType.offset < 0 ) group->fieldLegRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepurchaseTerm)
     if( group->fieldLegRepurchaseTerm.offset < 0 ) group->fieldLegRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRepurchaseRate)
     if( group->fieldLegRepurchaseRate.offset < 0 ) group->fieldLegRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(LegFactor)
     if( group->fieldLegFactor.offset < 0 ) group->fieldLegFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCreditRating)
     if( group->fieldLegCreditRating.offset < 0 ) group->fieldLegCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(LegInstrRegistry)
     if( group->fieldLegInstrRegistry.offset < 0 ) group->fieldLegInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCountryOfIssue)
     if( group->fieldLegCountryOfIssue.offset < 0 ) group->fieldLegCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStateOrProvinceOfIssue)
     if( group->fieldLegStateOrProvinceOfIssue.offset < 0 ) group->fieldLegStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LegLocaleOfIssue)
     if( group->fieldLegLocaleOfIssue.offset < 0 ) group->fieldLegLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRedemptionDate)
     if( group->fieldLegRedemptionDate.offset < 0 ) group->fieldLegRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStrikePrice)
     if( group->fieldLegStrikePrice.offset < 0 ) group->fieldLegStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegStrikeCurrency)
     if( group->fieldLegStrikeCurrency.offset < 0 ) group->fieldLegStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(LegOptAttribute)
     if( group->fieldLegOptAttribute.offset < 0 ) group->fieldLegOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(LegContractMultiplier)
     if( group->fieldLegContractMultiplier.offset < 0 ) group->fieldLegContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCouponRate)
     if( group->fieldLegCouponRate.offset < 0 ) group->fieldLegCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityExchange)
     if( group->fieldLegSecurityExchange.offset < 0 ) group->fieldLegSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIssuer)
     if( group->fieldLegIssuer.offset < 0 ) group->fieldLegIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedLegIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegIssuerLen)
     if( group->fieldEncodedLegIssuerLen.offset < 0 ) group->fieldEncodedLegIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedLegIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegIssuer)
     if( group->fieldEncodedLegIssuer.offset < 0 and group->fieldEncodedLegIssuerLen.offset >= 0 ) { group->fieldEncodedLegIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedLegIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSecurityDesc)
     if( group->fieldLegSecurityDesc.offset < 0 ) group->fieldLegSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedLegSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegSecurityDescLen)
     if( group->fieldEncodedLegSecurityDescLen.offset < 0 ) group->fieldEncodedLegSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedLegSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedLegSecurityDesc)
     if( group->fieldEncodedLegSecurityDesc.offset < 0 and group->fieldEncodedLegSecurityDescLen.offset >= 0 ) { group->fieldEncodedLegSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedLegSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRatioQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRatioQty)
     if( group->fieldLegRatioQty.offset < 0 ) group->fieldLegRatioQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSide::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSide)
     if( group->fieldLegSide.offset < 0 ) group->fieldLegSide.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCurrency)
     if( group->fieldLegCurrency.offset < 0 ) group->fieldLegCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegPool::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPool)
     if( group->fieldLegPool.offset < 0 ) group->fieldLegPool.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegDatedDate)
     if( group->fieldLegDatedDate.offset < 0 ) group->fieldLegDatedDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(LegContractSettlMonth)
     if( group->fieldLegContractSettlMonth.offset < 0 ) group->fieldLegContractSettlMonth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegInterestAccrualDate)
     if( group->fieldLegInterestAccrualDate.offset < 0 ) group->fieldLegInterestAccrualDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegQty)
     if( group->fieldLegQty.offset < 0 ) group->fieldLegQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSwapType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSwapType) 
     if( group->fieldLegSwapType.offset < 0 ) {
       group->fieldLegSwapType.offset = gpos;
       if( LegSwapTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoLegStipulations::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegStipulations) 
     if( group->fieldNoLegStipulations.offset < 0 ){
       group->fieldNoLegStipulations.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupLegStipulations::scanSafely( group->groupsLegStipulations, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegPositionEffect::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPositionEffect)
     if( group->fieldLegPositionEffect.offset < 0 ) group->fieldLegPositionEffect.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegCoveredOrUncovered::RAW_TAG:
     FIXPP_PRINT_FIELD(LegCoveredOrUncovered)
     if( group->fieldLegCoveredOrUncovered.offset < 0 ) group->fieldLegCoveredOrUncovered.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs) 
     if( group->fieldNoNestedPartyIDs.offset < 0 ){
       group->fieldNoNestedPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartyIDs::scanSafely( group->groupsNestedPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegRefID)
     if( group->fieldLegRefID.offset < 0 ) group->fieldLegRefID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(LegPrice)
     if( group->fieldLegPrice.offset < 0 ) group->fieldLegPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlType)
     if( group->fieldLegSettlType.offset < 0 ) group->fieldLegSettlType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlDate)
     if( group->fieldLegSettlDate.offset < 0 ) group->fieldLegSettlDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegLastPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LegLastPx)
     if( group->fieldLegLastPx.offset < 0 ) group->fieldLegLastPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteEntries::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupQuoteEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedSecurityDesc::RAW_TAG and tag != FieldEncodedIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     if( group->fieldSymbolSfx.offset < 0 ) group->fieldSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     if( group->fieldSecurityID.offset < 0 ) group->fieldSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource) 
     if( group->fieldSecurityIDSource.offset < 0 ) {
       group->fieldSecurityIDSource.offset = gpos;
       if( SecurityIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID) 
     if( group->fieldNoSecurityAltID.offset < 0 ){
       group->fieldNoSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSecurityAltID::scanSafely( group->groupsSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType) 
     if( group->fieldSecurityType.offset < 0 ) {
       group->fieldSecurityType.offset = gpos;
       if( SecurityTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     if( group->fieldSecuritySubType.offset < 0 ) group->fieldSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     if( group->fieldMaturityMonthYear.offset < 0 ) group->fieldMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     if( group->fieldMaturityDate.offset < 0 ) group->fieldMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall) 
     if( group->fieldPutOrCall.offset < 0 ) {
       group->fieldPutOrCall.offset = gpos;
       if( PutOrCallEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     if( group->fieldCouponPaymentDate.offset < 0 ) group->fieldCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     if( group->fieldIssueDate.offset < 0 ) group->fieldIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     if( group->fieldRepoCollateralSecurityType.offset < 0 ) group->fieldRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     if( group->fieldRepurchaseTerm.offset < 0 ) group->fieldRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     if( group->fieldRepurchaseRate.offset < 0 ) group->fieldRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     if( group->fieldFactor.offset < 0 ) group->fieldFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     if( group->fieldCreditRating.offset < 0 ) group->fieldCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     if( group->fieldInstrRegistry.offset < 0 ) group->fieldInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     if( group->fieldCountryOfIssue.offset < 0 ) group->fieldCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     if( group->fieldStateOrProvinceOfIssue.offset < 0 ) group->fieldStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     if( group->fieldLocaleOfIssue.offset < 0 ) group->fieldLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     if( group->fieldRedemptionDate.offset < 0 ) group->fieldRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     if( group->fieldStrikePrice.offset < 0 ) group->fieldStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     if( group->fieldStrikeCurrency.offset < 0 ) group->fieldStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     if( group->fieldOptAttribute.offset < 0 ) group->fieldOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     if( group->fieldContractMultiplier.offset < 0 ) group->fieldContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     if( group->fieldCouponRate.offset < 0 ) group->fieldCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     if( group->fieldSecurityExchange.offset < 0 ) group->fieldSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     if( group->fieldIssuer.offset < 0 ) group->fieldIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     if( group->fieldEncodedIssuerLen.offset < 0 ) group->fieldEncodedIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     if( group->fieldEncodedIssuer.offset < 0 and group->fieldEncodedIssuerLen.offset >= 0 ) { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     if( group->fieldSecurityDesc.offset < 0 ) group->fieldSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     if( group->fieldEncodedSecurityDescLen.offset < 0 ) group->fieldEncodedSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     if( group->fieldEncodedSecurityDesc.offset < 0 and group->fieldEncodedSecurityDescLen.offset >= 0 ) { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     if( group->fieldPool.offset < 0 ) group->fieldPool.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     if( group->fieldContractSettlMonth.offset < 0 ) group->fieldContractSettlMonth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram) 
     if( group->fieldCPProgram.offset < 0 ) {
       group->fieldCPProgram.offset = gpos;
       if( CPProgramEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     if( group->fieldCPRegType.offset < 0 ) group->fieldCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents) 
     if( group->fieldNoEvents.offset < 0 ){
       group->fieldNoEvents.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupEvents::scanSafely( group->groupsEvents, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     if( group->fieldDatedDate.offset < 0 ) group->fieldDatedDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     if( group->fieldInterestAccrualDate.offset < 0 ) group->fieldInterestAccrualDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAgreementDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementDesc)
     if( group->fieldAgreementDesc.offset < 0 ) group->fieldAgreementDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAgreementID::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementID)
     if( group->fieldAgreementID.offset < 0 ) group->fieldAgreementID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAgreementDate::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementDate)
     if( group->fieldAgreementDate.offset < 0 ) group->fieldAgreementDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAgreementCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(AgreementCurrency)
     if( group->fieldAgreementCurrency.offset < 0 ) group->fieldAgreementCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTerminationType::RAW_TAG:
     FIXPP_PRINT_FIELD(TerminationType) 
     if( group->fieldTerminationType.offset < 0 ) {
       group->fieldTerminationType.offset = gpos;
       if( TerminationTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldStartDate::RAW_TAG:
     FIXPP_PRINT_FIELD(StartDate)
     if( group->fieldStartDate.offset < 0 ) group->fieldStartDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEndDate::RAW_TAG:
     FIXPP_PRINT_FIELD(EndDate)
     if( group->fieldEndDate.offset < 0 ) group->fieldEndDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDeliveryType::RAW_TAG:
     FIXPP_PRINT_FIELD(DeliveryType) 
     if( group->fieldDeliveryType.offset < 0 ) {
       group->fieldDeliveryType.offset = gpos;
       if( DeliveryTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMarginRatio::RAW_TAG:
     FIXPP_PRINT_FIELD(MarginRatio)
     if( group->fieldMarginRatio.offset < 0 ) group->fieldMarginRatio.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyings::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyings) 
     if( group->fieldNoUnderlyings.offset < 0 ){
       group->fieldNoUnderlyings.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyings::scanSafely( group->groupsUnderlyings, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoLegs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoLegs) 
     if( group->fieldNoLegs.offset < 0 ){
       group->fieldNoLegs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupLegs::scanSafely( group->groupsLegs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteSets::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupQuoteSets * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldQuoteSetID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedLegSecurityDesc::RAW_TAG and tag != FieldEncodedLegIssuer::RAW_TAG and tag != FieldEncodedUnderlyingSecurityDesc::RAW_TAG and tag != FieldEncodedUnderlyingSecurityDesc::RAW_TAG and tag != FieldEncodedUnderlyingIssuer::RAW_TAG and tag != FieldEncodedUnderlyingIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteSetID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteSetID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteSetID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldUnderlyingSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbol)
     if( group->fieldUnderlyingSymbol.offset < 0 ) group->fieldUnderlyingSymbol.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSymbolSfx)
     if( group->fieldUnderlyingSymbolSfx.offset < 0 ) group->fieldUnderlyingSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityID)
     if( group->fieldUnderlyingSecurityID.offset < 0 ) group->fieldUnderlyingSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityIDSource)
     if( group->fieldUnderlyingSecurityIDSource.offset < 0 ) group->fieldUnderlyingSecurityIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingSecurityAltID) 
     if( group->fieldNoUnderlyingSecurityAltID.offset < 0 ){
       group->fieldNoUnderlyingSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyingSecurityAltID::scanSafely( group->groupsUnderlyingSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingProduct)
     if( group->fieldUnderlyingProduct.offset < 0 ) group->fieldUnderlyingProduct.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCFICode)
     if( group->fieldUnderlyingCFICode.offset < 0 ) group->fieldUnderlyingCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityType)
     if( group->fieldUnderlyingSecurityType.offset < 0 ) group->fieldUnderlyingSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecuritySubType)
     if( group->fieldUnderlyingSecuritySubType.offset < 0 ) group->fieldUnderlyingSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityMonthYear)
     if( group->fieldUnderlyingMaturityMonthYear.offset < 0 ) group->fieldUnderlyingMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingMaturityDate)
     if( group->fieldUnderlyingMaturityDate.offset < 0 ) group->fieldUnderlyingMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPutOrCall)
     if( group->fieldUnderlyingPutOrCall.offset < 0 ) group->fieldUnderlyingPutOrCall.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponPaymentDate)
     if( group->fieldUnderlyingCouponPaymentDate.offset < 0 ) group->fieldUnderlyingCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssueDate)
     if( group->fieldUnderlyingIssueDate.offset < 0 ) group->fieldUnderlyingIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepoCollateralSecurityType)
     if( group->fieldUnderlyingRepoCollateralSecurityType.offset < 0 ) group->fieldUnderlyingRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseTerm)
     if( group->fieldUnderlyingRepurchaseTerm.offset < 0 ) group->fieldUnderlyingRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRepurchaseRate)
     if( group->fieldUnderlyingRepurchaseRate.offset < 0 ) group->fieldUnderlyingRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingFactor)
     if( group->fieldUnderlyingFactor.offset < 0 ) group->fieldUnderlyingFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCreditRating)
     if( group->fieldUnderlyingCreditRating.offset < 0 ) group->fieldUnderlyingCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingInstrRegistry)
     if( group->fieldUnderlyingInstrRegistry.offset < 0 ) group->fieldUnderlyingInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCountryOfIssue)
     if( group->fieldUnderlyingCountryOfIssue.offset < 0 ) group->fieldUnderlyingCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStateOrProvinceOfIssue)
     if( group->fieldUnderlyingStateOrProvinceOfIssue.offset < 0 ) group->fieldUnderlyingStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingLocaleOfIssue)
     if( group->fieldUnderlyingLocaleOfIssue.offset < 0 ) group->fieldUnderlyingLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingRedemptionDate)
     if( group->fieldUnderlyingRedemptionDate.offset < 0 ) group->fieldUnderlyingRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikePrice)
     if( group->fieldUnderlyingStrikePrice.offset < 0 ) group->fieldUnderlyingStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStrikeCurrency)
     if( group->fieldUnderlyingStrikeCurrency.offset < 0 ) group->fieldUnderlyingStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingOptAttribute)
     if( group->fieldUnderlyingOptAttribute.offset < 0 ) group->fieldUnderlyingOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingContractMultiplier)
     if( group->fieldUnderlyingContractMultiplier.offset < 0 ) group->fieldUnderlyingContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCouponRate)
     if( group->fieldUnderlyingCouponRate.offset < 0 ) group->fieldUnderlyingCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityExchange)
     if( group->fieldUnderlyingSecurityExchange.offset < 0 ) group->fieldUnderlyingSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingIssuer)
     if( group->fieldUnderlyingIssuer.offset < 0 ) group->fieldUnderlyingIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuerLen)
     if( group->fieldEncodedUnderlyingIssuerLen.offset < 0 ) group->fieldEncodedUnderlyingIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingIssuer)
     if( group->fieldEncodedUnderlyingIssuer.offset < 0 and group->fieldEncodedUnderlyingIssuerLen.offset >= 0 ) { group->fieldEncodedUnderlyingIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingSecurityDesc)
     if( group->fieldUnderlyingSecurityDesc.offset < 0 ) group->fieldUnderlyingSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDescLen)
     if( group->fieldEncodedUnderlyingSecurityDescLen.offset < 0 ) group->fieldEncodedUnderlyingSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedUnderlyingSecurityDesc)
     if( group->fieldEncodedUnderlyingSecurityDesc.offset < 0 and group->fieldEncodedUnderlyingSecurityDescLen.offset >= 0 ) { group->fieldEncodedUnderlyingSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedUnderlyingSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPProgram)
     if( group->fieldUnderlyingCPProgram.offset < 0 ) group->fieldUnderlyingCPProgram.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCPRegType)
     if( group->fieldUnderlyingCPRegType.offset < 0 ) group->fieldUnderlyingCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrency)
     if( group->fieldUnderlyingCurrency.offset < 0 ) group->fieldUnderlyingCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingQty::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingQty)
     if( group->fieldUnderlyingQty.offset < 0 ) group->fieldUnderlyingQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingPx::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingPx)
     if( group->fieldUnderlyingPx.offset < 0 ) group->fieldUnderlyingPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingDirtyPrice)
     if( group->fieldUnderlyingDirtyPrice.offset < 0 ) group->fieldUnderlyingDirtyPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingEndPrice::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndPrice)
     if( group->fieldUnderlyingEndPrice.offset < 0 ) group->fieldUnderlyingEndPrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingStartValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingStartValue)
     if( group->fieldUnderlyingStartValue.offset < 0 ) group->fieldUnderlyingStartValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingCurrentValue)
     if( group->fieldUnderlyingCurrentValue.offset < 0 ) group->fieldUnderlyingCurrentValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldUnderlyingEndValue::RAW_TAG:
     FIXPP_PRINT_FIELD(UnderlyingEndValue)
     if( group->fieldUnderlyingEndValue.offset < 0 ) group->fieldUnderlyingEndValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoUnderlyingStips::RAW_TAG:
     FIXPP_PRINT_FIELD(NoUnderlyingStips) 
     if( group->fieldNoUnderlyingStips.offset < 0 ){
       group->fieldNoUnderlyingStips.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupUnderlyingStips::scanSafely( group->groupsUnderlyingStips, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTotNoQuoteEntries::RAW_TAG:
     FIXPP_PRINT_FIELD(TotNoQuoteEntries)
     if( group->fieldTotNoQuoteEntries.offset < 0 ) group->fieldTotNoQuoteEntries.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLastFragment::RAW_TAG:
     FIXPP_PRINT_FIELD(LastFragment) 
     if( group->fieldLastFragment.offset < 0 ) {
       group->fieldLastFragment.offset = gpos;
       if( LastFragmentEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoQuoteEntries::RAW_TAG:
     FIXPP_PRINT_FIELD(NoQuoteEntries) 
     if( group->fieldNoQuoteEntries.offset < 0 ){
       group->fieldNoQuoteEntries.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupQuoteEntries::scanSafely( group->groupsQuoteEntries, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSecurityTypes::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSecurityTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSecurityType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedSecurityDesc::RAW_TAG and tag != FieldEncodedIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSecurityType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     if( group->fieldSecuritySubType.offset < 0 ) group->fieldSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupNested3PartyIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupNested3PartyIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldNested3PartyID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldNested3PartyID::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldNested3PartyID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldNested3PartyIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyIDSource)
     if( group->fieldNested3PartyIDSource.offset < 0 ) group->fieldNested3PartyIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNested3PartyRole::RAW_TAG:
     FIXPP_PRINT_FIELD(Nested3PartyRole)
     if( group->fieldNested3PartyRole.offset < 0 ) group->fieldNested3PartyRole.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNested3PartySubIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested3PartySubIDs) 
     if( group->fieldNoNested3PartySubIDs.offset < 0 ){
       group->fieldNoNested3PartySubIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNested3PartySubIDs::scanSafely( group->groupsNested3PartySubIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPositions::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupPositions * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldPosType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosType::RAW_TAG:
     FIXPP_PRINT_FIELD(PosType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLongQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LongQty)
     if( group->fieldLongQty.offset < 0 ) group->fieldLongQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldShortQty::RAW_TAG:
     FIXPP_PRINT_FIELD(ShortQty)
     if( group->fieldShortQty.offset < 0 ) group->fieldShortQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPosQtyStatus::RAW_TAG:
     FIXPP_PRINT_FIELD(PosQtyStatus) 
     if( group->fieldPosQtyStatus.offset < 0 ) {
       group->fieldPosQtyStatus.offset = gpos;
       if( PosQtyStatusEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs) 
     if( group->fieldNoNestedPartyIDs.offset < 0 ){
       group->fieldNoNestedPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartyIDs::scanSafely( group->groupsNestedPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAffectedOrders::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupAffectedOrders * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldOrigClOrdID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldOrigClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigClOrdID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldOrigClOrdID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldAffectedOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(AffectedOrderID)
     if( group->fieldAffectedOrderID.offset < 0 ) group->fieldAffectedOrderID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAffectedSecondaryOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(AffectedSecondaryOrderID)
     if( group->fieldAffectedSecondaryOrderID.offset < 0 ) group->fieldAffectedSecondaryOrderID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupExecs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupExecs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldLastQty::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLastQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LastQty)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLastQty.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldExecID::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecID)
     if( group->fieldExecID.offset < 0 ) group->fieldExecID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecondaryExecID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryExecID)
     if( group->fieldSecondaryExecID.offset < 0 ) group->fieldSecondaryExecID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLastPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LastPx)
     if( group->fieldLastPx.offset < 0 ) group->fieldLastPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLastParPx::RAW_TAG:
     FIXPP_PRINT_FIELD(LastParPx)
     if( group->fieldLastParPx.offset < 0 ) group->fieldLastParPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLastCapacity::RAW_TAG:
     FIXPP_PRINT_FIELD(LastCapacity) 
     if( group->fieldLastCapacity.offset < 0 ) {
       group->fieldLastCapacity.offset = gpos;
       if( LastCapacityEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMsgTypes::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupMsgTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldRefMsgType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefMsgType::RAW_TAG:
     FIXPP_PRINT_FIELD(RefMsgType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefMsgType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMsgDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(MsgDirection) 
     if( group->fieldMsgDirection.offset < 0 ) {
       group->fieldMsgDirection.offset = gpos;
       if( MsgDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidComponents::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupBidComponents * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldListID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldListID::RAW_TAG:
     FIXPP_PRINT_FIELD(ListID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldListID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side) 
     if( group->fieldSide.offset < 0 ) {
       group->fieldSide.offset = gpos;
       if( SideEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     if( group->fieldTradingSessionID.offset < 0 ) group->fieldTradingSessionID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     if( group->fieldTradingSessionSubID.offset < 0 ) group->fieldTradingSessionSubID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNetGrossInd::RAW_TAG:
     FIXPP_PRINT_FIELD(NetGrossInd) 
     if( group->fieldNetGrossInd.offset < 0 ) {
       group->fieldNetGrossInd.offset = gpos;
       if( NetGrossIndEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSettlType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlType) 
     if( group->fieldSettlType.offset < 0 ) {
       group->fieldSettlType.offset = gpos;
       if( SettlTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSettlDate::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDate)
     if( group->fieldSettlDate.offset < 0 ) group->fieldSettlDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(Account)
     if( group->fieldAccount.offset < 0 ) group->fieldAccount.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(AcctIDSource) 
     if( group->fieldAcctIDSource.offset < 0 ) {
       group->fieldAcctIDSource.offset = gpos;
       if( AcctIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSettlInst::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSettlInst * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSettlInstID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSettlInstID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSettlInstID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSettlInstTransType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstTransType) 
     if( group->fieldSettlInstTransType.offset < 0 ) {
       group->fieldSettlInstTransType.offset = gpos;
       if( SettlInstTransTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSettlInstRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlInstRefID)
     if( group->fieldSettlInstRefID.offset < 0 ) group->fieldSettlInstRefID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs) 
     if( group->fieldNoPartyIDs.offset < 0 ){
       group->fieldNoPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupPartyIDs::scanSafely( group->groupsPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side) 
     if( group->fieldSide.offset < 0 ) {
       group->fieldSide.offset = gpos;
       if( SideEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType) 
     if( group->fieldSecurityType.offset < 0 ) {
       group->fieldSecurityType.offset = gpos;
       if( SecurityTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEffectiveTime::RAW_TAG:
     FIXPP_PRINT_FIELD(EffectiveTime)
     if( group->fieldEffectiveTime.offset < 0 ) group->fieldEffectiveTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     if( group->fieldExpireTime.offset < 0 ) group->fieldExpireTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLastUpdateTime::RAW_TAG:
     FIXPP_PRINT_FIELD(LastUpdateTime)
     if( group->fieldLastUpdateTime.offset < 0 ) group->fieldLastUpdateTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSettlDeliveryType::RAW_TAG:
     FIXPP_PRINT_FIELD(SettlDeliveryType) 
     if( group->fieldSettlDeliveryType.offset < 0 ) {
       group->fieldSettlDeliveryType.offset = gpos;
       if( SettlDeliveryTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldStandInstDbType::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbType) 
     if( group->fieldStandInstDbType.offset < 0 ) {
       group->fieldStandInstDbType.offset = gpos;
       if( StandInstDbTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldStandInstDbName::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbName)
     if( group->fieldStandInstDbName.offset < 0 ) group->fieldStandInstDbName.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStandInstDbID::RAW_TAG:
     FIXPP_PRINT_FIELD(StandInstDbID)
     if( group->fieldStandInstDbID.offset < 0 ) group->fieldStandInstDbID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoDlvyInst::RAW_TAG:
     FIXPP_PRINT_FIELD(NoDlvyInst) 
     if( group->fieldNoDlvyInst.offset < 0 ){
       group->fieldNoDlvyInst.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupDlvyInst::scanSafely( group->groupsDlvyInst, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPaymentMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentMethod) 
     if( group->fieldPaymentMethod.offset < 0 ) {
       group->fieldPaymentMethod.offset = gpos;
       if( PaymentMethodEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPaymentRef::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentRef)
     if( group->fieldPaymentRef.offset < 0 ) group->fieldPaymentRef.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCardHolderName::RAW_TAG:
     FIXPP_PRINT_FIELD(CardHolderName)
     if( group->fieldCardHolderName.offset < 0 ) group->fieldCardHolderName.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCardNumber::RAW_TAG:
     FIXPP_PRINT_FIELD(CardNumber)
     if( group->fieldCardNumber.offset < 0 ) group->fieldCardNumber.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCardStartDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CardStartDate)
     if( group->fieldCardStartDate.offset < 0 ) group->fieldCardStartDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCardExpDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CardExpDate)
     if( group->fieldCardExpDate.offset < 0 ) group->fieldCardExpDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCardIssNum::RAW_TAG:
     FIXPP_PRINT_FIELD(CardIssNum)
     if( group->fieldCardIssNum.offset < 0 ) group->fieldCardIssNum.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentDate)
     if( group->fieldPaymentDate.offset < 0 ) group->fieldPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPaymentRemitterID::RAW_TAG:
     FIXPP_PRINT_FIELD(PaymentRemitterID)
     if( group->fieldPaymentRemitterID.offset < 0 ) group->fieldPaymentRemitterID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupInstrAttrib::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupInstrAttrib * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldInstrAttribType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldInstrAttribType::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrAttribType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldInstrAttribType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldInstrAttribValue::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrAttribValue)
     if( group->fieldInstrAttribValue.offset < 0 ) group->fieldInstrAttribValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMiscFees::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupMiscFees * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldMiscFeeAmt::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMiscFeeAmt::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeAmt)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMiscFeeAmt.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMiscFeeCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeCurr)
     if( group->fieldMiscFeeCurr.offset < 0 ) group->fieldMiscFeeCurr.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMiscFeeType::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeType) 
     if( group->fieldMiscFeeType.offset < 0 ) {
       group->fieldMiscFeeType.offset = gpos;
       if( MiscFeeTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMiscFeeBasis::RAW_TAG:
     FIXPP_PRINT_FIELD(MiscFeeBasis) 
     if( group->fieldMiscFeeBasis.offset < 0 ) {
       group->fieldMiscFeeBasis.offset = gpos;
       if( MiscFeeBasisEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupQuoteQualifiers::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupQuoteQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldQuoteQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldQuoteQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldQuoteQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDistribInsts::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupDistribInsts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldDistribPaymentMethod::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldDistribPaymentMethod::RAW_TAG:
     FIXPP_PRINT_FIELD(DistribPaymentMethod)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldDistribPaymentMethod.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldDistribPercentage::RAW_TAG:
     FIXPP_PRINT_FIELD(DistribPercentage)
     if( group->fieldDistribPercentage.offset < 0 ) group->fieldDistribPercentage.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribCurr)
     if( group->fieldCashDistribCurr.offset < 0 ) group->fieldCashDistribCurr.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribAgentName::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentName)
     if( group->fieldCashDistribAgentName.offset < 0 ) group->fieldCashDistribAgentName.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribAgentCode::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentCode)
     if( group->fieldCashDistribAgentCode.offset < 0 ) group->fieldCashDistribAgentCode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribAgentAcctNumber::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentAcctNumber)
     if( group->fieldCashDistribAgentAcctNumber.offset < 0 ) group->fieldCashDistribAgentAcctNumber.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribPayRef::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribPayRef)
     if( group->fieldCashDistribPayRef.offset < 0 ) group->fieldCashDistribPayRef.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashDistribAgentAcctName::RAW_TAG:
     FIXPP_PRINT_FIELD(CashDistribAgentAcctName)
     if( group->fieldCashDistribAgentAcctName.offset < 0 ) group->fieldCashDistribAgentAcctName.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrdRegTimestamps::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupTrdRegTimestamps * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldTrdRegTimestamp::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTrdRegTimestamp::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestamp)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTrdRegTimestamp.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTrdRegTimestampType::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestampType) 
     if( group->fieldTrdRegTimestampType.offset < 0 ) {
       group->fieldTrdRegTimestampType.offset = gpos;
       if( TrdRegTimestampTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTrdRegTimestampOrigin::RAW_TAG:
     FIXPP_PRINT_FIELD(TrdRegTimestampOrigin)
     if( group->fieldTrdRegTimestampOrigin.offset < 0 ) group->fieldTrdRegTimestampOrigin.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupAltMDSource::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupAltMDSource * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldAltMDSourceID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldAltMDSourceID::RAW_TAG:
     FIXPP_PRINT_FIELD(AltMDSourceID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldAltMDSourceID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupSides::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupSides * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSide::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedText::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSide::RAW_TAG:
     FIXPP_PRINT_FIELD(Side)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSide.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldOrigClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigClOrdID)
     if( group->fieldOrigClOrdID.offset < 0 ) group->fieldOrigClOrdID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdID)
     if( group->fieldClOrdID.offset < 0 ) group->fieldClOrdID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecondaryClOrdID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryClOrdID)
     if( group->fieldSecondaryClOrdID.offset < 0 ) group->fieldSecondaryClOrdID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldClOrdLinkID::RAW_TAG:
     FIXPP_PRINT_FIELD(ClOrdLinkID)
     if( group->fieldClOrdLinkID.offset < 0 ) group->fieldClOrdLinkID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrigOrdModTime::RAW_TAG:
     FIXPP_PRINT_FIELD(OrigOrdModTime)
     if( group->fieldOrigOrdModTime.offset < 0 ) group->fieldOrigOrdModTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoPartyIDs) 
     if( group->fieldNoPartyIDs.offset < 0 ){
       group->fieldNoPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupPartyIDs::scanSafely( group->groupsPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradeOriginationDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeOriginationDate)
     if( group->fieldTradeOriginationDate.offset < 0 ) group->fieldTradeOriginationDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     if( group->fieldTradeDate.offset < 0 ) group->fieldTradeDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderQty)
     if( group->fieldOrderQty.offset < 0 ) group->fieldOrderQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCashOrderQty::RAW_TAG:
     FIXPP_PRINT_FIELD(CashOrderQty)
     if( group->fieldCashOrderQty.offset < 0 ) group->fieldCashOrderQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrderPercent::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderPercent)
     if( group->fieldOrderPercent.offset < 0 ) group->fieldOrderPercent.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRoundingDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingDirection) 
     if( group->fieldRoundingDirection.offset < 0 ) {
       group->fieldRoundingDirection.offset = gpos;
       if( RoundingDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldRoundingModulus::RAW_TAG:
     FIXPP_PRINT_FIELD(RoundingModulus)
     if( group->fieldRoundingModulus.offset < 0 ) group->fieldRoundingModulus.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldComplianceID::RAW_TAG:
     FIXPP_PRINT_FIELD(ComplianceID)
     if( group->fieldComplianceID.offset < 0 ) group->fieldComplianceID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     if( group->fieldText.offset < 0 ) group->fieldText.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     if( group->fieldEncodedTextLen.offset < 0 ) group->fieldEncodedTextLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     if( group->fieldEncodedText.offset < 0 and group->fieldEncodedTextLen.offset >= 0 ) { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRoutingIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupRoutingIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldRoutingType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRoutingType::RAW_TAG:
     FIXPP_PRINT_FIELD(RoutingType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRoutingType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRoutingID::RAW_TAG:
     FIXPP_PRINT_FIELD(RoutingID)
     if( group->fieldRoutingID.offset < 0 ) group->fieldRoutingID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupPosAmt::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupPosAmt * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldPosAmtType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldPosAmtType::RAW_TAG:
     FIXPP_PRINT_FIELD(PosAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldPosAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldPosAmt::RAW_TAG:
     FIXPP_PRINT_FIELD(PosAmt)
     if( group->fieldPosAmt.offset < 0 ) group->fieldPosAmt.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLinesOfText::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupLinesOfText * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldText::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedText::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldText.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     if( group->fieldEncodedTextLen.offset < 0 ) group->fieldEncodedTextLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     if( group->fieldEncodedText.offset < 0 and group->fieldEncodedTextLen.offset >= 0 ) { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupIOIQualifiers::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupIOIQualifiers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldIOIQualifier::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldIOIQualifier::RAW_TAG:
     FIXPP_PRINT_FIELD(IOIQualifier)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldIOIQualifier.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupDates::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupDates * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldTradeDate::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeDate::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeDate)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeDate.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldTransactTime::RAW_TAG:
     FIXPP_PRINT_FIELD(TransactTime)
     if( group->fieldTransactTime.offset < 0 ) group->fieldTransactTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntryTypes::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupMDEntryTypes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldMDEntryType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRelatedSym::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupRelatedSym * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedSecurityDesc::RAW_TAG and tag != FieldEncodedIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     if( group->fieldSymbolSfx.offset < 0 ) group->fieldSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     if( group->fieldSecurityID.offset < 0 ) group->fieldSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource) 
     if( group->fieldSecurityIDSource.offset < 0 ) {
       group->fieldSecurityIDSource.offset = gpos;
       if( SecurityIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID) 
     if( group->fieldNoSecurityAltID.offset < 0 ){
       group->fieldNoSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSecurityAltID::scanSafely( group->groupsSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType) 
     if( group->fieldSecurityType.offset < 0 ) {
       group->fieldSecurityType.offset = gpos;
       if( SecurityTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     if( group->fieldSecuritySubType.offset < 0 ) group->fieldSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     if( group->fieldMaturityMonthYear.offset < 0 ) group->fieldMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     if( group->fieldMaturityDate.offset < 0 ) group->fieldMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall) 
     if( group->fieldPutOrCall.offset < 0 ) {
       group->fieldPutOrCall.offset = gpos;
       if( PutOrCallEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     if( group->fieldCouponPaymentDate.offset < 0 ) group->fieldCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     if( group->fieldIssueDate.offset < 0 ) group->fieldIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     if( group->fieldRepoCollateralSecurityType.offset < 0 ) group->fieldRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     if( group->fieldRepurchaseTerm.offset < 0 ) group->fieldRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     if( group->fieldRepurchaseRate.offset < 0 ) group->fieldRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     if( group->fieldFactor.offset < 0 ) group->fieldFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     if( group->fieldCreditRating.offset < 0 ) group->fieldCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     if( group->fieldInstrRegistry.offset < 0 ) group->fieldInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     if( group->fieldCountryOfIssue.offset < 0 ) group->fieldCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     if( group->fieldStateOrProvinceOfIssue.offset < 0 ) group->fieldStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     if( group->fieldLocaleOfIssue.offset < 0 ) group->fieldLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     if( group->fieldRedemptionDate.offset < 0 ) group->fieldRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     if( group->fieldStrikePrice.offset < 0 ) group->fieldStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     if( group->fieldStrikeCurrency.offset < 0 ) group->fieldStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     if( group->fieldOptAttribute.offset < 0 ) group->fieldOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     if( group->fieldContractMultiplier.offset < 0 ) group->fieldContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     if( group->fieldCouponRate.offset < 0 ) group->fieldCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     if( group->fieldSecurityExchange.offset < 0 ) group->fieldSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     if( group->fieldIssuer.offset < 0 ) group->fieldIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     if( group->fieldEncodedIssuerLen.offset < 0 ) group->fieldEncodedIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     if( group->fieldEncodedIssuer.offset < 0 and group->fieldEncodedIssuerLen.offset >= 0 ) { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     if( group->fieldSecurityDesc.offset < 0 ) group->fieldSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     if( group->fieldEncodedSecurityDescLen.offset < 0 ) group->fieldEncodedSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     if( group->fieldEncodedSecurityDesc.offset < 0 and group->fieldEncodedSecurityDescLen.offset >= 0 ) { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     if( group->fieldPool.offset < 0 ) group->fieldPool.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     if( group->fieldContractSettlMonth.offset < 0 ) group->fieldContractSettlMonth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram) 
     if( group->fieldCPProgram.offset < 0 ) {
       group->fieldCPProgram.offset = gpos;
       if( CPProgramEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     if( group->fieldCPRegType.offset < 0 ) group->fieldCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents) 
     if( group->fieldNoEvents.offset < 0 ){
       group->fieldNoEvents.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupEvents::scanSafely( group->groupsEvents, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     if( group->fieldDatedDate.offset < 0 ) group->fieldDatedDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     if( group->fieldInterestAccrualDate.offset < 0 ) group->fieldInterestAccrualDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContraBrokers::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupContraBrokers * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldContraBroker::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContraBroker::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraBroker)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContraBroker.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContraTrader::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTrader)
     if( group->fieldContraTrader.offset < 0 ) group->fieldContraTrader.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContraTradeQty::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTradeQty)
     if( group->fieldContraTradeQty.offset < 0 ) group->fieldContraTradeQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContraTradeTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraTradeTime)
     if( group->fieldContraTradeTime.offset < 0 ) group->fieldContraTradeTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContraLegRefID::RAW_TAG:
     FIXPP_PRINT_FIELD(ContraLegRefID)
     if( group->fieldContraLegRefID.offset < 0 ) group->fieldContraLegRefID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupTrades::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupTrades * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldTradeReportID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldTradeReportID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeReportID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldTradeReportID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSecondaryTradeReportID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecondaryTradeReportID)
     if( group->fieldSecondaryTradeReportID.offset < 0 ) group->fieldSecondaryTradeReportID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupStrikes::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupStrikes * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldSymbol::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedSecurityDesc::RAW_TAG and tag != FieldEncodedIssuer::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldSymbol::RAW_TAG:
     FIXPP_PRINT_FIELD(Symbol)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldSymbol.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldSymbolSfx::RAW_TAG:
     FIXPP_PRINT_FIELD(SymbolSfx)
     if( group->fieldSymbolSfx.offset < 0 ) group->fieldSymbolSfx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityID::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityID)
     if( group->fieldSecurityID.offset < 0 ) group->fieldSecurityID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityIDSource) 
     if( group->fieldSecurityIDSource.offset < 0 ) {
       group->fieldSecurityIDSource.offset = gpos;
       if( SecurityIDSourceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldNoSecurityAltID::RAW_TAG:
     FIXPP_PRINT_FIELD(NoSecurityAltID) 
     if( group->fieldNoSecurityAltID.offset < 0 ){
       group->fieldNoSecurityAltID.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupSecurityAltID::scanSafely( group->groupsSecurityAltID, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldProduct::RAW_TAG:
     FIXPP_PRINT_FIELD(Product) 
     if( group->fieldProduct.offset < 0 ) {
       group->fieldProduct.offset = gpos;
       if( ProductEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCFICode::RAW_TAG:
     FIXPP_PRINT_FIELD(CFICode)
     if( group->fieldCFICode.offset < 0 ) group->fieldCFICode.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityType) 
     if( group->fieldSecurityType.offset < 0 ) {
       group->fieldSecurityType.offset = gpos;
       if( SecurityTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSecuritySubType::RAW_TAG:
     FIXPP_PRINT_FIELD(SecuritySubType)
     if( group->fieldSecuritySubType.offset < 0 ) group->fieldSecuritySubType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityMonthYear::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityMonthYear)
     if( group->fieldMaturityMonthYear.offset < 0 ) group->fieldMaturityMonthYear.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMaturityDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MaturityDate)
     if( group->fieldMaturityDate.offset < 0 ) group->fieldMaturityDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPutOrCall::RAW_TAG:
     FIXPP_PRINT_FIELD(PutOrCall) 
     if( group->fieldPutOrCall.offset < 0 ) {
       group->fieldPutOrCall.offset = gpos;
       if( PutOrCallEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCouponPaymentDate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponPaymentDate)
     if( group->fieldCouponPaymentDate.offset < 0 ) group->fieldCouponPaymentDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssueDate::RAW_TAG:
     FIXPP_PRINT_FIELD(IssueDate)
     if( group->fieldIssueDate.offset < 0 ) group->fieldIssueDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG:
     FIXPP_PRINT_FIELD(RepoCollateralSecurityType)
     if( group->fieldRepoCollateralSecurityType.offset < 0 ) group->fieldRepoCollateralSecurityType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseTerm::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseTerm)
     if( group->fieldRepurchaseTerm.offset < 0 ) group->fieldRepurchaseTerm.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRepurchaseRate::RAW_TAG:
     FIXPP_PRINT_FIELD(RepurchaseRate)
     if( group->fieldRepurchaseRate.offset < 0 ) group->fieldRepurchaseRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFactor::RAW_TAG:
     FIXPP_PRINT_FIELD(Factor)
     if( group->fieldFactor.offset < 0 ) group->fieldFactor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCreditRating::RAW_TAG:
     FIXPP_PRINT_FIELD(CreditRating)
     if( group->fieldCreditRating.offset < 0 ) group->fieldCreditRating.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInstrRegistry::RAW_TAG:
     FIXPP_PRINT_FIELD(InstrRegistry)
     if( group->fieldInstrRegistry.offset < 0 ) group->fieldInstrRegistry.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCountryOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(CountryOfIssue)
     if( group->fieldCountryOfIssue.offset < 0 ) group->fieldCountryOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(StateOrProvinceOfIssue)
     if( group->fieldStateOrProvinceOfIssue.offset < 0 ) group->fieldStateOrProvinceOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocaleOfIssue::RAW_TAG:
     FIXPP_PRINT_FIELD(LocaleOfIssue)
     if( group->fieldLocaleOfIssue.offset < 0 ) group->fieldLocaleOfIssue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldRedemptionDate::RAW_TAG:
     FIXPP_PRINT_FIELD(RedemptionDate)
     if( group->fieldRedemptionDate.offset < 0 ) group->fieldRedemptionDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikePrice::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikePrice)
     if( group->fieldStrikePrice.offset < 0 ) group->fieldStrikePrice.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldStrikeCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(StrikeCurrency)
     if( group->fieldStrikeCurrency.offset < 0 ) group->fieldStrikeCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOptAttribute::RAW_TAG:
     FIXPP_PRINT_FIELD(OptAttribute)
     if( group->fieldOptAttribute.offset < 0 ) group->fieldOptAttribute.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractMultiplier::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractMultiplier)
     if( group->fieldContractMultiplier.offset < 0 ) group->fieldContractMultiplier.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCouponRate::RAW_TAG:
     FIXPP_PRINT_FIELD(CouponRate)
     if( group->fieldCouponRate.offset < 0 ) group->fieldCouponRate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityExchange::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityExchange)
     if( group->fieldSecurityExchange.offset < 0 ) group->fieldSecurityExchange.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(Issuer)
     if( group->fieldIssuer.offset < 0 ) group->fieldIssuer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuerLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuerLen)
     if( group->fieldEncodedIssuerLen.offset < 0 ) group->fieldEncodedIssuerLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedIssuer::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedIssuer)
     if( group->fieldEncodedIssuer.offset < 0 and group->fieldEncodedIssuerLen.offset >= 0 ) { group->fieldEncodedIssuer.offset = gpos; posIsOnNextField = true; pos += group->getEncodedIssuerLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(SecurityDesc)
     if( group->fieldSecurityDesc.offset < 0 ) group->fieldSecurityDesc.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDescLen)
     if( group->fieldEncodedSecurityDescLen.offset < 0 ) group->fieldEncodedSecurityDescLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedSecurityDesc)
     if( group->fieldEncodedSecurityDesc.offset < 0 and group->fieldEncodedSecurityDescLen.offset >= 0 ) { group->fieldEncodedSecurityDesc.offset = gpos; posIsOnNextField = true; pos += group->getEncodedSecurityDescLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldPool::RAW_TAG:
     FIXPP_PRINT_FIELD(Pool)
     if( group->fieldPool.offset < 0 ) group->fieldPool.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContractSettlMonth::RAW_TAG:
     FIXPP_PRINT_FIELD(ContractSettlMonth)
     if( group->fieldContractSettlMonth.offset < 0 ) group->fieldContractSettlMonth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCPProgram::RAW_TAG:
     FIXPP_PRINT_FIELD(CPProgram) 
     if( group->fieldCPProgram.offset < 0 ) {
       group->fieldCPProgram.offset = gpos;
       if( CPProgramEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldCPRegType::RAW_TAG:
     FIXPP_PRINT_FIELD(CPRegType)
     if( group->fieldCPRegType.offset < 0 ) group->fieldCPRegType.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoEvents::RAW_TAG:
     FIXPP_PRINT_FIELD(NoEvents) 
     if( group->fieldNoEvents.offset < 0 ){
       group->fieldNoEvents.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupEvents::scanSafely( group->groupsEvents, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDatedDate::RAW_TAG:
     FIXPP_PRINT_FIELD(DatedDate)
     if( group->fieldDatedDate.offset < 0 ) group->fieldDatedDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInterestAccrualDate::RAW_TAG:
     FIXPP_PRINT_FIELD(InterestAccrualDate)
     if( group->fieldInterestAccrualDate.offset < 0 ) group->fieldInterestAccrualDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupBidDescriptors::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupBidDescriptors * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldBidDescriptorType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldBidDescriptorType::RAW_TAG:
     FIXPP_PRINT_FIELD(BidDescriptorType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldBidDescriptorType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldBidDescriptor::RAW_TAG:
     FIXPP_PRINT_FIELD(BidDescriptor)
     if( group->fieldBidDescriptor.offset < 0 ) group->fieldBidDescriptor.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldSideValueInd::RAW_TAG:
     FIXPP_PRINT_FIELD(SideValueInd) 
     if( group->fieldSideValueInd.offset < 0 ) {
       group->fieldSideValueInd.offset = gpos;
       if( SideValueIndEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldLiquidityValue::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityValue)
     if( group->fieldLiquidityValue.offset < 0 ) group->fieldLiquidityValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLiquidityNumSecurities::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityNumSecurities)
     if( group->fieldLiquidityNumSecurities.offset < 0 ) group->fieldLiquidityNumSecurities.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLiquidityPctLow::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityPctLow)
     if( group->fieldLiquidityPctLow.offset < 0 ) group->fieldLiquidityPctLow.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLiquidityPctHigh::RAW_TAG:
     FIXPP_PRINT_FIELD(LiquidityPctHigh)
     if( group->fieldLiquidityPctHigh.offset < 0 ) group->fieldLiquidityPctHigh.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEFPTrackingError::RAW_TAG:
     FIXPP_PRINT_FIELD(EFPTrackingError)
     if( group->fieldEFPTrackingError.offset < 0 ) group->fieldEFPTrackingError.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldFairValue::RAW_TAG:
     FIXPP_PRINT_FIELD(FairValue)
     if( group->fieldFairValue.offset < 0 ) group->fieldFairValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOutsideIndexPct::RAW_TAG:
     FIXPP_PRINT_FIELD(OutsideIndexPct)
     if( group->fieldOutsideIndexPct.offset < 0 ) group->fieldOutsideIndexPct.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldValueOfFutures::RAW_TAG:
     FIXPP_PRINT_FIELD(ValueOfFutures)
     if( group->fieldValueOfFutures.offset < 0 ) group->fieldValueOfFutures.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupCompIDs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupCompIDs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldRefCompID::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRefCompID::RAW_TAG:
     FIXPP_PRINT_FIELD(RefCompID)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRefCompID.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRefSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(RefSubID)
     if( group->fieldRefSubID.offset < 0 ) group->fieldRefSubID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocationID::RAW_TAG:
     FIXPP_PRINT_FIELD(LocationID)
     if( group->fieldLocationID.offset < 0 ) group->fieldLocationID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDeskID::RAW_TAG:
     FIXPP_PRINT_FIELD(DeskID)
     if( group->fieldDeskID.offset < 0 ) group->fieldDeskID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupLegAllocs::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupLegAllocs * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldLegAllocAccount::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldLegAllocAccount::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocAccount)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldLegAllocAccount.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldLegIndividualAllocID::RAW_TAG:
     FIXPP_PRINT_FIELD(LegIndividualAllocID)
     if( group->fieldLegIndividualAllocID.offset < 0 ) group->fieldLegIndividualAllocID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNested2PartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNested2PartyIDs) 
     if( group->fieldNoNested2PartyIDs.offset < 0 ){
       group->fieldNoNested2PartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNested2PartyIDs::scanSafely( group->groupsNested2PartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegAllocQty::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocQty)
     if( group->fieldLegAllocQty.offset < 0 ) group->fieldLegAllocQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegAllocAcctIDSource::RAW_TAG:
     FIXPP_PRINT_FIELD(LegAllocAcctIDSource)
     if( group->fieldLegAllocAcctIDSource.offset < 0 ) group->fieldLegAllocAcctIDSource.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLegSettlCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(LegSettlCurrency)
     if( group->fieldLegSettlCurrency.offset < 0 ) group->fieldLegSettlCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupRegistDtls::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupRegistDtls * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldRegistDtls::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldRegistDtls::RAW_TAG:
     FIXPP_PRINT_FIELD(RegistDtls)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldRegistDtls.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldRegistEmail::RAW_TAG:
     FIXPP_PRINT_FIELD(RegistEmail)
     if( group->fieldRegistEmail.offset < 0 ) group->fieldRegistEmail.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMailingDtls::RAW_TAG:
     FIXPP_PRINT_FIELD(MailingDtls)
     if( group->fieldMailingDtls.offset < 0 ) group->fieldMailingDtls.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMailingInst::RAW_TAG:
     FIXPP_PRINT_FIELD(MailingInst)
     if( group->fieldMailingInst.offset < 0 ) group->fieldMailingInst.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNoNestedPartyIDs::RAW_TAG:
     FIXPP_PRINT_FIELD(NoNestedPartyIDs) 
     if( group->fieldNoNestedPartyIDs.offset < 0 ){
       group->fieldNoNestedPartyIDs.offset = gpos;
       posIsOnNextField = true;
       {
       int groupExpected = parseGroupNoValue( fix + pos );
       unsigned groupFound = 0;
       gotoNextField( fix, pos );
       pos += GroupNestedPartyIDs::scanSafely( group->groupsNestedPartyIDs, fix+pos, len - pos, groupFound, badFieldPtr );
       if( badFieldPtr != nullptr ) { group->_fixLength = badFieldPtr - fix; return pos; }
       if( (int)groupFound != groupExpected ) { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
       }
     } else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOwnerType::RAW_TAG:
     FIXPP_PRINT_FIELD(OwnerType) 
     if( group->fieldOwnerType.offset < 0 ) {
       group->fieldOwnerType.offset = gpos;
       if( OwnerTypeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldDateOfBirth::RAW_TAG:
     FIXPP_PRINT_FIELD(DateOfBirth)
     if( group->fieldDateOfBirth.offset < 0 ) group->fieldDateOfBirth.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldInvestorCountryOfResidence::RAW_TAG:
     FIXPP_PRINT_FIELD(InvestorCountryOfResidence)
     if( group->fieldInvestorCountryOfResidence.offset < 0 ) group->fieldInvestorCountryOfResidence.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupContAmts::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupContAmts * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldContAmtType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldContAmtType::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldContAmtType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldContAmtValue::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtValue)
     if( group->fieldContAmtValue.offset < 0 ) group->fieldContAmtValue.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldContAmtCurr::RAW_TAG:
     FIXPP_PRINT_FIELD(ContAmtCurr)
     if( group->fieldContAmtCurr.offset < 0 ) group->fieldContAmtCurr.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

offset_t GroupMDEntries::scanSafely( Array & arr, const char * fix, unsigned len, unsigned & groupCount, const char * & badFieldPtr ){
 GroupMDEntries * group = nullptr; 
 offset_t prev = 0, pos = 0, gpos = 0;
 groupCount = 0; 
 if( loadRawTag( fix, gpos ) != FieldMDEntryType::RAW_TAG ) return 0;
 const char * groupBuf = fix; 
while( pos < (int)len ) {
   bool posIsOnNextField = false;
   prev = pos;
   if( not isGoodTag( fix+pos ) ) {badFieldPtr = fix + pos; break; }
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   if( fix[pos] == FIXPP_SOH and tag != FieldEncodedText::RAW_TAG ) { if( group ) group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
   gpos = pos - (groupBuf - fix);
   switch( tag ){
   case FieldMDEntryType::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryType)
     if( group ) group->_fixLength = gpos;
     group = groupCount < arr.size() ? & arr[ groupCount ] : & arr.emplace_back();
     group->fieldMDEntryType.offset = pos - prev;
     groupBuf = fix+prev;
     group->_fixPtr = groupBuf;
     ++groupCount;
     break;

   case FieldMDEntryPx::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryPx)
     if( group->fieldMDEntryPx.offset < 0 ) group->fieldMDEntryPx.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldCurrency::RAW_TAG:
     FIXPP_PRINT_FIELD(Currency)
     if( group->fieldCurrency.offset < 0 ) group->fieldCurrency.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntrySize::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntrySize)
     if( group->fieldMDEntrySize.offset < 0 ) group->fieldMDEntrySize.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntryDate::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryDate)
     if( group->fieldMDEntryDate.offset < 0 ) group->fieldMDEntryDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntryTime::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryTime)
     if( group->fieldMDEntryTime.offset < 0 ) group->fieldMDEntryTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTickDirection::RAW_TAG:
     FIXPP_PRINT_FIELD(TickDirection) 
     if( group->fieldTickDirection.offset < 0 ) {
       group->fieldTickDirection.offset = gpos;
       if( TickDirectionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMDMkt::RAW_TAG:
     FIXPP_PRINT_FIELD(MDMkt)
     if( group->fieldMDMkt.offset < 0 ) group->fieldMDMkt.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradingSessionID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionID)
     if( group->fieldTradingSessionID.offset < 0 ) group->fieldTradingSessionID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldTradingSessionSubID::RAW_TAG:
     FIXPP_PRINT_FIELD(TradingSessionSubID)
     if( group->fieldTradingSessionSubID.offset < 0 ) group->fieldTradingSessionSubID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldQuoteCondition::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteCondition) 
     if( group->fieldQuoteCondition.offset < 0 ) {
       group->fieldQuoteCondition.offset = gpos;
       if( QuoteConditionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTradeCondition::RAW_TAG:
     FIXPP_PRINT_FIELD(TradeCondition) 
     if( group->fieldTradeCondition.offset < 0 ) {
       group->fieldTradeCondition.offset = gpos;
       if( TradeConditionEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldMDEntryOriginator::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryOriginator)
     if( group->fieldMDEntryOriginator.offset < 0 ) group->fieldMDEntryOriginator.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldLocationID::RAW_TAG:
     FIXPP_PRINT_FIELD(LocationID)
     if( group->fieldLocationID.offset < 0 ) group->fieldLocationID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldDeskID::RAW_TAG:
     FIXPP_PRINT_FIELD(DeskID)
     if( group->fieldDeskID.offset < 0 ) group->fieldDeskID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOpenCloseSettlFlag::RAW_TAG:
     FIXPP_PRINT_FIELD(OpenCloseSettlFlag) 
     if( group->fieldOpenCloseSettlFlag.offset < 0 ) {
       group->fieldOpenCloseSettlFlag.offset = gpos;
       if( OpenCloseSettlFlagEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldTimeInForce::RAW_TAG:
     FIXPP_PRINT_FIELD(TimeInForce) 
     if( group->fieldTimeInForce.offset < 0 ) {
       group->fieldTimeInForce.offset = gpos;
       if( TimeInForceEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldExpireDate::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireDate)
     if( group->fieldExpireDate.offset < 0 ) group->fieldExpireDate.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExpireTime::RAW_TAG:
     FIXPP_PRINT_FIELD(ExpireTime)
     if( group->fieldExpireTime.offset < 0 ) group->fieldExpireTime.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMinQty::RAW_TAG:
     FIXPP_PRINT_FIELD(MinQty)
     if( group->fieldMinQty.offset < 0 ) group->fieldMinQty.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldExecInst::RAW_TAG:
     FIXPP_PRINT_FIELD(ExecInst) 
     if( group->fieldExecInst.offset < 0 ) {
       group->fieldExecInst.offset = gpos;
       if( ExecInstEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldSellerDays::RAW_TAG:
     FIXPP_PRINT_FIELD(SellerDays)
     if( group->fieldSellerDays.offset < 0 ) group->fieldSellerDays.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldOrderID::RAW_TAG:
     FIXPP_PRINT_FIELD(OrderID)
     if( group->fieldOrderID.offset < 0 ) group->fieldOrderID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldQuoteEntryID::RAW_TAG:
     FIXPP_PRINT_FIELD(QuoteEntryID)
     if( group->fieldQuoteEntryID.offset < 0 ) group->fieldQuoteEntryID.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntryBuyer::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryBuyer)
     if( group->fieldMDEntryBuyer.offset < 0 ) group->fieldMDEntryBuyer.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntrySeller::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntrySeller)
     if( group->fieldMDEntrySeller.offset < 0 ) group->fieldMDEntrySeller.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldNumberOfOrders::RAW_TAG:
     FIXPP_PRINT_FIELD(NumberOfOrders)
     if( group->fieldNumberOfOrders.offset < 0 ) group->fieldNumberOfOrders.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldMDEntryPositionNo::RAW_TAG:
     FIXPP_PRINT_FIELD(MDEntryPositionNo)
     if( group->fieldMDEntryPositionNo.offset < 0 ) group->fieldMDEntryPositionNo.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldScope::RAW_TAG:
     FIXPP_PRINT_FIELD(Scope) 
     if( group->fieldScope.offset < 0 ) {
       group->fieldScope.offset = gpos;
       if( ScopeEnums::findEnum( toRawEnum( group->_fixPtr + gpos ) ) == nullptr )
       { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     }
     else { group->_fixLength = prev; return pos; }
     break;

   case FieldPriceDelta::RAW_TAG:
     FIXPP_PRINT_FIELD(PriceDelta)
     if( group->fieldPriceDelta.offset < 0 ) group->fieldPriceDelta.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldText::RAW_TAG:
     FIXPP_PRINT_FIELD(Text)
     if( group->fieldText.offset < 0 ) group->fieldText.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedTextLen::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedTextLen)
     if( group->fieldEncodedTextLen.offset < 0 ) group->fieldEncodedTextLen.offset = gpos;
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   case FieldEncodedText::RAW_TAG:
     FIXPP_PRINT_FIELD(EncodedText)
     if( group->fieldEncodedText.offset < 0 and group->fieldEncodedTextLen.offset >= 0 ) { group->fieldEncodedText.offset = gpos; posIsOnNextField = true; pos += group->getEncodedTextLen()+1; }
     else { group->_fixLength = prev; badFieldPtr = fix + prev; return pos; }
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     if( group ) group->_fixLength = gpos;
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 if( group ) group->_fixLength = gpos;
 return pos;
}

// -------------------------------------- skip ----------------------------------------

offset_t GroupLegStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegStipulationType::RAW_TAG :
     break;

   case FieldLegStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupEvents::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldEventType::RAW_TAG :
     break;

   case FieldEventDate::RAW_TAG :
     break;

   case FieldEventPx::RAW_TAG :
     break;

   case FieldEventText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSecurityAltID::RAW_TAG :
     break;

   case FieldLegSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCapacities::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldOrderCapacity::RAW_TAG :
     break;

   case FieldOrderRestrictions::RAW_TAG :
     break;

   case FieldOrderCapacityQty::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested3PartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested3PartySubID::RAW_TAG :
     break;

   case FieldNested3PartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPartySubID::RAW_TAG :
     break;

   case FieldPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested2PartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested2PartySubID::RAW_TAG :
     break;

   case FieldNested2PartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested2PartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested2PartyID::RAW_TAG :
     break;

   case FieldNested2PartyIDSource::RAW_TAG :
     break;

   case FieldNested2PartyRole::RAW_TAG :
     break;

   case FieldNoNested2PartySubIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupHops::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldHopCompID::RAW_TAG :
     break;

   case FieldHopSendingTime::RAW_TAG :
     break;

   case FieldHopRefID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCollInquiryQualifier::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldCollInquiryQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPartyID::RAW_TAG :
     break;

   case FieldPartyIDSource::RAW_TAG :
     break;

   case FieldPartyRole::RAW_TAG :
     break;

   case FieldNoPartySubIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAllocs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldAllocAccount::RAW_TAG :
     break;

   case FieldAllocAcctIDSource::RAW_TAG :
     break;

   case FieldAllocPrice::RAW_TAG :
     break;

   case FieldIndividualAllocID::RAW_TAG :
     break;

   case FieldIndividualAllocRejCode::RAW_TAG :
     break;

   case FieldAllocText::RAW_TAG :
     break;

   case FieldEncodedAllocTextLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedAllocText::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedAllocText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTradingSessions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSecurityAltID::RAW_TAG :
     break;

   case FieldSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyingSecurityAltID::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingSecurityAltID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityAltIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyingStips::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingStipType::RAW_TAG :
     break;

   case FieldUnderlyingStipValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupUnderlyings::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldUnderlyingSymbol::RAW_TAG :
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedUnderlyingIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedUnderlyingSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     break;

   case FieldUnderlyingQty::RAW_TAG :
     break;

   case FieldUnderlyingPx::RAW_TAG :
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingSettlPrice::RAW_TAG :
     break;

   case FieldUnderlyingSettlPriceType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupStipulations::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldStipulationType::RAW_TAG :
     break;

   case FieldStipulationValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupOrders::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldClOrdID::RAW_TAG :
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     break;

   case FieldListSeqNo::RAW_TAG :
     break;

   case FieldClOrdLinkID::RAW_TAG :
     break;

   case FieldSettlInstMode::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     break;

   case FieldTradeDate::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldAcctIDSource::RAW_TAG :
     break;

   case FieldAccountType::RAW_TAG :
     break;

   case FieldDayBookingInst::RAW_TAG :
     break;

   case FieldBookingUnit::RAW_TAG :
     break;

   case FieldAllocID::RAW_TAG :
     break;

   case FieldPreallocMethod::RAW_TAG :
     break;

   case FieldNoAllocs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupAllocs::skip( fix+pos, len - pos );
     break;

   case FieldSettlType::RAW_TAG :
     break;

   case FieldSettlDate::RAW_TAG :
     break;

   case FieldCashMargin::RAW_TAG :
     break;

   case FieldClearingFeeIndicator::RAW_TAG :
     break;

   case FieldHandlInst::RAW_TAG :
     break;

   case FieldExecInst::RAW_TAG :
     break;

   case FieldMinQty::RAW_TAG :
     break;

   case FieldMaxFloor::RAW_TAG :
     break;

   case FieldExDestination::RAW_TAG :
     break;

   case FieldNoTradingSessions::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupTradingSessions::skip( fix+pos, len - pos );
     break;

   case FieldProcessCode::RAW_TAG :
     break;

   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   case FieldNoUnderlyings::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::skip( fix+pos, len - pos );
     break;

   case FieldPrevClosePx::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldSideValueInd::RAW_TAG :
     break;

   case FieldLocateReqd::RAW_TAG :
     break;

   case FieldTransactTime::RAW_TAG :
     break;

   case FieldNoStipulations::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupStipulations::skip( fix+pos, len - pos );
     break;

   case FieldQtyType::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldCashOrderQty::RAW_TAG :
     break;

   case FieldOrderPercent::RAW_TAG :
     break;

   case FieldRoundingDirection::RAW_TAG :
     break;

   case FieldRoundingModulus::RAW_TAG :
     break;

   case FieldOrdType::RAW_TAG :
     break;

   case FieldPriceType::RAW_TAG :
     break;

   case FieldPrice::RAW_TAG :
     break;

   case FieldStopPx::RAW_TAG :
     break;

   case FieldSpread::RAW_TAG :
     break;

   case FieldBenchmarkCurveCurrency::RAW_TAG :
     break;

   case FieldBenchmarkCurveName::RAW_TAG :
     break;

   case FieldBenchmarkCurvePoint::RAW_TAG :
     break;

   case FieldBenchmarkPrice::RAW_TAG :
     break;

   case FieldBenchmarkPriceType::RAW_TAG :
     break;

   case FieldBenchmarkSecurityID::RAW_TAG :
     break;

   case FieldBenchmarkSecurityIDSource::RAW_TAG :
     break;

   case FieldYieldType::RAW_TAG :
     break;

   case FieldYield::RAW_TAG :
     break;

   case FieldYieldCalcDate::RAW_TAG :
     break;

   case FieldYieldRedemptionDate::RAW_TAG :
     break;

   case FieldYieldRedemptionPrice::RAW_TAG :
     break;

   case FieldYieldRedemptionPriceType::RAW_TAG :
     break;

   case FieldCurrency::RAW_TAG :
     break;

   case FieldComplianceID::RAW_TAG :
     break;

   case FieldSolicitedFlag::RAW_TAG :
     break;

   case FieldIOIID::RAW_TAG :
     break;

   case FieldQuoteID::RAW_TAG :
     break;

   case FieldTimeInForce::RAW_TAG :
     break;

   case FieldEffectiveTime::RAW_TAG :
     break;

   case FieldExpireDate::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldGTBookingInst::RAW_TAG :
     break;

   case FieldCommission::RAW_TAG :
     break;

   case FieldCommType::RAW_TAG :
     break;

   case FieldCommCurrency::RAW_TAG :
     break;

   case FieldFundRenewWaiv::RAW_TAG :
     break;

   case FieldOrderCapacity::RAW_TAG :
     break;

   case FieldOrderRestrictions::RAW_TAG :
     break;

   case FieldCustOrderCapacity::RAW_TAG :
     break;

   case FieldForexReq::RAW_TAG :
     break;

   case FieldSettlCurrency::RAW_TAG :
     break;

   case FieldBookingType::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedText::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   case FieldSettlDate2::RAW_TAG :
     break;

   case FieldOrderQty2::RAW_TAG :
     break;

   case FieldPrice2::RAW_TAG :
     break;

   case FieldPositionEffect::RAW_TAG :
     break;

   case FieldCoveredOrUncovered::RAW_TAG :
     break;

   case FieldMaxShow::RAW_TAG :
     break;

   case FieldPegOffsetValue::RAW_TAG :
     break;

   case FieldPegMoveType::RAW_TAG :
     break;

   case FieldPegOffsetType::RAW_TAG :
     break;

   case FieldPegLimitType::RAW_TAG :
     break;

   case FieldPegRoundDirection::RAW_TAG :
     break;

   case FieldPegScope::RAW_TAG :
     break;

   case FieldDiscretionInst::RAW_TAG :
     break;

   case FieldDiscretionOffsetValue::RAW_TAG :
     break;

   case FieldDiscretionMoveType::RAW_TAG :
     break;

   case FieldDiscretionOffsetType::RAW_TAG :
     break;

   case FieldDiscretionLimitType::RAW_TAG :
     break;

   case FieldDiscretionRoundDirection::RAW_TAG :
     break;

   case FieldDiscretionScope::RAW_TAG :
     break;

   case FieldTargetStrategy::RAW_TAG :
     break;

   case FieldTargetStrategyParameters::RAW_TAG :
     break;

   case FieldParticipationRate::RAW_TAG :
     break;

   case FieldDesignation::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlPartySubID::RAW_TAG :
     break;

   case FieldSettlPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlPartyID::RAW_TAG :
     break;

   case FieldSettlPartyIDSource::RAW_TAG :
     break;

   case FieldSettlPartyRole::RAW_TAG :
     break;

   case FieldNoSettlPartySubIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDlvyInst::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlInstSource::RAW_TAG :
     break;

   case FieldDlvyInstType::RAW_TAG :
     break;

   case FieldNoSettlPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSettlPartyIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupClearingInstructions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldClearingInstruction::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartySubIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartySubID::RAW_TAG :
     break;

   case FieldNestedPartySubIDType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNestedPartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNestedPartyID::RAW_TAG :
     break;

   case FieldNestedPartyIDSource::RAW_TAG :
     break;

   case FieldNestedPartyRole::RAW_TAG :
     break;

   case FieldNoNestedPartySubIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegSymbol::RAW_TAG :
     break;

   case FieldLegSymbolSfx::RAW_TAG :
     break;

   case FieldLegSecurityID::RAW_TAG :
     break;

   case FieldLegSecurityIDSource::RAW_TAG :
     break;

   case FieldNoLegSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldLegProduct::RAW_TAG :
     break;

   case FieldLegCFICode::RAW_TAG :
     break;

   case FieldLegSecurityType::RAW_TAG :
     break;

   case FieldLegSecuritySubType::RAW_TAG :
     break;

   case FieldLegMaturityMonthYear::RAW_TAG :
     break;

   case FieldLegMaturityDate::RAW_TAG :
     break;

   case FieldLegCouponPaymentDate::RAW_TAG :
     break;

   case FieldLegIssueDate::RAW_TAG :
     break;

   case FieldLegRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldLegRepurchaseTerm::RAW_TAG :
     break;

   case FieldLegRepurchaseRate::RAW_TAG :
     break;

   case FieldLegFactor::RAW_TAG :
     break;

   case FieldLegCreditRating::RAW_TAG :
     break;

   case FieldLegInstrRegistry::RAW_TAG :
     break;

   case FieldLegCountryOfIssue::RAW_TAG :
     break;

   case FieldLegStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLegLocaleOfIssue::RAW_TAG :
     break;

   case FieldLegRedemptionDate::RAW_TAG :
     break;

   case FieldLegStrikePrice::RAW_TAG :
     break;

   case FieldLegStrikeCurrency::RAW_TAG :
     break;

   case FieldLegOptAttribute::RAW_TAG :
     break;

   case FieldLegContractMultiplier::RAW_TAG :
     break;

   case FieldLegCouponRate::RAW_TAG :
     break;

   case FieldLegSecurityExchange::RAW_TAG :
     break;

   case FieldLegIssuer::RAW_TAG :
     break;

   case FieldEncodedLegIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedLegIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedLegIssuer::RAW_TAG :
     break;

   case FieldLegSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedLegSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedLegSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedLegSecurityDesc::RAW_TAG :
     break;

   case FieldLegRatioQty::RAW_TAG :
     break;

   case FieldLegSide::RAW_TAG :
     break;

   case FieldLegCurrency::RAW_TAG :
     break;

   case FieldLegPool::RAW_TAG :
     break;

   case FieldLegDatedDate::RAW_TAG :
     break;

   case FieldLegContractSettlMonth::RAW_TAG :
     break;

   case FieldLegInterestAccrualDate::RAW_TAG :
     break;

   case FieldLegQty::RAW_TAG :
     break;

   case FieldLegSwapType::RAW_TAG :
     break;

   case FieldNoLegStipulations::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegStipulations::skip( fix+pos, len - pos );
     break;

   case FieldLegPositionEffect::RAW_TAG :
     break;

   case FieldLegCoveredOrUncovered::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegRefID::RAW_TAG :
     break;

   case FieldLegPrice::RAW_TAG :
     break;

   case FieldLegSettlType::RAW_TAG :
     break;

   case FieldLegSettlDate::RAW_TAG :
     break;

   case FieldLegLastPx::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteEntries::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   case FieldAgreementDesc::RAW_TAG :
     break;

   case FieldAgreementID::RAW_TAG :
     break;

   case FieldAgreementDate::RAW_TAG :
     break;

   case FieldAgreementCurrency::RAW_TAG :
     break;

   case FieldTerminationType::RAW_TAG :
     break;

   case FieldStartDate::RAW_TAG :
     break;

   case FieldEndDate::RAW_TAG :
     break;

   case FieldDeliveryType::RAW_TAG :
     break;

   case FieldMarginRatio::RAW_TAG :
     break;

   case FieldNoUnderlyings::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyings::skip( fix+pos, len - pos );
     break;

   case FieldNoLegs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupLegs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteSets::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldQuoteSetID::RAW_TAG :
     break;

   case FieldUnderlyingSymbol::RAW_TAG :
     break;

   case FieldUnderlyingSymbolSfx::RAW_TAG :
     break;

   case FieldUnderlyingSecurityID::RAW_TAG :
     break;

   case FieldUnderlyingSecurityIDSource::RAW_TAG :
     break;

   case FieldNoUnderlyingSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldUnderlyingProduct::RAW_TAG :
     break;

   case FieldUnderlyingCFICode::RAW_TAG :
     break;

   case FieldUnderlyingSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingSecuritySubType::RAW_TAG :
     break;

   case FieldUnderlyingMaturityMonthYear::RAW_TAG :
     break;

   case FieldUnderlyingMaturityDate::RAW_TAG :
     break;

   case FieldUnderlyingPutOrCall::RAW_TAG :
     break;

   case FieldUnderlyingCouponPaymentDate::RAW_TAG :
     break;

   case FieldUnderlyingIssueDate::RAW_TAG :
     break;

   case FieldUnderlyingRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseTerm::RAW_TAG :
     break;

   case FieldUnderlyingRepurchaseRate::RAW_TAG :
     break;

   case FieldUnderlyingFactor::RAW_TAG :
     break;

   case FieldUnderlyingCreditRating::RAW_TAG :
     break;

   case FieldUnderlyingInstrRegistry::RAW_TAG :
     break;

   case FieldUnderlyingCountryOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingLocaleOfIssue::RAW_TAG :
     break;

   case FieldUnderlyingRedemptionDate::RAW_TAG :
     break;

   case FieldUnderlyingStrikePrice::RAW_TAG :
     break;

   case FieldUnderlyingStrikeCurrency::RAW_TAG :
     break;

   case FieldUnderlyingOptAttribute::RAW_TAG :
     break;

   case FieldUnderlyingContractMultiplier::RAW_TAG :
     break;

   case FieldUnderlyingCouponRate::RAW_TAG :
     break;

   case FieldUnderlyingSecurityExchange::RAW_TAG :
     break;

   case FieldUnderlyingIssuer::RAW_TAG :
     break;

   case FieldEncodedUnderlyingIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedUnderlyingIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedUnderlyingIssuer::RAW_TAG :
     break;

   case FieldUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedUnderlyingSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedUnderlyingSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedUnderlyingSecurityDesc::RAW_TAG :
     break;

   case FieldUnderlyingCPProgram::RAW_TAG :
     break;

   case FieldUnderlyingCPRegType::RAW_TAG :
     break;

   case FieldUnderlyingCurrency::RAW_TAG :
     break;

   case FieldUnderlyingQty::RAW_TAG :
     break;

   case FieldUnderlyingPx::RAW_TAG :
     break;

   case FieldUnderlyingDirtyPrice::RAW_TAG :
     break;

   case FieldUnderlyingEndPrice::RAW_TAG :
     break;

   case FieldUnderlyingStartValue::RAW_TAG :
     break;

   case FieldUnderlyingCurrentValue::RAW_TAG :
     break;

   case FieldUnderlyingEndValue::RAW_TAG :
     break;

   case FieldNoUnderlyingStips::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupUnderlyingStips::skip( fix+pos, len - pos );
     break;

   case FieldTotNoQuoteEntries::RAW_TAG :
     break;

   case FieldLastFragment::RAW_TAG :
     break;

   case FieldNoQuoteEntries::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupQuoteEntries::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSecurityTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupNested3PartyIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldNested3PartyID::RAW_TAG :
     break;

   case FieldNested3PartyIDSource::RAW_TAG :
     break;

   case FieldNested3PartyRole::RAW_TAG :
     break;

   case FieldNoNested3PartySubIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested3PartySubIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPositions::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPosType::RAW_TAG :
     break;

   case FieldLongQty::RAW_TAG :
     break;

   case FieldShortQty::RAW_TAG :
     break;

   case FieldPosQtyStatus::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAffectedOrders::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldOrigClOrdID::RAW_TAG :
     break;

   case FieldAffectedOrderID::RAW_TAG :
     break;

   case FieldAffectedSecondaryOrderID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupExecs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLastQty::RAW_TAG :
     break;

   case FieldExecID::RAW_TAG :
     break;

   case FieldSecondaryExecID::RAW_TAG :
     break;

   case FieldLastPx::RAW_TAG :
     break;

   case FieldLastParPx::RAW_TAG :
     break;

   case FieldLastCapacity::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMsgTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRefMsgType::RAW_TAG :
     break;

   case FieldMsgDirection::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupBidComponents::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldListID::RAW_TAG :
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   case FieldNetGrossInd::RAW_TAG :
     break;

   case FieldSettlType::RAW_TAG :
     break;

   case FieldSettlDate::RAW_TAG :
     break;

   case FieldAccount::RAW_TAG :
     break;

   case FieldAcctIDSource::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSettlInst::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSettlInstID::RAW_TAG :
     break;

   case FieldSettlInstTransType::RAW_TAG :
     break;

   case FieldSettlInstRefID::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldSide::RAW_TAG :
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldEffectiveTime::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldLastUpdateTime::RAW_TAG :
     break;

   case FieldSettlDeliveryType::RAW_TAG :
     break;

   case FieldStandInstDbType::RAW_TAG :
     break;

   case FieldStandInstDbName::RAW_TAG :
     break;

   case FieldStandInstDbID::RAW_TAG :
     break;

   case FieldNoDlvyInst::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupDlvyInst::skip( fix+pos, len - pos );
     break;

   case FieldPaymentMethod::RAW_TAG :
     break;

   case FieldPaymentRef::RAW_TAG :
     break;

   case FieldCardHolderName::RAW_TAG :
     break;

   case FieldCardNumber::RAW_TAG :
     break;

   case FieldCardStartDate::RAW_TAG :
     break;

   case FieldCardExpDate::RAW_TAG :
     break;

   case FieldCardIssNum::RAW_TAG :
     break;

   case FieldPaymentDate::RAW_TAG :
     break;

   case FieldPaymentRemitterID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupInstrAttrib::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldInstrAttribType::RAW_TAG :
     break;

   case FieldInstrAttribValue::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMiscFees::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMiscFeeAmt::RAW_TAG :
     break;

   case FieldMiscFeeCurr::RAW_TAG :
     break;

   case FieldMiscFeeType::RAW_TAG :
     break;

   case FieldMiscFeeBasis::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupQuoteQualifiers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldQuoteQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDistribInsts::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldDistribPaymentMethod::RAW_TAG :
     break;

   case FieldDistribPercentage::RAW_TAG :
     break;

   case FieldCashDistribCurr::RAW_TAG :
     break;

   case FieldCashDistribAgentName::RAW_TAG :
     break;

   case FieldCashDistribAgentCode::RAW_TAG :
     break;

   case FieldCashDistribAgentAcctNumber::RAW_TAG :
     break;

   case FieldCashDistribPayRef::RAW_TAG :
     break;

   case FieldCashDistribAgentAcctName::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTrdRegTimestamps::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTrdRegTimestamp::RAW_TAG :
     break;

   case FieldTrdRegTimestampType::RAW_TAG :
     break;

   case FieldTrdRegTimestampOrigin::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupAltMDSource::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldAltMDSourceID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupSides::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSide::RAW_TAG :
     break;

   case FieldOrigClOrdID::RAW_TAG :
     break;

   case FieldClOrdID::RAW_TAG :
     break;

   case FieldSecondaryClOrdID::RAW_TAG :
     break;

   case FieldClOrdLinkID::RAW_TAG :
     break;

   case FieldOrigOrdModTime::RAW_TAG :
     break;

   case FieldNoPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldTradeOriginationDate::RAW_TAG :
     break;

   case FieldTradeDate::RAW_TAG :
     break;

   case FieldOrderQty::RAW_TAG :
     break;

   case FieldCashOrderQty::RAW_TAG :
     break;

   case FieldOrderPercent::RAW_TAG :
     break;

   case FieldRoundingDirection::RAW_TAG :
     break;

   case FieldRoundingModulus::RAW_TAG :
     break;

   case FieldComplianceID::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedText::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRoutingIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRoutingType::RAW_TAG :
     break;

   case FieldRoutingID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupPosAmt::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldPosAmtType::RAW_TAG :
     break;

   case FieldPosAmt::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLinesOfText::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedText::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupIOIQualifiers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldIOIQualifier::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupDates::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradeDate::RAW_TAG :
     break;

   case FieldTransactTime::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMDEntryTypes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRelatedSym::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupContraBrokers::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldContraBroker::RAW_TAG :
     break;

   case FieldContraTrader::RAW_TAG :
     break;

   case FieldContraTradeQty::RAW_TAG :
     break;

   case FieldContraTradeTime::RAW_TAG :
     break;

   case FieldContraLegRefID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupTrades::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldTradeReportID::RAW_TAG :
     break;

   case FieldSecondaryTradeReportID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupStrikes::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldSymbol::RAW_TAG :
     break;

   case FieldSymbolSfx::RAW_TAG :
     break;

   case FieldSecurityID::RAW_TAG :
     break;

   case FieldSecurityIDSource::RAW_TAG :
     break;

   case FieldNoSecurityAltID::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupSecurityAltID::skip( fix+pos, len - pos );
     break;

   case FieldProduct::RAW_TAG :
     break;

   case FieldCFICode::RAW_TAG :
     break;

   case FieldSecurityType::RAW_TAG :
     break;

   case FieldSecuritySubType::RAW_TAG :
     break;

   case FieldMaturityMonthYear::RAW_TAG :
     break;

   case FieldMaturityDate::RAW_TAG :
     break;

   case FieldPutOrCall::RAW_TAG :
     break;

   case FieldCouponPaymentDate::RAW_TAG :
     break;

   case FieldIssueDate::RAW_TAG :
     break;

   case FieldRepoCollateralSecurityType::RAW_TAG :
     break;

   case FieldRepurchaseTerm::RAW_TAG :
     break;

   case FieldRepurchaseRate::RAW_TAG :
     break;

   case FieldFactor::RAW_TAG :
     break;

   case FieldCreditRating::RAW_TAG :
     break;

   case FieldInstrRegistry::RAW_TAG :
     break;

   case FieldCountryOfIssue::RAW_TAG :
     break;

   case FieldStateOrProvinceOfIssue::RAW_TAG :
     break;

   case FieldLocaleOfIssue::RAW_TAG :
     break;

   case FieldRedemptionDate::RAW_TAG :
     break;

   case FieldStrikePrice::RAW_TAG :
     break;

   case FieldStrikeCurrency::RAW_TAG :
     break;

   case FieldOptAttribute::RAW_TAG :
     break;

   case FieldContractMultiplier::RAW_TAG :
     break;

   case FieldCouponRate::RAW_TAG :
     break;

   case FieldSecurityExchange::RAW_TAG :
     break;

   case FieldIssuer::RAW_TAG :
     break;

   case FieldEncodedIssuerLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedIssuer::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedIssuer::RAW_TAG :
     break;

   case FieldSecurityDesc::RAW_TAG :
     break;

   case FieldEncodedSecurityDescLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedSecurityDesc::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedSecurityDesc::RAW_TAG :
     break;

   case FieldPool::RAW_TAG :
     break;

   case FieldContractSettlMonth::RAW_TAG :
     break;

   case FieldCPProgram::RAW_TAG :
     break;

   case FieldCPRegType::RAW_TAG :
     break;

   case FieldNoEvents::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupEvents::skip( fix+pos, len - pos );
     break;

   case FieldDatedDate::RAW_TAG :
     break;

   case FieldInterestAccrualDate::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupBidDescriptors::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldBidDescriptorType::RAW_TAG :
     break;

   case FieldBidDescriptor::RAW_TAG :
     break;

   case FieldSideValueInd::RAW_TAG :
     break;

   case FieldLiquidityValue::RAW_TAG :
     break;

   case FieldLiquidityNumSecurities::RAW_TAG :
     break;

   case FieldLiquidityPctLow::RAW_TAG :
     break;

   case FieldLiquidityPctHigh::RAW_TAG :
     break;

   case FieldEFPTrackingError::RAW_TAG :
     break;

   case FieldFairValue::RAW_TAG :
     break;

   case FieldOutsideIndexPct::RAW_TAG :
     break;

   case FieldValueOfFutures::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupCompIDs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRefCompID::RAW_TAG :
     break;

   case FieldRefSubID::RAW_TAG :
     break;

   case FieldLocationID::RAW_TAG :
     break;

   case FieldDeskID::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupLegAllocs::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldLegAllocAccount::RAW_TAG :
     break;

   case FieldLegIndividualAllocID::RAW_TAG :
     break;

   case FieldNoNested2PartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNested2PartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldLegAllocQty::RAW_TAG :
     break;

   case FieldLegAllocAcctIDSource::RAW_TAG :
     break;

   case FieldLegSettlCurrency::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupRegistDtls::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldRegistDtls::RAW_TAG :
     break;

   case FieldRegistEmail::RAW_TAG :
     break;

   case FieldMailingDtls::RAW_TAG :
     break;

   case FieldMailingInst::RAW_TAG :
     break;

   case FieldNoNestedPartyIDs::RAW_TAG :
     posIsOnNextField = true;
     gotoNextField( fix, pos );
     pos += GroupNestedPartyIDs::skip( fix+pos, len - pos );
     break;

   case FieldOwnerType::RAW_TAG :
     break;

   case FieldDateOfBirth::RAW_TAG :
     break;

   case FieldInvestorCountryOfResidence::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupContAmts::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldContAmtType::RAW_TAG :
     break;

   case FieldContAmtValue::RAW_TAG :
     break;

   case FieldContAmtCurr::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

offset_t GroupMDEntries::skip( const char * fix, unsigned len ){
 offset_t prev = 0, pos = 0; 
 while( pos < (int)len ) { 
   bool posIsOnNextField = false;
   prev = pos;
   raw_tag_t tag = loadRawTag( fix+pos, pos );
   switch( tag ){
   case FieldMDEntryType::RAW_TAG :
     break;

   case FieldMDEntryPx::RAW_TAG :
     break;

   case FieldCurrency::RAW_TAG :
     break;

   case FieldMDEntrySize::RAW_TAG :
     break;

   case FieldMDEntryDate::RAW_TAG :
     break;

   case FieldMDEntryTime::RAW_TAG :
     break;

   case FieldTickDirection::RAW_TAG :
     break;

   case FieldMDMkt::RAW_TAG :
     break;

   case FieldTradingSessionID::RAW_TAG :
     break;

   case FieldTradingSessionSubID::RAW_TAG :
     break;

   case FieldQuoteCondition::RAW_TAG :
     break;

   case FieldTradeCondition::RAW_TAG :
     break;

   case FieldMDEntryOriginator::RAW_TAG :
     break;

   case FieldLocationID::RAW_TAG :
     break;

   case FieldDeskID::RAW_TAG :
     break;

   case FieldOpenCloseSettlFlag::RAW_TAG :
     break;

   case FieldTimeInForce::RAW_TAG :
     break;

   case FieldExpireDate::RAW_TAG :
     break;

   case FieldExpireTime::RAW_TAG :
     break;

   case FieldMinQty::RAW_TAG :
     break;

   case FieldExecInst::RAW_TAG :
     break;

   case FieldSellerDays::RAW_TAG :
     break;

   case FieldOrderID::RAW_TAG :
     break;

   case FieldQuoteEntryID::RAW_TAG :
     break;

   case FieldMDEntryBuyer::RAW_TAG :
     break;

   case FieldMDEntrySeller::RAW_TAG :
     break;

   case FieldNumberOfOrders::RAW_TAG :
     break;

   case FieldMDEntryPositionNo::RAW_TAG :
     break;

   case FieldScope::RAW_TAG :
     break;

   case FieldPriceDelta::RAW_TAG :
     break;

   case FieldText::RAW_TAG :
     break;

   case FieldEncodedTextLen::RAW_TAG: { posIsOnNextField = true; unsigned sz = 0; unsigned dataLen = parseUInt( fix+pos, sz ); pos += sz + 1 + FieldEncodedText::TAG_WIDTH + 1 + dataLen + 1; }
     break;

   case FieldEncodedText::RAW_TAG :
     break;

   default: FIXPP_PRINT_UNKNOWN_FIELD
     return prev;
   }
   if( ! posIsOnNextField ) gotoNextField( fix, pos );
 }
 return pos;
}

// -------------------------------------- reset ----------------------------------------

void GroupLegStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegStipulationValue.offset = -1;
}

void GroupEvents::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldEventDate.offset = -1;
     fieldEventPx.offset = -1;
     fieldEventText.offset = -1;
}

void GroupLegSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSecurityAltIDSource.offset = -1;
}

void GroupCapacities::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldOrderRestrictions.offset = -1;
     fieldOrderCapacityQty.offset = -1;
}

void GroupNested3PartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested3PartySubIDType.offset = -1;
}

void GroupPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPartySubIDType.offset = -1;
}

void GroupNested2PartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested2PartySubIDType.offset = -1;
}

void GroupNested2PartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested2PartyIDSource.offset = -1;
     fieldNested2PartyRole.offset = -1;
     fieldNoNested2PartySubIDs.offset = -1;
     for( auto g = groupsNested2PartySubIDs.begin(); g != groupsNested2PartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupHops::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldHopSendingTime.offset = -1;
     fieldHopRefID.offset = -1;
}

void GroupCollInquiryQualifier::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPartyIDSource.offset = -1;
     fieldPartyRole.offset = -1;
     fieldNoPartySubIDs.offset = -1;
     for( auto g = groupsPartySubIDs.begin(); g != groupsPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupAllocs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldAllocAcctIDSource.offset = -1;
     fieldAllocPrice.offset = -1;
     fieldIndividualAllocID.offset = -1;
     fieldIndividualAllocRejCode.offset = -1;
     fieldAllocText.offset = -1;
     fieldEncodedAllocTextLen.offset = -1;
     fieldEncodedAllocText.offset = -1;
}

void GroupTradingSessions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTradingSessionSubID.offset = -1;
}

void GroupSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecurityAltIDSource.offset = -1;
}

void GroupUnderlyingSecurityAltID::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSecurityAltIDSource.offset = -1;
}

void GroupUnderlyingStips::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingStipValue.offset = -1;
}

void GroupUnderlyings::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSymbolSfx.offset = -1;
     fieldUnderlyingSecurityID.offset = -1;
     fieldUnderlyingSecurityIDSource.offset = -1;
     fieldNoUnderlyingSecurityAltID.offset = -1;
     for( auto g = groupsUnderlyingSecurityAltID.begin(); g != groupsUnderlyingSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingProduct.offset = -1;
     fieldUnderlyingCFICode.offset = -1;
     fieldUnderlyingSecurityType.offset = -1;
     fieldUnderlyingSecuritySubType.offset = -1;
     fieldUnderlyingMaturityMonthYear.offset = -1;
     fieldUnderlyingMaturityDate.offset = -1;
     fieldUnderlyingPutOrCall.offset = -1;
     fieldUnderlyingCouponPaymentDate.offset = -1;
     fieldUnderlyingIssueDate.offset = -1;
     fieldUnderlyingRepoCollateralSecurityType.offset = -1;
     fieldUnderlyingRepurchaseTerm.offset = -1;
     fieldUnderlyingRepurchaseRate.offset = -1;
     fieldUnderlyingFactor.offset = -1;
     fieldUnderlyingCreditRating.offset = -1;
     fieldUnderlyingInstrRegistry.offset = -1;
     fieldUnderlyingCountryOfIssue.offset = -1;
     fieldUnderlyingStateOrProvinceOfIssue.offset = -1;
     fieldUnderlyingLocaleOfIssue.offset = -1;
     fieldUnderlyingRedemptionDate.offset = -1;
     fieldUnderlyingStrikePrice.offset = -1;
     fieldUnderlyingStrikeCurrency.offset = -1;
     fieldUnderlyingOptAttribute.offset = -1;
     fieldUnderlyingContractMultiplier.offset = -1;
     fieldUnderlyingCouponRate.offset = -1;
     fieldUnderlyingSecurityExchange.offset = -1;
     fieldUnderlyingIssuer.offset = -1;
     fieldEncodedUnderlyingIssuerLen.offset = -1;
     fieldEncodedUnderlyingIssuer.offset = -1;
     fieldUnderlyingSecurityDesc.offset = -1;
     fieldEncodedUnderlyingSecurityDescLen.offset = -1;
     fieldEncodedUnderlyingSecurityDesc.offset = -1;
     fieldUnderlyingCPProgram.offset = -1;
     fieldUnderlyingCPRegType.offset = -1;
     fieldUnderlyingCurrency.offset = -1;
     fieldUnderlyingQty.offset = -1;
     fieldUnderlyingPx.offset = -1;
     fieldUnderlyingDirtyPrice.offset = -1;
     fieldUnderlyingEndPrice.offset = -1;
     fieldUnderlyingStartValue.offset = -1;
     fieldUnderlyingCurrentValue.offset = -1;
     fieldUnderlyingEndValue.offset = -1;
     fieldNoUnderlyingStips.offset = -1;
     for( auto g = groupsUnderlyingStips.begin(); g != groupsUnderlyingStips.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingSettlPrice.offset = -1;
     fieldUnderlyingSettlPriceType.offset = -1;
}

void GroupStipulations::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldStipulationValue.offset = -1;
}

void GroupOrders::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecondaryClOrdID.offset = -1;
     fieldListSeqNo.offset = -1;
     fieldClOrdLinkID.offset = -1;
     fieldSettlInstMode.offset = -1;
     fieldNoPartyIDs.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTradeOriginationDate.offset = -1;
     fieldTradeDate.offset = -1;
     fieldAccount.offset = -1;
     fieldAcctIDSource.offset = -1;
     fieldAccountType.offset = -1;
     fieldDayBookingInst.offset = -1;
     fieldBookingUnit.offset = -1;
     fieldAllocID.offset = -1;
     fieldPreallocMethod.offset = -1;
     fieldNoAllocs.offset = -1;
     for( auto g = groupsAllocs.begin(); g != groupsAllocs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldSettlType.offset = -1;
     fieldSettlDate.offset = -1;
     fieldCashMargin.offset = -1;
     fieldClearingFeeIndicator.offset = -1;
     fieldHandlInst.offset = -1;
     fieldExecInst.offset = -1;
     fieldMinQty.offset = -1;
     fieldMaxFloor.offset = -1;
     fieldExDestination.offset = -1;
     fieldNoTradingSessions.offset = -1;
     for( auto g = groupsTradingSessions.begin(); g != groupsTradingSessions.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProcessCode.offset = -1;
     fieldSymbol.offset = -1;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     fieldNoSecurityAltID.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     fieldNoEvents.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
     fieldNoUnderlyings.offset = -1;
     for( auto g = groupsUnderlyings.begin(); g != groupsUnderlyings.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldPrevClosePx.offset = -1;
     fieldSide.offset = -1;
     fieldSideValueInd.offset = -1;
     fieldLocateReqd.offset = -1;
     fieldTransactTime.offset = -1;
     fieldNoStipulations.offset = -1;
     for( auto g = groupsStipulations.begin(); g != groupsStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldQtyType.offset = -1;
     fieldOrderQty.offset = -1;
     fieldCashOrderQty.offset = -1;
     fieldOrderPercent.offset = -1;
     fieldRoundingDirection.offset = -1;
     fieldRoundingModulus.offset = -1;
     fieldOrdType.offset = -1;
     fieldPriceType.offset = -1;
     fieldPrice.offset = -1;
     fieldStopPx.offset = -1;
     fieldSpread.offset = -1;
     fieldBenchmarkCurveCurrency.offset = -1;
     fieldBenchmarkCurveName.offset = -1;
     fieldBenchmarkCurvePoint.offset = -1;
     fieldBenchmarkPrice.offset = -1;
     fieldBenchmarkPriceType.offset = -1;
     fieldBenchmarkSecurityID.offset = -1;
     fieldBenchmarkSecurityIDSource.offset = -1;
     fieldYieldType.offset = -1;
     fieldYield.offset = -1;
     fieldYieldCalcDate.offset = -1;
     fieldYieldRedemptionDate.offset = -1;
     fieldYieldRedemptionPrice.offset = -1;
     fieldYieldRedemptionPriceType.offset = -1;
     fieldCurrency.offset = -1;
     fieldComplianceID.offset = -1;
     fieldSolicitedFlag.offset = -1;
     fieldIOIID.offset = -1;
     fieldQuoteID.offset = -1;
     fieldTimeInForce.offset = -1;
     fieldEffectiveTime.offset = -1;
     fieldExpireDate.offset = -1;
     fieldExpireTime.offset = -1;
     fieldGTBookingInst.offset = -1;
     fieldCommission.offset = -1;
     fieldCommType.offset = -1;
     fieldCommCurrency.offset = -1;
     fieldFundRenewWaiv.offset = -1;
     fieldOrderCapacity.offset = -1;
     fieldOrderRestrictions.offset = -1;
     fieldCustOrderCapacity.offset = -1;
     fieldForexReq.offset = -1;
     fieldSettlCurrency.offset = -1;
     fieldBookingType.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
     fieldSettlDate2.offset = -1;
     fieldOrderQty2.offset = -1;
     fieldPrice2.offset = -1;
     fieldPositionEffect.offset = -1;
     fieldCoveredOrUncovered.offset = -1;
     fieldMaxShow.offset = -1;
     fieldPegOffsetValue.offset = -1;
     fieldPegMoveType.offset = -1;
     fieldPegOffsetType.offset = -1;
     fieldPegLimitType.offset = -1;
     fieldPegRoundDirection.offset = -1;
     fieldPegScope.offset = -1;
     fieldDiscretionInst.offset = -1;
     fieldDiscretionOffsetValue.offset = -1;
     fieldDiscretionMoveType.offset = -1;
     fieldDiscretionOffsetType.offset = -1;
     fieldDiscretionLimitType.offset = -1;
     fieldDiscretionRoundDirection.offset = -1;
     fieldDiscretionScope.offset = -1;
     fieldTargetStrategy.offset = -1;
     fieldTargetStrategyParameters.offset = -1;
     fieldParticipationRate.offset = -1;
     fieldDesignation.offset = -1;
}

void GroupSettlPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlPartySubIDType.offset = -1;
}

void GroupSettlPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlPartyIDSource.offset = -1;
     fieldSettlPartyRole.offset = -1;
     fieldNoSettlPartySubIDs.offset = -1;
     for( auto g = groupsSettlPartySubIDs.begin(); g != groupsSettlPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupDlvyInst::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldDlvyInstType.offset = -1;
     fieldNoSettlPartyIDs.offset = -1;
     for( auto g = groupsSettlPartyIDs.begin(); g != groupsSettlPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupClearingInstructions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupNestedPartySubIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartySubIDType.offset = -1;
}

void GroupNestedPartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNestedPartyIDSource.offset = -1;
     fieldNestedPartyRole.offset = -1;
     fieldNoNestedPartySubIDs.offset = -1;
     for( auto g = groupsNestedPartySubIDs.begin(); g != groupsNestedPartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupLegs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegSymbolSfx.offset = -1;
     fieldLegSecurityID.offset = -1;
     fieldLegSecurityIDSource.offset = -1;
     fieldNoLegSecurityAltID.offset = -1;
     for( auto g = groupsLegSecurityAltID.begin(); g != groupsLegSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegProduct.offset = -1;
     fieldLegCFICode.offset = -1;
     fieldLegSecurityType.offset = -1;
     fieldLegSecuritySubType.offset = -1;
     fieldLegMaturityMonthYear.offset = -1;
     fieldLegMaturityDate.offset = -1;
     fieldLegCouponPaymentDate.offset = -1;
     fieldLegIssueDate.offset = -1;
     fieldLegRepoCollateralSecurityType.offset = -1;
     fieldLegRepurchaseTerm.offset = -1;
     fieldLegRepurchaseRate.offset = -1;
     fieldLegFactor.offset = -1;
     fieldLegCreditRating.offset = -1;
     fieldLegInstrRegistry.offset = -1;
     fieldLegCountryOfIssue.offset = -1;
     fieldLegStateOrProvinceOfIssue.offset = -1;
     fieldLegLocaleOfIssue.offset = -1;
     fieldLegRedemptionDate.offset = -1;
     fieldLegStrikePrice.offset = -1;
     fieldLegStrikeCurrency.offset = -1;
     fieldLegOptAttribute.offset = -1;
     fieldLegContractMultiplier.offset = -1;
     fieldLegCouponRate.offset = -1;
     fieldLegSecurityExchange.offset = -1;
     fieldLegIssuer.offset = -1;
     fieldEncodedLegIssuerLen.offset = -1;
     fieldEncodedLegIssuer.offset = -1;
     fieldLegSecurityDesc.offset = -1;
     fieldEncodedLegSecurityDescLen.offset = -1;
     fieldEncodedLegSecurityDesc.offset = -1;
     fieldLegRatioQty.offset = -1;
     fieldLegSide.offset = -1;
     fieldLegCurrency.offset = -1;
     fieldLegPool.offset = -1;
     fieldLegDatedDate.offset = -1;
     fieldLegContractSettlMonth.offset = -1;
     fieldLegInterestAccrualDate.offset = -1;
     fieldLegQty.offset = -1;
     fieldLegSwapType.offset = -1;
     fieldNoLegStipulations.offset = -1;
     for( auto g = groupsLegStipulations.begin(); g != groupsLegStipulations.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegPositionEffect.offset = -1;
     fieldLegCoveredOrUncovered.offset = -1;
     fieldNoNestedPartyIDs.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegRefID.offset = -1;
     fieldLegPrice.offset = -1;
     fieldLegSettlType.offset = -1;
     fieldLegSettlDate.offset = -1;
     fieldLegLastPx.offset = -1;
}

void GroupQuoteEntries::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     fieldNoSecurityAltID.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     fieldNoEvents.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
     fieldAgreementDesc.offset = -1;
     fieldAgreementID.offset = -1;
     fieldAgreementDate.offset = -1;
     fieldAgreementCurrency.offset = -1;
     fieldTerminationType.offset = -1;
     fieldStartDate.offset = -1;
     fieldEndDate.offset = -1;
     fieldDeliveryType.offset = -1;
     fieldMarginRatio.offset = -1;
     fieldNoUnderlyings.offset = -1;
     for( auto g = groupsUnderlyings.begin(); g != groupsUnderlyings.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldNoLegs.offset = -1;
     for( auto g = groupsLegs.begin(); g != groupsLegs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupQuoteSets::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldUnderlyingSymbol.offset = -1;
     fieldUnderlyingSymbolSfx.offset = -1;
     fieldUnderlyingSecurityID.offset = -1;
     fieldUnderlyingSecurityIDSource.offset = -1;
     fieldNoUnderlyingSecurityAltID.offset = -1;
     for( auto g = groupsUnderlyingSecurityAltID.begin(); g != groupsUnderlyingSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldUnderlyingProduct.offset = -1;
     fieldUnderlyingCFICode.offset = -1;
     fieldUnderlyingSecurityType.offset = -1;
     fieldUnderlyingSecuritySubType.offset = -1;
     fieldUnderlyingMaturityMonthYear.offset = -1;
     fieldUnderlyingMaturityDate.offset = -1;
     fieldUnderlyingPutOrCall.offset = -1;
     fieldUnderlyingCouponPaymentDate.offset = -1;
     fieldUnderlyingIssueDate.offset = -1;
     fieldUnderlyingRepoCollateralSecurityType.offset = -1;
     fieldUnderlyingRepurchaseTerm.offset = -1;
     fieldUnderlyingRepurchaseRate.offset = -1;
     fieldUnderlyingFactor.offset = -1;
     fieldUnderlyingCreditRating.offset = -1;
     fieldUnderlyingInstrRegistry.offset = -1;
     fieldUnderlyingCountryOfIssue.offset = -1;
     fieldUnderlyingStateOrProvinceOfIssue.offset = -1;
     fieldUnderlyingLocaleOfIssue.offset = -1;
     fieldUnderlyingRedemptionDate.offset = -1;
     fieldUnderlyingStrikePrice.offset = -1;
     fieldUnderlyingStrikeCurrency.offset = -1;
     fieldUnderlyingOptAttribute.offset = -1;
     fieldUnderlyingContractMultiplier.offset = -1;
     fieldUnderlyingCouponRate.offset = -1;
     fieldUnderlyingSecurityExchange.offset = -1;
     fieldUnderlyingIssuer.offset = -1;
     fieldEncodedUnderlyingIssuerLen.offset = -1;
     fieldEncodedUnderlyingIssuer.offset = -1;
     fieldUnderlyingSecurityDesc.offset = -1;
     fieldEncodedUnderlyingSecurityDescLen.offset = -1;
     fieldEncodedUnderlyingSecurityDesc.offset = -1;
     fieldUnderlyingCPProgram.offset = -1;
     fieldUnderlyingCPRegType.offset = -1;
     fieldUnderlyingCurrency.offset = -1;
     fieldUnderlyingQty.offset = -1;
     fieldUnderlyingPx.offset = -1;
     fieldUnderlyingDirtyPrice.offset = -1;
     fieldUnderlyingEndPrice.offset = -1;
     fieldUnderlyingStartValue.offset = -1;
     fieldUnderlyingCurrentValue.offset = -1;
     fieldUnderlyingEndValue.offset = -1;
     fieldNoUnderlyingStips.offset = -1;
     for( auto g = groupsUnderlyingStips.begin(); g != groupsUnderlyingStips.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTotNoQuoteEntries.offset = -1;
     fieldLastFragment.offset = -1;
     fieldNoQuoteEntries.offset = -1;
     for( auto g = groupsQuoteEntries.begin(); g != groupsQuoteEntries.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupSecurityTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecuritySubType.offset = -1;
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
}

void GroupNested3PartyIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldNested3PartyIDSource.offset = -1;
     fieldNested3PartyRole.offset = -1;
     fieldNoNested3PartySubIDs.offset = -1;
     for( auto g = groupsNested3PartySubIDs.begin(); g != groupsNested3PartySubIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupPositions::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLongQty.offset = -1;
     fieldShortQty.offset = -1;
     fieldPosQtyStatus.offset = -1;
     fieldNoNestedPartyIDs.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
}

void GroupAffectedOrders::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldAffectedOrderID.offset = -1;
     fieldAffectedSecondaryOrderID.offset = -1;
}

void GroupExecs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldExecID.offset = -1;
     fieldSecondaryExecID.offset = -1;
     fieldLastPx.offset = -1;
     fieldLastParPx.offset = -1;
     fieldLastCapacity.offset = -1;
}

void GroupMsgTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMsgDirection.offset = -1;
}

void GroupBidComponents::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSide.offset = -1;
     fieldTradingSessionID.offset = -1;
     fieldTradingSessionSubID.offset = -1;
     fieldNetGrossInd.offset = -1;
     fieldSettlType.offset = -1;
     fieldSettlDate.offset = -1;
     fieldAccount.offset = -1;
     fieldAcctIDSource.offset = -1;
}

void GroupSettlInst::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSettlInstTransType.offset = -1;
     fieldSettlInstRefID.offset = -1;
     fieldNoPartyIDs.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldSide.offset = -1;
     fieldProduct.offset = -1;
     fieldSecurityType.offset = -1;
     fieldCFICode.offset = -1;
     fieldEffectiveTime.offset = -1;
     fieldExpireTime.offset = -1;
     fieldLastUpdateTime.offset = -1;
     fieldSettlDeliveryType.offset = -1;
     fieldStandInstDbType.offset = -1;
     fieldStandInstDbName.offset = -1;
     fieldStandInstDbID.offset = -1;
     fieldNoDlvyInst.offset = -1;
     for( auto g = groupsDlvyInst.begin(); g != groupsDlvyInst.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldPaymentMethod.offset = -1;
     fieldPaymentRef.offset = -1;
     fieldCardHolderName.offset = -1;
     fieldCardNumber.offset = -1;
     fieldCardStartDate.offset = -1;
     fieldCardExpDate.offset = -1;
     fieldCardIssNum.offset = -1;
     fieldPaymentDate.offset = -1;
     fieldPaymentRemitterID.offset = -1;
}

void GroupInstrAttrib::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldInstrAttribValue.offset = -1;
}

void GroupMiscFees::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMiscFeeCurr.offset = -1;
     fieldMiscFeeType.offset = -1;
     fieldMiscFeeBasis.offset = -1;
}

void GroupQuoteQualifiers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupDistribInsts::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldDistribPercentage.offset = -1;
     fieldCashDistribCurr.offset = -1;
     fieldCashDistribAgentName.offset = -1;
     fieldCashDistribAgentCode.offset = -1;
     fieldCashDistribAgentAcctNumber.offset = -1;
     fieldCashDistribPayRef.offset = -1;
     fieldCashDistribAgentAcctName.offset = -1;
}

void GroupTrdRegTimestamps::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTrdRegTimestampType.offset = -1;
     fieldTrdRegTimestampOrigin.offset = -1;
}

void GroupAltMDSource::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupSides::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldOrigClOrdID.offset = -1;
     fieldClOrdID.offset = -1;
     fieldSecondaryClOrdID.offset = -1;
     fieldClOrdLinkID.offset = -1;
     fieldOrigOrdModTime.offset = -1;
     fieldNoPartyIDs.offset = -1;
     for( auto g = groupsPartyIDs.begin(); g != groupsPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldTradeOriginationDate.offset = -1;
     fieldTradeDate.offset = -1;
     fieldOrderQty.offset = -1;
     fieldCashOrderQty.offset = -1;
     fieldOrderPercent.offset = -1;
     fieldRoundingDirection.offset = -1;
     fieldRoundingModulus.offset = -1;
     fieldComplianceID.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}

void GroupRoutingIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRoutingID.offset = -1;
}

void GroupPosAmt::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldPosAmt.offset = -1;
}

void GroupLinesOfText::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}

void GroupIOIQualifiers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupDates::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldTransactTime.offset = -1;
}

void GroupMDEntryTypes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
}

void GroupRelatedSym::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     fieldNoSecurityAltID.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     fieldNoEvents.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
}

void GroupContraBrokers::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldContraTrader.offset = -1;
     fieldContraTradeQty.offset = -1;
     fieldContraTradeTime.offset = -1;
     fieldContraLegRefID.offset = -1;
}

void GroupTrades::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSecondaryTradeReportID.offset = -1;
}

void GroupStrikes::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldSymbolSfx.offset = -1;
     fieldSecurityID.offset = -1;
     fieldSecurityIDSource.offset = -1;
     fieldNoSecurityAltID.offset = -1;
     for( auto g = groupsSecurityAltID.begin(); g != groupsSecurityAltID.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldProduct.offset = -1;
     fieldCFICode.offset = -1;
     fieldSecurityType.offset = -1;
     fieldSecuritySubType.offset = -1;
     fieldMaturityMonthYear.offset = -1;
     fieldMaturityDate.offset = -1;
     fieldPutOrCall.offset = -1;
     fieldCouponPaymentDate.offset = -1;
     fieldIssueDate.offset = -1;
     fieldRepoCollateralSecurityType.offset = -1;
     fieldRepurchaseTerm.offset = -1;
     fieldRepurchaseRate.offset = -1;
     fieldFactor.offset = -1;
     fieldCreditRating.offset = -1;
     fieldInstrRegistry.offset = -1;
     fieldCountryOfIssue.offset = -1;
     fieldStateOrProvinceOfIssue.offset = -1;
     fieldLocaleOfIssue.offset = -1;
     fieldRedemptionDate.offset = -1;
     fieldStrikePrice.offset = -1;
     fieldStrikeCurrency.offset = -1;
     fieldOptAttribute.offset = -1;
     fieldContractMultiplier.offset = -1;
     fieldCouponRate.offset = -1;
     fieldSecurityExchange.offset = -1;
     fieldIssuer.offset = -1;
     fieldEncodedIssuerLen.offset = -1;
     fieldEncodedIssuer.offset = -1;
     fieldSecurityDesc.offset = -1;
     fieldEncodedSecurityDescLen.offset = -1;
     fieldEncodedSecurityDesc.offset = -1;
     fieldPool.offset = -1;
     fieldContractSettlMonth.offset = -1;
     fieldCPProgram.offset = -1;
     fieldCPRegType.offset = -1;
     fieldNoEvents.offset = -1;
     for( auto g = groupsEvents.begin(); g != groupsEvents.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldDatedDate.offset = -1;
     fieldInterestAccrualDate.offset = -1;
}

void GroupBidDescriptors::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldBidDescriptor.offset = -1;
     fieldSideValueInd.offset = -1;
     fieldLiquidityValue.offset = -1;
     fieldLiquidityNumSecurities.offset = -1;
     fieldLiquidityPctLow.offset = -1;
     fieldLiquidityPctHigh.offset = -1;
     fieldEFPTrackingError.offset = -1;
     fieldFairValue.offset = -1;
     fieldOutsideIndexPct.offset = -1;
     fieldValueOfFutures.offset = -1;
}

void GroupCompIDs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRefSubID.offset = -1;
     fieldLocationID.offset = -1;
     fieldDeskID.offset = -1;
}

void GroupLegAllocs::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldLegIndividualAllocID.offset = -1;
     fieldNoNested2PartyIDs.offset = -1;
     for( auto g = groupsNested2PartyIDs.begin(); g != groupsNested2PartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldLegAllocQty.offset = -1;
     fieldLegAllocAcctIDSource.offset = -1;
     fieldLegSettlCurrency.offset = -1;
}

void GroupRegistDtls::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldRegistEmail.offset = -1;
     fieldMailingDtls.offset = -1;
     fieldMailingInst.offset = -1;
     fieldNoNestedPartyIDs.offset = -1;
     for( auto g = groupsNestedPartyIDs.begin(); g != groupsNestedPartyIDs.end() and g->getMessageBuffer(); ++g ) g->reset();
     fieldOwnerType.offset = -1;
     fieldDateOfBirth.offset = -1;
     fieldInvestorCountryOfResidence.offset = -1;
}

void GroupContAmts::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldContAmtValue.offset = -1;
     fieldContAmtCurr.offset = -1;
}

void GroupMDEntries::reset(){
     _fixPtr = nullptr;
     _fixLength = 0;
     fieldMDEntryPx.offset = -1;
     fieldCurrency.offset = -1;
     fieldMDEntrySize.offset = -1;
     fieldMDEntryDate.offset = -1;
     fieldMDEntryTime.offset = -1;
     fieldTickDirection.offset = -1;
     fieldMDMkt.offset = -1;
     fieldTradingSessionID.offset = -1;
     fieldTradingSessionSubID.offset = -1;
     fieldQuoteCondition.offset = -1;
     fieldTradeCondition.offset = -1;
     fieldMDEntryOriginator.offset = -1;
     fieldLocationID.offset = -1;
     fieldDeskID.offset = -1;
     fieldOpenCloseSettlFlag.offset = -1;
     fieldTimeInForce.offset = -1;
     fieldExpireDate.offset = -1;
     fieldExpireTime.offset = -1;
     fieldMinQty.offset = -1;
     fieldExecInst.offset = -1;
     fieldSellerDays.offset = -1;
     fieldOrderID.offset = -1;
     fieldQuoteEntryID.offset = -1;
     fieldMDEntryBuyer.offset = -1;
     fieldMDEntrySeller.offset = -1;
     fieldNumberOfOrders.offset = -1;
     fieldMDEntryPositionNo.offset = -1;
     fieldScope.offset = -1;
     fieldPriceDelta.offset = -1;
     fieldText.offset = -1;
     fieldEncodedTextLen.offset = -1;
     fieldEncodedText.offset = -1;
}
// end of GroupScanners.cxx

} // namespace fix44
