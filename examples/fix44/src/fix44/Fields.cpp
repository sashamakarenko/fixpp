// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <fix44/Fields.h>
#include <set>

std::ostream & operator << ( std::ostream & os, const fix44::sohstr & str )
{
    if( str.ptr )
    {
        for( const char * ptr = str.ptr; (unsigned)*ptr > FIXPP_SOH; ++ptr )
        {
            os << *ptr;
        }
    }
    return os;
}

namespace fix44
{

FieldEnumsBase::~FieldEnumsBase()
{
}

Iterator::Iterator( const char * begin, const char * end )
: _begin      { begin }
, _end        { end }
, _pos        { 0 }
, _valueOffset{ 0 }
{
    ptrdiff_t len = _end - _begin;
    if( _begin != nullptr and _begin[_pos] != 0 and ( _end == nullptr or len < (ptrdiff_t)std::numeric_limits< offset_t >::max() ) )
    {
        update();
    }
}

bool Iterator::hasNext() const
{
    return _valueOffset > 0;
}

bool Iterator::next()
{
    if( _valueOffset == 0 or _begin == nullptr or _begin[_pos] == 0 or ( _end != nullptr and _begin + _pos >= _end  ) )
    {
        return false;
    }
    gotoNextField( _begin, _pos );
    if( _end != nullptr and _begin + _pos >= _end )
    {
        _valueOffset = 0;
    }
    else
    {
        update();
    }
    return _valueOffset > 0;
}

const char * Iterator::getTagPtr() const
{
    return _begin + _pos;
}

const char * Iterator::getValuePtr() const
{
    return _valueOffset ? _begin + _valueOffset : nullptr;
}

raw_tag_t Iterator::getRawTag() const
{
    if( _valueOffset )
    {
        offset_t len = 0;
        return loadRawTag( _begin + _pos, len );
    }
    return 0;
}

raw_tag_t Iterator::update()
{
    _valueOffset = _pos;
    raw_tag_t tag = loadRawTag( _begin + _pos, _valueOffset );
    if( tag == 0 )
    {
        _valueOffset = 0;
    }
    return tag;
}


std::map< raw_tag_t  , const char * const >           tagNameByRaw;
std::map< tag_t      , const char * const >           tagNameByValue;
std::map< raw_tag_t  , const FieldEnumsBase * const > enumsByRaw;
std::map< tag_t      , const FieldEnumsBase * const > enumsByTag;
std::map< std::string, tag_t >                        tagByName;
std::map< tag_t      , FieldType >                    fieldTypeByValue;
std::map< tag_t      , const std::string >            fieldTypeNameByValue;

const std::map< raw_tag_t  , const char * const >           & RAW_TAG_TO_NAME        = tagNameByRaw;
const std::map< tag_t      , const char * const >           & TAG_TO_NAME            = tagNameByValue;
const std::map< raw_tag_t  , const FieldEnumsBase * const > & RAW_TO_ENUM            = enumsByRaw;
const std::map< tag_t      , const FieldEnumsBase * const > & TAG_TO_ENUM            = enumsByTag;
const std::map< std::string, tag_t >                        & FIELD_NAME_TO_TAG      = tagByName;
const std::map< tag_t      , FieldType >                    & TAG_TO_FIELD_TYPE      = fieldTypeByValue;
const std::map< tag_t      , const std::string >            & TAG_TO_FIELD_TYPE_NAME = fieldTypeNameByValue;

tag_t getFieldTag( const std::string & fieldName )
{
    auto it = tagByName.find( fieldName );
    return it != tagByName.end() ? it->second : 0;
}

const char * getFieldName( tag_t tagValue )
{
    auto it = tagNameByValue.find( tagValue );
    return it != tagNameByValue.end() ? it->second : nullptr;
}

FieldType getFieldType( tag_t tagValue )
{
    auto it = fieldTypeByValue.find( tagValue );
    return it != fieldTypeByValue.end() ? it->second : FieldType::UNKNOWN;
}

const std::string & getFieldTypeName( tag_t tagValue )
{
    static std::string unknown{ "UNKNOWN" };
    auto it = fieldTypeNameByValue.find( tagValue );
    return it != fieldTypeNameByValue.end() ? it->second : unknown;
}

std::set< tag_t > headerTags =
{
// start of Header.cxx
 FieldBeginString::TAG,
 FieldBodyLength::TAG,
 FieldMsgType::TAG,
 FieldSenderCompID::TAG,
 FieldTargetCompID::TAG,
 FieldOnBehalfOfCompID::TAG,
 FieldDeliverToCompID::TAG,
 FieldSecureDataLen::TAG,
 FieldSecureData::TAG,
 FieldMsgSeqNum::TAG,
 FieldSenderSubID::TAG,
 FieldSenderLocationID::TAG,
 FieldTargetSubID::TAG,
 FieldTargetLocationID::TAG,
 FieldOnBehalfOfSubID::TAG,
 FieldOnBehalfOfLocationID::TAG,
 FieldDeliverToSubID::TAG,
 FieldDeliverToLocationID::TAG,
 FieldPossDupFlag::TAG,
 FieldPossResend::TAG,
 FieldSendingTime::TAG,
 FieldOrigSendingTime::TAG,
 FieldXmlDataLen::TAG,
 FieldXmlData::TAG,
 FieldMessageEncoding::TAG,
 FieldLastMsgSeqNumProcessed::TAG,
// end of Header.cxx
};

bool isHeaderField( tag_t tagValue )
{
    return headerTags.find( tagValue ) != headerTags.end();
}

// start of Fields.cxx

// Generated

// -------------------------------------- names ----------------------------------------
const std::string FixBeginStringValue( "FIX.4.4" );

const char * const FixAccount = "Account";
const char * const FixAdvId = "AdvId";
const char * const FixAdvRefID = "AdvRefID";
const char * const FixAdvSide = "AdvSide";
const char * const FixAdvTransType = "AdvTransType";
const char * const FixAvgPx = "AvgPx";
const char * const FixBeginSeqNo = "BeginSeqNo";
const char * const FixBeginString = "BeginString";
const char * const FixBodyLength = "BodyLength";
const char * const FixCheckSum = "CheckSum";
const char * const FixClOrdID = "ClOrdID";
const char * const FixCommission = "Commission";
const char * const FixCommType = "CommType";
const char * const FixCumQty = "CumQty";
const char * const FixCurrency = "Currency";
const char * const FixEndSeqNo = "EndSeqNo";
const char * const FixExecID = "ExecID";
const char * const FixExecInst = "ExecInst";
const char * const FixExecRefID = "ExecRefID";
const char * const FixHandlInst = "HandlInst";
const char * const FixSecurityIDSource = "SecurityIDSource";
const char * const FixIOIID = "IOIID";
const char * const FixIOIQltyInd = "IOIQltyInd";
const char * const FixIOIRefID = "IOIRefID";
const char * const FixIOIQty = "IOIQty";
const char * const FixIOITransType = "IOITransType";
const char * const FixLastCapacity = "LastCapacity";
const char * const FixLastMkt = "LastMkt";
const char * const FixLastPx = "LastPx";
const char * const FixLastQty = "LastQty";
const char * const FixNoLinesOfText = "NoLinesOfText";
const char * const FixMsgSeqNum = "MsgSeqNum";
const char * const FixMsgType = "MsgType";
const char * const FixNewSeqNo = "NewSeqNo";
const char * const FixOrderID = "OrderID";
const char * const FixOrderQty = "OrderQty";
const char * const FixOrdStatus = "OrdStatus";
const char * const FixOrdType = "OrdType";
const char * const FixOrigClOrdID = "OrigClOrdID";
const char * const FixOrigTime = "OrigTime";
const char * const FixPossDupFlag = "PossDupFlag";
const char * const FixPrice = "Price";
const char * const FixRefSeqNum = "RefSeqNum";
const char * const FixSecurityID = "SecurityID";
const char * const FixSenderCompID = "SenderCompID";
const char * const FixSenderSubID = "SenderSubID";
const char * const FixSendingTime = "SendingTime";
const char * const FixQuantity = "Quantity";
const char * const FixSide = "Side";
const char * const FixSymbol = "Symbol";
const char * const FixTargetCompID = "TargetCompID";
const char * const FixTargetSubID = "TargetSubID";
const char * const FixText = "Text";
const char * const FixTimeInForce = "TimeInForce";
const char * const FixTransactTime = "TransactTime";
const char * const FixUrgency = "Urgency";
const char * const FixValidUntilTime = "ValidUntilTime";
const char * const FixSettlType = "SettlType";
const char * const FixSettlDate = "SettlDate";
const char * const FixSymbolSfx = "SymbolSfx";
const char * const FixListID = "ListID";
const char * const FixListSeqNo = "ListSeqNo";
const char * const FixTotNoOrders = "TotNoOrders";
const char * const FixListExecInst = "ListExecInst";
const char * const FixAllocID = "AllocID";
const char * const FixAllocTransType = "AllocTransType";
const char * const FixRefAllocID = "RefAllocID";
const char * const FixNoOrders = "NoOrders";
const char * const FixAvgPxPrecision = "AvgPxPrecision";
const char * const FixTradeDate = "TradeDate";
const char * const FixPositionEffect = "PositionEffect";
const char * const FixNoAllocs = "NoAllocs";
const char * const FixAllocAccount = "AllocAccount";
const char * const FixAllocQty = "AllocQty";
const char * const FixProcessCode = "ProcessCode";
const char * const FixNoRpts = "NoRpts";
const char * const FixRptSeq = "RptSeq";
const char * const FixCxlQty = "CxlQty";
const char * const FixNoDlvyInst = "NoDlvyInst";
const char * const FixAllocStatus = "AllocStatus";
const char * const FixAllocRejCode = "AllocRejCode";
const char * const FixSignature = "Signature";
const char * const FixSecureDataLen = "SecureDataLen";
const char * const FixSecureData = "SecureData";
const char * const FixSignatureLength = "SignatureLength";
const char * const FixEmailType = "EmailType";
const char * const FixRawDataLength = "RawDataLength";
const char * const FixRawData = "RawData";
const char * const FixPossResend = "PossResend";
const char * const FixEncryptMethod = "EncryptMethod";
const char * const FixStopPx = "StopPx";
const char * const FixExDestination = "ExDestination";
const char * const FixCxlRejReason = "CxlRejReason";
const char * const FixOrdRejReason = "OrdRejReason";
const char * const FixIOIQualifier = "IOIQualifier";
const char * const FixIssuer = "Issuer";
const char * const FixSecurityDesc = "SecurityDesc";
const char * const FixHeartBtInt = "HeartBtInt";
const char * const FixMinQty = "MinQty";
const char * const FixMaxFloor = "MaxFloor";
const char * const FixTestReqID = "TestReqID";
const char * const FixReportToExch = "ReportToExch";
const char * const FixLocateReqd = "LocateReqd";
const char * const FixOnBehalfOfCompID = "OnBehalfOfCompID";
const char * const FixOnBehalfOfSubID = "OnBehalfOfSubID";
const char * const FixQuoteID = "QuoteID";
const char * const FixNetMoney = "NetMoney";
const char * const FixSettlCurrAmt = "SettlCurrAmt";
const char * const FixSettlCurrency = "SettlCurrency";
const char * const FixForexReq = "ForexReq";
const char * const FixOrigSendingTime = "OrigSendingTime";
const char * const FixGapFillFlag = "GapFillFlag";
const char * const FixNoExecs = "NoExecs";
const char * const FixExpireTime = "ExpireTime";
const char * const FixDKReason = "DKReason";
const char * const FixDeliverToCompID = "DeliverToCompID";
const char * const FixDeliverToSubID = "DeliverToSubID";
const char * const FixIOINaturalFlag = "IOINaturalFlag";
const char * const FixQuoteReqID = "QuoteReqID";
const char * const FixBidPx = "BidPx";
const char * const FixOfferPx = "OfferPx";
const char * const FixBidSize = "BidSize";
const char * const FixOfferSize = "OfferSize";
const char * const FixNoMiscFees = "NoMiscFees";
const char * const FixMiscFeeAmt = "MiscFeeAmt";
const char * const FixMiscFeeCurr = "MiscFeeCurr";
const char * const FixMiscFeeType = "MiscFeeType";
const char * const FixPrevClosePx = "PrevClosePx";
const char * const FixResetSeqNumFlag = "ResetSeqNumFlag";
const char * const FixSenderLocationID = "SenderLocationID";
const char * const FixTargetLocationID = "TargetLocationID";
const char * const FixOnBehalfOfLocationID = "OnBehalfOfLocationID";
const char * const FixDeliverToLocationID = "DeliverToLocationID";
const char * const FixNoRelatedSym = "NoRelatedSym";
const char * const FixSubject = "Subject";
const char * const FixHeadline = "Headline";
const char * const FixURLLink = "URLLink";
const char * const FixExecType = "ExecType";
const char * const FixLeavesQty = "LeavesQty";
const char * const FixCashOrderQty = "CashOrderQty";
const char * const FixAllocAvgPx = "AllocAvgPx";
const char * const FixAllocNetMoney = "AllocNetMoney";
const char * const FixSettlCurrFxRate = "SettlCurrFxRate";
const char * const FixSettlCurrFxRateCalc = "SettlCurrFxRateCalc";
const char * const FixNumDaysInterest = "NumDaysInterest";
const char * const FixAccruedInterestRate = "AccruedInterestRate";
const char * const FixAccruedInterestAmt = "AccruedInterestAmt";
const char * const FixSettlInstMode = "SettlInstMode";
const char * const FixAllocText = "AllocText";
const char * const FixSettlInstID = "SettlInstID";
const char * const FixSettlInstTransType = "SettlInstTransType";
const char * const FixEmailThreadID = "EmailThreadID";
const char * const FixSettlInstSource = "SettlInstSource";
const char * const FixSecurityType = "SecurityType";
const char * const FixEffectiveTime = "EffectiveTime";
const char * const FixStandInstDbType = "StandInstDbType";
const char * const FixStandInstDbName = "StandInstDbName";
const char * const FixStandInstDbID = "StandInstDbID";
const char * const FixSettlDeliveryType = "SettlDeliveryType";
const char * const FixBidSpotRate = "BidSpotRate";
const char * const FixBidForwardPoints = "BidForwardPoints";
const char * const FixOfferSpotRate = "OfferSpotRate";
const char * const FixOfferForwardPoints = "OfferForwardPoints";
const char * const FixOrderQty2 = "OrderQty2";
const char * const FixSettlDate2 = "SettlDate2";
const char * const FixLastSpotRate = "LastSpotRate";
const char * const FixLastForwardPoints = "LastForwardPoints";
const char * const FixAllocLinkID = "AllocLinkID";
const char * const FixAllocLinkType = "AllocLinkType";
const char * const FixSecondaryOrderID = "SecondaryOrderID";
const char * const FixNoIOIQualifiers = "NoIOIQualifiers";
const char * const FixMaturityMonthYear = "MaturityMonthYear";
const char * const FixPutOrCall = "PutOrCall";
const char * const FixStrikePrice = "StrikePrice";
const char * const FixCoveredOrUncovered = "CoveredOrUncovered";
const char * const FixOptAttribute = "OptAttribute";
const char * const FixSecurityExchange = "SecurityExchange";
const char * const FixNotifyBrokerOfCredit = "NotifyBrokerOfCredit";
const char * const FixAllocHandlInst = "AllocHandlInst";
const char * const FixMaxShow = "MaxShow";
const char * const FixPegOffsetValue = "PegOffsetValue";
const char * const FixXmlDataLen = "XmlDataLen";
const char * const FixXmlData = "XmlData";
const char * const FixSettlInstRefID = "SettlInstRefID";
const char * const FixNoRoutingIDs = "NoRoutingIDs";
const char * const FixRoutingType = "RoutingType";
const char * const FixRoutingID = "RoutingID";
const char * const FixSpread = "Spread";
const char * const FixBenchmarkCurveCurrency = "BenchmarkCurveCurrency";
const char * const FixBenchmarkCurveName = "BenchmarkCurveName";
const char * const FixBenchmarkCurvePoint = "BenchmarkCurvePoint";
const char * const FixCouponRate = "CouponRate";
const char * const FixCouponPaymentDate = "CouponPaymentDate";
const char * const FixIssueDate = "IssueDate";
const char * const FixRepurchaseTerm = "RepurchaseTerm";
const char * const FixRepurchaseRate = "RepurchaseRate";
const char * const FixFactor = "Factor";
const char * const FixTradeOriginationDate = "TradeOriginationDate";
const char * const FixExDate = "ExDate";
const char * const FixContractMultiplier = "ContractMultiplier";
const char * const FixNoStipulations = "NoStipulations";
const char * const FixStipulationType = "StipulationType";
const char * const FixStipulationValue = "StipulationValue";
const char * const FixYieldType = "YieldType";
const char * const FixYield = "Yield";
const char * const FixTotalTakedown = "TotalTakedown";
const char * const FixConcession = "Concession";
const char * const FixRepoCollateralSecurityType = "RepoCollateralSecurityType";
const char * const FixRedemptionDate = "RedemptionDate";
const char * const FixUnderlyingCouponPaymentDate = "UnderlyingCouponPaymentDate";
const char * const FixUnderlyingIssueDate = "UnderlyingIssueDate";
const char * const FixUnderlyingRepoCollateralSecurityType = "UnderlyingRepoCollateralSecurityType";
const char * const FixUnderlyingRepurchaseTerm = "UnderlyingRepurchaseTerm";
const char * const FixUnderlyingRepurchaseRate = "UnderlyingRepurchaseRate";
const char * const FixUnderlyingFactor = "UnderlyingFactor";
const char * const FixUnderlyingRedemptionDate = "UnderlyingRedemptionDate";
const char * const FixLegCouponPaymentDate = "LegCouponPaymentDate";
const char * const FixLegIssueDate = "LegIssueDate";
const char * const FixLegRepoCollateralSecurityType = "LegRepoCollateralSecurityType";
const char * const FixLegRepurchaseTerm = "LegRepurchaseTerm";
const char * const FixLegRepurchaseRate = "LegRepurchaseRate";
const char * const FixLegFactor = "LegFactor";
const char * const FixLegRedemptionDate = "LegRedemptionDate";
const char * const FixCreditRating = "CreditRating";
const char * const FixUnderlyingCreditRating = "UnderlyingCreditRating";
const char * const FixLegCreditRating = "LegCreditRating";
const char * const FixTradedFlatSwitch = "TradedFlatSwitch";
const char * const FixBasisFeatureDate = "BasisFeatureDate";
const char * const FixBasisFeaturePrice = "BasisFeaturePrice";
const char * const FixMDReqID = "MDReqID";
const char * const FixSubscriptionRequestType = "SubscriptionRequestType";
const char * const FixMarketDepth = "MarketDepth";
const char * const FixMDUpdateType = "MDUpdateType";
const char * const FixAggregatedBook = "AggregatedBook";
const char * const FixNoMDEntryTypes = "NoMDEntryTypes";
const char * const FixNoMDEntries = "NoMDEntries";
const char * const FixMDEntryType = "MDEntryType";
const char * const FixMDEntryPx = "MDEntryPx";
const char * const FixMDEntrySize = "MDEntrySize";
const char * const FixMDEntryDate = "MDEntryDate";
const char * const FixMDEntryTime = "MDEntryTime";
const char * const FixTickDirection = "TickDirection";
const char * const FixMDMkt = "MDMkt";
const char * const FixQuoteCondition = "QuoteCondition";
const char * const FixTradeCondition = "TradeCondition";
const char * const FixMDEntryID = "MDEntryID";
const char * const FixMDUpdateAction = "MDUpdateAction";
const char * const FixMDEntryRefID = "MDEntryRefID";
const char * const FixMDReqRejReason = "MDReqRejReason";
const char * const FixMDEntryOriginator = "MDEntryOriginator";
const char * const FixLocationID = "LocationID";
const char * const FixDeskID = "DeskID";
const char * const FixDeleteReason = "DeleteReason";
const char * const FixOpenCloseSettlFlag = "OpenCloseSettlFlag";
const char * const FixSellerDays = "SellerDays";
const char * const FixMDEntryBuyer = "MDEntryBuyer";
const char * const FixMDEntrySeller = "MDEntrySeller";
const char * const FixMDEntryPositionNo = "MDEntryPositionNo";
const char * const FixFinancialStatus = "FinancialStatus";
const char * const FixCorporateAction = "CorporateAction";
const char * const FixDefBidSize = "DefBidSize";
const char * const FixDefOfferSize = "DefOfferSize";
const char * const FixNoQuoteEntries = "NoQuoteEntries";
const char * const FixNoQuoteSets = "NoQuoteSets";
const char * const FixQuoteStatus = "QuoteStatus";
const char * const FixQuoteCancelType = "QuoteCancelType";
const char * const FixQuoteEntryID = "QuoteEntryID";
const char * const FixQuoteRejectReason = "QuoteRejectReason";
const char * const FixQuoteResponseLevel = "QuoteResponseLevel";
const char * const FixQuoteSetID = "QuoteSetID";
const char * const FixQuoteRequestType = "QuoteRequestType";
const char * const FixTotNoQuoteEntries = "TotNoQuoteEntries";
const char * const FixUnderlyingSecurityIDSource = "UnderlyingSecurityIDSource";
const char * const FixUnderlyingIssuer = "UnderlyingIssuer";
const char * const FixUnderlyingSecurityDesc = "UnderlyingSecurityDesc";
const char * const FixUnderlyingSecurityExchange = "UnderlyingSecurityExchange";
const char * const FixUnderlyingSecurityID = "UnderlyingSecurityID";
const char * const FixUnderlyingSecurityType = "UnderlyingSecurityType";
const char * const FixUnderlyingSymbol = "UnderlyingSymbol";
const char * const FixUnderlyingSymbolSfx = "UnderlyingSymbolSfx";
const char * const FixUnderlyingMaturityMonthYear = "UnderlyingMaturityMonthYear";
const char * const FixUnderlyingPutOrCall = "UnderlyingPutOrCall";
const char * const FixUnderlyingStrikePrice = "UnderlyingStrikePrice";
const char * const FixUnderlyingOptAttribute = "UnderlyingOptAttribute";
const char * const FixUnderlyingCurrency = "UnderlyingCurrency";
const char * const FixSecurityReqID = "SecurityReqID";
const char * const FixSecurityRequestType = "SecurityRequestType";
const char * const FixSecurityResponseID = "SecurityResponseID";
const char * const FixSecurityResponseType = "SecurityResponseType";
const char * const FixSecurityStatusReqID = "SecurityStatusReqID";
const char * const FixUnsolicitedIndicator = "UnsolicitedIndicator";
const char * const FixSecurityTradingStatus = "SecurityTradingStatus";
const char * const FixHaltReasonChar = "HaltReasonChar";
const char * const FixInViewOfCommon = "InViewOfCommon";
const char * const FixDueToRelated = "DueToRelated";
const char * const FixBuyVolume = "BuyVolume";
const char * const FixSellVolume = "SellVolume";
const char * const FixHighPx = "HighPx";
const char * const FixLowPx = "LowPx";
const char * const FixAdjustment = "Adjustment";
const char * const FixTradSesReqID = "TradSesReqID";
const char * const FixTradingSessionID = "TradingSessionID";
const char * const FixContraTrader = "ContraTrader";
const char * const FixTradSesMethod = "TradSesMethod";
const char * const FixTradSesMode = "TradSesMode";
const char * const FixTradSesStatus = "TradSesStatus";
const char * const FixTradSesStartTime = "TradSesStartTime";
const char * const FixTradSesOpenTime = "TradSesOpenTime";
const char * const FixTradSesPreCloseTime = "TradSesPreCloseTime";
const char * const FixTradSesCloseTime = "TradSesCloseTime";
const char * const FixTradSesEndTime = "TradSesEndTime";
const char * const FixNumberOfOrders = "NumberOfOrders";
const char * const FixMessageEncoding = "MessageEncoding";
const char * const FixEncodedIssuerLen = "EncodedIssuerLen";
const char * const FixEncodedIssuer = "EncodedIssuer";
const char * const FixEncodedSecurityDescLen = "EncodedSecurityDescLen";
const char * const FixEncodedSecurityDesc = "EncodedSecurityDesc";
const char * const FixEncodedListExecInstLen = "EncodedListExecInstLen";
const char * const FixEncodedListExecInst = "EncodedListExecInst";
const char * const FixEncodedTextLen = "EncodedTextLen";
const char * const FixEncodedText = "EncodedText";
const char * const FixEncodedSubjectLen = "EncodedSubjectLen";
const char * const FixEncodedSubject = "EncodedSubject";
const char * const FixEncodedHeadlineLen = "EncodedHeadlineLen";
const char * const FixEncodedHeadline = "EncodedHeadline";
const char * const FixEncodedAllocTextLen = "EncodedAllocTextLen";
const char * const FixEncodedAllocText = "EncodedAllocText";
const char * const FixEncodedUnderlyingIssuerLen = "EncodedUnderlyingIssuerLen";
const char * const FixEncodedUnderlyingIssuer = "EncodedUnderlyingIssuer";
const char * const FixEncodedUnderlyingSecurityDescLen = "EncodedUnderlyingSecurityDescLen";
const char * const FixEncodedUnderlyingSecurityDesc = "EncodedUnderlyingSecurityDesc";
const char * const FixAllocPrice = "AllocPrice";
const char * const FixQuoteSetValidUntilTime = "QuoteSetValidUntilTime";
const char * const FixQuoteEntryRejectReason = "QuoteEntryRejectReason";
const char * const FixLastMsgSeqNumProcessed = "LastMsgSeqNumProcessed";
const char * const FixRefTagID = "RefTagID";
const char * const FixRefMsgType = "RefMsgType";
const char * const FixSessionRejectReason = "SessionRejectReason";
const char * const FixBidRequestTransType = "BidRequestTransType";
const char * const FixContraBroker = "ContraBroker";
const char * const FixComplianceID = "ComplianceID";
const char * const FixSolicitedFlag = "SolicitedFlag";
const char * const FixExecRestatementReason = "ExecRestatementReason";
const char * const FixBusinessRejectRefID = "BusinessRejectRefID";
const char * const FixBusinessRejectReason = "BusinessRejectReason";
const char * const FixGrossTradeAmt = "GrossTradeAmt";
const char * const FixNoContraBrokers = "NoContraBrokers";
const char * const FixMaxMessageSize = "MaxMessageSize";
const char * const FixNoMsgTypes = "NoMsgTypes";
const char * const FixMsgDirection = "MsgDirection";
const char * const FixNoTradingSessions = "NoTradingSessions";
const char * const FixTotalVolumeTraded = "TotalVolumeTraded";
const char * const FixDiscretionInst = "DiscretionInst";
const char * const FixDiscretionOffsetValue = "DiscretionOffsetValue";
const char * const FixBidID = "BidID";
const char * const FixClientBidID = "ClientBidID";
const char * const FixListName = "ListName";
const char * const FixTotNoRelatedSym = "TotNoRelatedSym";
const char * const FixBidType = "BidType";
const char * const FixNumTickets = "NumTickets";
const char * const FixSideValue1 = "SideValue1";
const char * const FixSideValue2 = "SideValue2";
const char * const FixNoBidDescriptors = "NoBidDescriptors";
const char * const FixBidDescriptorType = "BidDescriptorType";
const char * const FixBidDescriptor = "BidDescriptor";
const char * const FixSideValueInd = "SideValueInd";
const char * const FixLiquidityPctLow = "LiquidityPctLow";
const char * const FixLiquidityPctHigh = "LiquidityPctHigh";
const char * const FixLiquidityValue = "LiquidityValue";
const char * const FixEFPTrackingError = "EFPTrackingError";
const char * const FixFairValue = "FairValue";
const char * const FixOutsideIndexPct = "OutsideIndexPct";
const char * const FixValueOfFutures = "ValueOfFutures";
const char * const FixLiquidityIndType = "LiquidityIndType";
const char * const FixWtAverageLiquidity = "WtAverageLiquidity";
const char * const FixExchangeForPhysical = "ExchangeForPhysical";
const char * const FixOutMainCntryUIndex = "OutMainCntryUIndex";
const char * const FixCrossPercent = "CrossPercent";
const char * const FixProgRptReqs = "ProgRptReqs";
const char * const FixProgPeriodInterval = "ProgPeriodInterval";
const char * const FixIncTaxInd = "IncTaxInd";
const char * const FixNumBidders = "NumBidders";
const char * const FixBidTradeType = "BidTradeType";
const char * const FixBasisPxType = "BasisPxType";
const char * const FixNoBidComponents = "NoBidComponents";
const char * const FixCountry = "Country";
const char * const FixTotNoStrikes = "TotNoStrikes";
const char * const FixPriceType = "PriceType";
const char * const FixDayOrderQty = "DayOrderQty";
const char * const FixDayCumQty = "DayCumQty";
const char * const FixDayAvgPx = "DayAvgPx";
const char * const FixGTBookingInst = "GTBookingInst";
const char * const FixNoStrikes = "NoStrikes";
const char * const FixListStatusType = "ListStatusType";
const char * const FixNetGrossInd = "NetGrossInd";
const char * const FixListOrderStatus = "ListOrderStatus";
const char * const FixExpireDate = "ExpireDate";
const char * const FixListExecInstType = "ListExecInstType";
const char * const FixCxlRejResponseTo = "CxlRejResponseTo";
const char * const FixUnderlyingCouponRate = "UnderlyingCouponRate";
const char * const FixUnderlyingContractMultiplier = "UnderlyingContractMultiplier";
const char * const FixContraTradeQty = "ContraTradeQty";
const char * const FixContraTradeTime = "ContraTradeTime";
const char * const FixLiquidityNumSecurities = "LiquidityNumSecurities";
const char * const FixMultiLegReportingType = "MultiLegReportingType";
const char * const FixStrikeTime = "StrikeTime";
const char * const FixListStatusText = "ListStatusText";
const char * const FixEncodedListStatusTextLen = "EncodedListStatusTextLen";
const char * const FixEncodedListStatusText = "EncodedListStatusText";
const char * const FixPartyIDSource = "PartyIDSource";
const char * const FixPartyID = "PartyID";
const char * const FixNetChgPrevDay = "NetChgPrevDay";
const char * const FixPartyRole = "PartyRole";
const char * const FixNoPartyIDs = "NoPartyIDs";
const char * const FixNoSecurityAltID = "NoSecurityAltID";
const char * const FixSecurityAltID = "SecurityAltID";
const char * const FixSecurityAltIDSource = "SecurityAltIDSource";
const char * const FixNoUnderlyingSecurityAltID = "NoUnderlyingSecurityAltID";
const char * const FixUnderlyingSecurityAltID = "UnderlyingSecurityAltID";
const char * const FixUnderlyingSecurityAltIDSource = "UnderlyingSecurityAltIDSource";
const char * const FixProduct = "Product";
const char * const FixCFICode = "CFICode";
const char * const FixUnderlyingProduct = "UnderlyingProduct";
const char * const FixUnderlyingCFICode = "UnderlyingCFICode";
const char * const FixTestMessageIndicator = "TestMessageIndicator";
const char * const FixBookingRefID = "BookingRefID";
const char * const FixIndividualAllocID = "IndividualAllocID";
const char * const FixRoundingDirection = "RoundingDirection";
const char * const FixRoundingModulus = "RoundingModulus";
const char * const FixCountryOfIssue = "CountryOfIssue";
const char * const FixStateOrProvinceOfIssue = "StateOrProvinceOfIssue";
const char * const FixLocaleOfIssue = "LocaleOfIssue";
const char * const FixNoRegistDtls = "NoRegistDtls";
const char * const FixMailingDtls = "MailingDtls";
const char * const FixInvestorCountryOfResidence = "InvestorCountryOfResidence";
const char * const FixPaymentRef = "PaymentRef";
const char * const FixDistribPaymentMethod = "DistribPaymentMethod";
const char * const FixCashDistribCurr = "CashDistribCurr";
const char * const FixCommCurrency = "CommCurrency";
const char * const FixCancellationRights = "CancellationRights";
const char * const FixMoneyLaunderingStatus = "MoneyLaunderingStatus";
const char * const FixMailingInst = "MailingInst";
const char * const FixTransBkdTime = "TransBkdTime";
const char * const FixExecPriceType = "ExecPriceType";
const char * const FixExecPriceAdjustment = "ExecPriceAdjustment";
const char * const FixDateOfBirth = "DateOfBirth";
const char * const FixTradeReportTransType = "TradeReportTransType";
const char * const FixCardHolderName = "CardHolderName";
const char * const FixCardNumber = "CardNumber";
const char * const FixCardExpDate = "CardExpDate";
const char * const FixCardIssNum = "CardIssNum";
const char * const FixPaymentMethod = "PaymentMethod";
const char * const FixRegistAcctType = "RegistAcctType";
const char * const FixDesignation = "Designation";
const char * const FixTaxAdvantageType = "TaxAdvantageType";
const char * const FixRegistRejReasonText = "RegistRejReasonText";
const char * const FixFundRenewWaiv = "FundRenewWaiv";
const char * const FixCashDistribAgentName = "CashDistribAgentName";
const char * const FixCashDistribAgentCode = "CashDistribAgentCode";
const char * const FixCashDistribAgentAcctNumber = "CashDistribAgentAcctNumber";
const char * const FixCashDistribPayRef = "CashDistribPayRef";
const char * const FixCashDistribAgentAcctName = "CashDistribAgentAcctName";
const char * const FixCardStartDate = "CardStartDate";
const char * const FixPaymentDate = "PaymentDate";
const char * const FixPaymentRemitterID = "PaymentRemitterID";
const char * const FixRegistStatus = "RegistStatus";
const char * const FixRegistRejReasonCode = "RegistRejReasonCode";
const char * const FixRegistRefID = "RegistRefID";
const char * const FixRegistDtls = "RegistDtls";
const char * const FixNoDistribInsts = "NoDistribInsts";
const char * const FixRegistEmail = "RegistEmail";
const char * const FixDistribPercentage = "DistribPercentage";
const char * const FixRegistID = "RegistID";
const char * const FixRegistTransType = "RegistTransType";
const char * const FixExecValuationPoint = "ExecValuationPoint";
const char * const FixOrderPercent = "OrderPercent";
const char * const FixOwnershipType = "OwnershipType";
const char * const FixNoContAmts = "NoContAmts";
const char * const FixContAmtType = "ContAmtType";
const char * const FixContAmtValue = "ContAmtValue";
const char * const FixContAmtCurr = "ContAmtCurr";
const char * const FixOwnerType = "OwnerType";
const char * const FixPartySubID = "PartySubID";
const char * const FixNestedPartyID = "NestedPartyID";
const char * const FixNestedPartyIDSource = "NestedPartyIDSource";
const char * const FixSecondaryClOrdID = "SecondaryClOrdID";
const char * const FixSecondaryExecID = "SecondaryExecID";
const char * const FixOrderCapacity = "OrderCapacity";
const char * const FixOrderRestrictions = "OrderRestrictions";
const char * const FixMassCancelRequestType = "MassCancelRequestType";
const char * const FixMassCancelResponse = "MassCancelResponse";
const char * const FixMassCancelRejectReason = "MassCancelRejectReason";
const char * const FixTotalAffectedOrders = "TotalAffectedOrders";
const char * const FixNoAffectedOrders = "NoAffectedOrders";
const char * const FixAffectedOrderID = "AffectedOrderID";
const char * const FixAffectedSecondaryOrderID = "AffectedSecondaryOrderID";
const char * const FixQuoteType = "QuoteType";
const char * const FixNestedPartyRole = "NestedPartyRole";
const char * const FixNoNestedPartyIDs = "NoNestedPartyIDs";
const char * const FixTotalAccruedInterestAmt = "TotalAccruedInterestAmt";
const char * const FixMaturityDate = "MaturityDate";
const char * const FixUnderlyingMaturityDate = "UnderlyingMaturityDate";
const char * const FixInstrRegistry = "InstrRegistry";
const char * const FixCashMargin = "CashMargin";
const char * const FixNestedPartySubID = "NestedPartySubID";
const char * const FixScope = "Scope";
const char * const FixMDImplicitDelete = "MDImplicitDelete";
const char * const FixCrossID = "CrossID";
const char * const FixCrossType = "CrossType";
const char * const FixCrossPrioritization = "CrossPrioritization";
const char * const FixOrigCrossID = "OrigCrossID";
const char * const FixNoSides = "NoSides";
const char * const FixUsername = "Username";
const char * const FixPassword = "Password";
const char * const FixNoLegs = "NoLegs";
const char * const FixLegCurrency = "LegCurrency";
const char * const FixTotNoSecurityTypes = "TotNoSecurityTypes";
const char * const FixNoSecurityTypes = "NoSecurityTypes";
const char * const FixSecurityListRequestType = "SecurityListRequestType";
const char * const FixSecurityRequestResult = "SecurityRequestResult";
const char * const FixRoundLot = "RoundLot";
const char * const FixMinTradeVol = "MinTradeVol";
const char * const FixMultiLegRptTypeReq = "MultiLegRptTypeReq";
const char * const FixLegPositionEffect = "LegPositionEffect";
const char * const FixLegCoveredOrUncovered = "LegCoveredOrUncovered";
const char * const FixLegPrice = "LegPrice";
const char * const FixTradSesStatusRejReason = "TradSesStatusRejReason";
const char * const FixTradeRequestID = "TradeRequestID";
const char * const FixTradeRequestType = "TradeRequestType";
const char * const FixPreviouslyReported = "PreviouslyReported";
const char * const FixTradeReportID = "TradeReportID";
const char * const FixTradeReportRefID = "TradeReportRefID";
const char * const FixMatchStatus = "MatchStatus";
const char * const FixMatchType = "MatchType";
const char * const FixOddLot = "OddLot";
const char * const FixNoClearingInstructions = "NoClearingInstructions";
const char * const FixClearingInstruction = "ClearingInstruction";
const char * const FixTradeInputSource = "TradeInputSource";
const char * const FixTradeInputDevice = "TradeInputDevice";
const char * const FixNoDates = "NoDates";
const char * const FixAccountType = "AccountType";
const char * const FixCustOrderCapacity = "CustOrderCapacity";
const char * const FixClOrdLinkID = "ClOrdLinkID";
const char * const FixMassStatusReqID = "MassStatusReqID";
const char * const FixMassStatusReqType = "MassStatusReqType";
const char * const FixOrigOrdModTime = "OrigOrdModTime";
const char * const FixLegSettlType = "LegSettlType";
const char * const FixLegSettlDate = "LegSettlDate";
const char * const FixDayBookingInst = "DayBookingInst";
const char * const FixBookingUnit = "BookingUnit";
const char * const FixPreallocMethod = "PreallocMethod";
const char * const FixUnderlyingCountryOfIssue = "UnderlyingCountryOfIssue";
const char * const FixUnderlyingStateOrProvinceOfIssue = "UnderlyingStateOrProvinceOfIssue";
const char * const FixUnderlyingLocaleOfIssue = "UnderlyingLocaleOfIssue";
const char * const FixUnderlyingInstrRegistry = "UnderlyingInstrRegistry";
const char * const FixLegCountryOfIssue = "LegCountryOfIssue";
const char * const FixLegStateOrProvinceOfIssue = "LegStateOrProvinceOfIssue";
const char * const FixLegLocaleOfIssue = "LegLocaleOfIssue";
const char * const FixLegInstrRegistry = "LegInstrRegistry";
const char * const FixLegSymbol = "LegSymbol";
const char * const FixLegSymbolSfx = "LegSymbolSfx";
const char * const FixLegSecurityID = "LegSecurityID";
const char * const FixLegSecurityIDSource = "LegSecurityIDSource";
const char * const FixNoLegSecurityAltID = "NoLegSecurityAltID";
const char * const FixLegSecurityAltID = "LegSecurityAltID";
const char * const FixLegSecurityAltIDSource = "LegSecurityAltIDSource";
const char * const FixLegProduct = "LegProduct";
const char * const FixLegCFICode = "LegCFICode";
const char * const FixLegSecurityType = "LegSecurityType";
const char * const FixLegMaturityMonthYear = "LegMaturityMonthYear";
const char * const FixLegMaturityDate = "LegMaturityDate";
const char * const FixLegStrikePrice = "LegStrikePrice";
const char * const FixLegOptAttribute = "LegOptAttribute";
const char * const FixLegContractMultiplier = "LegContractMultiplier";
const char * const FixLegCouponRate = "LegCouponRate";
const char * const FixLegSecurityExchange = "LegSecurityExchange";
const char * const FixLegIssuer = "LegIssuer";
const char * const FixEncodedLegIssuerLen = "EncodedLegIssuerLen";
const char * const FixEncodedLegIssuer = "EncodedLegIssuer";
const char * const FixLegSecurityDesc = "LegSecurityDesc";
const char * const FixEncodedLegSecurityDescLen = "EncodedLegSecurityDescLen";
const char * const FixEncodedLegSecurityDesc = "EncodedLegSecurityDesc";
const char * const FixLegRatioQty = "LegRatioQty";
const char * const FixLegSide = "LegSide";
const char * const FixTradingSessionSubID = "TradingSessionSubID";
const char * const FixAllocType = "AllocType";
const char * const FixNoHops = "NoHops";
const char * const FixHopCompID = "HopCompID";
const char * const FixHopSendingTime = "HopSendingTime";
const char * const FixHopRefID = "HopRefID";
const char * const FixMidPx = "MidPx";
const char * const FixBidYield = "BidYield";
const char * const FixMidYield = "MidYield";
const char * const FixOfferYield = "OfferYield";
const char * const FixClearingFeeIndicator = "ClearingFeeIndicator";
const char * const FixWorkingIndicator = "WorkingIndicator";
const char * const FixLegLastPx = "LegLastPx";
const char * const FixPriorityIndicator = "PriorityIndicator";
const char * const FixPriceImprovement = "PriceImprovement";
const char * const FixPrice2 = "Price2";
const char * const FixLastForwardPoints2 = "LastForwardPoints2";
const char * const FixBidForwardPoints2 = "BidForwardPoints2";
const char * const FixOfferForwardPoints2 = "OfferForwardPoints2";
const char * const FixRFQReqID = "RFQReqID";
const char * const FixMktBidPx = "MktBidPx";
const char * const FixMktOfferPx = "MktOfferPx";
const char * const FixMinBidSize = "MinBidSize";
const char * const FixMinOfferSize = "MinOfferSize";
const char * const FixQuoteStatusReqID = "QuoteStatusReqID";
const char * const FixLegalConfirm = "LegalConfirm";
const char * const FixUnderlyingLastPx = "UnderlyingLastPx";
const char * const FixUnderlyingLastQty = "UnderlyingLastQty";
const char * const FixLegRefID = "LegRefID";
const char * const FixContraLegRefID = "ContraLegRefID";
const char * const FixSettlCurrBidFxRate = "SettlCurrBidFxRate";
const char * const FixSettlCurrOfferFxRate = "SettlCurrOfferFxRate";
const char * const FixQuoteRequestRejectReason = "QuoteRequestRejectReason";
const char * const FixSideComplianceID = "SideComplianceID";
const char * const FixAcctIDSource = "AcctIDSource";
const char * const FixAllocAcctIDSource = "AllocAcctIDSource";
const char * const FixBenchmarkPrice = "BenchmarkPrice";
const char * const FixBenchmarkPriceType = "BenchmarkPriceType";
const char * const FixConfirmID = "ConfirmID";
const char * const FixConfirmStatus = "ConfirmStatus";
const char * const FixConfirmTransType = "ConfirmTransType";
const char * const FixContractSettlMonth = "ContractSettlMonth";
const char * const FixDeliveryForm = "DeliveryForm";
const char * const FixLastParPx = "LastParPx";
const char * const FixNoLegAllocs = "NoLegAllocs";
const char * const FixLegAllocAccount = "LegAllocAccount";
const char * const FixLegIndividualAllocID = "LegIndividualAllocID";
const char * const FixLegAllocQty = "LegAllocQty";
const char * const FixLegAllocAcctIDSource = "LegAllocAcctIDSource";
const char * const FixLegSettlCurrency = "LegSettlCurrency";
const char * const FixLegBenchmarkCurveCurrency = "LegBenchmarkCurveCurrency";
const char * const FixLegBenchmarkCurveName = "LegBenchmarkCurveName";
const char * const FixLegBenchmarkCurvePoint = "LegBenchmarkCurvePoint";
const char * const FixLegBenchmarkPrice = "LegBenchmarkPrice";
const char * const FixLegBenchmarkPriceType = "LegBenchmarkPriceType";
const char * const FixLegBidPx = "LegBidPx";
const char * const FixLegIOIQty = "LegIOIQty";
const char * const FixNoLegStipulations = "NoLegStipulations";
const char * const FixLegOfferPx = "LegOfferPx";
const char * const FixLegPriceType = "LegPriceType";
const char * const FixLegQty = "LegQty";
const char * const FixLegStipulationType = "LegStipulationType";
const char * const FixLegStipulationValue = "LegStipulationValue";
const char * const FixLegSwapType = "LegSwapType";
const char * const FixPool = "Pool";
const char * const FixQuotePriceType = "QuotePriceType";
const char * const FixQuoteRespID = "QuoteRespID";
const char * const FixQuoteRespType = "QuoteRespType";
const char * const FixQuoteQualifier = "QuoteQualifier";
const char * const FixYieldRedemptionDate = "YieldRedemptionDate";
const char * const FixYieldRedemptionPrice = "YieldRedemptionPrice";
const char * const FixYieldRedemptionPriceType = "YieldRedemptionPriceType";
const char * const FixBenchmarkSecurityID = "BenchmarkSecurityID";
const char * const FixReversalIndicator = "ReversalIndicator";
const char * const FixYieldCalcDate = "YieldCalcDate";
const char * const FixNoPositions = "NoPositions";
const char * const FixPosType = "PosType";
const char * const FixLongQty = "LongQty";
const char * const FixShortQty = "ShortQty";
const char * const FixPosQtyStatus = "PosQtyStatus";
const char * const FixPosAmtType = "PosAmtType";
const char * const FixPosAmt = "PosAmt";
const char * const FixPosTransType = "PosTransType";
const char * const FixPosReqID = "PosReqID";
const char * const FixNoUnderlyings = "NoUnderlyings";
const char * const FixPosMaintAction = "PosMaintAction";
const char * const FixOrigPosReqRefID = "OrigPosReqRefID";
const char * const FixPosMaintRptRefID = "PosMaintRptRefID";
const char * const FixClearingBusinessDate = "ClearingBusinessDate";
const char * const FixSettlSessID = "SettlSessID";
const char * const FixSettlSessSubID = "SettlSessSubID";
const char * const FixAdjustmentType = "AdjustmentType";
const char * const FixContraryInstructionIndicator = "ContraryInstructionIndicator";
const char * const FixPriorSpreadIndicator = "PriorSpreadIndicator";
const char * const FixPosMaintRptID = "PosMaintRptID";
const char * const FixPosMaintStatus = "PosMaintStatus";
const char * const FixPosMaintResult = "PosMaintResult";
const char * const FixPosReqType = "PosReqType";
const char * const FixResponseTransportType = "ResponseTransportType";
const char * const FixResponseDestination = "ResponseDestination";
const char * const FixTotalNumPosReports = "TotalNumPosReports";
const char * const FixPosReqResult = "PosReqResult";
const char * const FixPosReqStatus = "PosReqStatus";
const char * const FixSettlPrice = "SettlPrice";
const char * const FixSettlPriceType = "SettlPriceType";
const char * const FixUnderlyingSettlPrice = "UnderlyingSettlPrice";
const char * const FixUnderlyingSettlPriceType = "UnderlyingSettlPriceType";
const char * const FixPriorSettlPrice = "PriorSettlPrice";
const char * const FixNoQuoteQualifiers = "NoQuoteQualifiers";
const char * const FixAllocSettlCurrency = "AllocSettlCurrency";
const char * const FixAllocSettlCurrAmt = "AllocSettlCurrAmt";
const char * const FixInterestAtMaturity = "InterestAtMaturity";
const char * const FixLegDatedDate = "LegDatedDate";
const char * const FixLegPool = "LegPool";
const char * const FixAllocInterestAtMaturity = "AllocInterestAtMaturity";
const char * const FixAllocAccruedInterestAmt = "AllocAccruedInterestAmt";
const char * const FixDeliveryDate = "DeliveryDate";
const char * const FixAssignmentMethod = "AssignmentMethod";
const char * const FixAssignmentUnit = "AssignmentUnit";
const char * const FixOpenInterest = "OpenInterest";
const char * const FixExerciseMethod = "ExerciseMethod";
const char * const FixTotNumTradeReports = "TotNumTradeReports";
const char * const FixTradeRequestResult = "TradeRequestResult";
const char * const FixTradeRequestStatus = "TradeRequestStatus";
const char * const FixTradeReportRejectReason = "TradeReportRejectReason";
const char * const FixSideMultiLegReportingType = "SideMultiLegReportingType";
const char * const FixNoPosAmt = "NoPosAmt";
const char * const FixAutoAcceptIndicator = "AutoAcceptIndicator";
const char * const FixAllocReportID = "AllocReportID";
const char * const FixNoNested2PartyIDs = "NoNested2PartyIDs";
const char * const FixNested2PartyID = "Nested2PartyID";
const char * const FixNested2PartyIDSource = "Nested2PartyIDSource";
const char * const FixNested2PartyRole = "Nested2PartyRole";
const char * const FixNested2PartySubID = "Nested2PartySubID";
const char * const FixBenchmarkSecurityIDSource = "BenchmarkSecurityIDSource";
const char * const FixSecuritySubType = "SecuritySubType";
const char * const FixUnderlyingSecuritySubType = "UnderlyingSecuritySubType";
const char * const FixLegSecuritySubType = "LegSecuritySubType";
const char * const FixAllowableOneSidednessPct = "AllowableOneSidednessPct";
const char * const FixAllowableOneSidednessValue = "AllowableOneSidednessValue";
const char * const FixAllowableOneSidednessCurr = "AllowableOneSidednessCurr";
const char * const FixNoTrdRegTimestamps = "NoTrdRegTimestamps";
const char * const FixTrdRegTimestamp = "TrdRegTimestamp";
const char * const FixTrdRegTimestampType = "TrdRegTimestampType";
const char * const FixTrdRegTimestampOrigin = "TrdRegTimestampOrigin";
const char * const FixConfirmRefID = "ConfirmRefID";
const char * const FixConfirmType = "ConfirmType";
const char * const FixConfirmRejReason = "ConfirmRejReason";
const char * const FixBookingType = "BookingType";
const char * const FixIndividualAllocRejCode = "IndividualAllocRejCode";
const char * const FixSettlInstMsgID = "SettlInstMsgID";
const char * const FixNoSettlInst = "NoSettlInst";
const char * const FixLastUpdateTime = "LastUpdateTime";
const char * const FixAllocSettlInstType = "AllocSettlInstType";
const char * const FixNoSettlPartyIDs = "NoSettlPartyIDs";
const char * const FixSettlPartyID = "SettlPartyID";
const char * const FixSettlPartyIDSource = "SettlPartyIDSource";
const char * const FixSettlPartyRole = "SettlPartyRole";
const char * const FixSettlPartySubID = "SettlPartySubID";
const char * const FixSettlPartySubIDType = "SettlPartySubIDType";
const char * const FixDlvyInstType = "DlvyInstType";
const char * const FixTerminationType = "TerminationType";
const char * const FixNextExpectedMsgSeqNum = "NextExpectedMsgSeqNum";
const char * const FixOrdStatusReqID = "OrdStatusReqID";
const char * const FixSettlInstReqID = "SettlInstReqID";
const char * const FixSettlInstReqRejCode = "SettlInstReqRejCode";
const char * const FixSecondaryAllocID = "SecondaryAllocID";
const char * const FixAllocReportType = "AllocReportType";
const char * const FixAllocReportRefID = "AllocReportRefID";
const char * const FixAllocCancReplaceReason = "AllocCancReplaceReason";
const char * const FixCopyMsgIndicator = "CopyMsgIndicator";
const char * const FixAllocAccountType = "AllocAccountType";
const char * const FixOrderAvgPx = "OrderAvgPx";
const char * const FixOrderBookingQty = "OrderBookingQty";
const char * const FixNoSettlPartySubIDs = "NoSettlPartySubIDs";
const char * const FixNoPartySubIDs = "NoPartySubIDs";
const char * const FixPartySubIDType = "PartySubIDType";
const char * const FixNoNestedPartySubIDs = "NoNestedPartySubIDs";
const char * const FixNestedPartySubIDType = "NestedPartySubIDType";
const char * const FixNoNested2PartySubIDs = "NoNested2PartySubIDs";
const char * const FixNested2PartySubIDType = "Nested2PartySubIDType";
const char * const FixAllocIntermedReqType = "AllocIntermedReqType";
const char * const FixUnderlyingPx = "UnderlyingPx";
const char * const FixPriceDelta = "PriceDelta";
const char * const FixApplQueueMax = "ApplQueueMax";
const char * const FixApplQueueDepth = "ApplQueueDepth";
const char * const FixApplQueueResolution = "ApplQueueResolution";
const char * const FixApplQueueAction = "ApplQueueAction";
const char * const FixNoAltMDSource = "NoAltMDSource";
const char * const FixAltMDSourceID = "AltMDSourceID";
const char * const FixSecondaryTradeReportID = "SecondaryTradeReportID";
const char * const FixAvgPxIndicator = "AvgPxIndicator";
const char * const FixTradeLinkID = "TradeLinkID";
const char * const FixOrderInputDevice = "OrderInputDevice";
const char * const FixUnderlyingTradingSessionID = "UnderlyingTradingSessionID";
const char * const FixUnderlyingTradingSessionSubID = "UnderlyingTradingSessionSubID";
const char * const FixTradeLegRefID = "TradeLegRefID";
const char * const FixExchangeRule = "ExchangeRule";
const char * const FixTradeAllocIndicator = "TradeAllocIndicator";
const char * const FixExpirationCycle = "ExpirationCycle";
const char * const FixTrdType = "TrdType";
const char * const FixTrdSubType = "TrdSubType";
const char * const FixTransferReason = "TransferReason";
const char * const FixTotNumAssignmentReports = "TotNumAssignmentReports";
const char * const FixAsgnRptID = "AsgnRptID";
const char * const FixThresholdAmount = "ThresholdAmount";
const char * const FixPegMoveType = "PegMoveType";
const char * const FixPegOffsetType = "PegOffsetType";
const char * const FixPegLimitType = "PegLimitType";
const char * const FixPegRoundDirection = "PegRoundDirection";
const char * const FixPeggedPrice = "PeggedPrice";
const char * const FixPegScope = "PegScope";
const char * const FixDiscretionMoveType = "DiscretionMoveType";
const char * const FixDiscretionOffsetType = "DiscretionOffsetType";
const char * const FixDiscretionLimitType = "DiscretionLimitType";
const char * const FixDiscretionRoundDirection = "DiscretionRoundDirection";
const char * const FixDiscretionPrice = "DiscretionPrice";
const char * const FixDiscretionScope = "DiscretionScope";
const char * const FixTargetStrategy = "TargetStrategy";
const char * const FixTargetStrategyParameters = "TargetStrategyParameters";
const char * const FixParticipationRate = "ParticipationRate";
const char * const FixTargetStrategyPerformance = "TargetStrategyPerformance";
const char * const FixLastLiquidityInd = "LastLiquidityInd";
const char * const FixPublishTrdIndicator = "PublishTrdIndicator";
const char * const FixShortSaleReason = "ShortSaleReason";
const char * const FixQtyType = "QtyType";
const char * const FixSecondaryTrdType = "SecondaryTrdType";
const char * const FixTradeReportType = "TradeReportType";
const char * const FixAllocNoOrdersType = "AllocNoOrdersType";
const char * const FixSharedCommission = "SharedCommission";
const char * const FixConfirmReqID = "ConfirmReqID";
const char * const FixAvgParPx = "AvgParPx";
const char * const FixReportedPx = "ReportedPx";
const char * const FixNoCapacities = "NoCapacities";
const char * const FixOrderCapacityQty = "OrderCapacityQty";
const char * const FixNoEvents = "NoEvents";
const char * const FixEventType = "EventType";
const char * const FixEventDate = "EventDate";
const char * const FixEventPx = "EventPx";
const char * const FixEventText = "EventText";
const char * const FixPctAtRisk = "PctAtRisk";
const char * const FixNoInstrAttrib = "NoInstrAttrib";
const char * const FixInstrAttribType = "InstrAttribType";
const char * const FixInstrAttribValue = "InstrAttribValue";
const char * const FixDatedDate = "DatedDate";
const char * const FixInterestAccrualDate = "InterestAccrualDate";
const char * const FixCPProgram = "CPProgram";
const char * const FixCPRegType = "CPRegType";
const char * const FixUnderlyingCPProgram = "UnderlyingCPProgram";
const char * const FixUnderlyingCPRegType = "UnderlyingCPRegType";
const char * const FixUnderlyingQty = "UnderlyingQty";
const char * const FixTrdMatchID = "TrdMatchID";
const char * const FixSecondaryTradeReportRefID = "SecondaryTradeReportRefID";
const char * const FixUnderlyingDirtyPrice = "UnderlyingDirtyPrice";
const char * const FixUnderlyingEndPrice = "UnderlyingEndPrice";
const char * const FixUnderlyingStartValue = "UnderlyingStartValue";
const char * const FixUnderlyingCurrentValue = "UnderlyingCurrentValue";
const char * const FixUnderlyingEndValue = "UnderlyingEndValue";
const char * const FixNoUnderlyingStips = "NoUnderlyingStips";
const char * const FixUnderlyingStipType = "UnderlyingStipType";
const char * const FixUnderlyingStipValue = "UnderlyingStipValue";
const char * const FixMaturityNetMoney = "MaturityNetMoney";
const char * const FixMiscFeeBasis = "MiscFeeBasis";
const char * const FixTotNoAllocs = "TotNoAllocs";
const char * const FixLastFragment = "LastFragment";
const char * const FixCollReqID = "CollReqID";
const char * const FixCollAsgnReason = "CollAsgnReason";
const char * const FixCollInquiryQualifier = "CollInquiryQualifier";
const char * const FixNoTrades = "NoTrades";
const char * const FixMarginRatio = "MarginRatio";
const char * const FixMarginExcess = "MarginExcess";
const char * const FixTotalNetValue = "TotalNetValue";
const char * const FixCashOutstanding = "CashOutstanding";
const char * const FixCollAsgnID = "CollAsgnID";
const char * const FixCollAsgnTransType = "CollAsgnTransType";
const char * const FixCollRespID = "CollRespID";
const char * const FixCollAsgnRespType = "CollAsgnRespType";
const char * const FixCollAsgnRejectReason = "CollAsgnRejectReason";
const char * const FixCollAsgnRefID = "CollAsgnRefID";
const char * const FixCollRptID = "CollRptID";
const char * const FixCollInquiryID = "CollInquiryID";
const char * const FixCollStatus = "CollStatus";
const char * const FixTotNumReports = "TotNumReports";
const char * const FixLastRptRequested = "LastRptRequested";
const char * const FixAgreementDesc = "AgreementDesc";
const char * const FixAgreementID = "AgreementID";
const char * const FixAgreementDate = "AgreementDate";
const char * const FixStartDate = "StartDate";
const char * const FixEndDate = "EndDate";
const char * const FixAgreementCurrency = "AgreementCurrency";
const char * const FixDeliveryType = "DeliveryType";
const char * const FixEndAccruedInterestAmt = "EndAccruedInterestAmt";
const char * const FixStartCash = "StartCash";
const char * const FixEndCash = "EndCash";
const char * const FixUserRequestID = "UserRequestID";
const char * const FixUserRequestType = "UserRequestType";
const char * const FixNewPassword = "NewPassword";
const char * const FixUserStatus = "UserStatus";
const char * const FixUserStatusText = "UserStatusText";
const char * const FixStatusValue = "StatusValue";
const char * const FixStatusText = "StatusText";
const char * const FixRefCompID = "RefCompID";
const char * const FixRefSubID = "RefSubID";
const char * const FixNetworkResponseID = "NetworkResponseID";
const char * const FixNetworkRequestID = "NetworkRequestID";
const char * const FixLastNetworkResponseID = "LastNetworkResponseID";
const char * const FixNetworkRequestType = "NetworkRequestType";
const char * const FixNoCompIDs = "NoCompIDs";
const char * const FixNetworkStatusResponseType = "NetworkStatusResponseType";
const char * const FixNoCollInquiryQualifier = "NoCollInquiryQualifier";
const char * const FixTrdRptStatus = "TrdRptStatus";
const char * const FixAffirmStatus = "AffirmStatus";
const char * const FixUnderlyingStrikeCurrency = "UnderlyingStrikeCurrency";
const char * const FixLegStrikeCurrency = "LegStrikeCurrency";
const char * const FixTimeBracket = "TimeBracket";
const char * const FixCollAction = "CollAction";
const char * const FixCollInquiryStatus = "CollInquiryStatus";
const char * const FixCollInquiryResult = "CollInquiryResult";
const char * const FixStrikeCurrency = "StrikeCurrency";
const char * const FixNoNested3PartyIDs = "NoNested3PartyIDs";
const char * const FixNested3PartyID = "Nested3PartyID";
const char * const FixNested3PartyIDSource = "Nested3PartyIDSource";
const char * const FixNested3PartyRole = "Nested3PartyRole";
const char * const FixNoNested3PartySubIDs = "NoNested3PartySubIDs";
const char * const FixNested3PartySubID = "Nested3PartySubID";
const char * const FixNested3PartySubIDType = "Nested3PartySubIDType";
const char * const FixLegContractSettlMonth = "LegContractSettlMonth";
const char * const FixLegInterestAccrualDate = "LegInterestAccrualDate";

const AdvSideEnums::ItemType AdvSideEnums::BAD_ENUM( "BAD_ENUM", AdvSideEnums::ITEM_BAD_ENUM );
const AdvSideEnums::ItemType AdvSideEnums::BUY( "BUY", 'B' );
const AdvSideEnums::ItemType AdvSideEnums::SELL( "SELL", 'S' );
const AdvSideEnums::ItemType AdvSideEnums::CROSS( "CROSS", 'X' );
const AdvSideEnums::ItemType AdvSideEnums::TRADE( "TRADE", 'T' );

const AdvTransTypeEnums::ItemType AdvTransTypeEnums::BAD_ENUM( "BAD_ENUM", AdvTransTypeEnums::ITEM_BAD_ENUM );
const AdvTransTypeEnums::ItemType AdvTransTypeEnums::NEW( "NEW", SOHSTR(N) );
const AdvTransTypeEnums::ItemType AdvTransTypeEnums::CANCEL( "CANCEL", SOHSTR(C) );
const AdvTransTypeEnums::ItemType AdvTransTypeEnums::REPLACE( "REPLACE", SOHSTR(R) );

const CommTypeEnums::ItemType CommTypeEnums::BAD_ENUM( "BAD_ENUM", CommTypeEnums::ITEM_BAD_ENUM );
const CommTypeEnums::ItemType CommTypeEnums::PER_UNIT( "PER_UNIT", '1' );
const CommTypeEnums::ItemType CommTypeEnums::PERCENTAGE( "PERCENTAGE", '2' );
const CommTypeEnums::ItemType CommTypeEnums::ABSOLUTE( "ABSOLUTE", '3' );
const CommTypeEnums::ItemType CommTypeEnums::_4( "_4", '4' );
const CommTypeEnums::ItemType CommTypeEnums::_5( "_5", '5' );
const CommTypeEnums::ItemType CommTypeEnums::POINTS_PER_BOND_OR_CONTRACT_SUPPLY_CONTRACTMULTIPLIER( "POINTS_PER_BOND_OR_CONTRACT_SUPPLY_CONTRACTMULTIPLIER", '6' );

const ExecInstEnums::ItemType ExecInstEnums::BAD_ENUM( "BAD_ENUM", ExecInstEnums::ITEM_BAD_ENUM );
const ExecInstEnums::ItemType ExecInstEnums::NOT_HELD( "NOT_HELD", SOHSTR(1) );
const ExecInstEnums::ItemType ExecInstEnums::WORK( "WORK", SOHSTR(2) );
const ExecInstEnums::ItemType ExecInstEnums::GO_ALONG( "GO_ALONG", SOHSTR(3) );
const ExecInstEnums::ItemType ExecInstEnums::OVER_THE_DAY( "OVER_THE_DAY", SOHSTR(4) );
const ExecInstEnums::ItemType ExecInstEnums::HELD( "HELD", SOHSTR(5) );
const ExecInstEnums::ItemType ExecInstEnums::PARTICIPATE_DONT_INITIATE( "PARTICIPATE_DONT_INITIATE", SOHSTR(6) );
const ExecInstEnums::ItemType ExecInstEnums::STRICT_SCALE( "STRICT_SCALE", SOHSTR(7) );
const ExecInstEnums::ItemType ExecInstEnums::TRY_TO_SCALE( "TRY_TO_SCALE", SOHSTR(8) );
const ExecInstEnums::ItemType ExecInstEnums::STAY_ON_BIDSIDE( "STAY_ON_BIDSIDE", SOHSTR(9) );
const ExecInstEnums::ItemType ExecInstEnums::STAY_ON_OFFERSIDE( "STAY_ON_OFFERSIDE", SOHSTR(0) );
const ExecInstEnums::ItemType ExecInstEnums::NO_CROSS( "NO_CROSS", SOHSTR(A) );
const ExecInstEnums::ItemType ExecInstEnums::OK_TO_CROSS( "OK_TO_CROSS", SOHSTR(B) );
const ExecInstEnums::ItemType ExecInstEnums::CALL_FIRST( "CALL_FIRST", SOHSTR(C) );
const ExecInstEnums::ItemType ExecInstEnums::PERCENT_OF_VOLUME( "PERCENT_OF_VOLUME", SOHSTR(D) );
const ExecInstEnums::ItemType ExecInstEnums::DO_NOT_INCREASE( "DO_NOT_INCREASE", SOHSTR(E) );
const ExecInstEnums::ItemType ExecInstEnums::DO_NOT_REDUCE( "DO_NOT_REDUCE", SOHSTR(F) );
const ExecInstEnums::ItemType ExecInstEnums::ALL_OR_NONE( "ALL_OR_NONE", SOHSTR(G) );
const ExecInstEnums::ItemType ExecInstEnums::REINSTATE_ON_SYSTEM_FAILURE( "REINSTATE_ON_SYSTEM_FAILURE", SOHSTR(H) );
const ExecInstEnums::ItemType ExecInstEnums::INSTITUTIONS_ONLY( "INSTITUTIONS_ONLY", SOHSTR(I) );
const ExecInstEnums::ItemType ExecInstEnums::REINSTATE_ON_TRADING_HALT( "REINSTATE_ON_TRADING_HALT", SOHSTR(J) );
const ExecInstEnums::ItemType ExecInstEnums::CANCEL_ON_TRADING_HALT( "CANCEL_ON_TRADING_HALT", SOHSTR(K) );
const ExecInstEnums::ItemType ExecInstEnums::LAST_PEG( "LAST_PEG", SOHSTR(L) );
const ExecInstEnums::ItemType ExecInstEnums::MID_PRICE_PEG( "MID_PRICE_PEG", SOHSTR(M) );
const ExecInstEnums::ItemType ExecInstEnums::NON_NEGOTIABLE( "NON_NEGOTIABLE", SOHSTR(N) );
const ExecInstEnums::ItemType ExecInstEnums::OPENING_PEG( "OPENING_PEG", SOHSTR(O) );
const ExecInstEnums::ItemType ExecInstEnums::MARKET_PEG( "MARKET_PEG", SOHSTR(P) );
const ExecInstEnums::ItemType ExecInstEnums::CANCEL_ON_SYSTEM_FAILURE( "CANCEL_ON_SYSTEM_FAILURE", SOHSTR(Q) );
const ExecInstEnums::ItemType ExecInstEnums::PRIMARY_PEG( "PRIMARY_PEG", SOHSTR(R) );
const ExecInstEnums::ItemType ExecInstEnums::SUSPEND( "SUSPEND", SOHSTR(S) );
const ExecInstEnums::ItemType ExecInstEnums::CUSTOMER_DISPLAY_INSTRUCTION( "CUSTOMER_DISPLAY_INSTRUCTION", SOHSTR(U) );
const ExecInstEnums::ItemType ExecInstEnums::NETTING( "NETTING", SOHSTR(V) );
const ExecInstEnums::ItemType ExecInstEnums::PEG_TO_VWAP( "PEG_TO_VWAP", SOHSTR(W) );
const ExecInstEnums::ItemType ExecInstEnums::TRADE_ALONG( "TRADE_ALONG", SOHSTR(X) );
const ExecInstEnums::ItemType ExecInstEnums::TRY_TO_STOP( "TRY_TO_STOP", SOHSTR(Y) );
const ExecInstEnums::ItemType ExecInstEnums::CANCEL_IF_NOT_BEST( "CANCEL_IF_NOT_BEST", SOHSTR(Z) );
const ExecInstEnums::ItemType ExecInstEnums::TRAILING_STOP_PEG( "TRAILING_STOP_PEG", SOHSTR(a) );
const ExecInstEnums::ItemType ExecInstEnums::STRICT_LIMIT( "STRICT_LIMIT", SOHSTR(b) );
const ExecInstEnums::ItemType ExecInstEnums::IGNORE_PRICE_VALIDITY_CHECKS( "IGNORE_PRICE_VALIDITY_CHECKS", SOHSTR(c) );
const ExecInstEnums::ItemType ExecInstEnums::PEG_TO_LIMIT_PRICE( "PEG_TO_LIMIT_PRICE", SOHSTR(d) );
const ExecInstEnums::ItemType ExecInstEnums::WORK_TO_TARGET_STRATEGY( "WORK_TO_TARGET_STRATEGY", SOHSTR(e) );

const HandlInstEnums::ItemType HandlInstEnums::BAD_ENUM( "BAD_ENUM", HandlInstEnums::ITEM_BAD_ENUM );
const HandlInstEnums::ItemType HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION( "AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION", '1' );
const HandlInstEnums::ItemType HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PUBLIC_BROKER_INTERVENTION_OK( "AUTOMATED_EXECUTION_ORDER_PUBLIC_BROKER_INTERVENTION_OK", '2' );
const HandlInstEnums::ItemType HandlInstEnums::MANUAL_ORDER_BEST_EXECUTION( "MANUAL_ORDER_BEST_EXECUTION", '3' );

const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::BAD_ENUM( "BAD_ENUM", SecurityIDSourceEnums::ITEM_BAD_ENUM );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::CUSIP( "CUSIP", SOHSTR(1) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::SEDOL( "SEDOL", SOHSTR(2) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::QUIK( "QUIK", SOHSTR(3) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::ISIN_NUMBER( "ISIN_NUMBER", SOHSTR(4) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::RIC_CODE( "RIC_CODE", SOHSTR(5) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::ISO_CURRENCY_CODE( "ISO_CURRENCY_CODE", SOHSTR(6) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::ISO_COUNTRY_CODE( "ISO_COUNTRY_CODE", SOHSTR(7) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::EXCHANGE_SYMBOL( "EXCHANGE_SYMBOL", SOHSTR(8) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::CONSOLIDATED_TAPE_ASSOCIATION( "CONSOLIDATED_TAPE_ASSOCIATION", SOHSTR(9) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::BLOOMBERG_SYMBOL( "BLOOMBERG_SYMBOL", SOHSTR(A) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::WERTPAPIER( "WERTPAPIER", SOHSTR(B) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::DUTCH( "DUTCH", SOHSTR(C) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::VALOREN( "VALOREN", SOHSTR(D) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::SICOVAM( "SICOVAM", SOHSTR(E) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::BELGIAN( "BELGIAN", SOHSTR(F) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::COMMON( "COMMON", SOHSTR(G) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::CLEARING_HOUSE( "CLEARING_HOUSE", SOHSTR(H) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::ISDA_FPML_PRODUCT_SPECIFICATION( "ISDA_FPML_PRODUCT_SPECIFICATION", SOHSTR(I) );
const SecurityIDSourceEnums::ItemType SecurityIDSourceEnums::OPTIONS_PRICE_REPORTING_AUTHORITY( "OPTIONS_PRICE_REPORTING_AUTHORITY", SOHSTR(J) );

const IOIQltyIndEnums::ItemType IOIQltyIndEnums::BAD_ENUM( "BAD_ENUM", IOIQltyIndEnums::ITEM_BAD_ENUM );
const IOIQltyIndEnums::ItemType IOIQltyIndEnums::LOW( "LOW", 'L' );
const IOIQltyIndEnums::ItemType IOIQltyIndEnums::MEDIUM( "MEDIUM", 'M' );
const IOIQltyIndEnums::ItemType IOIQltyIndEnums::HIGH( "HIGH", 'H' );

const IOIQtyEnums::ItemType IOIQtyEnums::BAD_ENUM( "BAD_ENUM", IOIQtyEnums::ITEM_BAD_ENUM );
const IOIQtyEnums::ItemType IOIQtyEnums::SMALL( "SMALL", SOHSTR(S) );
const IOIQtyEnums::ItemType IOIQtyEnums::MEDIUM( "MEDIUM", SOHSTR(M) );
const IOIQtyEnums::ItemType IOIQtyEnums::LARGE( "LARGE", SOHSTR(L) );

const IOITransTypeEnums::ItemType IOITransTypeEnums::BAD_ENUM( "BAD_ENUM", IOITransTypeEnums::ITEM_BAD_ENUM );
const IOITransTypeEnums::ItemType IOITransTypeEnums::NEW( "NEW", 'N' );
const IOITransTypeEnums::ItemType IOITransTypeEnums::CANCEL( "CANCEL", 'C' );
const IOITransTypeEnums::ItemType IOITransTypeEnums::REPLACE( "REPLACE", 'R' );

const LastCapacityEnums::ItemType LastCapacityEnums::BAD_ENUM( "BAD_ENUM", LastCapacityEnums::ITEM_BAD_ENUM );
const LastCapacityEnums::ItemType LastCapacityEnums::AGENT( "AGENT", '1' );
const LastCapacityEnums::ItemType LastCapacityEnums::CROSS_AS_AGENT( "CROSS_AS_AGENT", '2' );
const LastCapacityEnums::ItemType LastCapacityEnums::CROSS_AS_PRINCIPAL( "CROSS_AS_PRINCIPAL", '3' );
const LastCapacityEnums::ItemType LastCapacityEnums::PRINCIPAL( "PRINCIPAL", '4' );

const MsgTypeEnums::ItemType MsgTypeEnums::BAD_ENUM( "BAD_ENUM", MsgTypeEnums::ITEM_BAD_ENUM );
const MsgTypeEnums::ItemType MsgTypeEnums::HEARTBEAT( "HEARTBEAT", SOHSTR(0) );
const MsgTypeEnums::ItemType MsgTypeEnums::TEST_REQUEST( "TEST_REQUEST", SOHSTR(1) );
const MsgTypeEnums::ItemType MsgTypeEnums::RESEND_REQUEST( "RESEND_REQUEST", SOHSTR(2) );
const MsgTypeEnums::ItemType MsgTypeEnums::REJECT( "REJECT", SOHSTR(3) );
const MsgTypeEnums::ItemType MsgTypeEnums::SEQUENCE_RESET( "SEQUENCE_RESET", SOHSTR(4) );
const MsgTypeEnums::ItemType MsgTypeEnums::LOGOUT( "LOGOUT", SOHSTR(5) );
const MsgTypeEnums::ItemType MsgTypeEnums::INDICATION_OF_INTEREST( "INDICATION_OF_INTEREST", SOHSTR(6) );
const MsgTypeEnums::ItemType MsgTypeEnums::ADVERTISEMENT( "ADVERTISEMENT", SOHSTR(7) );
const MsgTypeEnums::ItemType MsgTypeEnums::EXECUTION_REPORT( "EXECUTION_REPORT", SOHSTR(8) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_CANCEL_REJECT( "ORDER_CANCEL_REJECT", SOHSTR(9) );
const MsgTypeEnums::ItemType MsgTypeEnums::LOGON( "LOGON", SOHSTR(A) );
const MsgTypeEnums::ItemType MsgTypeEnums::NEWS( "NEWS", SOHSTR(B) );
const MsgTypeEnums::ItemType MsgTypeEnums::EMAIL( "EMAIL", SOHSTR(C) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_SINGLE( "ORDER_SINGLE", SOHSTR(D) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_LIST( "ORDER_LIST", SOHSTR(E) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_CANCEL_REQUEST( "ORDER_CANCEL_REQUEST", SOHSTR(F) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_CANCEL_REPLACE_REQUEST( "ORDER_CANCEL_REPLACE_REQUEST", SOHSTR(G) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_STATUS_REQUEST( "ORDER_STATUS_REQUEST", SOHSTR(H) );
const MsgTypeEnums::ItemType MsgTypeEnums::ALLOCATION_INSTRUCTION( "ALLOCATION_INSTRUCTION", SOHSTR(J) );
const MsgTypeEnums::ItemType MsgTypeEnums::LIST_CANCEL_REQUEST( "LIST_CANCEL_REQUEST", SOHSTR(K) );
const MsgTypeEnums::ItemType MsgTypeEnums::LIST_EXECUTE( "LIST_EXECUTE", SOHSTR(L) );
const MsgTypeEnums::ItemType MsgTypeEnums::LIST_STATUS_REQUEST( "LIST_STATUS_REQUEST", SOHSTR(M) );
const MsgTypeEnums::ItemType MsgTypeEnums::LIST_STATUS( "LIST_STATUS", SOHSTR(N) );
const MsgTypeEnums::ItemType MsgTypeEnums::ALLOCATION_INSTRUCTION_ACK( "ALLOCATION_INSTRUCTION_ACK", SOHSTR(P) );
const MsgTypeEnums::ItemType MsgTypeEnums::DONT_KNOW_TRADE( "DONT_KNOW_TRADE", SOHSTR(Q) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_REQUEST( "QUOTE_REQUEST", SOHSTR(R) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE( "QUOTE", SOHSTR(S) );
const MsgTypeEnums::ItemType MsgTypeEnums::SETTLEMENT_INSTRUCTIONS( "SETTLEMENT_INSTRUCTIONS", SOHSTR(T) );
const MsgTypeEnums::ItemType MsgTypeEnums::MARKET_DATA_REQUEST( "MARKET_DATA_REQUEST", SOHSTR(V) );
const MsgTypeEnums::ItemType MsgTypeEnums::MARKET_DATA_SNAPSHOT_FULL_REFRESH( "MARKET_DATA_SNAPSHOT_FULL_REFRESH", SOHSTR(W) );
const MsgTypeEnums::ItemType MsgTypeEnums::MARKET_DATA_INCREMENTAL_REFRESH( "MARKET_DATA_INCREMENTAL_REFRESH", SOHSTR(X) );
const MsgTypeEnums::ItemType MsgTypeEnums::MARKET_DATA_REQUEST_REJECT( "MARKET_DATA_REQUEST_REJECT", SOHSTR(Y) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_CANCEL( "QUOTE_CANCEL", SOHSTR(Z) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_STATUS_REQUEST( "QUOTE_STATUS_REQUEST", SOHSTR(a) );
const MsgTypeEnums::ItemType MsgTypeEnums::MASS_QUOTE_ACKNOWLEDGEMENT( "MASS_QUOTE_ACKNOWLEDGEMENT", SOHSTR(b) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_DEFINITION_REQUEST( "SECURITY_DEFINITION_REQUEST", SOHSTR(c) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_DEFINITION( "SECURITY_DEFINITION", SOHSTR(d) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_STATUS_REQUEST( "SECURITY_STATUS_REQUEST", SOHSTR(e) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_STATUS( "SECURITY_STATUS", SOHSTR(f) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADING_SESSION_STATUS_REQUEST( "TRADING_SESSION_STATUS_REQUEST", SOHSTR(g) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADING_SESSION_STATUS( "TRADING_SESSION_STATUS", SOHSTR(h) );
const MsgTypeEnums::ItemType MsgTypeEnums::MASS_QUOTE( "MASS_QUOTE", SOHSTR(i) );
const MsgTypeEnums::ItemType MsgTypeEnums::BUSINESS_MESSAGE_REJECT( "BUSINESS_MESSAGE_REJECT", SOHSTR(j) );
const MsgTypeEnums::ItemType MsgTypeEnums::BID_REQUEST( "BID_REQUEST", SOHSTR(k) );
const MsgTypeEnums::ItemType MsgTypeEnums::BID_RESPONSE( "BID_RESPONSE", SOHSTR(l) );
const MsgTypeEnums::ItemType MsgTypeEnums::LIST_STRIKE_PRICE( "LIST_STRIKE_PRICE", SOHSTR(m) );
const MsgTypeEnums::ItemType MsgTypeEnums::XML_MESSAGE( "XML_MESSAGE", SOHSTR(n) );
const MsgTypeEnums::ItemType MsgTypeEnums::REGISTRATION_INSTRUCTIONS( "REGISTRATION_INSTRUCTIONS", SOHSTR(o) );
const MsgTypeEnums::ItemType MsgTypeEnums::REGISTRATION_INSTRUCTIONS_RESPONSE( "REGISTRATION_INSTRUCTIONS_RESPONSE", SOHSTR(p) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_MASS_CANCEL_REQUEST( "ORDER_MASS_CANCEL_REQUEST", SOHSTR(q) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_MASS_CANCEL_REPORT( "ORDER_MASS_CANCEL_REPORT", SOHSTR(r) );
const MsgTypeEnums::ItemType MsgTypeEnums::NEW_ORDER_s( "NEW_ORDER_s", SOHSTR(s) );
const MsgTypeEnums::ItemType MsgTypeEnums::CROSS_ORDER_CANCEL_REPLACE_REQUEST( "CROSS_ORDER_CANCEL_REPLACE_REQUEST", SOHSTR(t) );
const MsgTypeEnums::ItemType MsgTypeEnums::CROSS_ORDER_CANCEL_REQUEST( "CROSS_ORDER_CANCEL_REQUEST", SOHSTR(u) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_TYPE_REQUEST( "SECURITY_TYPE_REQUEST", SOHSTR(v) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_TYPES( "SECURITY_TYPES", SOHSTR(w) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_LIST_REQUEST( "SECURITY_LIST_REQUEST", SOHSTR(x) );
const MsgTypeEnums::ItemType MsgTypeEnums::SECURITY_LIST( "SECURITY_LIST", SOHSTR(y) );
const MsgTypeEnums::ItemType MsgTypeEnums::DERIVATIVE_SECURITY_LIST_REQUEST( "DERIVATIVE_SECURITY_LIST_REQUEST", SOHSTR(z) );
const MsgTypeEnums::ItemType MsgTypeEnums::DERIVATIVE_SECURITY_LIST( "DERIVATIVE_SECURITY_LIST", SOHSTR(AA) );
const MsgTypeEnums::ItemType MsgTypeEnums::NEW_ORDER_AB( "NEW_ORDER_AB", SOHSTR(AB) );
const MsgTypeEnums::ItemType MsgTypeEnums::MULTILEG_ORDER_CANCEL_REPLACE( "MULTILEG_ORDER_CANCEL_REPLACE", SOHSTR(AC) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST( "TRADE_CAPTURE_REPORT_REQUEST", SOHSTR(AD) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADE_CAPTURE_REPORT( "TRADE_CAPTURE_REPORT", SOHSTR(AE) );
const MsgTypeEnums::ItemType MsgTypeEnums::ORDER_MASS_STATUS_REQUEST( "ORDER_MASS_STATUS_REQUEST", SOHSTR(AF) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_REQUEST_REJECT( "QUOTE_REQUEST_REJECT", SOHSTR(AG) );
const MsgTypeEnums::ItemType MsgTypeEnums::RFQ_REQUEST( "RFQ_REQUEST", SOHSTR(AH) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_STATUS_REPORT( "QUOTE_STATUS_REPORT", SOHSTR(AI) );
const MsgTypeEnums::ItemType MsgTypeEnums::QUOTE_RESPONSE( "QUOTE_RESPONSE", SOHSTR(AJ) );
const MsgTypeEnums::ItemType MsgTypeEnums::CONFIRMATION( "CONFIRMATION", SOHSTR(AK) );
const MsgTypeEnums::ItemType MsgTypeEnums::POSITION_MAINTENANCE_REQUEST( "POSITION_MAINTENANCE_REQUEST", SOHSTR(AL) );
const MsgTypeEnums::ItemType MsgTypeEnums::POSITION_MAINTENANCE_REPORT( "POSITION_MAINTENANCE_REPORT", SOHSTR(AM) );
const MsgTypeEnums::ItemType MsgTypeEnums::REQUEST_FOR_POSITIONS( "REQUEST_FOR_POSITIONS", SOHSTR(AN) );
const MsgTypeEnums::ItemType MsgTypeEnums::REQUEST_FOR_POSITIONS_ACK( "REQUEST_FOR_POSITIONS_ACK", SOHSTR(AO) );
const MsgTypeEnums::ItemType MsgTypeEnums::POSITION_REPORT( "POSITION_REPORT", SOHSTR(AP) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST_ACK( "TRADE_CAPTURE_REPORT_REQUEST_ACK", SOHSTR(AQ) );
const MsgTypeEnums::ItemType MsgTypeEnums::TRADE_CAPTURE_REPORT_ACK( "TRADE_CAPTURE_REPORT_ACK", SOHSTR(AR) );
const MsgTypeEnums::ItemType MsgTypeEnums::ALLOCATION_REPORT( "ALLOCATION_REPORT", SOHSTR(AS) );
const MsgTypeEnums::ItemType MsgTypeEnums::ALLOCATION_REPORT_ACK( "ALLOCATION_REPORT_ACK", SOHSTR(AT) );
const MsgTypeEnums::ItemType MsgTypeEnums::CONFIRMATION_ACK( "CONFIRMATION_ACK", SOHSTR(AU) );
const MsgTypeEnums::ItemType MsgTypeEnums::SETTLEMENT_INSTRUCTION_REQUEST( "SETTLEMENT_INSTRUCTION_REQUEST", SOHSTR(AV) );
const MsgTypeEnums::ItemType MsgTypeEnums::ASSIGNMENT_REPORT( "ASSIGNMENT_REPORT", SOHSTR(AW) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_REQUEST( "COLLATERAL_REQUEST", SOHSTR(AX) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_ASSIGNMENT( "COLLATERAL_ASSIGNMENT", SOHSTR(AY) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_RESPONSE( "COLLATERAL_RESPONSE", SOHSTR(AZ) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_REPORT( "COLLATERAL_REPORT", SOHSTR(BA) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_INQUIRY( "COLLATERAL_INQUIRY", SOHSTR(BB) );
const MsgTypeEnums::ItemType MsgTypeEnums::NETWORK_BC( "NETWORK_BC", SOHSTR(BC) );
const MsgTypeEnums::ItemType MsgTypeEnums::NETWORK_BD( "NETWORK_BD", SOHSTR(BD) );
const MsgTypeEnums::ItemType MsgTypeEnums::USER_REQUEST( "USER_REQUEST", SOHSTR(BE) );
const MsgTypeEnums::ItemType MsgTypeEnums::USER_RESPONSE( "USER_RESPONSE", SOHSTR(BF) );
const MsgTypeEnums::ItemType MsgTypeEnums::COLLATERAL_INQUIRY_ACK( "COLLATERAL_INQUIRY_ACK", SOHSTR(BG) );
const MsgTypeEnums::ItemType MsgTypeEnums::CONFIRMATION_REQUEST( "CONFIRMATION_REQUEST", SOHSTR(BH) );

const OrdStatusEnums::ItemType OrdStatusEnums::BAD_ENUM( "BAD_ENUM", OrdStatusEnums::ITEM_BAD_ENUM );
const OrdStatusEnums::ItemType OrdStatusEnums::NEW( "NEW", '0' );
const OrdStatusEnums::ItemType OrdStatusEnums::PARTIALLY_FILLED( "PARTIALLY_FILLED", '1' );
const OrdStatusEnums::ItemType OrdStatusEnums::FILLED( "FILLED", '2' );
const OrdStatusEnums::ItemType OrdStatusEnums::DONE_FOR_DAY( "DONE_FOR_DAY", '3' );
const OrdStatusEnums::ItemType OrdStatusEnums::CANCELED( "CANCELED", '4' );
const OrdStatusEnums::ItemType OrdStatusEnums::PENDING_CANCEL( "PENDING_CANCEL", '6' );
const OrdStatusEnums::ItemType OrdStatusEnums::STOPPED( "STOPPED", '7' );
const OrdStatusEnums::ItemType OrdStatusEnums::REJECTED( "REJECTED", '8' );
const OrdStatusEnums::ItemType OrdStatusEnums::SUSPENDED( "SUSPENDED", '9' );
const OrdStatusEnums::ItemType OrdStatusEnums::PENDING_NEW( "PENDING_NEW", 'A' );
const OrdStatusEnums::ItemType OrdStatusEnums::CALCULATED( "CALCULATED", 'B' );
const OrdStatusEnums::ItemType OrdStatusEnums::EXPIRED( "EXPIRED", 'C' );
const OrdStatusEnums::ItemType OrdStatusEnums::ACCEPTED_FOR_BIDDING( "ACCEPTED_FOR_BIDDING", 'D' );
const OrdStatusEnums::ItemType OrdStatusEnums::PENDING_REPLACE( "PENDING_REPLACE", 'E' );

const OrdTypeEnums::ItemType OrdTypeEnums::BAD_ENUM( "BAD_ENUM", OrdTypeEnums::ITEM_BAD_ENUM );
const OrdTypeEnums::ItemType OrdTypeEnums::MARKET( "MARKET", '1' );
const OrdTypeEnums::ItemType OrdTypeEnums::LIMIT( "LIMIT", '2' );
const OrdTypeEnums::ItemType OrdTypeEnums::STOP( "STOP", '3' );
const OrdTypeEnums::ItemType OrdTypeEnums::STOP_LIMIT( "STOP_LIMIT", '4' );
const OrdTypeEnums::ItemType OrdTypeEnums::WITH_OR_WITHOUT( "WITH_OR_WITHOUT", '6' );
const OrdTypeEnums::ItemType OrdTypeEnums::LIMIT_OR_BETTER( "LIMIT_OR_BETTER", '7' );
const OrdTypeEnums::ItemType OrdTypeEnums::LIMIT_WITH_OR_WITHOUT( "LIMIT_WITH_OR_WITHOUT", '8' );
const OrdTypeEnums::ItemType OrdTypeEnums::ON_BASIS( "ON_BASIS", '9' );
const OrdTypeEnums::ItemType OrdTypeEnums::PREVIOUSLY_QUOTED( "PREVIOUSLY_QUOTED", 'D' );
const OrdTypeEnums::ItemType OrdTypeEnums::PREVIOUSLY_INDICATED( "PREVIOUSLY_INDICATED", 'E' );
const OrdTypeEnums::ItemType OrdTypeEnums::FOREX( "FOREX", 'G' );
const OrdTypeEnums::ItemType OrdTypeEnums::FUNARI( "FUNARI", 'I' );
const OrdTypeEnums::ItemType OrdTypeEnums::MARKET_IF_TOUCHED( "MARKET_IF_TOUCHED", 'J' );
const OrdTypeEnums::ItemType OrdTypeEnums::MARKET_WITH_LEFTOVER_AS_LIMIT( "MARKET_WITH_LEFTOVER_AS_LIMIT", 'K' );
const OrdTypeEnums::ItemType OrdTypeEnums::PREVIOUS_FUND_VALUATION_POINT( "PREVIOUS_FUND_VALUATION_POINT", 'L' );
const OrdTypeEnums::ItemType OrdTypeEnums::NEXT_FUND_VALUATION_POINT( "NEXT_FUND_VALUATION_POINT", 'M' );
const OrdTypeEnums::ItemType OrdTypeEnums::PEGGED( "PEGGED", 'P' );

const PossDupFlagEnums::ItemType PossDupFlagEnums::BAD_ENUM( "BAD_ENUM", PossDupFlagEnums::ITEM_BAD_ENUM );
const PossDupFlagEnums::ItemType PossDupFlagEnums::YES( "YES", 'Y' );
const PossDupFlagEnums::ItemType PossDupFlagEnums::NO( "NO", 'N' );

const SideEnums::ItemType SideEnums::BAD_ENUM( "BAD_ENUM", SideEnums::ITEM_BAD_ENUM );
const SideEnums::ItemType SideEnums::BUY( "BUY", '1' );
const SideEnums::ItemType SideEnums::SELL( "SELL", '2' );
const SideEnums::ItemType SideEnums::BUY_MINUS( "BUY_MINUS", '3' );
const SideEnums::ItemType SideEnums::SELL_PLUS( "SELL_PLUS", '4' );
const SideEnums::ItemType SideEnums::SELL_SHORT( "SELL_SHORT", '5' );
const SideEnums::ItemType SideEnums::SELL_SHORT_EXEMPT( "SELL_SHORT_EXEMPT", '6' );
const SideEnums::ItemType SideEnums::UNDISCLOSED( "UNDISCLOSED", '7' );
const SideEnums::ItemType SideEnums::CROSS( "CROSS", '8' );
const SideEnums::ItemType SideEnums::CROSS_SHORT( "CROSS_SHORT", '9' );
const SideEnums::ItemType SideEnums::CROSS_SHORT_EXEMPT( "CROSS_SHORT_EXEMPT", 'A' );
const SideEnums::ItemType SideEnums::AS_DEFINED( "AS_DEFINED", 'B' );
const SideEnums::ItemType SideEnums::OPPOSITE( "OPPOSITE", 'C' );
const SideEnums::ItemType SideEnums::SUBSCRIBE( "SUBSCRIBE", 'D' );
const SideEnums::ItemType SideEnums::REDEEM( "REDEEM", 'E' );
const SideEnums::ItemType SideEnums::LEND( "LEND", 'F' );
const SideEnums::ItemType SideEnums::BORROW( "BORROW", 'G' );

const TimeInForceEnums::ItemType TimeInForceEnums::BAD_ENUM( "BAD_ENUM", TimeInForceEnums::ITEM_BAD_ENUM );
const TimeInForceEnums::ItemType TimeInForceEnums::DAY( "DAY", '0' );
const TimeInForceEnums::ItemType TimeInForceEnums::GOOD_TILL_CANCEL( "GOOD_TILL_CANCEL", '1' );
const TimeInForceEnums::ItemType TimeInForceEnums::AT_THE_OPENING( "AT_THE_OPENING", '2' );
const TimeInForceEnums::ItemType TimeInForceEnums::IMMEDIATE_OR_CANCEL( "IMMEDIATE_OR_CANCEL", '3' );
const TimeInForceEnums::ItemType TimeInForceEnums::FILL_OR_KILL( "FILL_OR_KILL", '4' );
const TimeInForceEnums::ItemType TimeInForceEnums::GOOD_TILL_CROSSING( "GOOD_TILL_CROSSING", '5' );
const TimeInForceEnums::ItemType TimeInForceEnums::GOOD_TILL_DATE( "GOOD_TILL_DATE", '6' );
const TimeInForceEnums::ItemType TimeInForceEnums::AT_THE_CLOSE( "AT_THE_CLOSE", '7' );

const UrgencyEnums::ItemType UrgencyEnums::BAD_ENUM( "BAD_ENUM", UrgencyEnums::ITEM_BAD_ENUM );
const UrgencyEnums::ItemType UrgencyEnums::NORMAL( "NORMAL", '0' );
const UrgencyEnums::ItemType UrgencyEnums::FLASH( "FLASH", '1' );
const UrgencyEnums::ItemType UrgencyEnums::BACKGROUND( "BACKGROUND", '2' );

const SettlTypeEnums::ItemType SettlTypeEnums::BAD_ENUM( "BAD_ENUM", SettlTypeEnums::ITEM_BAD_ENUM );
const SettlTypeEnums::ItemType SettlTypeEnums::REGULAR( "REGULAR", '0' );
const SettlTypeEnums::ItemType SettlTypeEnums::CASH( "CASH", '1' );
const SettlTypeEnums::ItemType SettlTypeEnums::NEXT_DAY( "NEXT_DAY", '2' );
const SettlTypeEnums::ItemType SettlTypeEnums::T_PLUS_2( "T_PLUS_2", '3' );
const SettlTypeEnums::ItemType SettlTypeEnums::T_PLUS_3( "T_PLUS_3", '4' );
const SettlTypeEnums::ItemType SettlTypeEnums::T_PLUS_4( "T_PLUS_4", '5' );
const SettlTypeEnums::ItemType SettlTypeEnums::FUTURE( "FUTURE", '6' );
const SettlTypeEnums::ItemType SettlTypeEnums::WHEN_AND_IF_ISSUED( "WHEN_AND_IF_ISSUED", '7' );
const SettlTypeEnums::ItemType SettlTypeEnums::SELLERS_OPTION( "SELLERS_OPTION", '8' );
const SettlTypeEnums::ItemType SettlTypeEnums::T_PLUS_5( "T_PLUS_5", '9' );

const AllocTransTypeEnums::ItemType AllocTransTypeEnums::BAD_ENUM( "BAD_ENUM", AllocTransTypeEnums::ITEM_BAD_ENUM );
const AllocTransTypeEnums::ItemType AllocTransTypeEnums::NEW( "NEW", '0' );
const AllocTransTypeEnums::ItemType AllocTransTypeEnums::REPLACE( "REPLACE", '1' );
const AllocTransTypeEnums::ItemType AllocTransTypeEnums::CANCEL( "CANCEL", '2' );

const PositionEffectEnums::ItemType PositionEffectEnums::BAD_ENUM( "BAD_ENUM", PositionEffectEnums::ITEM_BAD_ENUM );
const PositionEffectEnums::ItemType PositionEffectEnums::OPEN( "OPEN", 'O' );
const PositionEffectEnums::ItemType PositionEffectEnums::CLOSE( "CLOSE", 'C' );
const PositionEffectEnums::ItemType PositionEffectEnums::ROLLED( "ROLLED", 'R' );
const PositionEffectEnums::ItemType PositionEffectEnums::FIFO( "FIFO", 'F' );

const ProcessCodeEnums::ItemType ProcessCodeEnums::BAD_ENUM( "BAD_ENUM", ProcessCodeEnums::ITEM_BAD_ENUM );
const ProcessCodeEnums::ItemType ProcessCodeEnums::REGULAR( "REGULAR", '0' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::SOFT_DOLLAR( "SOFT_DOLLAR", '1' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::STEP_IN( "STEP_IN", '2' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::STEP_OUT( "STEP_OUT", '3' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::SOFT_DOLLAR_STEP_IN( "SOFT_DOLLAR_STEP_IN", '4' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::SOFT_DOLLAR_STEP_OUT( "SOFT_DOLLAR_STEP_OUT", '5' );
const ProcessCodeEnums::ItemType ProcessCodeEnums::PLAN_SPONSOR( "PLAN_SPONSOR", '6' );

const AllocStatusEnums::ItemType AllocStatusEnums::BAD_ENUM( "BAD_ENUM", AllocStatusEnums::ITEM_BAD_ENUM );
const AllocStatusEnums::ItemType AllocStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const AllocStatusEnums::ItemType AllocStatusEnums::BLOCK_LEVEL_REJECT( "BLOCK_LEVEL_REJECT", 1 );
const AllocStatusEnums::ItemType AllocStatusEnums::ACCOUNT_LEVEL_REJECT( "ACCOUNT_LEVEL_REJECT", 2 );
const AllocStatusEnums::ItemType AllocStatusEnums::RECEIVED( "RECEIVED", 3 );
const AllocStatusEnums::ItemType AllocStatusEnums::INCOMPLETE( "INCOMPLETE", 4 );
const AllocStatusEnums::ItemType AllocStatusEnums::REJECTED_BY_INTERMEDIARY( "REJECTED_BY_INTERMEDIARY", 5 );

const AllocRejCodeEnums::ItemType AllocRejCodeEnums::BAD_ENUM( "BAD_ENUM", AllocRejCodeEnums::ITEM_BAD_ENUM );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_ACCOUNT( "UNKNOWN_ACCOUNT", 0 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::INCORRECT_QUANTITY( "INCORRECT_QUANTITY", 1 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::INCORRECT_AVERAGE_PRICE( "INCORRECT_AVERAGE_PRICE", 2 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_EXECUTING_BROKER_MNEMONIC( "UNKNOWN_EXECUTING_BROKER_MNEMONIC", 3 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::COMMISSION_DIFFERENCE( "COMMISSION_DIFFERENCE", 4 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_ORDERID( "UNKNOWN_ORDERID", 5 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_LISTID( "UNKNOWN_LISTID", 6 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::OTHER( "OTHER", 7 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::INCORRECT_ALLOCATED_QUANTITY( "INCORRECT_ALLOCATED_QUANTITY", 8 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::CALCULATION_DIFFERENCE( "CALCULATION_DIFFERENCE", 9 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_OR_STALE_EXECID( "UNKNOWN_OR_STALE_EXECID", 10 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::MISMATCHED_DATA_VALUE( "MISMATCHED_DATA_VALUE", 11 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::UNKNOWN_CLORDID( "UNKNOWN_CLORDID", 12 );
const AllocRejCodeEnums::ItemType AllocRejCodeEnums::WAREHOUSE_REQUEST_REJECTED( "WAREHOUSE_REQUEST_REJECTED", 13 );

const EmailTypeEnums::ItemType EmailTypeEnums::BAD_ENUM( "BAD_ENUM", EmailTypeEnums::ITEM_BAD_ENUM );
const EmailTypeEnums::ItemType EmailTypeEnums::NEW( "NEW", '0' );
const EmailTypeEnums::ItemType EmailTypeEnums::REPLY( "REPLY", '1' );
const EmailTypeEnums::ItemType EmailTypeEnums::ADMIN_REPLY( "ADMIN_REPLY", '2' );

const PossResendEnums::ItemType PossResendEnums::BAD_ENUM( "BAD_ENUM", PossResendEnums::ITEM_BAD_ENUM );
const PossResendEnums::ItemType PossResendEnums::YES( "YES", 'Y' );
const PossResendEnums::ItemType PossResendEnums::NO( "NO", 'N' );

const EncryptMethodEnums::ItemType EncryptMethodEnums::BAD_ENUM( "BAD_ENUM", EncryptMethodEnums::ITEM_BAD_ENUM );
const EncryptMethodEnums::ItemType EncryptMethodEnums::NONE( "NONE", 0 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::PKCS( "PKCS", 1 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::DES( "DES", 2 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::PKCS_DES( "PKCS_DES", 3 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::PGP_DES( "PGP_DES", 4 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::PGP_DES_MD5( "PGP_DES_MD5", 5 );
const EncryptMethodEnums::ItemType EncryptMethodEnums::PEM_DES_MD5( "PEM_DES_MD5", 6 );

const CxlRejReasonEnums::ItemType CxlRejReasonEnums::BAD_ENUM( "BAD_ENUM", CxlRejReasonEnums::ITEM_BAD_ENUM );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::TOO_LATE_TO_CANCEL( "TOO_LATE_TO_CANCEL", 0 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::UNKNOWN_ORDER( "UNKNOWN_ORDER", 1 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::BROKER( "BROKER", 2 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS( "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS", 3 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST( "UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST", 4 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::ORIGORDMODTIME( "ORIGORDMODTIME", 5 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::DUPLICATE_CLORDID( "DUPLICATE_CLORDID", 6 );
const CxlRejReasonEnums::ItemType CxlRejReasonEnums::OTHER( "OTHER", 99 );

const OrdRejReasonEnums::ItemType OrdRejReasonEnums::BAD_ENUM( "BAD_ENUM", OrdRejReasonEnums::ITEM_BAD_ENUM );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::BROKER( "BROKER", 0 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::UNKNOWN_SYMBOL( "UNKNOWN_SYMBOL", 1 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::EXCHANGE_CLOSED( "EXCHANGE_CLOSED", 2 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::ORDER_EXCEEDS_LIMIT( "ORDER_EXCEEDS_LIMIT", 3 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::TOO_LATE_TO_ENTER( "TOO_LATE_TO_ENTER", 4 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::UNKNOWN_ORDER( "UNKNOWN_ORDER", 5 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::DUPLICATE_ORDER( "DUPLICATE_ORDER", 6 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER( "DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER", 7 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::STALE_ORDER( "STALE_ORDER", 8 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::TRADE_ALONG_REQUIRED( "TRADE_ALONG_REQUIRED", 9 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::INVALID_INVESTOR_ID( "INVALID_INVESTOR_ID", 10 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::UNSUPPORTED_ORDER_CHARACTERISTIC12_SURVEILLENCE_OPTION( "UNSUPPORTED_ORDER_CHARACTERISTIC12_SURVEILLENCE_OPTION", 11 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::INCORRECT_QUANTITY( "INCORRECT_QUANTITY", 13 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::INCORRECT_ALLOCATED_QUANTITY( "INCORRECT_ALLOCATED_QUANTITY", 14 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::UNKNOWN_ACCOUNT( "UNKNOWN_ACCOUNT", 15 );
const OrdRejReasonEnums::ItemType OrdRejReasonEnums::OTHER( "OTHER", 99 );

const IOIQualifierEnums::ItemType IOIQualifierEnums::BAD_ENUM( "BAD_ENUM", IOIQualifierEnums::ITEM_BAD_ENUM );
const IOIQualifierEnums::ItemType IOIQualifierEnums::ALL_OR_NONE( "ALL_OR_NONE", 'A' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::MARKET_ON_CLOSE( "MARKET_ON_CLOSE", 'B' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::AT_THE_CLOSE( "AT_THE_CLOSE", 'C' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::VWAP( "VWAP", 'D' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::IN_TOUCH_WITH( "IN_TOUCH_WITH", 'I' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::LIMIT( "LIMIT", 'L' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::MORE_BEHIND( "MORE_BEHIND", 'M' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::AT_THE_OPEN( "AT_THE_OPEN", 'O' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::TAKING_A_POSITION( "TAKING_A_POSITION", 'P' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::AT_THE_MARKET( "AT_THE_MARKET", 'Q' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::READY_TO_TRADE( "READY_TO_TRADE", 'R' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::PORTFOLIO_SHOWN( "PORTFOLIO_SHOWN", 'S' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::THROUGH_THE_DAY( "THROUGH_THE_DAY", 'T' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::VERSUS( "VERSUS", 'V' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::INDICATION( "INDICATION", 'W' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::CROSSING_OPPORTUNITY( "CROSSING_OPPORTUNITY", 'X' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::AT_THE_MIDPOINT( "AT_THE_MIDPOINT", 'Y' );
const IOIQualifierEnums::ItemType IOIQualifierEnums::PRE_OPEN( "PRE_OPEN", 'Z' );

const ReportToExchEnums::ItemType ReportToExchEnums::BAD_ENUM( "BAD_ENUM", ReportToExchEnums::ITEM_BAD_ENUM );
const ReportToExchEnums::ItemType ReportToExchEnums::YES( "YES", 'Y' );
const ReportToExchEnums::ItemType ReportToExchEnums::NO( "NO", 'N' );

const LocateReqdEnums::ItemType LocateReqdEnums::BAD_ENUM( "BAD_ENUM", LocateReqdEnums::ITEM_BAD_ENUM );
const LocateReqdEnums::ItemType LocateReqdEnums::YES( "YES", 'Y' );
const LocateReqdEnums::ItemType LocateReqdEnums::NO( "NO", 'N' );

const ForexReqEnums::ItemType ForexReqEnums::BAD_ENUM( "BAD_ENUM", ForexReqEnums::ITEM_BAD_ENUM );
const ForexReqEnums::ItemType ForexReqEnums::YES( "YES", 'Y' );
const ForexReqEnums::ItemType ForexReqEnums::NO( "NO", 'N' );

const GapFillFlagEnums::ItemType GapFillFlagEnums::BAD_ENUM( "BAD_ENUM", GapFillFlagEnums::ITEM_BAD_ENUM );
const GapFillFlagEnums::ItemType GapFillFlagEnums::YES( "YES", 'Y' );
const GapFillFlagEnums::ItemType GapFillFlagEnums::NO( "NO", 'N' );

const DKReasonEnums::ItemType DKReasonEnums::BAD_ENUM( "BAD_ENUM", DKReasonEnums::ITEM_BAD_ENUM );
const DKReasonEnums::ItemType DKReasonEnums::UNKNOWN_SYMBOL( "UNKNOWN_SYMBOL", 'A' );
const DKReasonEnums::ItemType DKReasonEnums::WRONG_SIDE( "WRONG_SIDE", 'B' );
const DKReasonEnums::ItemType DKReasonEnums::QUANTITY_EXCEEDS_ORDER( "QUANTITY_EXCEEDS_ORDER", 'C' );
const DKReasonEnums::ItemType DKReasonEnums::NO_MATCHING_ORDER( "NO_MATCHING_ORDER", 'D' );
const DKReasonEnums::ItemType DKReasonEnums::PRICE_EXCEEDS_LIMIT( "PRICE_EXCEEDS_LIMIT", 'E' );
const DKReasonEnums::ItemType DKReasonEnums::CALCULATION_DIFFERENCE( "CALCULATION_DIFFERENCE", 'F' );
const DKReasonEnums::ItemType DKReasonEnums::OTHER( "OTHER", 'Z' );

const IOINaturalFlagEnums::ItemType IOINaturalFlagEnums::BAD_ENUM( "BAD_ENUM", IOINaturalFlagEnums::ITEM_BAD_ENUM );
const IOINaturalFlagEnums::ItemType IOINaturalFlagEnums::YES( "YES", 'Y' );
const IOINaturalFlagEnums::ItemType IOINaturalFlagEnums::NO( "NO", 'N' );

const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::BAD_ENUM( "BAD_ENUM", MiscFeeTypeEnums::ITEM_BAD_ENUM );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::REGULATORY( "REGULATORY", SOHSTR(1) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::TAX( "TAX", SOHSTR(2) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::LOCAL_COMMISSION( "LOCAL_COMMISSION", SOHSTR(3) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::EXCHANGE_FEES( "EXCHANGE_FEES", SOHSTR(4) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::STAMP( "STAMP", SOHSTR(5) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::LEVY( "LEVY", SOHSTR(6) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::OTHER( "OTHER", SOHSTR(7) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::MARKUP( "MARKUP", SOHSTR(8) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::CONSUMPTION_TAX( "CONSUMPTION_TAX", SOHSTR(9) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::PER_TRANSACTION( "PER_TRANSACTION", SOHSTR(10) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::CONVERSION( "CONVERSION", SOHSTR(11) );
const MiscFeeTypeEnums::ItemType MiscFeeTypeEnums::AGENT( "AGENT", SOHSTR(12) );

const ResetSeqNumFlagEnums::ItemType ResetSeqNumFlagEnums::BAD_ENUM( "BAD_ENUM", ResetSeqNumFlagEnums::ITEM_BAD_ENUM );
const ResetSeqNumFlagEnums::ItemType ResetSeqNumFlagEnums::YES( "YES", 'Y' );
const ResetSeqNumFlagEnums::ItemType ResetSeqNumFlagEnums::NO( "NO", 'N' );

const ExecTypeEnums::ItemType ExecTypeEnums::BAD_ENUM( "BAD_ENUM", ExecTypeEnums::ITEM_BAD_ENUM );
const ExecTypeEnums::ItemType ExecTypeEnums::NEW( "NEW", '0' );
const ExecTypeEnums::ItemType ExecTypeEnums::DONE_FOR_DAY( "DONE_FOR_DAY", '3' );
const ExecTypeEnums::ItemType ExecTypeEnums::CANCELED( "CANCELED", '4' );
const ExecTypeEnums::ItemType ExecTypeEnums::REPLACE( "REPLACE", '5' );
const ExecTypeEnums::ItemType ExecTypeEnums::PENDING_CANCEL( "PENDING_CANCEL", '6' );
const ExecTypeEnums::ItemType ExecTypeEnums::STOPPED( "STOPPED", '7' );
const ExecTypeEnums::ItemType ExecTypeEnums::REJECTED( "REJECTED", '8' );
const ExecTypeEnums::ItemType ExecTypeEnums::SUSPENDED( "SUSPENDED", '9' );
const ExecTypeEnums::ItemType ExecTypeEnums::PENDING_NEW( "PENDING_NEW", 'A' );
const ExecTypeEnums::ItemType ExecTypeEnums::CALCULATED( "CALCULATED", 'B' );
const ExecTypeEnums::ItemType ExecTypeEnums::EXPIRED( "EXPIRED", 'C' );
const ExecTypeEnums::ItemType ExecTypeEnums::RESTATED( "RESTATED", 'D' );
const ExecTypeEnums::ItemType ExecTypeEnums::PENDING_REPLACE( "PENDING_REPLACE", 'E' );
const ExecTypeEnums::ItemType ExecTypeEnums::TRADE( "TRADE", 'F' );
const ExecTypeEnums::ItemType ExecTypeEnums::TRADE_CORRECT( "TRADE_CORRECT", 'G' );
const ExecTypeEnums::ItemType ExecTypeEnums::TRADE_CANCEL( "TRADE_CANCEL", 'H' );
const ExecTypeEnums::ItemType ExecTypeEnums::ORDER_STATUS( "ORDER_STATUS", 'I' );

const SettlCurrFxRateCalcEnums::ItemType SettlCurrFxRateCalcEnums::BAD_ENUM( "BAD_ENUM", SettlCurrFxRateCalcEnums::ITEM_BAD_ENUM );
const SettlCurrFxRateCalcEnums::ItemType SettlCurrFxRateCalcEnums::MULTIPLY( "MULTIPLY", 'M' );
const SettlCurrFxRateCalcEnums::ItemType SettlCurrFxRateCalcEnums::DIVIDE( "DIVIDE", 'D' );

const SettlInstModeEnums::ItemType SettlInstModeEnums::BAD_ENUM( "BAD_ENUM", SettlInstModeEnums::ITEM_BAD_ENUM );
const SettlInstModeEnums::ItemType SettlInstModeEnums::STANDING_INSTRUCTIONS_PROVIDED( "STANDING_INSTRUCTIONS_PROVIDED", '1' );
const SettlInstModeEnums::ItemType SettlInstModeEnums::SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT( "SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT", '4' );
const SettlInstModeEnums::ItemType SettlInstModeEnums::REQUEST_REJECT( "REQUEST_REJECT", '5' );

const SettlInstTransTypeEnums::ItemType SettlInstTransTypeEnums::BAD_ENUM( "BAD_ENUM", SettlInstTransTypeEnums::ITEM_BAD_ENUM );
const SettlInstTransTypeEnums::ItemType SettlInstTransTypeEnums::NEW( "NEW", 'N' );
const SettlInstTransTypeEnums::ItemType SettlInstTransTypeEnums::CANCEL( "CANCEL", 'C' );
const SettlInstTransTypeEnums::ItemType SettlInstTransTypeEnums::REPLACE( "REPLACE", 'R' );
const SettlInstTransTypeEnums::ItemType SettlInstTransTypeEnums::RESTATE( "RESTATE", 'T' );

const SettlInstSourceEnums::ItemType SettlInstSourceEnums::BAD_ENUM( "BAD_ENUM", SettlInstSourceEnums::ITEM_BAD_ENUM );
const SettlInstSourceEnums::ItemType SettlInstSourceEnums::BROKERS_INSTRUCTIONS( "BROKERS_INSTRUCTIONS", '1' );
const SettlInstSourceEnums::ItemType SettlInstSourceEnums::INSTITUTIONS_INSTRUCTIONS( "INSTITUTIONS_INSTRUCTIONS", '2' );
const SettlInstSourceEnums::ItemType SettlInstSourceEnums::INVESTOR( "INVESTOR", '3' );

const SecurityTypeEnums::ItemType SecurityTypeEnums::BAD_ENUM( "BAD_ENUM", SecurityTypeEnums::ITEM_BAD_ENUM );
const SecurityTypeEnums::ItemType SecurityTypeEnums::FUTURE( "FUTURE", SOHSTR(FUT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::OPTION( "OPTION", SOHSTR(OPT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EURO_SUPRANATIONAL_COUPONS( "EURO_SUPRANATIONAL_COUPONS", SOHSTR(EUSUPRA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::FEDERAL_AGENCY_COUPON( "FEDERAL_AGENCY_COUPON", SOHSTR(FAC) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::FEDERAL_AGENCY_DISCOUNT_NOTE( "FEDERAL_AGENCY_DISCOUNT_NOTE", SOHSTR(FADN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PRIVATE_EXPORT_FUNDING( "PRIVATE_EXPORT_FUNDING", SOHSTR(PEF) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::USD_SUPRANATIONAL_COUPONS( "USD_SUPRANATIONAL_COUPONS", SOHSTR(SUPRA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CORPORATE_BOND( "CORPORATE_BOND", SOHSTR(CORP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CORPORATE_PRIVATE_PLACEMENT( "CORPORATE_PRIVATE_PLACEMENT", SOHSTR(CPP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CONVERTIBLE_BOND( "CONVERTIBLE_BOND", SOHSTR(CB) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::DUAL_CURRENCY( "DUAL_CURRENCY", SOHSTR(DUAL) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EURO_CORPORATE_BOND( "EURO_CORPORATE_BOND", SOHSTR(EUCORP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::INDEXED_LINKED( "INDEXED_LINKED", SOHSTR(XLINKD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::STRUCTURED_NOTES( "STRUCTURED_NOTES", SOHSTR(STRUCT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::YANKEE_CORPORATE_BOND( "YANKEE_CORPORATE_BOND", SOHSTR(YANK) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::FOREIGN_EXCHANGE_CONTRACT( "FOREIGN_EXCHANGE_CONTRACT", SOHSTR(FOR) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::COMMON_STOCK( "COMMON_STOCK", SOHSTR(CS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PREFERRED_STOCK( "PREFERRED_STOCK", SOHSTR(PS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BRADY_BOND( "BRADY_BOND", SOHSTR(BRADY) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EURO_SOVEREIGNS( "EURO_SOVEREIGNS", SOHSTR(EUSOV) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::US_TREASURY_BOND( "US_TREASURY_BOND", SOHSTR(TBOND) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE( "INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE", SOHSTR(TINT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TREASURY_INFLATION_PROTECTED_SECURITIES( "TREASURY_INFLATION_PROTECTED_SECURITIES", SOHSTR(TIPS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE( "PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE", SOHSTR(TCAL) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE( "PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE", SOHSTR(TPRN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::US_TREASURY_NOTE_UST( "US_TREASURY_NOTE_UST", SOHSTR(UST) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::US_TREASURY_BILL_USTB( "US_TREASURY_BILL_USTB", SOHSTR(USTB) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::US_TREASURY_NOTE_TNOTE( "US_TREASURY_NOTE_TNOTE", SOHSTR(TNOTE) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::US_TREASURY_BILL_TBILL( "US_TREASURY_BILL_TBILL", SOHSTR(TBILL) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REPURCHASE( "REPURCHASE", SOHSTR(REPO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::FORWARD( "FORWARD", SOHSTR(FORWARD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BUY_SELLBACK( "BUY_SELLBACK", SOHSTR(BUYSELL) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SECURITIES_LOAN( "SECURITIES_LOAN", SOHSTR(SECLOAN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SECURITIES_PLEDGE( "SECURITIES_PLEDGE", SOHSTR(SECPLEDGE) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TERM_LOAN( "TERM_LOAN", SOHSTR(TERM) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REVOLVER_LOAN( "REVOLVER_LOAN", SOHSTR(RVLV) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REVOLVER_TERM_LOAN( "REVOLVER_TERM_LOAN", SOHSTR(RVLVTRM) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BRIDGE_LOAN( "BRIDGE_LOAN", SOHSTR(BRIDGE) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::LETTER_OF_CREDIT( "LETTER_OF_CREDIT", SOHSTR(LOFC) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SWING_LINE_FACILITY( "SWING_LINE_FACILITY", SOHSTR(SWING) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::DEBTOR_IN_POSSESSION( "DEBTOR_IN_POSSESSION", SOHSTR(DINP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::DEFAULTED( "DEFAULTED", SOHSTR(DEFLTED) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::WITHDRAWN( "WITHDRAWN", SOHSTR(WITHDRN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REPLACED( "REPLACED", SOHSTR(REPLACD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MATURED( "MATURED", SOHSTR(MATURED) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::AMENDED_RESTATED( "AMENDED_RESTATED", SOHSTR(AMENDED) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::RETIRED( "RETIRED", SOHSTR(RETIRED) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BANKERS_ACCEPTANCE( "BANKERS_ACCEPTANCE", SOHSTR(BA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BANK_NOTES( "BANK_NOTES", SOHSTR(BN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::BILL_OF_EXCHANGES( "BILL_OF_EXCHANGES", SOHSTR(BOX) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CERTIFICATE_OF_DEPOSIT( "CERTIFICATE_OF_DEPOSIT", SOHSTR(CD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CALL_LOANS( "CALL_LOANS", SOHSTR(CL) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::COMMERCIAL_PAPER( "COMMERCIAL_PAPER", SOHSTR(CP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::DEPOSIT_NOTES( "DEPOSIT_NOTES", SOHSTR(DN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EURO_CERTIFICATE_OF_DEPOSIT( "EURO_CERTIFICATE_OF_DEPOSIT", SOHSTR(EUCD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EURO_COMMERCIAL_PAPER( "EURO_COMMERCIAL_PAPER", SOHSTR(EUCP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::LIQUIDITY_NOTE( "LIQUIDITY_NOTE", SOHSTR(LQN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MEDIUM_TERM_NOTES( "MEDIUM_TERM_NOTES", SOHSTR(MTN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::OVERNIGHT( "OVERNIGHT", SOHSTR(ONITE) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PROMISSORY_NOTE( "PROMISSORY_NOTE", SOHSTR(PN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PLAZOS_FIJOS( "PLAZOS_FIJOS", SOHSTR(PZFJ) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SHORT_TERM_LOAN_NOTE( "SHORT_TERM_LOAN_NOTE", SOHSTR(STN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TIME_DEPOSIT( "TIME_DEPOSIT", SOHSTR(TD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::EXTENDED_COMM_NOTE( "EXTENDED_COMM_NOTE", SOHSTR(XCN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::YANKEE_CERTIFICATE_OF_DEPOSIT( "YANKEE_CERTIFICATE_OF_DEPOSIT", SOHSTR(YCD) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::ASSET_BACKED_SECURITIES( "ASSET_BACKED_SECURITIES", SOHSTR(ABS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CORP_MORTGAGE_BACKED_SECURITIES( "CORP_MORTGAGE_BACKED_SECURITIES", SOHSTR(CMBS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::COLLATERALIZED_MORTGAGE_OBLIGATION( "COLLATERALIZED_MORTGAGE_OBLIGATION", SOHSTR(CMO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::IOETTE_MORTGAGE( "IOETTE_MORTGAGE", SOHSTR(IET) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MORTGAGE_BACKED_SECURITIES( "MORTGAGE_BACKED_SECURITIES", SOHSTR(MBS) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MORTGAGE_INTEREST_ONLY( "MORTGAGE_INTEREST_ONLY", SOHSTR(MIO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MORTGAGE_PRINCIPAL_ONLY( "MORTGAGE_PRINCIPAL_ONLY", SOHSTR(MPO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MORTGAGE_PRIVATE_PLACEMENT( "MORTGAGE_PRIVATE_PLACEMENT", SOHSTR(MPP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MISCELLANEOUS_PASS_THROUGH( "MISCELLANEOUS_PASS_THROUGH", SOHSTR(MPT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::PFANDBRIEFE( "PFANDBRIEFE", SOHSTR(PFAND) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TO_BE_ANNOUNCED( "TO_BE_ANNOUNCED", SOHSTR(TBA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::OTHER_ANTICIPATION_NOTES_BAN_GAN_ETC( "OTHER_ANTICIPATION_NOTES_BAN_GAN_ETC", SOHSTR(AN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CERTIFICATE_OF_OBLIGATION( "CERTIFICATE_OF_OBLIGATION", SOHSTR(COFO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::CERTIFICATE_OF_PARTICIPATION( "CERTIFICATE_OF_PARTICIPATION", SOHSTR(COFP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::GENERAL_OBLIGATION_BONDS( "GENERAL_OBLIGATION_BONDS", SOHSTR(GO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MANDATORY_TENDER( "MANDATORY_TENDER", SOHSTR(MT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REVENUE_ANTICIPATION_NOTE( "REVENUE_ANTICIPATION_NOTE", SOHSTR(RAN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::REVENUE_BONDS( "REVENUE_BONDS", SOHSTR(REV) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SPECIAL_ASSESSMENT( "SPECIAL_ASSESSMENT", SOHSTR(SPCLA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SPECIAL_OBLIGATION( "SPECIAL_OBLIGATION", SOHSTR(SPCLO) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::SPECIAL_TAX( "SPECIAL_TAX", SOHSTR(SPCLT) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TAX_ANTICIPATION_NOTE( "TAX_ANTICIPATION_NOTE", SOHSTR(TAN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TAX_ALLOCATION( "TAX_ALLOCATION", SOHSTR(TAXA) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TAX_EXEMPT_COMMERCIAL_PAPER( "TAX_EXEMPT_COMMERCIAL_PAPER", SOHSTR(TECP) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::TAX_REVENUE_ANTICIPATION_NOTE( "TAX_REVENUE_ANTICIPATION_NOTE", SOHSTR(TRAN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::VARIABLE_RATE_DEMAND_NOTE( "VARIABLE_RATE_DEMAND_NOTE", SOHSTR(VRDN) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::WARRANT( "WARRANT", SOHSTR(WAR) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MUTUAL_FUND( "MUTUAL_FUND", SOHSTR(MF) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::MULTI_LEG_INSTRUMENT( "MULTI_LEG_INSTRUMENT", SOHSTR(MLEG) );
const SecurityTypeEnums::ItemType SecurityTypeEnums::NO_SECURITY_TYPE( "NO_SECURITY_TYPE", SOHSTR(NONE) );

const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::BAD_ENUM( "BAD_ENUM", StandInstDbTypeEnums::ITEM_BAD_ENUM );
const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::OTHER( "OTHER", 0 );
const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::DTC_SID( "DTC_SID", 1 );
const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::THOMSON_ALERT( "THOMSON_ALERT", 2 );
const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::A_GLOBAL_CUSTODIAN( "A_GLOBAL_CUSTODIAN", 3 );
const StandInstDbTypeEnums::ItemType StandInstDbTypeEnums::ACCOUNTNET( "ACCOUNTNET", 4 );

const SettlDeliveryTypeEnums::ItemType SettlDeliveryTypeEnums::BAD_ENUM( "BAD_ENUM", SettlDeliveryTypeEnums::ITEM_BAD_ENUM );
const SettlDeliveryTypeEnums::ItemType SettlDeliveryTypeEnums::VERSUS_PAYMENT_DELIVER( "VERSUS_PAYMENT_DELIVER", 0 );
const SettlDeliveryTypeEnums::ItemType SettlDeliveryTypeEnums::FREE_DELIVER( "FREE_DELIVER", 1 );
const SettlDeliveryTypeEnums::ItemType SettlDeliveryTypeEnums::TRI_PARTY( "TRI_PARTY", 2 );
const SettlDeliveryTypeEnums::ItemType SettlDeliveryTypeEnums::HOLD_IN_CUSTODY( "HOLD_IN_CUSTODY", 3 );

const AllocLinkTypeEnums::ItemType AllocLinkTypeEnums::BAD_ENUM( "BAD_ENUM", AllocLinkTypeEnums::ITEM_BAD_ENUM );
const AllocLinkTypeEnums::ItemType AllocLinkTypeEnums::F_X_NETTING( "F_X_NETTING", 0 );
const AllocLinkTypeEnums::ItemType AllocLinkTypeEnums::F_X_SWAP( "F_X_SWAP", 1 );

const PutOrCallEnums::ItemType PutOrCallEnums::BAD_ENUM( "BAD_ENUM", PutOrCallEnums::ITEM_BAD_ENUM );
const PutOrCallEnums::ItemType PutOrCallEnums::PUT( "PUT", 0 );
const PutOrCallEnums::ItemType PutOrCallEnums::CALL( "CALL", 1 );

const CoveredOrUncoveredEnums::ItemType CoveredOrUncoveredEnums::BAD_ENUM( "BAD_ENUM", CoveredOrUncoveredEnums::ITEM_BAD_ENUM );
const CoveredOrUncoveredEnums::ItemType CoveredOrUncoveredEnums::COVERED( "COVERED", 0 );
const CoveredOrUncoveredEnums::ItemType CoveredOrUncoveredEnums::UNCOVERED( "UNCOVERED", 1 );

const NotifyBrokerOfCreditEnums::ItemType NotifyBrokerOfCreditEnums::BAD_ENUM( "BAD_ENUM", NotifyBrokerOfCreditEnums::ITEM_BAD_ENUM );
const NotifyBrokerOfCreditEnums::ItemType NotifyBrokerOfCreditEnums::YES( "YES", 'Y' );
const NotifyBrokerOfCreditEnums::ItemType NotifyBrokerOfCreditEnums::NO( "NO", 'N' );

const AllocHandlInstEnums::ItemType AllocHandlInstEnums::BAD_ENUM( "BAD_ENUM", AllocHandlInstEnums::ITEM_BAD_ENUM );
const AllocHandlInstEnums::ItemType AllocHandlInstEnums::MATCH( "MATCH", 1 );
const AllocHandlInstEnums::ItemType AllocHandlInstEnums::FORWARD( "FORWARD", 2 );
const AllocHandlInstEnums::ItemType AllocHandlInstEnums::FORWARD_AND_MATCH( "FORWARD_AND_MATCH", 3 );

const RoutingTypeEnums::ItemType RoutingTypeEnums::BAD_ENUM( "BAD_ENUM", RoutingTypeEnums::ITEM_BAD_ENUM );
const RoutingTypeEnums::ItemType RoutingTypeEnums::TARGET_FIRM( "TARGET_FIRM", 1 );
const RoutingTypeEnums::ItemType RoutingTypeEnums::TARGET_LIST( "TARGET_LIST", 2 );
const RoutingTypeEnums::ItemType RoutingTypeEnums::BLOCK_FIRM( "BLOCK_FIRM", 3 );
const RoutingTypeEnums::ItemType RoutingTypeEnums::BLOCK_LIST( "BLOCK_LIST", 4 );

const StipulationTypeEnums::ItemType StipulationTypeEnums::BAD_ENUM( "BAD_ENUM", StipulationTypeEnums::ITEM_BAD_ENUM );
const StipulationTypeEnums::ItemType StipulationTypeEnums::AMT( "AMT", SOHSTR(AMT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::AUTO_REINVESTMENT_AT_RATE_OR_BETTER( "AUTO_REINVESTMENT_AT_RATE_OR_BETTER", SOHSTR(AUTOREINV) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::BANK_QUALIFIED( "BANK_QUALIFIED", SOHSTR(BANKQUAL) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::BARGAIN_CONDITIONS_SEE( "BARGAIN_CONDITIONS_SEE", SOHSTR(BGNCON) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::COUPON_RANGE( "COUPON_RANGE", SOHSTR(COUPON) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::ISO_CURRENCY_CODE( "ISO_CURRENCY_CODE", SOHSTR(CURRENCY) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::CUSTOM_START_END_DATE( "CUSTOM_START_END_DATE", SOHSTR(CUSTOMDATE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::GEOGRAPHICS_AND_RANGE( "GEOGRAPHICS_AND_RANGE", SOHSTR(GEOG) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::VALUATION_DISCOUNT( "VALUATION_DISCOUNT", SOHSTR(HAIRCUT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::INSURED( "INSURED", SOHSTR(INSURED) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::YEAR_OR_YEAR_MONTH_OF_ISSUE( "YEAR_OR_YEAR_MONTH_OF_ISSUE", SOHSTR(ISSUE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::ISSUERS_TICKER( "ISSUERS_TICKER", SOHSTR(ISSUER) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::ISSUE_SIZE_RANGE( "ISSUE_SIZE_RANGE", SOHSTR(ISSUESIZE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::LOOKBACK_DAYS( "LOOKBACK_DAYS", SOHSTR(LOOKBACK) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::EXPLICIT_LOT_IDENTIFIER( "EXPLICIT_LOT_IDENTIFIER", SOHSTR(LOT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::LOT_VARIANCE( "LOT_VARIANCE", SOHSTR(LOTVAR) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MATURITY_YEAR_AND_MONTH( "MATURITY_YEAR_AND_MONTH", SOHSTR(MAT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MATURITY_RANGE( "MATURITY_RANGE", SOHSTR(MATURITY) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MAXIMUM_SUBSTITUTIONS( "MAXIMUM_SUBSTITUTIONS", SOHSTR(MAXSUBS) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MINIMUM_QUANTITY( "MINIMUM_QUANTITY", SOHSTR(MINQTY) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MINIMUM_INCREMENT( "MINIMUM_INCREMENT", SOHSTR(MININCR) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MINIMUM_DENOMINATION( "MINIMUM_DENOMINATION", SOHSTR(MINDNOM) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::PAYMENT_FREQUENCY_CALENDAR( "PAYMENT_FREQUENCY_CALENDAR", SOHSTR(PAYFREQ) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::NUMBER_OF_PIECES( "NUMBER_OF_PIECES", SOHSTR(PIECES) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::POOLS_MAXIMUM( "POOLS_MAXIMUM", SOHSTR(PMAX) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::POOLS_PER_MILLION( "POOLS_PER_MILLION", SOHSTR(PPM) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::POOLS_PER_LOT( "POOLS_PER_LOT", SOHSTR(PPL) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::POOLS_PER_TRADE( "POOLS_PER_TRADE", SOHSTR(PPT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::PRICE_RANGE( "PRICE_RANGE", SOHSTR(PRICE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::PRICING_FREQUENCY( "PRICING_FREQUENCY", SOHSTR(PRICEFREQ) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::PRODUCTION_YEAR( "PRODUCTION_YEAR", SOHSTR(PROD) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::CALL_PROTECTION( "CALL_PROTECTION", SOHSTR(PROTECT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::PURPOSE( "PURPOSE", SOHSTR(PURPOSE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::BENCHMARK_PRICE_SOURCE( "BENCHMARK_PRICE_SOURCE", SOHSTR(PXSOURCE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::RATING_SOURCE_AND_RANGE( "RATING_SOURCE_AND_RANGE", SOHSTR(RATING) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::TYPE_OF_REDEMPTION_VALUES_ARE_NONCALLABLE_CALLABLE_PREFUNDED_ESCROWEDTOMATURITY_PUTABLE_CONVERTIBLE( "TYPE_OF_REDEMPTION_VALUES_ARE_NONCALLABLE_CALLABLE_PREFUNDED_ESCROWEDTOMATURITY_PUTABLE_CONVERTIBLE", SOHSTR(REDEMPTION) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::RESTRICTED( "RESTRICTED", SOHSTR(RESTRICTED) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::MARKET_SECTOR( "MARKET_SECTOR", SOHSTR(SECTOR) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::SECURITYTYPE_INCLUDED_OR_EXCLUDED( "SECURITYTYPE_INCLUDED_OR_EXCLUDED", SOHSTR(SECTYPE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::STRUCTURE( "STRUCTURE", SOHSTR(STRUCT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::SUBSTITUTIONS_FREQUENCY( "SUBSTITUTIONS_FREQUENCY", SOHSTR(SUBSFREQ) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::SUBSTITUTIONS_LEFT( "SUBSTITUTIONS_LEFT", SOHSTR(SUBSLEFT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::FREEFORM_TEXT( "FREEFORM_TEXT", SOHSTR(TEXT) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::TRADE_VARIANCE( "TRADE_VARIANCE", SOHSTR(TRDVAR) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::WEIGHTED_AVERAGE_COUPONVALUE_IN_PERCENT( "WEIGHTED_AVERAGE_COUPONVALUE_IN_PERCENT", SOHSTR(WAC) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::WEIGHTED_AVERAGE_LIFE_COUPON_VALUE_IN_PERCENT( "WEIGHTED_AVERAGE_LIFE_COUPON_VALUE_IN_PERCENT", SOHSTR(WAL) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::WEIGHTED_AVERAGE_LOAN_AGE_VALUE_IN_MONTHS( "WEIGHTED_AVERAGE_LOAN_AGE_VALUE_IN_MONTHS", SOHSTR(WALA) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::WEIGHTED_AVERAGE_MATURITY_VALUE_IN_MONTHS( "WEIGHTED_AVERAGE_MATURITY_VALUE_IN_MONTHS", SOHSTR(WAM) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::WHOLE_POOL( "WHOLE_POOL", SOHSTR(WHOLE) );
const StipulationTypeEnums::ItemType StipulationTypeEnums::YIELD_RANGE( "YIELD_RANGE", SOHSTR(YIELD) );

const YieldTypeEnums::ItemType YieldTypeEnums::BAD_ENUM( "BAD_ENUM", YieldTypeEnums::ITEM_BAD_ENUM );
const YieldTypeEnums::ItemType YieldTypeEnums::AFTER_TAX_YIELD( "AFTER_TAX_YIELD", SOHSTR(AFTERTAX) );
const YieldTypeEnums::ItemType YieldTypeEnums::ANNUAL_YIELD( "ANNUAL_YIELD", SOHSTR(ANNUAL) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_AT_ISSUE( "YIELD_AT_ISSUE", SOHSTR(ATISSUE) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_AVERAGE_MATURITY( "YIELD_TO_AVERAGE_MATURITY", SOHSTR(AVGMATURITY) );
const YieldTypeEnums::ItemType YieldTypeEnums::BOOK_YIELD( "BOOK_YIELD", SOHSTR(BOOK) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_NEXT_CALL( "YIELD_TO_NEXT_CALL", SOHSTR(CALL) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_CHANGE_SINCE_CLOSE( "YIELD_CHANGE_SINCE_CLOSE", SOHSTR(CHANGE) );
const YieldTypeEnums::ItemType YieldTypeEnums::CLOSING_YIELD( "CLOSING_YIELD", SOHSTR(CLOSE) );
const YieldTypeEnums::ItemType YieldTypeEnums::COMPOUND_YIELD( "COMPOUND_YIELD", SOHSTR(COMPOUND) );
const YieldTypeEnums::ItemType YieldTypeEnums::CURRENT_YIELD( "CURRENT_YIELD", SOHSTR(CURRENT) );
const YieldTypeEnums::ItemType YieldTypeEnums::TRUE_GROSS_YIELD( "TRUE_GROSS_YIELD", SOHSTR(GROSS) );
const YieldTypeEnums::ItemType YieldTypeEnums::GOVERNMENT_EQUIVALENT_YIELD( "GOVERNMENT_EQUIVALENT_YIELD", SOHSTR(GOVTEQUIV) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_WITH_INFLATION_ASSUMPTION( "YIELD_WITH_INFLATION_ASSUMPTION", SOHSTR(INFLATION) );
const YieldTypeEnums::ItemType YieldTypeEnums::INVERSE_FLOATER_BOND_YIELD( "INVERSE_FLOATER_BOND_YIELD", SOHSTR(INVERSEFLOATER) );
const YieldTypeEnums::ItemType YieldTypeEnums::MOST_RECENT_CLOSING_YIELD( "MOST_RECENT_CLOSING_YIELD", SOHSTR(LASTCLOSE) );
const YieldTypeEnums::ItemType YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_MONTH( "CLOSING_YIELD_MOST_RECENT_MONTH", SOHSTR(LASTMONTH) );
const YieldTypeEnums::ItemType YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_QUARTER( "CLOSING_YIELD_MOST_RECENT_QUARTER", SOHSTR(LASTQUARTER) );
const YieldTypeEnums::ItemType YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_YEAR( "CLOSING_YIELD_MOST_RECENT_YEAR", SOHSTR(LASTYEAR) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_LONGEST_AVERAGE_LIFE( "YIELD_TO_LONGEST_AVERAGE_LIFE", SOHSTR(LONGAVGLIFE) );
const YieldTypeEnums::ItemType YieldTypeEnums::MARK_TO_MARKET_YIELD( "MARK_TO_MARKET_YIELD", SOHSTR(MARK) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_MATURITY( "YIELD_TO_MATURITY", SOHSTR(MATURITY) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_NEXT_REFUND( "YIELD_TO_NEXT_REFUND", SOHSTR(NEXTREFUND) );
const YieldTypeEnums::ItemType YieldTypeEnums::OPEN_AVERAGE_YIELD( "OPEN_AVERAGE_YIELD", SOHSTR(OPENAVG) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_NEXT_PUT( "YIELD_TO_NEXT_PUT", SOHSTR(PUT) );
const YieldTypeEnums::ItemType YieldTypeEnums::PREVIOUS_CLOSE_YIELD( "PREVIOUS_CLOSE_YIELD", SOHSTR(PREVCLOSE) );
const YieldTypeEnums::ItemType YieldTypeEnums::PROCEEDS_YIELD( "PROCEEDS_YIELD", SOHSTR(PROCEEDS) );
const YieldTypeEnums::ItemType YieldTypeEnums::SEMI_ANNUAL_YIELD( "SEMI_ANNUAL_YIELD", SOHSTR(SEMIANNUAL) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_SHORTEST_AVERAGE_LIFE( "YIELD_TO_SHORTEST_AVERAGE_LIFE", SOHSTR(SHORTAVGLIFE) );
const YieldTypeEnums::ItemType YieldTypeEnums::SIMPLE_YIELD( "SIMPLE_YIELD", SOHSTR(SIMPLE) );
const YieldTypeEnums::ItemType YieldTypeEnums::TAX_EQUIVALENT_YIELD( "TAX_EQUIVALENT_YIELD", SOHSTR(TAXEQUIV) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_TENDER_DATE( "YIELD_TO_TENDER_DATE", SOHSTR(TENDER) );
const YieldTypeEnums::ItemType YieldTypeEnums::TRUE_YIELD( "TRUE_YIELD", SOHSTR(TRUE) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_VALUE_OF_1_32( "YIELD_VALUE_OF_1_32", SOHSTR(VALUE1/32) );
const YieldTypeEnums::ItemType YieldTypeEnums::YIELD_TO_WORST( "YIELD_TO_WORST", SOHSTR(WORST) );

const TradedFlatSwitchEnums::ItemType TradedFlatSwitchEnums::BAD_ENUM( "BAD_ENUM", TradedFlatSwitchEnums::ITEM_BAD_ENUM );
const TradedFlatSwitchEnums::ItemType TradedFlatSwitchEnums::YES( "YES", 'Y' );
const TradedFlatSwitchEnums::ItemType TradedFlatSwitchEnums::NO( "NO", 'N' );

const SubscriptionRequestTypeEnums::ItemType SubscriptionRequestTypeEnums::BAD_ENUM( "BAD_ENUM", SubscriptionRequestTypeEnums::ITEM_BAD_ENUM );
const SubscriptionRequestTypeEnums::ItemType SubscriptionRequestTypeEnums::SNAPSHOT( "SNAPSHOT", '0' );
const SubscriptionRequestTypeEnums::ItemType SubscriptionRequestTypeEnums::SNAPSHOT_PLUS_UPDATES( "SNAPSHOT_PLUS_UPDATES", '1' );
const SubscriptionRequestTypeEnums::ItemType SubscriptionRequestTypeEnums::DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST( "DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST", '2' );

const MDUpdateTypeEnums::ItemType MDUpdateTypeEnums::BAD_ENUM( "BAD_ENUM", MDUpdateTypeEnums::ITEM_BAD_ENUM );
const MDUpdateTypeEnums::ItemType MDUpdateTypeEnums::FULL_REFRESH( "FULL_REFRESH", 0 );
const MDUpdateTypeEnums::ItemType MDUpdateTypeEnums::INCREMENTAL_REFRESH( "INCREMENTAL_REFRESH", 1 );

const AggregatedBookEnums::ItemType AggregatedBookEnums::BAD_ENUM( "BAD_ENUM", AggregatedBookEnums::ITEM_BAD_ENUM );
const AggregatedBookEnums::ItemType AggregatedBookEnums::YES( "YES", 'Y' );
const AggregatedBookEnums::ItemType AggregatedBookEnums::NO( "NO", 'N' );

const MDEntryTypeEnums::ItemType MDEntryTypeEnums::BAD_ENUM( "BAD_ENUM", MDEntryTypeEnums::ITEM_BAD_ENUM );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::BID( "BID", '0' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::OFFER( "OFFER", '1' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::TRADE( "TRADE", '2' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::INDEX_VALUE( "INDEX_VALUE", '3' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::OPENING_PRICE( "OPENING_PRICE", '4' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::CLOSING_PRICE( "CLOSING_PRICE", '5' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::SETTLEMENT_PRICE( "SETTLEMENT_PRICE", '6' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::TRADING_SESSION_HIGH_PRICE( "TRADING_SESSION_HIGH_PRICE", '7' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::TRADING_SESSION_LOW_PRICE( "TRADING_SESSION_LOW_PRICE", '8' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::TRADING_SESSION_VWAP_PRICE( "TRADING_SESSION_VWAP_PRICE", '9' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::IMBALANCE( "IMBALANCE", 'A' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::TRADE_VOLUME( "TRADE_VOLUME", 'B' );
const MDEntryTypeEnums::ItemType MDEntryTypeEnums::OPEN_INTEREST( "OPEN_INTEREST", 'C' );

const TickDirectionEnums::ItemType TickDirectionEnums::BAD_ENUM( "BAD_ENUM", TickDirectionEnums::ITEM_BAD_ENUM );
const TickDirectionEnums::ItemType TickDirectionEnums::PLUS_TICK( "PLUS_TICK", '0' );
const TickDirectionEnums::ItemType TickDirectionEnums::ZERO_PLUS_TICK( "ZERO_PLUS_TICK", '1' );
const TickDirectionEnums::ItemType TickDirectionEnums::MINUS_TICK( "MINUS_TICK", '2' );
const TickDirectionEnums::ItemType TickDirectionEnums::ZERO_MINUS_TICK( "ZERO_MINUS_TICK", '3' );

const QuoteConditionEnums::ItemType QuoteConditionEnums::BAD_ENUM( "BAD_ENUM", QuoteConditionEnums::ITEM_BAD_ENUM );
const QuoteConditionEnums::ItemType QuoteConditionEnums::OPEN( "OPEN", SOHSTR(A) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::CLOSED( "CLOSED", SOHSTR(B) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::EXCHANGE_BEST( "EXCHANGE_BEST", SOHSTR(C) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::CONSOLIDATED_BEST( "CONSOLIDATED_BEST", SOHSTR(D) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::LOCKED( "LOCKED", SOHSTR(E) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::CROSSED( "CROSSED", SOHSTR(F) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::DEPTH( "DEPTH", SOHSTR(G) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::FAST_TRADING( "FAST_TRADING", SOHSTR(H) );
const QuoteConditionEnums::ItemType QuoteConditionEnums::NON_FIRM( "NON_FIRM", SOHSTR(I) );

const TradeConditionEnums::ItemType TradeConditionEnums::BAD_ENUM( "BAD_ENUM", TradeConditionEnums::ITEM_BAD_ENUM );
const TradeConditionEnums::ItemType TradeConditionEnums::CASH( "CASH", SOHSTR(A) );
const TradeConditionEnums::ItemType TradeConditionEnums::AVERAGE_PRICE_TRADE( "AVERAGE_PRICE_TRADE", SOHSTR(B) );
const TradeConditionEnums::ItemType TradeConditionEnums::CASH_TRADE( "CASH_TRADE", SOHSTR(C) );
const TradeConditionEnums::ItemType TradeConditionEnums::NEXT_DAY( "NEXT_DAY", SOHSTR(D) );
const TradeConditionEnums::ItemType TradeConditionEnums::OPENING( "OPENING", SOHSTR(E) );
const TradeConditionEnums::ItemType TradeConditionEnums::INTRADAY_TRADE_DETAIL( "INTRADAY_TRADE_DETAIL", SOHSTR(F) );
const TradeConditionEnums::ItemType TradeConditionEnums::RULE_127_TRADE( "RULE_127_TRADE", SOHSTR(G) );
const TradeConditionEnums::ItemType TradeConditionEnums::RULE_155_TRADE( "RULE_155_TRADE", SOHSTR(H) );
const TradeConditionEnums::ItemType TradeConditionEnums::SOLD_LAST( "SOLD_LAST", SOHSTR(I) );
const TradeConditionEnums::ItemType TradeConditionEnums::NEXT_DAY_TRADE( "NEXT_DAY_TRADE", SOHSTR(J) );
const TradeConditionEnums::ItemType TradeConditionEnums::OPENED( "OPENED", SOHSTR(K) );
const TradeConditionEnums::ItemType TradeConditionEnums::SELLER( "SELLER", SOHSTR(L) );
const TradeConditionEnums::ItemType TradeConditionEnums::SOLD( "SOLD", SOHSTR(M) );
const TradeConditionEnums::ItemType TradeConditionEnums::STOPPED_STOCK( "STOPPED_STOCK", SOHSTR(N) );
const TradeConditionEnums::ItemType TradeConditionEnums::IMBALANCE_MORE_BUYERS( "IMBALANCE_MORE_BUYERS", SOHSTR(P) );
const TradeConditionEnums::ItemType TradeConditionEnums::IMBALANCE_MORE_SELLERS( "IMBALANCE_MORE_SELLERS", SOHSTR(Q) );
const TradeConditionEnums::ItemType TradeConditionEnums::OPENING_PRICE( "OPENING_PRICE", SOHSTR(R) );

const MDUpdateActionEnums::ItemType MDUpdateActionEnums::BAD_ENUM( "BAD_ENUM", MDUpdateActionEnums::ITEM_BAD_ENUM );
const MDUpdateActionEnums::ItemType MDUpdateActionEnums::NEW( "NEW", '0' );
const MDUpdateActionEnums::ItemType MDUpdateActionEnums::CHANGE( "CHANGE", '1' );
const MDUpdateActionEnums::ItemType MDUpdateActionEnums::DELETE( "DELETE", '2' );

const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::BAD_ENUM( "BAD_ENUM", MDReqRejReasonEnums::ITEM_BAD_ENUM );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNKNOWN_SYMBOL( "UNKNOWN_SYMBOL", '0' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::DUPLICATE_MDREQID( "DUPLICATE_MDREQID", '1' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::INSUFFICIENT_BANDWIDTH( "INSUFFICIENT_BANDWIDTH", '2' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::INSUFFICIENT_PERMISSIONS( "INSUFFICIENT_PERMISSIONS", '3' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE( "UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE", '4' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_MARKETDEPTH( "UNSUPPORTED_MARKETDEPTH", '5' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_MDUPDATETYPE( "UNSUPPORTED_MDUPDATETYPE", '6' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_AGGREGATEDBOOK( "UNSUPPORTED_AGGREGATEDBOOK", '7' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_MDENTRYTYPE( "UNSUPPORTED_MDENTRYTYPE", '8' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_TRADINGSESSIONID( "UNSUPPORTED_TRADINGSESSIONID", '9' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_SCOPE( "UNSUPPORTED_SCOPE", 'A' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_OPENCLOSESETTLEFLAG( "UNSUPPORTED_OPENCLOSESETTLEFLAG", 'B' );
const MDReqRejReasonEnums::ItemType MDReqRejReasonEnums::UNSUPPORTED_MDIMPLICITDELETE( "UNSUPPORTED_MDIMPLICITDELETE", 'C' );

const DeleteReasonEnums::ItemType DeleteReasonEnums::BAD_ENUM( "BAD_ENUM", DeleteReasonEnums::ITEM_BAD_ENUM );
const DeleteReasonEnums::ItemType DeleteReasonEnums::CANCELATION( "CANCELATION", '0' );
const DeleteReasonEnums::ItemType DeleteReasonEnums::ERROR( "ERROR", '1' );

const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::BAD_ENUM( "BAD_ENUM", OpenCloseSettlFlagEnums::ITEM_BAD_ENUM );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::DAILY_OPEN( "DAILY_OPEN", SOHSTR(0) );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::SESSION_OPEN( "SESSION_OPEN", SOHSTR(1) );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::DELIVERY_SETTLEMENT_ENTRY( "DELIVERY_SETTLEMENT_ENTRY", SOHSTR(2) );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::EXPECTED_ENTRY( "EXPECTED_ENTRY", SOHSTR(3) );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::ENTRY_FROM_PREVIOUS_BUSINESS_DAY( "ENTRY_FROM_PREVIOUS_BUSINESS_DAY", SOHSTR(4) );
const OpenCloseSettlFlagEnums::ItemType OpenCloseSettlFlagEnums::THEORETICAL_PRICE_VALUE( "THEORETICAL_PRICE_VALUE", SOHSTR(5) );

const FinancialStatusEnums::ItemType FinancialStatusEnums::BAD_ENUM( "BAD_ENUM", FinancialStatusEnums::ITEM_BAD_ENUM );
const FinancialStatusEnums::ItemType FinancialStatusEnums::BANKRUPT( "BANKRUPT", SOHSTR(1) );
const FinancialStatusEnums::ItemType FinancialStatusEnums::PENDING_DELISTING( "PENDING_DELISTING", SOHSTR(2) );

const CorporateActionEnums::ItemType CorporateActionEnums::BAD_ENUM( "BAD_ENUM", CorporateActionEnums::ITEM_BAD_ENUM );
const CorporateActionEnums::ItemType CorporateActionEnums::EX_DIVIDEND( "EX_DIVIDEND", SOHSTR(A) );
const CorporateActionEnums::ItemType CorporateActionEnums::EX_DISTRIBUTION( "EX_DISTRIBUTION", SOHSTR(B) );
const CorporateActionEnums::ItemType CorporateActionEnums::EX_RIGHTS( "EX_RIGHTS", SOHSTR(C) );
const CorporateActionEnums::ItemType CorporateActionEnums::NEW( "NEW", SOHSTR(D) );
const CorporateActionEnums::ItemType CorporateActionEnums::EX_INTEREST( "EX_INTEREST", SOHSTR(E) );

const QuoteStatusEnums::ItemType QuoteStatusEnums::BAD_ENUM( "BAD_ENUM", QuoteStatusEnums::ITEM_BAD_ENUM );
const QuoteStatusEnums::ItemType QuoteStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_FOR_SYMBOL( "CANCELED_FOR_SYMBOL", 1 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_FOR_SECURITY_TYPE( "CANCELED_FOR_SECURITY_TYPE", 2 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_FOR_UNDERLYING( "CANCELED_FOR_UNDERLYING", 3 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_ALL( "CANCELED_ALL", 4 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::REJECTED( "REJECTED", 5 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::REMOVED_FROM_MARKET( "REMOVED_FROM_MARKET", 6 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::EXPIRED( "EXPIRED", 7 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::QUERY( "QUERY", 8 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::QUOTE_NOT_FOUND( "QUOTE_NOT_FOUND", 9 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::PENDING( "PENDING", 10 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::PASS( "PASS", 11 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::LOCKED_MARKET_WARNING( "LOCKED_MARKET_WARNING", 12 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CROSS_MARKET_WARNING( "CROSS_MARKET_WARNING", 13 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_DUE_TO_LOCK_MARKET( "CANCELED_DUE_TO_LOCK_MARKET", 14 );
const QuoteStatusEnums::ItemType QuoteStatusEnums::CANCELED_DUE_TO_CROSS_MARKET( "CANCELED_DUE_TO_CROSS_MARKET", 15 );

const QuoteCancelTypeEnums::ItemType QuoteCancelTypeEnums::BAD_ENUM( "BAD_ENUM", QuoteCancelTypeEnums::ITEM_BAD_ENUM );
const QuoteCancelTypeEnums::ItemType QuoteCancelTypeEnums::CANCEL_FOR_SYMBOL( "CANCEL_FOR_SYMBOL", 1 );
const QuoteCancelTypeEnums::ItemType QuoteCancelTypeEnums::CANCEL_FOR_SECURITY_TYPE( "CANCEL_FOR_SECURITY_TYPE", 2 );
const QuoteCancelTypeEnums::ItemType QuoteCancelTypeEnums::CANCEL_FOR_UNDERLYING_SYMBOL( "CANCEL_FOR_UNDERLYING_SYMBOL", 3 );
const QuoteCancelTypeEnums::ItemType QuoteCancelTypeEnums::CANCEL_ALL_QUOTES( "CANCEL_ALL_QUOTES", 4 );

const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::BAD_ENUM( "BAD_ENUM", QuoteRejectReasonEnums::ITEM_BAD_ENUM );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::UNKNOWN_SYMBOL( "UNKNOWN_SYMBOL", 1 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::EXCHANGE( "EXCHANGE", 2 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT( "QUOTE_REQUEST_EXCEEDS_LIMIT", 3 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::TOO_LATE_TO_ENTER( "TOO_LATE_TO_ENTER", 4 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::UNKNOWN_QUOTE( "UNKNOWN_QUOTE", 5 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::DUPLICATE_QUOTE( "DUPLICATE_QUOTE", 6 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::INVALID_BID_ASK_SPREAD( "INVALID_BID_ASK_SPREAD", 7 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::INVALID_PRICE( "INVALID_PRICE", 8 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::NOT_AUTHORIZED_TO_QUOTE_SECURITY( "NOT_AUTHORIZED_TO_QUOTE_SECURITY", 9 );
const QuoteRejectReasonEnums::ItemType QuoteRejectReasonEnums::OTHER( "OTHER", 99 );

const QuoteResponseLevelEnums::ItemType QuoteResponseLevelEnums::BAD_ENUM( "BAD_ENUM", QuoteResponseLevelEnums::ITEM_BAD_ENUM );
const QuoteResponseLevelEnums::ItemType QuoteResponseLevelEnums::NO_ACKNOWLEDGEMENT( "NO_ACKNOWLEDGEMENT", 0 );
const QuoteResponseLevelEnums::ItemType QuoteResponseLevelEnums::ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES( "ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES", 1 );
const QuoteResponseLevelEnums::ItemType QuoteResponseLevelEnums::ACKNOWLEDGE_EACH_QUOTE_MESSAGES( "ACKNOWLEDGE_EACH_QUOTE_MESSAGES", 2 );

const QuoteRequestTypeEnums::ItemType QuoteRequestTypeEnums::BAD_ENUM( "BAD_ENUM", QuoteRequestTypeEnums::ITEM_BAD_ENUM );
const QuoteRequestTypeEnums::ItemType QuoteRequestTypeEnums::MANUAL( "MANUAL", 1 );
const QuoteRequestTypeEnums::ItemType QuoteRequestTypeEnums::AUTOMATIC( "AUTOMATIC", 2 );

const SecurityRequestTypeEnums::ItemType SecurityRequestTypeEnums::BAD_ENUM( "BAD_ENUM", SecurityRequestTypeEnums::ITEM_BAD_ENUM );
const SecurityRequestTypeEnums::ItemType SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS( "REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS", 0 );
const SecurityRequestTypeEnums::ItemType SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED( "REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED", 1 );
const SecurityRequestTypeEnums::ItemType SecurityRequestTypeEnums::REQUEST_LIST_SECURITY_TYPES( "REQUEST_LIST_SECURITY_TYPES", 2 );
const SecurityRequestTypeEnums::ItemType SecurityRequestTypeEnums::REQUEST_LIST_SECURITIES( "REQUEST_LIST_SECURITIES", 3 );

const SecurityResponseTypeEnums::ItemType SecurityResponseTypeEnums::BAD_ENUM( "BAD_ENUM", SecurityResponseTypeEnums::ITEM_BAD_ENUM );
const SecurityResponseTypeEnums::ItemType SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_AS_IS( "ACCEPT_SECURITY_PROPOSAL_AS_IS", 1 );
const SecurityResponseTypeEnums::ItemType SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE( "ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE", 2 );
const SecurityResponseTypeEnums::ItemType SecurityResponseTypeEnums::REJECT_SECURITY_PROPOSAL( "REJECT_SECURITY_PROPOSAL", 5 );
const SecurityResponseTypeEnums::ItemType SecurityResponseTypeEnums::CAN_NOT_MATCH_SELECTION_CRITERIA( "CAN_NOT_MATCH_SELECTION_CRITERIA", 6 );

const UnsolicitedIndicatorEnums::ItemType UnsolicitedIndicatorEnums::BAD_ENUM( "BAD_ENUM", UnsolicitedIndicatorEnums::ITEM_BAD_ENUM );
const UnsolicitedIndicatorEnums::ItemType UnsolicitedIndicatorEnums::YES( "YES", 'Y' );
const UnsolicitedIndicatorEnums::ItemType UnsolicitedIndicatorEnums::NO( "NO", 'N' );

const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::BAD_ENUM( "BAD_ENUM", SecurityTradingStatusEnums::ITEM_BAD_ENUM );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::OPENING_DELAY( "OPENING_DELAY", 1 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::TRADING_HALT( "TRADING_HALT", 2 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::RESUME( "RESUME", 3 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NO_OPEN_NO_RESUME( "NO_OPEN_NO_RESUME", 4 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::PRICE_INDICATION( "PRICE_INDICATION", 5 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::TRADING_RANGE_INDICATION( "TRADING_RANGE_INDICATION", 6 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::MARKET_IMBALANCE_BUY( "MARKET_IMBALANCE_BUY", 7 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::MARKET_IMBALANCE_SELL( "MARKET_IMBALANCE_SELL", 8 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_BUY( "MARKET_ON_CLOSE_IMBALANCE_BUY", 9 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_SELL( "MARKET_ON_CLOSE_IMBALANCE_SELL", 10 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NO_MARKET_IMBALANCE( "NO_MARKET_IMBALANCE", 12 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NO_MARKET_ON_CLOSE_IMBALANCE( "NO_MARKET_ON_CLOSE_IMBALANCE", 13 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::ITS_PRE_OPENING( "ITS_PRE_OPENING", 14 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NEW_PRICE_INDICATION( "NEW_PRICE_INDICATION", 15 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::TRADE_DISSEMINATION_TIME( "TRADE_DISSEMINATION_TIME", 16 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::READY_TO_TRADE( "READY_TO_TRADE", 17 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NOT_AVAILABLE_FOR_TRADING( "NOT_AVAILABLE_FOR_TRADING", 18 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::NOT_TRADED_ON_THIS_MARKET( "NOT_TRADED_ON_THIS_MARKET", 19 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::UNKNOWN_OR_INVALID( "UNKNOWN_OR_INVALID", 20 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::PRE_OPEN( "PRE_OPEN", 21 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::OPENING_ROTATION( "OPENING_ROTATION", 22 );
const SecurityTradingStatusEnums::ItemType SecurityTradingStatusEnums::FAST_MARKET( "FAST_MARKET", 23 );

const HaltReasonCharEnums::ItemType HaltReasonCharEnums::BAD_ENUM( "BAD_ENUM", HaltReasonCharEnums::ITEM_BAD_ENUM );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::ORDER_IMBALANCE( "ORDER_IMBALANCE", 'I' );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::EQUIPMENT_CHANGEOVER( "EQUIPMENT_CHANGEOVER", 'X' );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::NEWS_PENDING( "NEWS_PENDING", 'P' );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::NEWS_DISSEMINATION( "NEWS_DISSEMINATION", 'D' );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::ORDER_INFLUX( "ORDER_INFLUX", 'E' );
const HaltReasonCharEnums::ItemType HaltReasonCharEnums::ADDITIONAL_INFORMATION( "ADDITIONAL_INFORMATION", 'M' );

const InViewOfCommonEnums::ItemType InViewOfCommonEnums::BAD_ENUM( "BAD_ENUM", InViewOfCommonEnums::ITEM_BAD_ENUM );
const InViewOfCommonEnums::ItemType InViewOfCommonEnums::YES( "YES", 'Y' );
const InViewOfCommonEnums::ItemType InViewOfCommonEnums::NO( "NO", 'N' );

const DueToRelatedEnums::ItemType DueToRelatedEnums::BAD_ENUM( "BAD_ENUM", DueToRelatedEnums::ITEM_BAD_ENUM );
const DueToRelatedEnums::ItemType DueToRelatedEnums::YES( "YES", 'Y' );
const DueToRelatedEnums::ItemType DueToRelatedEnums::NO( "NO", 'N' );

const AdjustmentEnums::ItemType AdjustmentEnums::BAD_ENUM( "BAD_ENUM", AdjustmentEnums::ITEM_BAD_ENUM );
const AdjustmentEnums::ItemType AdjustmentEnums::CANCEL( "CANCEL", 1 );
const AdjustmentEnums::ItemType AdjustmentEnums::ERROR( "ERROR", 2 );
const AdjustmentEnums::ItemType AdjustmentEnums::CORRECTION( "CORRECTION", 3 );

const TradSesMethodEnums::ItemType TradSesMethodEnums::BAD_ENUM( "BAD_ENUM", TradSesMethodEnums::ITEM_BAD_ENUM );
const TradSesMethodEnums::ItemType TradSesMethodEnums::ELECTRONIC( "ELECTRONIC", 1 );
const TradSesMethodEnums::ItemType TradSesMethodEnums::OPEN_OUTCRY( "OPEN_OUTCRY", 2 );
const TradSesMethodEnums::ItemType TradSesMethodEnums::TWO_PARTY( "TWO_PARTY", 3 );

const TradSesModeEnums::ItemType TradSesModeEnums::BAD_ENUM( "BAD_ENUM", TradSesModeEnums::ITEM_BAD_ENUM );
const TradSesModeEnums::ItemType TradSesModeEnums::TESTING( "TESTING", 1 );
const TradSesModeEnums::ItemType TradSesModeEnums::SIMULATED( "SIMULATED", 2 );
const TradSesModeEnums::ItemType TradSesModeEnums::PRODUCTION( "PRODUCTION", 3 );

const TradSesStatusEnums::ItemType TradSesStatusEnums::BAD_ENUM( "BAD_ENUM", TradSesStatusEnums::ITEM_BAD_ENUM );
const TradSesStatusEnums::ItemType TradSesStatusEnums::UNKNOWN( "UNKNOWN", 0 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::HALTED( "HALTED", 1 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::OPEN( "OPEN", 2 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::CLOSED( "CLOSED", 3 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::PRE_OPEN( "PRE_OPEN", 4 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::PRE_CLOSE( "PRE_CLOSE", 5 );
const TradSesStatusEnums::ItemType TradSesStatusEnums::REQUEST_REJECTED( "REQUEST_REJECTED", 6 );

const MessageEncodingEnums::ItemType MessageEncodingEnums::BAD_ENUM( "BAD_ENUM", MessageEncodingEnums::ITEM_BAD_ENUM );
const MessageEncodingEnums::ItemType MessageEncodingEnums::JIS( "JIS", SOHSTR(ISO-2022-JP) );
const MessageEncodingEnums::ItemType MessageEncodingEnums::EUC( "EUC", SOHSTR(EUC-JP) );
const MessageEncodingEnums::ItemType MessageEncodingEnums::FOR_USING_SJIS( "FOR_USING_SJIS", SOHSTR(Shift_JIS) );
const MessageEncodingEnums::ItemType MessageEncodingEnums::UNICODE( "UNICODE", SOHSTR(UTF-8) );

const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::BAD_ENUM( "BAD_ENUM", SessionRejectReasonEnums::ITEM_BAD_ENUM );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::INVALID_TAG_NUMBER( "INVALID_TAG_NUMBER", 0 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::REQUIRED_TAG_MISSING( "REQUIRED_TAG_MISSING", 1 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE( "TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE", 2 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::UNDEFINED_TAG( "UNDEFINED_TAG", 3 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::TAG_SPECIFIED_WITHOUT_A_VALUE( "TAG_SPECIFIED_WITHOUT_A_VALUE", 4 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::VALUE_IS_INCORRECT( "VALUE_IS_INCORRECT", 5 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::INCORRECT_DATA_FORMAT_FOR_VALUE( "INCORRECT_DATA_FORMAT_FOR_VALUE", 6 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::DECRYPTION_PROBLEM( "DECRYPTION_PROBLEM", 7 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::SIGNATURE_PROBLEM( "SIGNATURE_PROBLEM", 8 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::COMPID_PROBLEM( "COMPID_PROBLEM", 9 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::SENDINGTIME_ACCURACY_PROBLEM( "SENDINGTIME_ACCURACY_PROBLEM", 10 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::INVALID_MSGTYPE( "INVALID_MSGTYPE", 11 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::XML_VALIDATION_ERROR( "XML_VALIDATION_ERROR", 12 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::TAG_APPEARS_MORE_THAN_ONCE( "TAG_APPEARS_MORE_THAN_ONCE", 13 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER( "TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER", 14 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::REPEATING_GROUP_FIELDS_OUT_OF_ORDER( "REPEATING_GROUP_FIELDS_OUT_OF_ORDER", 15 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP( "INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP", 16 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER( "NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER", 17 );
const SessionRejectReasonEnums::ItemType SessionRejectReasonEnums::OTHER( "OTHER", 99 );

const BidRequestTransTypeEnums::ItemType BidRequestTransTypeEnums::BAD_ENUM( "BAD_ENUM", BidRequestTransTypeEnums::ITEM_BAD_ENUM );
const BidRequestTransTypeEnums::ItemType BidRequestTransTypeEnums::NEW( "NEW", 'N' );
const BidRequestTransTypeEnums::ItemType BidRequestTransTypeEnums::CANCEL( "CANCEL", 'C' );

const SolicitedFlagEnums::ItemType SolicitedFlagEnums::BAD_ENUM( "BAD_ENUM", SolicitedFlagEnums::ITEM_BAD_ENUM );
const SolicitedFlagEnums::ItemType SolicitedFlagEnums::YES( "YES", 'Y' );
const SolicitedFlagEnums::ItemType SolicitedFlagEnums::NO( "NO", 'N' );

const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::BAD_ENUM( "BAD_ENUM", ExecRestatementReasonEnums::ITEM_BAD_ENUM );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::GT_CORPORATE_ACTION( "GT_CORPORATE_ACTION", 0 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::GT_RENEWAL( "GT_RENEWAL", 1 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::VERBAL_CHANGE( "VERBAL_CHANGE", 2 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::REPRICING_OF_ORDER( "REPRICING_OF_ORDER", 3 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::BROKER_OPTION( "BROKER_OPTION", 4 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::PARTIAL_DECLINE_OF_ORDERQTY( "PARTIAL_DECLINE_OF_ORDERQTY", 5 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::CANCEL_ON_TRADING_HALT( "CANCEL_ON_TRADING_HALT", 6 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::CANCEL_ON_SYSTEM_FAILURE( "CANCEL_ON_SYSTEM_FAILURE", 7 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::MARKET( "MARKET", 8 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::CANCELED_NOT_BEST( "CANCELED_NOT_BEST", 9 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::WAREHOUSE_RECAP( "WAREHOUSE_RECAP", 10 );
const ExecRestatementReasonEnums::ItemType ExecRestatementReasonEnums::OTHER( "OTHER", 99 );

const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::BAD_ENUM( "BAD_ENUM", BusinessRejectReasonEnums::ITEM_BAD_ENUM );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::OTHER( "OTHER", 0 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::UNKOWN_ID( "UNKOWN_ID", 1 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::UNKNOWN_SECURITY( "UNKNOWN_SECURITY", 2 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::UNSUPPORTED_MESSAGE_TYPE( "UNSUPPORTED_MESSAGE_TYPE", 3 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::APPLICATION_NOT_AVAILABLE( "APPLICATION_NOT_AVAILABLE", 4 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::CONDITIONALLY_REQUIRED_FIELD_MISSING( "CONDITIONALLY_REQUIRED_FIELD_MISSING", 5 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::NOT_AUTHORIZED( "NOT_AUTHORIZED", 6 );
const BusinessRejectReasonEnums::ItemType BusinessRejectReasonEnums::DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME( "DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME", 7 );

const MsgDirectionEnums::ItemType MsgDirectionEnums::BAD_ENUM( "BAD_ENUM", MsgDirectionEnums::ITEM_BAD_ENUM );
const MsgDirectionEnums::ItemType MsgDirectionEnums::SEND( "SEND", 'S' );
const MsgDirectionEnums::ItemType MsgDirectionEnums::RECEIVE( "RECEIVE", 'R' );

const DiscretionInstEnums::ItemType DiscretionInstEnums::BAD_ENUM( "BAD_ENUM", DiscretionInstEnums::ITEM_BAD_ENUM );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_DISPLAYED_PRICE( "RELATED_TO_DISPLAYED_PRICE", '0' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_MARKET_PRICE( "RELATED_TO_MARKET_PRICE", '1' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_PRIMARY_PRICE( "RELATED_TO_PRIMARY_PRICE", '2' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_LOCAL_PRIMARY_PRICE( "RELATED_TO_LOCAL_PRIMARY_PRICE", '3' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_MIDPOINT_PRICE( "RELATED_TO_MIDPOINT_PRICE", '4' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_LAST_TRADE_PRICE( "RELATED_TO_LAST_TRADE_PRICE", '5' );
const DiscretionInstEnums::ItemType DiscretionInstEnums::RELATED_TO_VWAP( "RELATED_TO_VWAP", '6' );

const BidTypeEnums::ItemType BidTypeEnums::BAD_ENUM( "BAD_ENUM", BidTypeEnums::ITEM_BAD_ENUM );
const BidTypeEnums::ItemType BidTypeEnums::NON_DISCLOSED_STYLE( "NON_DISCLOSED_STYLE", 1 );
const BidTypeEnums::ItemType BidTypeEnums::DISCLOSED_STYLE( "DISCLOSED_STYLE", 2 );
const BidTypeEnums::ItemType BidTypeEnums::NO_BIDDING_PROCESS( "NO_BIDDING_PROCESS", 3 );

const BidDescriptorTypeEnums::ItemType BidDescriptorTypeEnums::BAD_ENUM( "BAD_ENUM", BidDescriptorTypeEnums::ITEM_BAD_ENUM );
const BidDescriptorTypeEnums::ItemType BidDescriptorTypeEnums::SECTOR( "SECTOR", 1 );
const BidDescriptorTypeEnums::ItemType BidDescriptorTypeEnums::COUNTRY( "COUNTRY", 2 );
const BidDescriptorTypeEnums::ItemType BidDescriptorTypeEnums::INDEX( "INDEX", 3 );

const SideValueIndEnums::ItemType SideValueIndEnums::BAD_ENUM( "BAD_ENUM", SideValueIndEnums::ITEM_BAD_ENUM );
const SideValueIndEnums::ItemType SideValueIndEnums::SIDEVALUE1( "SIDEVALUE1", 1 );
const SideValueIndEnums::ItemType SideValueIndEnums::SIDEVALUE_2( "SIDEVALUE_2", 2 );

const LiquidityIndTypeEnums::ItemType LiquidityIndTypeEnums::BAD_ENUM( "BAD_ENUM", LiquidityIndTypeEnums::ITEM_BAD_ENUM );
const LiquidityIndTypeEnums::ItemType LiquidityIndTypeEnums::_5DAY_MOVING_AVERAGE( "_5DAY_MOVING_AVERAGE", 1 );
const LiquidityIndTypeEnums::ItemType LiquidityIndTypeEnums::_20_DAY_MOVING_AVERAGE( "_20_DAY_MOVING_AVERAGE", 2 );
const LiquidityIndTypeEnums::ItemType LiquidityIndTypeEnums::NORMAL_MARKET_SIZE( "NORMAL_MARKET_SIZE", 3 );
const LiquidityIndTypeEnums::ItemType LiquidityIndTypeEnums::OTHER( "OTHER", 4 );

const ExchangeForPhysicalEnums::ItemType ExchangeForPhysicalEnums::BAD_ENUM( "BAD_ENUM", ExchangeForPhysicalEnums::ITEM_BAD_ENUM );
const ExchangeForPhysicalEnums::ItemType ExchangeForPhysicalEnums::YES( "YES", 'Y' );
const ExchangeForPhysicalEnums::ItemType ExchangeForPhysicalEnums::NO( "NO", 'N' );

const ProgRptReqsEnums::ItemType ProgRptReqsEnums::BAD_ENUM( "BAD_ENUM", ProgRptReqsEnums::ITEM_BAD_ENUM );
const ProgRptReqsEnums::ItemType ProgRptReqsEnums::BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST( "BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST", 1 );
const ProgRptReqsEnums::ItemType ProgRptReqsEnums::SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_PERIOD_OPTIONALLY_SPECIFIED_IN_PROGRESSPERIOD( "SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_PERIOD_OPTIONALLY_SPECIFIED_IN_PROGRESSPERIOD", 2 );
const ProgRptReqsEnums::ItemType ProgRptReqsEnums::REAL_TIME_EXECUTION_REPORTS( "REAL_TIME_EXECUTION_REPORTS", 3 );

const IncTaxIndEnums::ItemType IncTaxIndEnums::BAD_ENUM( "BAD_ENUM", IncTaxIndEnums::ITEM_BAD_ENUM );
const IncTaxIndEnums::ItemType IncTaxIndEnums::NET( "NET", 1 );
const IncTaxIndEnums::ItemType IncTaxIndEnums::GROSS( "GROSS", 2 );

const BidTradeTypeEnums::ItemType BidTradeTypeEnums::BAD_ENUM( "BAD_ENUM", BidTradeTypeEnums::ITEM_BAD_ENUM );
const BidTradeTypeEnums::ItemType BidTradeTypeEnums::RISK_TRADE( "RISK_TRADE", 'R' );
const BidTradeTypeEnums::ItemType BidTradeTypeEnums::VWAP_GUARANTEE( "VWAP_GUARANTEE", 'G' );
const BidTradeTypeEnums::ItemType BidTradeTypeEnums::AGENCY( "AGENCY", 'A' );
const BidTradeTypeEnums::ItemType BidTradeTypeEnums::GUARANTEED_CLOSE( "GUARANTEED_CLOSE", 'J' );

const BasisPxTypeEnums::ItemType BasisPxTypeEnums::BAD_ENUM( "BAD_ENUM", BasisPxTypeEnums::ITEM_BAD_ENUM );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::CLOSING_PRICE_AT_MORNING_SESSION( "CLOSING_PRICE_AT_MORNING_SESSION", '2' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::CLOSING_PRICE( "CLOSING_PRICE", '3' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::CURRENT_PRICE( "CURRENT_PRICE", '4' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::SQ( "SQ", '5' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_A_DAY( "VWAP_THROUGH_A_DAY", '6' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION( "VWAP_THROUGH_A_MORNING_SESSION", '7' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION( "VWAP_THROUGH_AN_AFTERNOON_SESSION", '8' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_A_DAY_EXCEPT_YORI( "VWAP_THROUGH_A_DAY_EXCEPT_YORI", '9' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI( "VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI", 'A' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI( "VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI", 'B' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::STRIKE( "STRIKE", 'C' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::OPEN( "OPEN", 'D' );
const BasisPxTypeEnums::ItemType BasisPxTypeEnums::OTHERS( "OTHERS", 'Z' );

const PriceTypeEnums::ItemType PriceTypeEnums::BAD_ENUM( "BAD_ENUM", PriceTypeEnums::ITEM_BAD_ENUM );
const PriceTypeEnums::ItemType PriceTypeEnums::PERCENTAGE( "PERCENTAGE", 1 );
const PriceTypeEnums::ItemType PriceTypeEnums::PER_UNIT( "PER_UNIT", 2 );
const PriceTypeEnums::ItemType PriceTypeEnums::FIXED_AMOUNT( "FIXED_AMOUNT", 3 );
const PriceTypeEnums::ItemType PriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR( "DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR", 4 );
const PriceTypeEnums::ItemType PriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR( "PREMIUM_PERCENTAGE_POINTS_OVER_PAR", 5 );
const PriceTypeEnums::ItemType PriceTypeEnums::SPREAD( "SPREAD", 6 );
const PriceTypeEnums::ItemType PriceTypeEnums::TED_PRICE( "TED_PRICE", 7 );
const PriceTypeEnums::ItemType PriceTypeEnums::TED_YIELD( "TED_YIELD", 8 );
const PriceTypeEnums::ItemType PriceTypeEnums::YIELD( "YIELD", 9 );
const PriceTypeEnums::ItemType PriceTypeEnums::FIXED_CABINET_TRADE_PRICE( "FIXED_CABINET_TRADE_PRICE", 10 );
const PriceTypeEnums::ItemType PriceTypeEnums::VARIABLE_CABINET_TRADE_PRICE( "VARIABLE_CABINET_TRADE_PRICE", 11 );

const GTBookingInstEnums::ItemType GTBookingInstEnums::BAD_ENUM( "BAD_ENUM", GTBookingInstEnums::ITEM_BAD_ENUM );
const GTBookingInstEnums::ItemType GTBookingInstEnums::BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION( "BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION", 0 );
const GTBookingInstEnums::ItemType GTBookingInstEnums::ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES( "ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES", 1 );
const GTBookingInstEnums::ItemType GTBookingInstEnums::ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE( "ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE", 2 );

const ListStatusTypeEnums::ItemType ListStatusTypeEnums::BAD_ENUM( "BAD_ENUM", ListStatusTypeEnums::ITEM_BAD_ENUM );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::ACK( "ACK", 1 );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::RESPONSE( "RESPONSE", 2 );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::TIMED( "TIMED", 3 );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::EXECSTARTED( "EXECSTARTED", 4 );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::ALLDONE( "ALLDONE", 5 );
const ListStatusTypeEnums::ItemType ListStatusTypeEnums::ALERT( "ALERT", 6 );

const NetGrossIndEnums::ItemType NetGrossIndEnums::BAD_ENUM( "BAD_ENUM", NetGrossIndEnums::ITEM_BAD_ENUM );
const NetGrossIndEnums::ItemType NetGrossIndEnums::NET( "NET", 1 );
const NetGrossIndEnums::ItemType NetGrossIndEnums::GROSS( "GROSS", 2 );

const ListOrderStatusEnums::ItemType ListOrderStatusEnums::BAD_ENUM( "BAD_ENUM", ListOrderStatusEnums::ITEM_BAD_ENUM );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::INBIDDINGPROCESS( "INBIDDINGPROCESS", 1 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::RECEIVEDFOREXECUTION( "RECEIVEDFOREXECUTION", 2 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::EXECUTING( "EXECUTING", 3 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::CANCELING( "CANCELING", 4 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::ALERT( "ALERT", 5 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::ALL_DONE( "ALL_DONE", 6 );
const ListOrderStatusEnums::ItemType ListOrderStatusEnums::REJECT( "REJECT", 7 );

const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::BAD_ENUM( "BAD_ENUM", ListExecInstTypeEnums::ITEM_BAD_ENUM );
const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::IMMEDIATE( "IMMEDIATE", '1' );
const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::WAIT_FOR_EXECUTE_INSTRUCTION( "WAIT_FOR_EXECUTE_INSTRUCTION", '2' );
const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN( "EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN", '3' );
const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP( "EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP", '4' );
const ListExecInstTypeEnums::ItemType ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW( "EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW", '5' );

const CxlRejResponseToEnums::ItemType CxlRejResponseToEnums::BAD_ENUM( "BAD_ENUM", CxlRejResponseToEnums::ITEM_BAD_ENUM );
const CxlRejResponseToEnums::ItemType CxlRejResponseToEnums::ORDER_CANCEL_REQUEST( "ORDER_CANCEL_REQUEST", '1' );
const CxlRejResponseToEnums::ItemType CxlRejResponseToEnums::ORDER_CANCEL_REPLACE_REQUEST( "ORDER_CANCEL_REPLACE_REQUEST", '2' );

const MultiLegReportingTypeEnums::ItemType MultiLegReportingTypeEnums::BAD_ENUM( "BAD_ENUM", MultiLegReportingTypeEnums::ITEM_BAD_ENUM );
const MultiLegReportingTypeEnums::ItemType MultiLegReportingTypeEnums::SINGLE_SECURITY( "SINGLE_SECURITY", '1' );
const MultiLegReportingTypeEnums::ItemType MultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY( "INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY", '2' );
const MultiLegReportingTypeEnums::ItemType MultiLegReportingTypeEnums::MULTI_LEG_SECURITY( "MULTI_LEG_SECURITY", '3' );

const PartyIDSourceEnums::ItemType PartyIDSourceEnums::BAD_ENUM( "BAD_ENUM", PartyIDSourceEnums::ITEM_BAD_ENUM );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::BIC( "BIC", 'B' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER( "GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER", 'C' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::PROPRIETARY_CUSTOM_CODE( "PROPRIETARY_CUSTOM_CODE", 'D' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::ISO_COUNTRY_CODE( "ISO_COUNTRY_CODE", 'E' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::SETTLEMENT_ENTITY_LOCATION( "SETTLEMENT_ENTITY_LOCATION", 'F' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::MIC( "MIC", 'G' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::CSD_PARTICIPANT_MEMBER_CODE( "CSD_PARTICIPANT_MEMBER_CODE", 'H' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::KOREAN_INVESTOR_ID( "KOREAN_INVESTOR_ID", '1' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII( "TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII", '2' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::TAIWANESE_TRADING_ACCOUNT( "TAIWANESE_TRADING_ACCOUNT", '3' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::MALAYSIAN_CENTRAL_DEPOSITORY( "MALAYSIAN_CENTRAL_DEPOSITORY", '4' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::CHINESE_B_SHARE( "CHINESE_B_SHARE", '5' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER( "UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER", '6' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::US_SOCIAL_SECURITY_NUMBER( "US_SOCIAL_SECURITY_NUMBER", '7' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::US_EMPLOYER_IDENTIFICATION_NUMBER( "US_EMPLOYER_IDENTIFICATION_NUMBER", '8' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::AUSTRALIAN_BUSINESS_NUMBER( "AUSTRALIAN_BUSINESS_NUMBER", '9' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::AUSTRALIAN_TAX_FILE_NUMBER( "AUSTRALIAN_TAX_FILE_NUMBER", 'A' );
const PartyIDSourceEnums::ItemType PartyIDSourceEnums::DIRECTED_BROKER_THREE_CHARACTER_ACRONYM_AS_DEFINED_IN_ISITC_ETC_BEST_PRACTICE_GUIDELINES_DOCUMENT( "DIRECTED_BROKER_THREE_CHARACTER_ACRONYM_AS_DEFINED_IN_ISITC_ETC_BEST_PRACTICE_GUIDELINES_DOCUMENT", 'I' );

const PartyRoleEnums::ItemType PartyRoleEnums::BAD_ENUM( "BAD_ENUM", PartyRoleEnums::ITEM_BAD_ENUM );
const PartyRoleEnums::ItemType PartyRoleEnums::EXECUTING_FIRM( "EXECUTING_FIRM", 1 );
const PartyRoleEnums::ItemType PartyRoleEnums::BROKER_OF_CREDIT( "BROKER_OF_CREDIT", 2 );
const PartyRoleEnums::ItemType PartyRoleEnums::CLIENT_ID( "CLIENT_ID", 3 );
const PartyRoleEnums::ItemType PartyRoleEnums::CLEARING_FIRM( "CLEARING_FIRM", 4 );
const PartyRoleEnums::ItemType PartyRoleEnums::INVESTOR_ID( "INVESTOR_ID", 5 );
const PartyRoleEnums::ItemType PartyRoleEnums::INTRODUCING_FIRM( "INTRODUCING_FIRM", 6 );
const PartyRoleEnums::ItemType PartyRoleEnums::ENTERING_FIRM( "ENTERING_FIRM", 7 );
const PartyRoleEnums::ItemType PartyRoleEnums::LOCATE_LENDING_FIRM( "LOCATE_LENDING_FIRM", 8 );
const PartyRoleEnums::ItemType PartyRoleEnums::FUND_MANAGER_CLIENT_ID( "FUND_MANAGER_CLIENT_ID", 9 );
const PartyRoleEnums::ItemType PartyRoleEnums::SETTLEMENT_LOCATION( "SETTLEMENT_LOCATION", 10 );
const PartyRoleEnums::ItemType PartyRoleEnums::ORDER_ORIGINATION_TRADER( "ORDER_ORIGINATION_TRADER", 11 );
const PartyRoleEnums::ItemType PartyRoleEnums::EXECUTING_TRADER( "EXECUTING_TRADER", 12 );
const PartyRoleEnums::ItemType PartyRoleEnums::ORDER_ORIGINATION_FIRM( "ORDER_ORIGINATION_FIRM", 13 );
const PartyRoleEnums::ItemType PartyRoleEnums::GIVEUP_CLEARING_FIRM( "GIVEUP_CLEARING_FIRM", 14 );
const PartyRoleEnums::ItemType PartyRoleEnums::CORRESPONDANT_CLEARING_FIRM( "CORRESPONDANT_CLEARING_FIRM", 15 );
const PartyRoleEnums::ItemType PartyRoleEnums::EXECUTING_SYSTEM( "EXECUTING_SYSTEM", 16 );
const PartyRoleEnums::ItemType PartyRoleEnums::CONTRA_FIRM( "CONTRA_FIRM", 17 );
const PartyRoleEnums::ItemType PartyRoleEnums::CONTRA_CLEARING_FIRM( "CONTRA_CLEARING_FIRM", 18 );
const PartyRoleEnums::ItemType PartyRoleEnums::SPONSORING_FIRM( "SPONSORING_FIRM", 19 );
const PartyRoleEnums::ItemType PartyRoleEnums::UNDERLYING_CONTRA_FIRM( "UNDERLYING_CONTRA_FIRM", 20 );
const PartyRoleEnums::ItemType PartyRoleEnums::CLEARING_ORGANIZATION( "CLEARING_ORGANIZATION", 21 );
const PartyRoleEnums::ItemType PartyRoleEnums::EXCHANGE( "EXCHANGE", 22 );
const PartyRoleEnums::ItemType PartyRoleEnums::CUSTOMER_ACCOUNT( "CUSTOMER_ACCOUNT", 24 );
const PartyRoleEnums::ItemType PartyRoleEnums::CORRESPONDENT_CLEARING_ORGANIZATION( "CORRESPONDENT_CLEARING_ORGANIZATION", 25 );
const PartyRoleEnums::ItemType PartyRoleEnums::CORRESPONDENT_BROKER( "CORRESPONDENT_BROKER", 26 );
const PartyRoleEnums::ItemType PartyRoleEnums::BUYER_SELLER( "BUYER_SELLER", 27 );
const PartyRoleEnums::ItemType PartyRoleEnums::CUSTODIAN( "CUSTODIAN", 28 );
const PartyRoleEnums::ItemType PartyRoleEnums::INTERMEDIARY( "INTERMEDIARY", 29 );
const PartyRoleEnums::ItemType PartyRoleEnums::AGENT( "AGENT", 30 );
const PartyRoleEnums::ItemType PartyRoleEnums::SUB_CUSTODIAN( "SUB_CUSTODIAN", 31 );
const PartyRoleEnums::ItemType PartyRoleEnums::BENEFICIARY( "BENEFICIARY", 32 );
const PartyRoleEnums::ItemType PartyRoleEnums::INTERESTED_PARTY( "INTERESTED_PARTY", 33 );
const PartyRoleEnums::ItemType PartyRoleEnums::REGULATORY_BODY( "REGULATORY_BODY", 34 );
const PartyRoleEnums::ItemType PartyRoleEnums::LIQUIDITY_PROVIDER( "LIQUIDITY_PROVIDER", 35 );
const PartyRoleEnums::ItemType PartyRoleEnums::ENTERING_TRADER( "ENTERING_TRADER", 36 );
const PartyRoleEnums::ItemType PartyRoleEnums::CONTRA_TRADER( "CONTRA_TRADER", 37 );
const PartyRoleEnums::ItemType PartyRoleEnums::POSITION_ACCOUNT( "POSITION_ACCOUNT", 38 );

const ProductEnums::ItemType ProductEnums::BAD_ENUM( "BAD_ENUM", ProductEnums::ITEM_BAD_ENUM );
const ProductEnums::ItemType ProductEnums::AGENCY( "AGENCY", 1 );
const ProductEnums::ItemType ProductEnums::COMMODITY( "COMMODITY", 2 );
const ProductEnums::ItemType ProductEnums::CORPORATE( "CORPORATE", 3 );
const ProductEnums::ItemType ProductEnums::CURRENCY( "CURRENCY", 4 );
const ProductEnums::ItemType ProductEnums::EQUITY( "EQUITY", 5 );
const ProductEnums::ItemType ProductEnums::GOVERNMENT( "GOVERNMENT", 6 );
const ProductEnums::ItemType ProductEnums::INDEX( "INDEX", 7 );
const ProductEnums::ItemType ProductEnums::LOAN( "LOAN", 8 );
const ProductEnums::ItemType ProductEnums::MONEYMARKET( "MONEYMARKET", 9 );
const ProductEnums::ItemType ProductEnums::MORTGAGE( "MORTGAGE", 10 );
const ProductEnums::ItemType ProductEnums::MUNICIPAL( "MUNICIPAL", 11 );
const ProductEnums::ItemType ProductEnums::OTHER( "OTHER", 12 );
const ProductEnums::ItemType ProductEnums::FINANCING( "FINANCING", 13 );

const TestMessageIndicatorEnums::ItemType TestMessageIndicatorEnums::BAD_ENUM( "BAD_ENUM", TestMessageIndicatorEnums::ITEM_BAD_ENUM );
const TestMessageIndicatorEnums::ItemType TestMessageIndicatorEnums::YES( "YES", 'Y' );
const TestMessageIndicatorEnums::ItemType TestMessageIndicatorEnums::NO( "NO", 'N' );

const RoundingDirectionEnums::ItemType RoundingDirectionEnums::BAD_ENUM( "BAD_ENUM", RoundingDirectionEnums::ITEM_BAD_ENUM );
const RoundingDirectionEnums::ItemType RoundingDirectionEnums::ROUND_TO_NEAREST( "ROUND_TO_NEAREST", '0' );
const RoundingDirectionEnums::ItemType RoundingDirectionEnums::ROUND_DOWN( "ROUND_DOWN", '1' );
const RoundingDirectionEnums::ItemType RoundingDirectionEnums::ROUND_UP( "ROUND_UP", '2' );

const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::BAD_ENUM( "BAD_ENUM", DistribPaymentMethodEnums::ITEM_BAD_ENUM );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::CREST( "CREST", 1 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::NSCC( "NSCC", 2 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::EUROCLEAR( "EUROCLEAR", 3 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::CLEARSTREAM( "CLEARSTREAM", 4 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::CHEQUE( "CHEQUE", 5 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::TELEGRAPHIC_TRANSFER( "TELEGRAPHIC_TRANSFER", 6 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::FEDWIRE( "FEDWIRE", 7 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::DIRECT_CREDIT( "DIRECT_CREDIT", 8 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::ACH_CREDIT( "ACH_CREDIT", 9 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::BPAY( "BPAY", 10 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM( "HIGH_VALUE_CLEARING_SYSTEM", 11 );
const DistribPaymentMethodEnums::ItemType DistribPaymentMethodEnums::REINVEST_IN_FUND( "REINVEST_IN_FUND", 12 );

const CancellationRightsEnums::ItemType CancellationRightsEnums::BAD_ENUM( "BAD_ENUM", CancellationRightsEnums::ITEM_BAD_ENUM );
const CancellationRightsEnums::ItemType CancellationRightsEnums::YES( "YES", 'Y' );
const CancellationRightsEnums::ItemType CancellationRightsEnums::NO_EXECUTION_ONLY( "NO_EXECUTION_ONLY", 'N' );
const CancellationRightsEnums::ItemType CancellationRightsEnums::NO_WAIVER_AGREEMENT( "NO_WAIVER_AGREEMENT", 'M' );
const CancellationRightsEnums::ItemType CancellationRightsEnums::NO_INSTITUTIONAL( "NO_INSTITUTIONAL", 'O' );

const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::BAD_ENUM( "BAD_ENUM", MoneyLaunderingStatusEnums::ITEM_BAD_ENUM );
const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::PASSED( "PASSED", 'Y' );
const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::NOT_CHECKED( "NOT_CHECKED", 'N' );
const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::EXEMPT_BELOW_THE_LIMIT( "EXEMPT_BELOW_THE_LIMIT", '1' );
const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION( "EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION", '2' );
const MoneyLaunderingStatusEnums::ItemType MoneyLaunderingStatusEnums::EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION( "EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION", '3' );

const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::BAD_ENUM( "BAD_ENUM", ExecPriceTypeEnums::ITEM_BAD_ENUM );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::BID_PRICE( "BID_PRICE", 'B' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::CREATION_PRICE( "CREATION_PRICE", 'C' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT( "CREATION_PRICE_PLUS_ADJUSTMENT", 'D' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT( "CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT", 'E' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::OFFER_PRICE( "OFFER_PRICE", 'O' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT( "OFFER_PRICE_MINUS_ADJUSTMENT", 'P' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT( "OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT", 'Q' );
const ExecPriceTypeEnums::ItemType ExecPriceTypeEnums::SINGLE_PRICE( "SINGLE_PRICE", 'S' );

const PaymentMethodEnums::ItemType PaymentMethodEnums::BAD_ENUM( "BAD_ENUM", PaymentMethodEnums::ITEM_BAD_ENUM );
const PaymentMethodEnums::ItemType PaymentMethodEnums::CREST( "CREST", 1 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::NSCC( "NSCC", 2 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::EUROCLEAR( "EUROCLEAR", 3 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::CLEARSTREAM( "CLEARSTREAM", 4 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::CHEQUE( "CHEQUE", 5 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::TELEGRAPHIC_TRANSFER( "TELEGRAPHIC_TRANSFER", 6 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::FEDWIRE( "FEDWIRE", 7 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::DEBIT_CARD( "DEBIT_CARD", 8 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::DIRECT_DEBIT( "DIRECT_DEBIT", 9 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::DIRECT_CREDIT( "DIRECT_CREDIT", 10 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::CREDIT_CARD( "CREDIT_CARD", 11 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::ACH_DEBIT( "ACH_DEBIT", 12 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::ACH_CREDIT( "ACH_CREDIT", 13 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::BPAY( "BPAY", 14 );
const PaymentMethodEnums::ItemType PaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM( "HIGH_VALUE_CLEARING_SYSTEM", 15 );

const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::BAD_ENUM( "BAD_ENUM", TaxAdvantageTypeEnums::ITEM_BAD_ENUM );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::NONE_NOT_APPLICABLE( "NONE_NOT_APPLICABLE", 0 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::MAXI_ISA( "MAXI_ISA", 1 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::TESSA( "TESSA", 2 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::MINI_CASH_ISA( "MINI_CASH_ISA", 3 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::MINI_STOCKS_AND_SHARES_ISA( "MINI_STOCKS_AND_SHARES_ISA", 4 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::MINI_INSURANCE_ISA( "MINI_INSURANCE_ISA", 5 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::CURRENT_YEAR_PAYMENT( "CURRENT_YEAR_PAYMENT", 6 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::PRIOR_YEAR_PAYMENT( "PRIOR_YEAR_PAYMENT", 7 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::ASSET_TRANSFER( "ASSET_TRANSFER", 8 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EMPLOYEE( "EMPLOYEE", 9 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EMPLOYEE_CURRENT_YEAR( "EMPLOYEE_CURRENT_YEAR", 10 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EMPLOYER( "EMPLOYER", 11 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EMPLOYER_CURRENT_YEAR( "EMPLOYER_CURRENT_YEAR", 12 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::NON_FUND_PROTOTYPE_IRA( "NON_FUND_PROTOTYPE_IRA", 13 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::NON_FUND_QUALIFIED_PLAN( "NON_FUND_QUALIFIED_PLAN", 14 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::DEFINED_CONTRIBUTION_PLAN( "DEFINED_CONTRIBUTION_PLAN", 15 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT( "INDIVIDUAL_RETIREMENT_ACCOUNT", 16 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT_ROLLOVER( "INDIVIDUAL_RETIREMENT_ACCOUNT_ROLLOVER", 17 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::KEOGH( "KEOGH", 18 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::PROFIT_SHARING_PLAN( "PROFIT_SHARING_PLAN", 19 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::_401K( "_401K", 20 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::SELF_DIRECTED_IRA( "SELF_DIRECTED_IRA", 21 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::_403( "_403", 22 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::_457( "_457", 23 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::ROTH_IRA_24( "ROTH_IRA_24", 24 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::ROTH_IRA_25( "ROTH_IRA_25", 25 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_26( "ROTH_CONVERSION_IRA_26", 26 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_27( "ROTH_CONVERSION_IRA_27", 27 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EDUCATION_IRA_28( "EDUCATION_IRA_28", 28 );
const TaxAdvantageTypeEnums::ItemType TaxAdvantageTypeEnums::EDUCATION_IRA_29( "EDUCATION_IRA_29", 29 );

const FundRenewWaivEnums::ItemType FundRenewWaivEnums::BAD_ENUM( "BAD_ENUM", FundRenewWaivEnums::ITEM_BAD_ENUM );
const FundRenewWaivEnums::ItemType FundRenewWaivEnums::YES( "YES", 'Y' );
const FundRenewWaivEnums::ItemType FundRenewWaivEnums::NO( "NO", 'N' );

const RegistStatusEnums::ItemType RegistStatusEnums::BAD_ENUM( "BAD_ENUM", RegistStatusEnums::ITEM_BAD_ENUM );
const RegistStatusEnums::ItemType RegistStatusEnums::ACCEPTED( "ACCEPTED", 'A' );
const RegistStatusEnums::ItemType RegistStatusEnums::REJECTED( "REJECTED", 'R' );
const RegistStatusEnums::ItemType RegistStatusEnums::HELD( "HELD", 'H' );
const RegistStatusEnums::ItemType RegistStatusEnums::REMINDER_IE_REGISTRATION_INSTRUCTIONS_ARE_STILL_OUTSTANDING( "REMINDER_IE_REGISTRATION_INSTRUCTIONS_ARE_STILL_OUTSTANDING", 'N' );

const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::BAD_ENUM( "BAD_ENUM", RegistRejReasonCodeEnums::ITEM_BAD_ENUM );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_ACCOUNT_TYPE( "INVALID_UNACCEPTABLE_ACCOUNT_TYPE", 1 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE( "INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE", 2 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_OWNERSHIP_TYPE( "INVALID_UNACCEPTABLE_OWNERSHIP_TYPE", 3 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NO_REG_DETLS( "INVALID_UNACCEPTABLE_NO_REG_DETLS", 4 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_SEQ_NO( "INVALID_UNACCEPTABLE_REG_SEQ_NO", 5 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_DTLS( "INVALID_UNACCEPTABLE_REG_DTLS", 6 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_DTLS( "INVALID_UNACCEPTABLE_MAILING_DTLS", 7 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_INST( "INVALID_UNACCEPTABLE_MAILING_INST", 8 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID( "INVALID_UNACCEPTABLE_INVESTOR_ID", 9 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE( "INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE", 10 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DATE_OF_BIRTH( "INVALID_UNACCEPTABLE_DATE_OF_BIRTH", 11 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE( "INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE", 12 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NODISTRIBINSTNS( "INVALID_UNACCEPTABLE_NODISTRIBINSTNS", 13 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE( "INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE", 14 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD( "INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD", 15 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME( "INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME", 16 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE( "INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE", 17 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM( "INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM", 18 );
const RegistRejReasonCodeEnums::ItemType RegistRejReasonCodeEnums::OTHER( "OTHER", 99 );

const RegistTransTypeEnums::ItemType RegistTransTypeEnums::BAD_ENUM( "BAD_ENUM", RegistTransTypeEnums::ITEM_BAD_ENUM );
const RegistTransTypeEnums::ItemType RegistTransTypeEnums::NEW( "NEW", '0' );
const RegistTransTypeEnums::ItemType RegistTransTypeEnums::REPLACE( "REPLACE", '1' );
const RegistTransTypeEnums::ItemType RegistTransTypeEnums::CANCEL( "CANCEL", '2' );

const OwnershipTypeEnums::ItemType OwnershipTypeEnums::BAD_ENUM( "BAD_ENUM", OwnershipTypeEnums::ITEM_BAD_ENUM );
const OwnershipTypeEnums::ItemType OwnershipTypeEnums::JOINT_INVESTORS( "JOINT_INVESTORS", 'J' );
const OwnershipTypeEnums::ItemType OwnershipTypeEnums::TENANTS_IN_COMMON( "TENANTS_IN_COMMON", 'T' );
const OwnershipTypeEnums::ItemType OwnershipTypeEnums::JOINT_TRUSTEES( "JOINT_TRUSTEES", '2' );

const ContAmtTypeEnums::ItemType ContAmtTypeEnums::BAD_ENUM( "BAD_ENUM", ContAmtTypeEnums::ITEM_BAD_ENUM );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::COMMISSION_AMOUNT( "COMMISSION_AMOUNT", 1 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::COMMISSION( "COMMISSION", 2 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::INITIAL_CHARGE_AMOUNT( "INITIAL_CHARGE_AMOUNT", 3 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::INITIAL_CHARGE( "INITIAL_CHARGE", 4 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::DISCOUNT_AMOUNT( "DISCOUNT_AMOUNT", 5 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::DISCOUNT( "DISCOUNT", 6 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::DILUTION_LEVY_AMOUNT( "DILUTION_LEVY_AMOUNT", 7 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::DILUTION_LEVY( "DILUTION_LEVY", 8 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::EXIT_CHARGE_AMOUNT( "EXIT_CHARGE_AMOUNT", 9 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::EXIT_CHARGE( "EXIT_CHARGE", 10 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION( "FUND_BASED_RENEWAL_COMMISSION", 11 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::PROJECTED_FUND_VALUE( "PROJECTED_FUND_VALUE", 12 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_13( "FUND_BASED_RENEWAL_COMMISSION_AMOUNT_13", 13 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_14( "FUND_BASED_RENEWAL_COMMISSION_AMOUNT_14", 14 );
const ContAmtTypeEnums::ItemType ContAmtTypeEnums::NET_SETTLEMENT_AMOUNT( "NET_SETTLEMENT_AMOUNT", 15 );

const OwnerTypeEnums::ItemType OwnerTypeEnums::BAD_ENUM( "BAD_ENUM", OwnerTypeEnums::ITEM_BAD_ENUM );
const OwnerTypeEnums::ItemType OwnerTypeEnums::INDIVIDUAL_INVESTOR( "INDIVIDUAL_INVESTOR", 1 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::PUBLIC_COMPANY( "PUBLIC_COMPANY", 2 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::PRIVATE_COMPANY( "PRIVATE_COMPANY", 3 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::INDIVIDUAL_TRUSTEE( "INDIVIDUAL_TRUSTEE", 4 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::COMPANY_TRUSTEE( "COMPANY_TRUSTEE", 5 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::PENSION_PLAN( "PENSION_PLAN", 6 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT( "CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT", 7 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::TRUSTS( "TRUSTS", 8 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::FIDUCIARIES( "FIDUCIARIES", 9 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::NETWORKING_SUB_ACCOUNT( "NETWORKING_SUB_ACCOUNT", 10 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::NON_PROFIT_ORGANIZATION( "NON_PROFIT_ORGANIZATION", 11 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::CORPORATE_BODY( "CORPORATE_BODY", 12 );
const OwnerTypeEnums::ItemType OwnerTypeEnums::NOMINEE( "NOMINEE", 13 );

const OrderCapacityEnums::ItemType OrderCapacityEnums::BAD_ENUM( "BAD_ENUM", OrderCapacityEnums::ITEM_BAD_ENUM );
const OrderCapacityEnums::ItemType OrderCapacityEnums::AGENCY( "AGENCY", 'A' );
const OrderCapacityEnums::ItemType OrderCapacityEnums::PROPRIETARY( "PROPRIETARY", 'G' );
const OrderCapacityEnums::ItemType OrderCapacityEnums::INDIVIDUAL( "INDIVIDUAL", 'I' );
const OrderCapacityEnums::ItemType OrderCapacityEnums::PRINCIPAL( "PRINCIPAL", 'P' );
const OrderCapacityEnums::ItemType OrderCapacityEnums::RISKLESS_PRINCIPAL( "RISKLESS_PRINCIPAL", 'R' );
const OrderCapacityEnums::ItemType OrderCapacityEnums::AGENT_FOR_OTHER_MEMBER( "AGENT_FOR_OTHER_MEMBER", 'W' );

const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::BAD_ENUM( "BAD_ENUM", OrderRestrictionsEnums::ITEM_BAD_ENUM );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::PROGRAM_TRADE( "PROGRAM_TRADE", SOHSTR(1) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::INDEX_ARBITRAGE( "INDEX_ARBITRAGE", SOHSTR(2) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::NON_INDEX_ARBITRAGE( "NON_INDEX_ARBITRAGE", SOHSTR(3) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::COMPETING_MARKET_MAKER( "COMPETING_MARKET_MAKER", SOHSTR(4) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY( "ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY", SOHSTR(5) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY( "ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY", SOHSTR(6) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::FOREIGN_ENTITY( "FOREIGN_ENTITY", SOHSTR(7) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::EXTERNAL_MARKET_PARTICIPANT( "EXTERNAL_MARKET_PARTICIPANT", SOHSTR(8) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE( "EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE", SOHSTR(9) );
const OrderRestrictionsEnums::ItemType OrderRestrictionsEnums::RISKLESS_ARBITRAGE( "RISKLESS_ARBITRAGE", SOHSTR(A) );

const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::BAD_ENUM( "BAD_ENUM", MassCancelRequestTypeEnums::ITEM_BAD_ENUM );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITY( "CANCEL_ORDERS_FOR_A_SECURITY", '1' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY( "CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", '2' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_PRODUCT( "CANCEL_ORDERS_FOR_A_PRODUCT", '3' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_CFICODE( "CANCEL_ORDERS_FOR_A_CFICODE", '4' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE( "CANCEL_ORDERS_FOR_A_SECURITYTYPE", '5' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION( "CANCEL_ORDERS_FOR_A_TRADING_SESSION", '6' );
const MassCancelRequestTypeEnums::ItemType MassCancelRequestTypeEnums::CANCEL_ALL_ORDERS( "CANCEL_ALL_ORDERS", '7' );

const MassCancelResponseEnums::ItemType MassCancelResponseEnums::BAD_ENUM( "BAD_ENUM", MassCancelResponseEnums::ITEM_BAD_ENUM );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_REQUEST_REJECTED( "CANCEL_REQUEST_REJECTED", '0' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITY( "CANCEL_ORDERS_FOR_A_SECURITY", '1' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY( "CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY", '2' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_PRODUCT( "CANCEL_ORDERS_FOR_A_PRODUCT", '3' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_CFICODE( "CANCEL_ORDERS_FOR_A_CFICODE", '4' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE( "CANCEL_ORDERS_FOR_A_SECURITYTYPE", '5' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION( "CANCEL_ORDERS_FOR_A_TRADING_SESSION", '6' );
const MassCancelResponseEnums::ItemType MassCancelResponseEnums::CANCEL_ALL_ORDERS( "CANCEL_ALL_ORDERS", '7' );

const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::BAD_ENUM( "BAD_ENUM", MassCancelRejectReasonEnums::ITEM_BAD_ENUM );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::MASS_CANCEL_NOT_SUPPORTED( "MASS_CANCEL_NOT_SUPPORTED", '0' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY( "INVALID_OR_UNKNOWN_SECURITY", '1' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_UNDERLYING( "INVALID_OR_UNKNOWN_UNDERLYING", '2' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_PRODUCT( "INVALID_OR_UNKNOWN_PRODUCT", '3' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_CFICODE( "INVALID_OR_UNKNOWN_CFICODE", '4' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY_TYPE( "INVALID_OR_UNKNOWN_SECURITY_TYPE", '5' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_TRADING_SESSION( "INVALID_OR_UNKNOWN_TRADING_SESSION", '6' );
const MassCancelRejectReasonEnums::ItemType MassCancelRejectReasonEnums::OTHER( "OTHER", '9' );

const QuoteTypeEnums::ItemType QuoteTypeEnums::BAD_ENUM( "BAD_ENUM", QuoteTypeEnums::ITEM_BAD_ENUM );
const QuoteTypeEnums::ItemType QuoteTypeEnums::INDICATIVE( "INDICATIVE", 0 );
const QuoteTypeEnums::ItemType QuoteTypeEnums::TRADEABLE( "TRADEABLE", 1 );
const QuoteTypeEnums::ItemType QuoteTypeEnums::RESTRICTED_TRADEABLE( "RESTRICTED_TRADEABLE", 2 );
const QuoteTypeEnums::ItemType QuoteTypeEnums::COUNTER( "COUNTER", 3 );

const CashMarginEnums::ItemType CashMarginEnums::BAD_ENUM( "BAD_ENUM", CashMarginEnums::ITEM_BAD_ENUM );
const CashMarginEnums::ItemType CashMarginEnums::CASH( "CASH", '1' );
const CashMarginEnums::ItemType CashMarginEnums::MARGIN_OPEN( "MARGIN_OPEN", '2' );
const CashMarginEnums::ItemType CashMarginEnums::MARGIN_CLOSE( "MARGIN_CLOSE", '3' );

const ScopeEnums::ItemType ScopeEnums::BAD_ENUM( "BAD_ENUM", ScopeEnums::ITEM_BAD_ENUM );
const ScopeEnums::ItemType ScopeEnums::LOCAL( "LOCAL", SOHSTR(1) );
const ScopeEnums::ItemType ScopeEnums::NATIONAL( "NATIONAL", SOHSTR(2) );
const ScopeEnums::ItemType ScopeEnums::GLOBAL( "GLOBAL", SOHSTR(3) );

const MDImplicitDeleteEnums::ItemType MDImplicitDeleteEnums::BAD_ENUM( "BAD_ENUM", MDImplicitDeleteEnums::ITEM_BAD_ENUM );
const MDImplicitDeleteEnums::ItemType MDImplicitDeleteEnums::YES( "YES", 'Y' );
const MDImplicitDeleteEnums::ItemType MDImplicitDeleteEnums::NO( "NO", 'N' );

const CrossTypeEnums::ItemType CrossTypeEnums::BAD_ENUM( "BAD_ENUM", CrossTypeEnums::ITEM_BAD_ENUM );
const CrossTypeEnums::ItemType CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_BOTH_SIDES_ARE_TREATED_IN_THE_SAME_MANNER_THIS_IS_EQUIVALENT_TO_AN_ALL_OR_NONE( "CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_BOTH_SIDES_ARE_TREATED_IN_THE_SAME_MANNER_THIS_IS_EQUIVALENT_TO_AN_ALL_OR_NONE", 1 );
const CrossTypeEnums::ItemType CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_ONE_SIDE_IS_FULLY_EXECUTED_THE_OTHER_SIDE_IS_PARTIALLY_EXECUTED_WITH_THE_REMAINDER_BEING_CANCELLED_THIS_IS_EQUIVALENT_TO_AN_IMMEDIATE_OR_CANCEL_ON_THE_OTHER_SIDE_NOTE_THE_CROSSPRIORITZATION( "CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_ONE_SIDE_IS_FULLY_EXECUTED_THE_OTHER_SIDE_IS_PARTIALLY_EXECUTED_WITH_THE_REMAINDER_BEING_CANCELLED_THIS_IS_EQUIVALENT_TO_AN_IMMEDIATE_OR_CANCEL_ON_THE_OTHER_SIDE_NOTE_THE_CROSSPRIORITZATION", 2 );
const CrossTypeEnums::ItemType CrossTypeEnums::CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_ONE_SIDE_OF_THE_CROSS_IS_FULLY_EXECUTED( "CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_ONE_SIDE_OF_THE_CROSS_IS_FULLY_EXECUTED", 3 );
const CrossTypeEnums::ItemType CrossTypeEnums::CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_IN_THE_CASE_OTHER_ORDERS_EXIST_WITH_THE_SAME_PRICE_THE_QUANTITY_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_EXISTING_ORDERS_AND_QUOTES_THE_REMAINDER_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_OTHER_SIDE_OF_THE_CROSS_THE_TWO_SIDES_POTENTIALLY_HAVE_DIFFERENT_QUANTITIES( "CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_IN_THE_CASE_OTHER_ORDERS_EXIST_WITH_THE_SAME_PRICE_THE_QUANTITY_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_EXISTING_ORDERS_AND_QUOTES_THE_REMAINDER_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_OTHER_SIDE_OF_THE_CROSS_THE_TWO_SIDES_POTENTIALLY_HAVE_DIFFERENT_QUANTITIES", 4 );

const CrossPrioritizationEnums::ItemType CrossPrioritizationEnums::BAD_ENUM( "BAD_ENUM", CrossPrioritizationEnums::ITEM_BAD_ENUM );
const CrossPrioritizationEnums::ItemType CrossPrioritizationEnums::NONE( "NONE", 0 );
const CrossPrioritizationEnums::ItemType CrossPrioritizationEnums::BUY_SIDE_IS_PRIORITIZED( "BUY_SIDE_IS_PRIORITIZED", 1 );
const CrossPrioritizationEnums::ItemType CrossPrioritizationEnums::SELL_SIDE_IS_PRIORITIZED( "SELL_SIDE_IS_PRIORITIZED", 2 );

const NoSidesEnums::ItemType NoSidesEnums::BAD_ENUM( "BAD_ENUM", NoSidesEnums::ITEM_BAD_ENUM );
const NoSidesEnums::ItemType NoSidesEnums::ONE_SIDE( "ONE_SIDE", 1 );
const NoSidesEnums::ItemType NoSidesEnums::BOTH_SIDES( "BOTH_SIDES", 2 );

const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::BAD_ENUM( "BAD_ENUM", SecurityListRequestTypeEnums::ITEM_BAD_ENUM );
const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::SYMBOL( "SYMBOL", 0 );
const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::SECURITYTYPE_AND_OR_CFICODE( "SECURITYTYPE_AND_OR_CFICODE", 1 );
const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::PRODUCT( "PRODUCT", 2 );
const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::TRADINGSESSIONID( "TRADINGSESSIONID", 3 );
const SecurityListRequestTypeEnums::ItemType SecurityListRequestTypeEnums::ALL_SECURITIES( "ALL_SECURITIES", 4 );

const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::BAD_ENUM( "BAD_ENUM", SecurityRequestResultEnums::ITEM_BAD_ENUM );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::VALID_REQUEST( "VALID_REQUEST", 0 );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::INVALID_OR_UNSUPPORTED_REQUEST( "INVALID_OR_UNSUPPORTED_REQUEST", 1 );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA( "NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA", 2 );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA( "NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA", 3 );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE( "INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE", 4 );
const SecurityRequestResultEnums::ItemType SecurityRequestResultEnums::REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED( "REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED", 5 );

const MultiLegRptTypeReqEnums::ItemType MultiLegRptTypeReqEnums::BAD_ENUM( "BAD_ENUM", MultiLegRptTypeReqEnums::ITEM_BAD_ENUM );
const MultiLegRptTypeReqEnums::ItemType MultiLegRptTypeReqEnums::REPORT_BY_MULITLEG_SECURITY_ONLY( "REPORT_BY_MULITLEG_SECURITY_ONLY", 0 );
const MultiLegRptTypeReqEnums::ItemType MultiLegRptTypeReqEnums::REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY( "REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY", 1 );
const MultiLegRptTypeReqEnums::ItemType MultiLegRptTypeReqEnums::REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY( "REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY", 2 );

const TradSesStatusRejReasonEnums::ItemType TradSesStatusRejReasonEnums::BAD_ENUM( "BAD_ENUM", TradSesStatusRejReasonEnums::ITEM_BAD_ENUM );
const TradSesStatusRejReasonEnums::ItemType TradSesStatusRejReasonEnums::UNKNOWN_OR_INVALID_TRADINGSESSIONID( "UNKNOWN_OR_INVALID_TRADINGSESSIONID", 1 );
const TradSesStatusRejReasonEnums::ItemType TradSesStatusRejReasonEnums::OTHER( "OTHER", 99 );

const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::BAD_ENUM( "BAD_ENUM", TradeRequestTypeEnums::ITEM_BAD_ENUM );
const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::ALL_TRADES( "ALL_TRADES", 0 );
const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST( "MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST", 1 );
const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::UNMATCHED_TRADES_THAT_MATCH_CRITERIA( "UNMATCHED_TRADES_THAT_MATCH_CRITERIA", 2 );
const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::UNREPORTED_TRADES_THAT_MATCH_CRITERIA( "UNREPORTED_TRADES_THAT_MATCH_CRITERIA", 3 );
const TradeRequestTypeEnums::ItemType TradeRequestTypeEnums::ADVISORIES_THAT_MATCH_CRITERIA( "ADVISORIES_THAT_MATCH_CRITERIA", 4 );

const PreviouslyReportedEnums::ItemType PreviouslyReportedEnums::BAD_ENUM( "BAD_ENUM", PreviouslyReportedEnums::ITEM_BAD_ENUM );
const PreviouslyReportedEnums::ItemType PreviouslyReportedEnums::YES( "YES", 'Y' );
const PreviouslyReportedEnums::ItemType PreviouslyReportedEnums::NO( "NO", 'N' );

const MatchStatusEnums::ItemType MatchStatusEnums::BAD_ENUM( "BAD_ENUM", MatchStatusEnums::ITEM_BAD_ENUM );
const MatchStatusEnums::ItemType MatchStatusEnums::COMPARED_MATCHED_OR_AFFIRMED( "COMPARED_MATCHED_OR_AFFIRMED", '0' );
const MatchStatusEnums::ItemType MatchStatusEnums::UNCOMPARED_UNMATCHED_OR_UNAFFIRMED( "UNCOMPARED_UNMATCHED_OR_UNAFFIRMED", '1' );
const MatchStatusEnums::ItemType MatchStatusEnums::ADVISORY_OR_ALERT( "ADVISORY_OR_ALERT", '2' );

const MatchTypeEnums::ItemType MatchTypeEnums::BAD_ENUM( "BAD_ENUM", MatchTypeEnums::ITEM_BAD_ENUM );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES_AND_EXECUTION_TIME( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES_AND_EXECUTION_TIME", SOHSTR(A1) );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES", SOHSTR(A2) );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES_AND_EXECUTION_TIME( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES_AND_EXECUTION_TIME", SOHSTR(A3) );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES", SOHSTR(A4) );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_EXECUTION_TIME( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_EXECUTION_TIME", SOHSTR(A5) );
const MatchTypeEnums::ItemType MatchTypeEnums::COMPARED_RECORDS_RESULTING_FROM_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_PAIR_OFFS( "COMPARED_RECORDS_RESULTING_FROM_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_PAIR_OFFS", SOHSTR(AQ) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_USING_A1_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED( "SUMMARIZED_MATCH_USING_A1_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED", SOHSTR(S1) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_USING_A2_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED( "SUMMARIZED_MATCH_USING_A2_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED", SOHSTR(S2) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_USING_A3_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED( "SUMMARIZED_MATCH_USING_A3_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED", SOHSTR(S3) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_USING_A4_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED( "SUMMARIZED_MATCH_USING_A4_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED", SOHSTR(S4) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_USING_A5_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED( "SUMMARIZED_MATCH_USING_A5_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED", SOHSTR(S5) );
const MatchTypeEnums::ItemType MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_MINUS_BADGES_AND_TIMES_ACT_M1_MATCH( "EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_MINUS_BADGES_AND_TIMES_ACT_M1_MATCH", SOHSTR(M1) );
const MatchTypeEnums::ItemType MatchTypeEnums::SUMMARIZED_MATCH_MINUS_BADGES_AND_TIMES_ACT_M2_MATCH( "SUMMARIZED_MATCH_MINUS_BADGES_AND_TIMES_ACT_M2_MATCH", SOHSTR(M2) );
const MatchTypeEnums::ItemType MatchTypeEnums::OCS_LOCKED_IN_NON_ACT( "OCS_LOCKED_IN_NON_ACT", SOHSTR(MT) );
const MatchTypeEnums::ItemType MatchTypeEnums::ACT_ACCEPTED_TRADE( "ACT_ACCEPTED_TRADE", SOHSTR(M3) );
const MatchTypeEnums::ItemType MatchTypeEnums::ACT_DEFAULT_TRADE( "ACT_DEFAULT_TRADE", SOHSTR(M4) );
const MatchTypeEnums::ItemType MatchTypeEnums::ACT_DEFAULT_AFTER_M2( "ACT_DEFAULT_AFTER_M2", SOHSTR(M5) );
const MatchTypeEnums::ItemType MatchTypeEnums::ACT_M6_MATCH( "ACT_M6_MATCH", SOHSTR(M6) );

const OddLotEnums::ItemType OddLotEnums::BAD_ENUM( "BAD_ENUM", OddLotEnums::ITEM_BAD_ENUM );
const OddLotEnums::ItemType OddLotEnums::YES( "YES", 'Y' );
const OddLotEnums::ItemType OddLotEnums::NO( "NO", 'N' );

const ClearingInstructionEnums::ItemType ClearingInstructionEnums::BAD_ENUM( "BAD_ENUM", ClearingInstructionEnums::ITEM_BAD_ENUM );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::PROCESS_NORMALLY( "PROCESS_NORMALLY", 0 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::EXCLUDE_FROM_ALL_NETTING( "EXCLUDE_FROM_ALL_NETTING", 1 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::BILATERAL_NETTING_ONLY( "BILATERAL_NETTING_ONLY", 2 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::EX_CLEARING( "EX_CLEARING", 3 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::SPECIAL_TRADE( "SPECIAL_TRADE", 4 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::MULTILATERAL_NETTING( "MULTILATERAL_NETTING", 5 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::CLEAR_AGAINST_CENTRAL_COUNTERPARTY( "CLEAR_AGAINST_CENTRAL_COUNTERPARTY", 6 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::EXCLUDE_FROM_CENTRAL_COUNTERPARTY( "EXCLUDE_FROM_CENTRAL_COUNTERPARTY", 7 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::MANUAL_MODE( "MANUAL_MODE", 8 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::AUTOMATIC_POSTING_MODE( "AUTOMATIC_POSTING_MODE", 9 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::AUTOMATIC_GIVE_UP_MODE( "AUTOMATIC_GIVE_UP_MODE", 10 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::QUALIFIED_SERVICE_REPRESENTATIVE( "QUALIFIED_SERVICE_REPRESENTATIVE", 11 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::CUSTOMER_TRADE( "CUSTOMER_TRADE", 12 );
const ClearingInstructionEnums::ItemType ClearingInstructionEnums::SELF_CLEARING( "SELF_CLEARING", 13 );

const AccountTypeEnums::ItemType AccountTypeEnums::BAD_ENUM( "BAD_ENUM", AccountTypeEnums::ITEM_BAD_ENUM );
const AccountTypeEnums::ItemType AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS( "ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS", 1 );
const AccountTypeEnums::ItemType AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS( "ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS", 2 );
const AccountTypeEnums::ItemType AccountTypeEnums::HOUSE_TRADER( "HOUSE_TRADER", 3 );
const AccountTypeEnums::ItemType AccountTypeEnums::FLOOR_TRADER( "FLOOR_TRADER", 4 );
const AccountTypeEnums::ItemType AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED( "ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED", 6 );
const AccountTypeEnums::ItemType AccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED( "ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED", 7 );
const AccountTypeEnums::ItemType AccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT( "JOINT_BACKOFFICE_ACCOUNT", 8 );

const CustOrderCapacityEnums::ItemType CustOrderCapacityEnums::BAD_ENUM( "BAD_ENUM", CustOrderCapacityEnums::ITEM_BAD_ENUM );
const CustOrderCapacityEnums::ItemType CustOrderCapacityEnums::MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT( "MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT", 1 );
const CustOrderCapacityEnums::ItemType CustOrderCapacityEnums::CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT( "CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT", 2 );
const CustOrderCapacityEnums::ItemType CustOrderCapacityEnums::MEMBER_TRADING_FOR_ANOTHER_MEMBER( "MEMBER_TRADING_FOR_ANOTHER_MEMBER", 3 );
const CustOrderCapacityEnums::ItemType CustOrderCapacityEnums::ALL_OTHER( "ALL_OTHER", 4 );

const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::BAD_ENUM( "BAD_ENUM", MassStatusReqTypeEnums::ITEM_BAD_ENUM );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITY( "STATUS_FOR_ORDERS_FOR_A_SECURITY", 1 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY( "STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY", 2 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PRODUCT( "STATUS_FOR_ORDERS_FOR_A_PRODUCT", 3 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_CFICODE( "STATUS_FOR_ORDERS_FOR_A_CFICODE", 4 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE( "STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE", 5 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION( "STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION", 6 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ALL_ORDERS( "STATUS_FOR_ALL_ORDERS", 7 );
const MassStatusReqTypeEnums::ItemType MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PARTYID( "STATUS_FOR_ORDERS_FOR_A_PARTYID", 8 );

const DayBookingInstEnums::ItemType DayBookingInstEnums::BAD_ENUM( "BAD_ENUM", DayBookingInstEnums::ITEM_BAD_ENUM );
const DayBookingInstEnums::ItemType DayBookingInstEnums::CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR( "CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR", '0' );
const DayBookingInstEnums::ItemType DayBookingInstEnums::SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING( "SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING", '1' );
const DayBookingInstEnums::ItemType DayBookingInstEnums::ACCUMULATE( "ACCUMULATE", '2' );

const BookingUnitEnums::ItemType BookingUnitEnums::BAD_ENUM( "BAD_ENUM", BookingUnitEnums::ITEM_BAD_ENUM );
const BookingUnitEnums::ItemType BookingUnitEnums::EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT( "EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT", '0' );
const BookingUnitEnums::ItemType BookingUnitEnums::AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER( "AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER", '1' );
const BookingUnitEnums::ItemType BookingUnitEnums::AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE( "AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE", '2' );

const PreallocMethodEnums::ItemType PreallocMethodEnums::BAD_ENUM( "BAD_ENUM", PreallocMethodEnums::ITEM_BAD_ENUM );
const PreallocMethodEnums::ItemType PreallocMethodEnums::PRO_RATA( "PRO_RATA", '0' );
const PreallocMethodEnums::ItemType PreallocMethodEnums::DO_NOT_PRO_RATA_DISCUSS_FIRST( "DO_NOT_PRO_RATA_DISCUSS_FIRST", '1' );

const AllocTypeEnums::ItemType AllocTypeEnums::BAD_ENUM( "BAD_ENUM", AllocTypeEnums::ITEM_BAD_ENUM );
const AllocTypeEnums::ItemType AllocTypeEnums::CALCULATED( "CALCULATED", 1 );
const AllocTypeEnums::ItemType AllocTypeEnums::PRELIMINARY( "PRELIMINARY", 2 );
const AllocTypeEnums::ItemType AllocTypeEnums::READY_TO_BOOK( "READY_TO_BOOK", 5 );
const AllocTypeEnums::ItemType AllocTypeEnums::WAREHOUSE_INSTRUCTION( "WAREHOUSE_INSTRUCTION", 7 );
const AllocTypeEnums::ItemType AllocTypeEnums::REQUEST_TO_INTERMEDIARY( "REQUEST_TO_INTERMEDIARY", 8 );

const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::BAD_ENUM( "BAD_ENUM", ClearingFeeIndicatorEnums::ITEM_BAD_ENUM );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::CBOE_MEMBER( "CBOE_MEMBER", SOHSTR(B) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::NON_MEMBER_AND_CUSTOMER( "NON_MEMBER_AND_CUSTOMER", SOHSTR(C) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::EQUITY_MEMBER_AND_CLEARING_MEMBER( "EQUITY_MEMBER_AND_CLEARING_MEMBER", SOHSTR(E) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS( "FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS", SOHSTR(F) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_106H_AND_106J_FIRMS( "_106H_AND_106J_FIRMS", SOHSTR(H) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS( "GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS", SOHSTR(I) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::LESSEE_AND_106F_EMPLOYEES( "LESSEE_AND_106F_EMPLOYEES", SOHSTR(L) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::ALL_OTHER_OWNERSHIP_TYPES( "ALL_OTHER_OWNERSHIP_TYPES", SOHSTR(M) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_1ST_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_1ST_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(1) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_2ND_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_2ND_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(2) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_3RD_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_3RD_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(3) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_4TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_4TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(4) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_5TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_5TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(5) );
const ClearingFeeIndicatorEnums::ItemType ClearingFeeIndicatorEnums::_6TH_YEAR_AND_BEYOND_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT( "_6TH_YEAR_AND_BEYOND_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT", SOHSTR(9) );

const WorkingIndicatorEnums::ItemType WorkingIndicatorEnums::BAD_ENUM( "BAD_ENUM", WorkingIndicatorEnums::ITEM_BAD_ENUM );
const WorkingIndicatorEnums::ItemType WorkingIndicatorEnums::YES( "YES", 'Y' );
const WorkingIndicatorEnums::ItemType WorkingIndicatorEnums::NO( "NO", 'N' );

const PriorityIndicatorEnums::ItemType PriorityIndicatorEnums::BAD_ENUM( "BAD_ENUM", PriorityIndicatorEnums::ITEM_BAD_ENUM );
const PriorityIndicatorEnums::ItemType PriorityIndicatorEnums::PRIORITY_UNCHANGED( "PRIORITY_UNCHANGED", 0 );
const PriorityIndicatorEnums::ItemType PriorityIndicatorEnums::LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE( "LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE", 1 );

const LegalConfirmEnums::ItemType LegalConfirmEnums::BAD_ENUM( "BAD_ENUM", LegalConfirmEnums::ITEM_BAD_ENUM );
const LegalConfirmEnums::ItemType LegalConfirmEnums::YES( "YES", 'Y' );
const LegalConfirmEnums::ItemType LegalConfirmEnums::NO( "NO", 'N' );

const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::BAD_ENUM( "BAD_ENUM", QuoteRequestRejectReasonEnums::ITEM_BAD_ENUM );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::UNKNOWN_SYMBOL( "UNKNOWN_SYMBOL", 1 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::EXCHANGE( "EXCHANGE", 2 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT( "QUOTE_REQUEST_EXCEEDS_LIMIT", 3 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::TOO_LATE_TO_ENTER( "TOO_LATE_TO_ENTER", 4 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::INVALID_PRICE( "INVALID_PRICE", 5 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::NOT_AUTHORIZED_TO_REQUEST_QUOTE( "NOT_AUTHORIZED_TO_REQUEST_QUOTE", 6 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::NO_MATCH_FOR_INQUIRY( "NO_MATCH_FOR_INQUIRY", 7 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::NO_MARKET_FOR_INSTRUMENT( "NO_MARKET_FOR_INSTRUMENT", 8 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::NO_INVENTORY( "NO_INVENTORY", 9 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::PASS( "PASS", 10 );
const QuoteRequestRejectReasonEnums::ItemType QuoteRequestRejectReasonEnums::OTHER( "OTHER", 99 );

const AcctIDSourceEnums::ItemType AcctIDSourceEnums::BAD_ENUM( "BAD_ENUM", AcctIDSourceEnums::ITEM_BAD_ENUM );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::BIC( "BIC", 1 );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::SID_CODE( "SID_CODE", 2 );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::TFM( "TFM", 3 );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::OMGEO( "OMGEO", 4 );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::DTCC_CODE( "DTCC_CODE", 5 );
const AcctIDSourceEnums::ItemType AcctIDSourceEnums::OTHER( "OTHER", 99 );

const ConfirmStatusEnums::ItemType ConfirmStatusEnums::BAD_ENUM( "BAD_ENUM", ConfirmStatusEnums::ITEM_BAD_ENUM );
const ConfirmStatusEnums::ItemType ConfirmStatusEnums::RECEIVED( "RECEIVED", 1 );
const ConfirmStatusEnums::ItemType ConfirmStatusEnums::MISMATCHED_ACCOUNT( "MISMATCHED_ACCOUNT", 2 );
const ConfirmStatusEnums::ItemType ConfirmStatusEnums::MISSING_SETTLEMENT_INSTRUCTIONS( "MISSING_SETTLEMENT_INSTRUCTIONS", 3 );
const ConfirmStatusEnums::ItemType ConfirmStatusEnums::CONFIRMED( "CONFIRMED", 4 );
const ConfirmStatusEnums::ItemType ConfirmStatusEnums::REQUEST_REJECTED( "REQUEST_REJECTED", 5 );

const ConfirmTransTypeEnums::ItemType ConfirmTransTypeEnums::BAD_ENUM( "BAD_ENUM", ConfirmTransTypeEnums::ITEM_BAD_ENUM );
const ConfirmTransTypeEnums::ItemType ConfirmTransTypeEnums::NEW( "NEW", 0 );
const ConfirmTransTypeEnums::ItemType ConfirmTransTypeEnums::REPLACE( "REPLACE", 1 );
const ConfirmTransTypeEnums::ItemType ConfirmTransTypeEnums::CANCEL( "CANCEL", 2 );

const DeliveryFormEnums::ItemType DeliveryFormEnums::BAD_ENUM( "BAD_ENUM", DeliveryFormEnums::ITEM_BAD_ENUM );
const DeliveryFormEnums::ItemType DeliveryFormEnums::BOOKENTRY( "BOOKENTRY", 1 );
const DeliveryFormEnums::ItemType DeliveryFormEnums::BEARER( "BEARER", 2 );

const LegSwapTypeEnums::ItemType LegSwapTypeEnums::BAD_ENUM( "BAD_ENUM", LegSwapTypeEnums::ITEM_BAD_ENUM );
const LegSwapTypeEnums::ItemType LegSwapTypeEnums::PAR_FOR_PAR( "PAR_FOR_PAR", 1 );
const LegSwapTypeEnums::ItemType LegSwapTypeEnums::MODIFIED_DURATION( "MODIFIED_DURATION", 2 );
const LegSwapTypeEnums::ItemType LegSwapTypeEnums::RISK( "RISK", 4 );
const LegSwapTypeEnums::ItemType LegSwapTypeEnums::PROCEEDS( "PROCEEDS", 5 );

const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::BAD_ENUM( "BAD_ENUM", QuotePriceTypeEnums::ITEM_BAD_ENUM );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::PERCENT( "PERCENT", 1 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::PER_SHARE( "PER_SHARE", 2 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::FIXED_AMOUNT( "FIXED_AMOUNT", 3 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR( "DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR", 4 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR( "PREMIUM_PERCENTAGE_POINTS_OVER_PAR", 5 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::BASIS_POINTS_RELATIVE_TO_BENCHMARK( "BASIS_POINTS_RELATIVE_TO_BENCHMARK", 6 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::TED_PRICE( "TED_PRICE", 7 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::TED_YIELD( "TED_YIELD", 8 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::YIELD_SPREAD( "YIELD_SPREAD", 9 );
const QuotePriceTypeEnums::ItemType QuotePriceTypeEnums::YIELD( "YIELD", 10 );

const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::BAD_ENUM( "BAD_ENUM", QuoteRespTypeEnums::ITEM_BAD_ENUM );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::HIT_LIFT( "HIT_LIFT", 1 );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::COUNTER( "COUNTER", 2 );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::EXPIRED( "EXPIRED", 3 );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::COVER( "COVER", 4 );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::DONE_AWAY( "DONE_AWAY", 5 );
const QuoteRespTypeEnums::ItemType QuoteRespTypeEnums::PASS( "PASS", 6 );

const PosTypeEnums::ItemType PosTypeEnums::BAD_ENUM( "BAD_ENUM", PosTypeEnums::ITEM_BAD_ENUM );
const PosTypeEnums::ItemType PosTypeEnums::TRANSACTION_QUANTITY( "TRANSACTION_QUANTITY", SOHSTR(TQ) );
const PosTypeEnums::ItemType PosTypeEnums::INTRA_SPREAD_QTY( "INTRA_SPREAD_QTY", SOHSTR(IAS) );
const PosTypeEnums::ItemType PosTypeEnums::INTER_SPREAD_QTY( "INTER_SPREAD_QTY", SOHSTR(IES) );
const PosTypeEnums::ItemType PosTypeEnums::END_OF_DAY_QTY( "END_OF_DAY_QTY", SOHSTR(FIN) );
const PosTypeEnums::ItemType PosTypeEnums::START_OF_DAY_QTY( "START_OF_DAY_QTY", SOHSTR(SOD) );
const PosTypeEnums::ItemType PosTypeEnums::OPTION_EXERCISE_QTY( "OPTION_EXERCISE_QTY", SOHSTR(EX) );
const PosTypeEnums::ItemType PosTypeEnums::OPTION_ASSIGNMENT( "OPTION_ASSIGNMENT", SOHSTR(AS) );
const PosTypeEnums::ItemType PosTypeEnums::TRANSACTION_FROM_EXERCISE( "TRANSACTION_FROM_EXERCISE", SOHSTR(TX) );
const PosTypeEnums::ItemType PosTypeEnums::TRANSACTION_FROM_ASSIGNMENT( "TRANSACTION_FROM_ASSIGNMENT", SOHSTR(TA) );
const PosTypeEnums::ItemType PosTypeEnums::PIT_TRADE_QTY( "PIT_TRADE_QTY", SOHSTR(PIT) );
const PosTypeEnums::ItemType PosTypeEnums::TRANSFER_TRADE_QTY( "TRANSFER_TRADE_QTY", SOHSTR(TRF) );
const PosTypeEnums::ItemType PosTypeEnums::ELECTRONIC_TRADE_QTY( "ELECTRONIC_TRADE_QTY", SOHSTR(ETR) );
const PosTypeEnums::ItemType PosTypeEnums::ALLOCATION_TRADE_QTY( "ALLOCATION_TRADE_QTY", SOHSTR(ALC) );
const PosTypeEnums::ItemType PosTypeEnums::ADJUSTMENT_QTY( "ADJUSTMENT_QTY", SOHSTR(PA) );
const PosTypeEnums::ItemType PosTypeEnums::AS_OF_TRADE_QTY( "AS_OF_TRADE_QTY", SOHSTR(ASF) );
const PosTypeEnums::ItemType PosTypeEnums::DELIVERY_QTY( "DELIVERY_QTY", SOHSTR(DLV) );
const PosTypeEnums::ItemType PosTypeEnums::TOTAL_TRANSACTION_QTY( "TOTAL_TRANSACTION_QTY", SOHSTR(TOT) );
const PosTypeEnums::ItemType PosTypeEnums::CROSS_MARGIN_QTY( "CROSS_MARGIN_QTY", SOHSTR(XM) );
const PosTypeEnums::ItemType PosTypeEnums::INTEGRAL_SPLIT( "INTEGRAL_SPLIT", SOHSTR(SPL) );

const PosQtyStatusEnums::ItemType PosQtyStatusEnums::BAD_ENUM( "BAD_ENUM", PosQtyStatusEnums::ITEM_BAD_ENUM );
const PosQtyStatusEnums::ItemType PosQtyStatusEnums::SUBMITTED( "SUBMITTED", 0 );
const PosQtyStatusEnums::ItemType PosQtyStatusEnums::ACCEPTED( "ACCEPTED", 1 );
const PosQtyStatusEnums::ItemType PosQtyStatusEnums::REJECTED( "REJECTED", 2 );

const PosAmtTypeEnums::ItemType PosAmtTypeEnums::BAD_ENUM( "BAD_ENUM", PosAmtTypeEnums::ITEM_BAD_ENUM );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::FINAL_MARK_TO_MARKET_AMOUNT( "FINAL_MARK_TO_MARKET_AMOUNT", SOHSTR(FMTM) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::INCREMENTAL_MARK_TO_MARKET_AMOUNT( "INCREMENTAL_MARK_TO_MARKET_AMOUNT", SOHSTR(IMTM) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::TRADE_VARIATION_AMOUNT( "TRADE_VARIATION_AMOUNT", SOHSTR(TVAR) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::START_OF_DAY_MARK_TO_MARKET_AMOUNT( "START_OF_DAY_MARK_TO_MARKET_AMOUNT", SOHSTR(SMTM) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::PREMIUM_AMOUNT( "PREMIUM_AMOUNT", SOHSTR(PREM) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::CASH_RESIDUAL_AMOUNT( "CASH_RESIDUAL_AMOUNT", SOHSTR(CRES) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::CASH_AMOUNT( "CASH_AMOUNT", SOHSTR(CASH) );
const PosAmtTypeEnums::ItemType PosAmtTypeEnums::VALUE_ADJUSTED_AMOUNT( "VALUE_ADJUSTED_AMOUNT", SOHSTR(VADJ) );

const PosTransTypeEnums::ItemType PosTransTypeEnums::BAD_ENUM( "BAD_ENUM", PosTransTypeEnums::ITEM_BAD_ENUM );
const PosTransTypeEnums::ItemType PosTransTypeEnums::EXERCISE( "EXERCISE", 1 );
const PosTransTypeEnums::ItemType PosTransTypeEnums::DO_NOT_EXERCISE( "DO_NOT_EXERCISE", 2 );
const PosTransTypeEnums::ItemType PosTransTypeEnums::POSITION_ADJUSTMENT( "POSITION_ADJUSTMENT", 3 );
const PosTransTypeEnums::ItemType PosTransTypeEnums::POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION( "POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION", 4 );
const PosTransTypeEnums::ItemType PosTransTypeEnums::PLEDGE( "PLEDGE", 5 );

const PosMaintActionEnums::ItemType PosMaintActionEnums::BAD_ENUM( "BAD_ENUM", PosMaintActionEnums::ITEM_BAD_ENUM );
const PosMaintActionEnums::ItemType PosMaintActionEnums::NEW_USED_TO_INCREMENT_THE_OVERALL_TRANSACTION_QUANTITY( "NEW_USED_TO_INCREMENT_THE_OVERALL_TRANSACTION_QUANTITY", 1 );
const PosMaintActionEnums::ItemType PosMaintActionEnums::REPLACE_USED_TO_OVERRIDE_THE_OVERALL_TRANSACTION_QUANTITY_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_THE_REFERENCE_ID( "REPLACE_USED_TO_OVERRIDE_THE_OVERALL_TRANSACTION_QUANTITY_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_THE_REFERENCE_ID", 2 );
const PosMaintActionEnums::ItemType PosMaintActionEnums::CANCEL_USED_TO_REMOVE_THE_OVERALL_TRANSACTION_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_REFERENCE_ID( "CANCEL_USED_TO_REMOVE_THE_OVERALL_TRANSACTION_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_REFERENCE_ID", 3 );

const SettlSessIDEnums::ItemType SettlSessIDEnums::BAD_ENUM( "BAD_ENUM", SettlSessIDEnums::ITEM_BAD_ENUM );
const SettlSessIDEnums::ItemType SettlSessIDEnums::INTRADAY( "INTRADAY", SOHSTR(ITD) );
const SettlSessIDEnums::ItemType SettlSessIDEnums::REGULAR_TRADING_HOURS( "REGULAR_TRADING_HOURS", SOHSTR(RTH) );
const SettlSessIDEnums::ItemType SettlSessIDEnums::ELECTRONIC_TRADING_HOURS( "ELECTRONIC_TRADING_HOURS", SOHSTR(ETH) );

const AdjustmentTypeEnums::ItemType AdjustmentTypeEnums::BAD_ENUM( "BAD_ENUM", AdjustmentTypeEnums::ITEM_BAD_ENUM );
const AdjustmentTypeEnums::ItemType AdjustmentTypeEnums::PROCESS_REQUEST_AS_MARGIN_DISPOSITION( "PROCESS_REQUEST_AS_MARGIN_DISPOSITION", 0 );
const AdjustmentTypeEnums::ItemType AdjustmentTypeEnums::DELTA_PLUS( "DELTA_PLUS", 1 );
const AdjustmentTypeEnums::ItemType AdjustmentTypeEnums::DELTA_MINUS( "DELTA_MINUS", 2 );
const AdjustmentTypeEnums::ItemType AdjustmentTypeEnums::FINAL( "FINAL", 3 );

const PosMaintStatusEnums::ItemType PosMaintStatusEnums::BAD_ENUM( "BAD_ENUM", PosMaintStatusEnums::ITEM_BAD_ENUM );
const PosMaintStatusEnums::ItemType PosMaintStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const PosMaintStatusEnums::ItemType PosMaintStatusEnums::ACCEPTED_WITH_WARNINGS( "ACCEPTED_WITH_WARNINGS", 1 );
const PosMaintStatusEnums::ItemType PosMaintStatusEnums::REJECTED( "REJECTED", 2 );
const PosMaintStatusEnums::ItemType PosMaintStatusEnums::COMPLETED( "COMPLETED", 3 );
const PosMaintStatusEnums::ItemType PosMaintStatusEnums::COMPLETED_WITH_WARNINGS( "COMPLETED_WITH_WARNINGS", 4 );

const PosMaintResultEnums::ItemType PosMaintResultEnums::BAD_ENUM( "BAD_ENUM", PosMaintResultEnums::ITEM_BAD_ENUM );
const PosMaintResultEnums::ItemType PosMaintResultEnums::SUCCESSFUL_COMPLETION( "SUCCESSFUL_COMPLETION", 0 );
const PosMaintResultEnums::ItemType PosMaintResultEnums::REJECTED( "REJECTED", 1 );
const PosMaintResultEnums::ItemType PosMaintResultEnums::OTHER( "OTHER", 99 );

const PosReqTypeEnums::ItemType PosReqTypeEnums::BAD_ENUM( "BAD_ENUM", PosReqTypeEnums::ITEM_BAD_ENUM );
const PosReqTypeEnums::ItemType PosReqTypeEnums::POSITIONS( "POSITIONS", 0 );
const PosReqTypeEnums::ItemType PosReqTypeEnums::TRADES( "TRADES", 1 );
const PosReqTypeEnums::ItemType PosReqTypeEnums::EXERCISES( "EXERCISES", 2 );
const PosReqTypeEnums::ItemType PosReqTypeEnums::ASSIGNMENTS( "ASSIGNMENTS", 3 );

const ResponseTransportTypeEnums::ItemType ResponseTransportTypeEnums::BAD_ENUM( "BAD_ENUM", ResponseTransportTypeEnums::ITEM_BAD_ENUM );
const ResponseTransportTypeEnums::ItemType ResponseTransportTypeEnums::INBAND_TRANSPORT_THE_REQUEST_WAS_SENT_OVER( "INBAND_TRANSPORT_THE_REQUEST_WAS_SENT_OVER", 0 );
const ResponseTransportTypeEnums::ItemType ResponseTransportTypeEnums::OUT_OF_BAND_PRE_ARRANGED_OUT_OF_BAND_DELIVERY_MECHANISM( "OUT_OF_BAND_PRE_ARRANGED_OUT_OF_BAND_DELIVERY_MECHANISM", 1 );

const PosReqResultEnums::ItemType PosReqResultEnums::BAD_ENUM( "BAD_ENUM", PosReqResultEnums::ITEM_BAD_ENUM );
const PosReqResultEnums::ItemType PosReqResultEnums::VALID_REQUEST( "VALID_REQUEST", 0 );
const PosReqResultEnums::ItemType PosReqResultEnums::INVALID_OR_UNSUPPORTED_REQUEST( "INVALID_OR_UNSUPPORTED_REQUEST", 1 );
const PosReqResultEnums::ItemType PosReqResultEnums::NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA( "NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA", 2 );
const PosReqResultEnums::ItemType PosReqResultEnums::NOT_AUTHORIZED_TO_REQUEST_POSITIONS( "NOT_AUTHORIZED_TO_REQUEST_POSITIONS", 3 );
const PosReqResultEnums::ItemType PosReqResultEnums::REQUEST_FOR_POSITION_NOT_SUPPORTED( "REQUEST_FOR_POSITION_NOT_SUPPORTED", 4 );
const PosReqResultEnums::ItemType PosReqResultEnums::OTHER( "OTHER", 99 );

const PosReqStatusEnums::ItemType PosReqStatusEnums::BAD_ENUM( "BAD_ENUM", PosReqStatusEnums::ITEM_BAD_ENUM );
const PosReqStatusEnums::ItemType PosReqStatusEnums::COMPLETED( "COMPLETED", 0 );
const PosReqStatusEnums::ItemType PosReqStatusEnums::COMPLETED_WITH_WARNINGS( "COMPLETED_WITH_WARNINGS", 1 );
const PosReqStatusEnums::ItemType PosReqStatusEnums::REJECTED( "REJECTED", 2 );

const SettlPriceTypeEnums::ItemType SettlPriceTypeEnums::BAD_ENUM( "BAD_ENUM", SettlPriceTypeEnums::ITEM_BAD_ENUM );
const SettlPriceTypeEnums::ItemType SettlPriceTypeEnums::FINAL( "FINAL", 1 );
const SettlPriceTypeEnums::ItemType SettlPriceTypeEnums::THEORETICAL( "THEORETICAL", 2 );

const AssignmentMethodEnums::ItemType AssignmentMethodEnums::BAD_ENUM( "BAD_ENUM", AssignmentMethodEnums::ITEM_BAD_ENUM );
const AssignmentMethodEnums::ItemType AssignmentMethodEnums::RANDOM( "RANDOM", 'R' );
const AssignmentMethodEnums::ItemType AssignmentMethodEnums::PRORATA( "PRORATA", 'P' );

const ExerciseMethodEnums::ItemType ExerciseMethodEnums::BAD_ENUM( "BAD_ENUM", ExerciseMethodEnums::ITEM_BAD_ENUM );
const ExerciseMethodEnums::ItemType ExerciseMethodEnums::AUTOMATIC( "AUTOMATIC", 'A' );
const ExerciseMethodEnums::ItemType ExerciseMethodEnums::MANUAL( "MANUAL", 'M' );

const TradeRequestResultEnums::ItemType TradeRequestResultEnums::BAD_ENUM( "BAD_ENUM", TradeRequestResultEnums::ITEM_BAD_ENUM );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::SUCCESSFUL( "SUCCESSFUL", 0 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT( "INVALID_OR_UNKNOWN_INSTRUMENT", 1 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::INVALID_TYPE_OF_TRADE_REQUESTED( "INVALID_TYPE_OF_TRADE_REQUESTED", 2 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::INVALID_PARTIES( "INVALID_PARTIES", 3 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED( "INVALID_TRANSPORT_TYPE_REQUESTED", 4 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::INVALID_DESTINATION_REQUESTED( "INVALID_DESTINATION_REQUESTED", 5 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::TRADEREQUESTTYPE_NOT_SUPPORTED( "TRADEREQUESTTYPE_NOT_SUPPORTED", 8 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST( "UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST", 9 );
const TradeRequestResultEnums::ItemType TradeRequestResultEnums::OTHER( "OTHER", 99 );

const TradeRequestStatusEnums::ItemType TradeRequestStatusEnums::BAD_ENUM( "BAD_ENUM", TradeRequestStatusEnums::ITEM_BAD_ENUM );
const TradeRequestStatusEnums::ItemType TradeRequestStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const TradeRequestStatusEnums::ItemType TradeRequestStatusEnums::COMPLETED( "COMPLETED", 1 );
const TradeRequestStatusEnums::ItemType TradeRequestStatusEnums::REJECTED( "REJECTED", 2 );

const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::BAD_ENUM( "BAD_ENUM", TradeReportRejectReasonEnums::ITEM_BAD_ENUM );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::SUCCESSFUL( "SUCCESSFUL", 0 );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::INVALID_PARTY_INFORMATION( "INVALID_PARTY_INFORMATION", 1 );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::UNKNOWN_INSTRUMENT( "UNKNOWN_INSTRUMENT", 2 );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::UNAUTHORIZED_TO_REPORT_TRADES( "UNAUTHORIZED_TO_REPORT_TRADES", 3 );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::INVALID_TRADE_TYPE( "INVALID_TRADE_TYPE", 4 );
const TradeReportRejectReasonEnums::ItemType TradeReportRejectReasonEnums::OTHER( "OTHER", 99 );

const SideMultiLegReportingTypeEnums::ItemType SideMultiLegReportingTypeEnums::BAD_ENUM( "BAD_ENUM", SideMultiLegReportingTypeEnums::ITEM_BAD_ENUM );
const SideMultiLegReportingTypeEnums::ItemType SideMultiLegReportingTypeEnums::SINGLE_SECURITY( "SINGLE_SECURITY", 1 );
const SideMultiLegReportingTypeEnums::ItemType SideMultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY( "INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY", 2 );
const SideMultiLegReportingTypeEnums::ItemType SideMultiLegReportingTypeEnums::MULTI_LEG_SECURITY( "MULTI_LEG_SECURITY", 3 );

const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::BAD_ENUM( "BAD_ENUM", TrdRegTimestampTypeEnums::ITEM_BAD_ENUM );
const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::EXECUTION_TIME( "EXECUTION_TIME", 1 );
const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::TIME_IN( "TIME_IN", 2 );
const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::TIME_OUT( "TIME_OUT", 3 );
const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::BROKER_RECEIPT( "BROKER_RECEIPT", 4 );
const TrdRegTimestampTypeEnums::ItemType TrdRegTimestampTypeEnums::BROKER_EXECUTION( "BROKER_EXECUTION", 5 );

const ConfirmTypeEnums::ItemType ConfirmTypeEnums::BAD_ENUM( "BAD_ENUM", ConfirmTypeEnums::ITEM_BAD_ENUM );
const ConfirmTypeEnums::ItemType ConfirmTypeEnums::STATUS( "STATUS", 1 );
const ConfirmTypeEnums::ItemType ConfirmTypeEnums::CONFIRMATION( "CONFIRMATION", 2 );
const ConfirmTypeEnums::ItemType ConfirmTypeEnums::CONFIRMATION_REQUEST_REJECTED( "CONFIRMATION_REQUEST_REJECTED", 3 );

const ConfirmRejReasonEnums::ItemType ConfirmRejReasonEnums::BAD_ENUM( "BAD_ENUM", ConfirmRejReasonEnums::ITEM_BAD_ENUM );
const ConfirmRejReasonEnums::ItemType ConfirmRejReasonEnums::MISMATCHED_ACCOUNT( "MISMATCHED_ACCOUNT", 1 );
const ConfirmRejReasonEnums::ItemType ConfirmRejReasonEnums::MISSING_SETTLEMENT_INSTRUCTIONS( "MISSING_SETTLEMENT_INSTRUCTIONS", 2 );
const ConfirmRejReasonEnums::ItemType ConfirmRejReasonEnums::OTHER( "OTHER", 99 );

const BookingTypeEnums::ItemType BookingTypeEnums::BAD_ENUM( "BAD_ENUM", BookingTypeEnums::ITEM_BAD_ENUM );
const BookingTypeEnums::ItemType BookingTypeEnums::REGULAR_BOOKING( "REGULAR_BOOKING", 0 );
const BookingTypeEnums::ItemType BookingTypeEnums::CFD( "CFD", 1 );
const BookingTypeEnums::ItemType BookingTypeEnums::TOTAL_RETURN_SWAP( "TOTAL_RETURN_SWAP", 2 );

const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::BAD_ENUM( "BAD_ENUM", AllocSettlInstTypeEnums::ITEM_BAD_ENUM );
const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::USE_DEFAULT_INSTRUCTIONS( "USE_DEFAULT_INSTRUCTIONS", 0 );
const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::DERIVE_FROM_PARAMETERS_PROVIDED( "DERIVE_FROM_PARAMETERS_PROVIDED", 1 );
const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::FULL_DETAILS_PROVIDED( "FULL_DETAILS_PROVIDED", 2 );
const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::SSI_DB_IDS_PROVIDED( "SSI_DB_IDS_PROVIDED", 3 );
const AllocSettlInstTypeEnums::ItemType AllocSettlInstTypeEnums::PHONE_FOR_INSTRUCTIONS( "PHONE_FOR_INSTRUCTIONS", 4 );

const DlvyInstTypeEnums::ItemType DlvyInstTypeEnums::BAD_ENUM( "BAD_ENUM", DlvyInstTypeEnums::ITEM_BAD_ENUM );
const DlvyInstTypeEnums::ItemType DlvyInstTypeEnums::SECURITIES( "SECURITIES", 'S' );
const DlvyInstTypeEnums::ItemType DlvyInstTypeEnums::CASH( "CASH", 'C' );

const TerminationTypeEnums::ItemType TerminationTypeEnums::BAD_ENUM( "BAD_ENUM", TerminationTypeEnums::ITEM_BAD_ENUM );
const TerminationTypeEnums::ItemType TerminationTypeEnums::OVERNIGHT( "OVERNIGHT", 1 );
const TerminationTypeEnums::ItemType TerminationTypeEnums::TERM( "TERM", 2 );
const TerminationTypeEnums::ItemType TerminationTypeEnums::FLEXIBLE( "FLEXIBLE", 3 );
const TerminationTypeEnums::ItemType TerminationTypeEnums::OPEN( "OPEN", 4 );

const SettlInstReqRejCodeEnums::ItemType SettlInstReqRejCodeEnums::BAD_ENUM( "BAD_ENUM", SettlInstReqRejCodeEnums::ITEM_BAD_ENUM );
const SettlInstReqRejCodeEnums::ItemType SettlInstReqRejCodeEnums::UNABLE_TO_PROCESS_REQUEST( "UNABLE_TO_PROCESS_REQUEST", 0 );
const SettlInstReqRejCodeEnums::ItemType SettlInstReqRejCodeEnums::UNKNOWN_ACCOUNT( "UNKNOWN_ACCOUNT", 1 );
const SettlInstReqRejCodeEnums::ItemType SettlInstReqRejCodeEnums::NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND( "NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND", 2 );
const SettlInstReqRejCodeEnums::ItemType SettlInstReqRejCodeEnums::OTHER( "OTHER", 99 );

const AllocReportTypeEnums::ItemType AllocReportTypeEnums::BAD_ENUM( "BAD_ENUM", AllocReportTypeEnums::ITEM_BAD_ENUM );
const AllocReportTypeEnums::ItemType AllocReportTypeEnums::SELLSIDE_CALCULATED_USING_PRELIMINARY( "SELLSIDE_CALCULATED_USING_PRELIMINARY", 3 );
const AllocReportTypeEnums::ItemType AllocReportTypeEnums::SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY( "SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY", 4 );
const AllocReportTypeEnums::ItemType AllocReportTypeEnums::WAREHOUSE_RECAP( "WAREHOUSE_RECAP", 5 );
const AllocReportTypeEnums::ItemType AllocReportTypeEnums::REQUEST_TO_INTERMEDIARY( "REQUEST_TO_INTERMEDIARY", 8 );

const AllocCancReplaceReasonEnums::ItemType AllocCancReplaceReasonEnums::BAD_ENUM( "BAD_ENUM", AllocCancReplaceReasonEnums::ITEM_BAD_ENUM );
const AllocCancReplaceReasonEnums::ItemType AllocCancReplaceReasonEnums::ORIGINAL_DETAILS_INCOMPLETE_INCORRECT( "ORIGINAL_DETAILS_INCOMPLETE_INCORRECT", 1 );
const AllocCancReplaceReasonEnums::ItemType AllocCancReplaceReasonEnums::CHANGE_IN_UNDERLYING_ORDER_DETAILS( "CHANGE_IN_UNDERLYING_ORDER_DETAILS", 2 );
const AllocCancReplaceReasonEnums::ItemType AllocCancReplaceReasonEnums::OTHER( "OTHER", 99 );

const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::BAD_ENUM( "BAD_ENUM", AllocAccountTypeEnums::ITEM_BAD_ENUM );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS( "ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS", 1 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS( "ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS", 2 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::HOUSE_TRADER( "HOUSE_TRADER", 3 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::FLOOR_TRADER( "FLOOR_TRADER", 4 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED( "ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED", 6 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED( "ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED", 7 );
const AllocAccountTypeEnums::ItemType AllocAccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT( "JOINT_BACKOFFICE_ACCOUNT", 8 );

const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::BAD_ENUM( "BAD_ENUM", PartySubIDTypeEnums::ITEM_BAD_ENUM );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::FIRM( "FIRM", 1 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::PERSON( "PERSON", 2 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::SYSTEM( "SYSTEM", 3 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::APPLICATION( "APPLICATION", 4 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::FULL_LEGAL_NAME_OF_FIRM( "FULL_LEGAL_NAME_OF_FIRM", 5 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::POSTAL_ADDRESS( "POSTAL_ADDRESS", 6 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::PHONE_NUMBER( "PHONE_NUMBER", 7 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::EMAIL_ADDRESS( "EMAIL_ADDRESS", 8 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::CONTACT_NAME( "CONTACT_NAME", 9 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::SECURITIES_ACCOUNT_NUMBER( "SECURITIES_ACCOUNT_NUMBER", 10 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::REGISTRATION_NUMBER( "REGISTRATION_NUMBER", 11 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::REGISTERED_ADDRESS_12( "REGISTERED_ADDRESS_12", 12 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::REGULATORY_STATUS( "REGULATORY_STATUS", 13 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::REGISTRATION_NAME( "REGISTRATION_NAME", 14 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::CASH_ACCOUNT_NUMBER( "CASH_ACCOUNT_NUMBER", 15 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::BIC( "BIC", 16 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::CSD_PARTICIPANT_MEMBER_CODE( "CSD_PARTICIPANT_MEMBER_CODE", 17 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::REGISTERED_ADDRESS_18( "REGISTERED_ADDRESS_18", 18 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::FUND_ACCOUNT_NAME( "FUND_ACCOUNT_NAME", 19 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::TELEX_NUMBER( "TELEX_NUMBER", 20 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::FAX_NUMBER( "FAX_NUMBER", 21 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::SECURITIES_ACCOUNT_NAME( "SECURITIES_ACCOUNT_NAME", 22 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::CASH_ACCOUNT_NAME( "CASH_ACCOUNT_NAME", 23 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::DEPARTMENT( "DEPARTMENT", 24 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::LOCATION( "LOCATION", 25 );
const PartySubIDTypeEnums::ItemType PartySubIDTypeEnums::POSITION_ACCOUNT_TYPE( "POSITION_ACCOUNT_TYPE", 26 );

const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::BAD_ENUM( "BAD_ENUM", AllocIntermedReqTypeEnums::ITEM_BAD_ENUM );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::PENDING_ACCEPT( "PENDING_ACCEPT", 1 );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::PENDING_RELEASE( "PENDING_RELEASE", 2 );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::PENDING_REVERSAL( "PENDING_REVERSAL", 3 );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::ACCEPT( "ACCEPT", 4 );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::BLOCK_LEVEL_REJECT( "BLOCK_LEVEL_REJECT", 5 );
const AllocIntermedReqTypeEnums::ItemType AllocIntermedReqTypeEnums::ACCOUNT_LEVEL_REJECT( "ACCOUNT_LEVEL_REJECT", 6 );

const ApplQueueResolutionEnums::ItemType ApplQueueResolutionEnums::BAD_ENUM( "BAD_ENUM", ApplQueueResolutionEnums::ITEM_BAD_ENUM );
const ApplQueueResolutionEnums::ItemType ApplQueueResolutionEnums::NO_ACTION_TAKEN( "NO_ACTION_TAKEN", 0 );
const ApplQueueResolutionEnums::ItemType ApplQueueResolutionEnums::QUEUE_FLUSHED( "QUEUE_FLUSHED", 1 );
const ApplQueueResolutionEnums::ItemType ApplQueueResolutionEnums::OVERLAY_LAST( "OVERLAY_LAST", 2 );
const ApplQueueResolutionEnums::ItemType ApplQueueResolutionEnums::END_SESSION( "END_SESSION", 3 );

const ApplQueueActionEnums::ItemType ApplQueueActionEnums::BAD_ENUM( "BAD_ENUM", ApplQueueActionEnums::ITEM_BAD_ENUM );
const ApplQueueActionEnums::ItemType ApplQueueActionEnums::NO_ACTION_TAKEN( "NO_ACTION_TAKEN", 0 );
const ApplQueueActionEnums::ItemType ApplQueueActionEnums::QUEUE_FLUSHED( "QUEUE_FLUSHED", 1 );
const ApplQueueActionEnums::ItemType ApplQueueActionEnums::OVERLAY_LAST( "OVERLAY_LAST", 2 );
const ApplQueueActionEnums::ItemType ApplQueueActionEnums::END_SESSION( "END_SESSION", 3 );

const AvgPxIndicatorEnums::ItemType AvgPxIndicatorEnums::BAD_ENUM( "BAD_ENUM", AvgPxIndicatorEnums::ITEM_BAD_ENUM );
const AvgPxIndicatorEnums::ItemType AvgPxIndicatorEnums::NO_AVERAGE_PRICING( "NO_AVERAGE_PRICING", 0 );
const AvgPxIndicatorEnums::ItemType AvgPxIndicatorEnums::TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID( "TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID", 1 );
const AvgPxIndicatorEnums::ItemType AvgPxIndicatorEnums::LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID( "LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID", 2 );

const TradeAllocIndicatorEnums::ItemType TradeAllocIndicatorEnums::BAD_ENUM( "BAD_ENUM", TradeAllocIndicatorEnums::ITEM_BAD_ENUM );
const TradeAllocIndicatorEnums::ItemType TradeAllocIndicatorEnums::ALLOCATION_NOT_REQUIRED( "ALLOCATION_NOT_REQUIRED", 0 );
const TradeAllocIndicatorEnums::ItemType TradeAllocIndicatorEnums::ALLOCATION_REQUIRED( "ALLOCATION_REQUIRED", 1 );
const TradeAllocIndicatorEnums::ItemType TradeAllocIndicatorEnums::USE_ALLOCATION_PROVIDED_WITH_THE_TRADE( "USE_ALLOCATION_PROVIDED_WITH_THE_TRADE", 2 );

const ExpirationCycleEnums::ItemType ExpirationCycleEnums::BAD_ENUM( "BAD_ENUM", ExpirationCycleEnums::ITEM_BAD_ENUM );
const ExpirationCycleEnums::ItemType ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_CLOSE( "EXPIRE_ON_TRADING_SESSION_CLOSE", 0 );
const ExpirationCycleEnums::ItemType ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_OPEN( "EXPIRE_ON_TRADING_SESSION_OPEN", 1 );

const TrdTypeEnums::ItemType TrdTypeEnums::BAD_ENUM( "BAD_ENUM", TrdTypeEnums::ITEM_BAD_ENUM );
const TrdTypeEnums::ItemType TrdTypeEnums::REGULAR_TRADE( "REGULAR_TRADE", 0 );
const TrdTypeEnums::ItemType TrdTypeEnums::BLOCK_TRADE( "BLOCK_TRADE", 1 );
const TrdTypeEnums::ItemType TrdTypeEnums::EFP( "EFP", 2 );
const TrdTypeEnums::ItemType TrdTypeEnums::TRANSFER( "TRANSFER", 3 );
const TrdTypeEnums::ItemType TrdTypeEnums::LATE_TRADE( "LATE_TRADE", 4 );
const TrdTypeEnums::ItemType TrdTypeEnums::T_TRADE( "T_TRADE", 5 );
const TrdTypeEnums::ItemType TrdTypeEnums::WEIGHTED_AVERAGE_PRICE_TRADE( "WEIGHTED_AVERAGE_PRICE_TRADE", 6 );
const TrdTypeEnums::ItemType TrdTypeEnums::BUNCHED_TRADE( "BUNCHED_TRADE", 7 );
const TrdTypeEnums::ItemType TrdTypeEnums::LATE_BUNCHED_TRADE( "LATE_BUNCHED_TRADE", 8 );
const TrdTypeEnums::ItemType TrdTypeEnums::PRIOR_REFERENCE_PRICE_TRADE( "PRIOR_REFERENCE_PRICE_TRADE", 9 );
const TrdTypeEnums::ItemType TrdTypeEnums::AFTER_HOURS_TRADE( "AFTER_HOURS_TRADE", 10 );

const PegMoveTypeEnums::ItemType PegMoveTypeEnums::BAD_ENUM( "BAD_ENUM", PegMoveTypeEnums::ITEM_BAD_ENUM );
const PegMoveTypeEnums::ItemType PegMoveTypeEnums::FLOATING( "FLOATING", 0 );
const PegMoveTypeEnums::ItemType PegMoveTypeEnums::FIXED( "FIXED", 1 );

const PegOffsetTypeEnums::ItemType PegOffsetTypeEnums::BAD_ENUM( "BAD_ENUM", PegOffsetTypeEnums::ITEM_BAD_ENUM );
const PegOffsetTypeEnums::ItemType PegOffsetTypeEnums::PRICE( "PRICE", 0 );
const PegOffsetTypeEnums::ItemType PegOffsetTypeEnums::BASIS_POINTS( "BASIS_POINTS", 1 );
const PegOffsetTypeEnums::ItemType PegOffsetTypeEnums::TICKS( "TICKS", 2 );
const PegOffsetTypeEnums::ItemType PegOffsetTypeEnums::PRICE_TIER( "PRICE_TIER", 3 );

const PegLimitTypeEnums::ItemType PegLimitTypeEnums::BAD_ENUM( "BAD_ENUM", PegLimitTypeEnums::ITEM_BAD_ENUM );
const PegLimitTypeEnums::ItemType PegLimitTypeEnums::OR_BETTER( "OR_BETTER", 0 );
const PegLimitTypeEnums::ItemType PegLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT( "STRICT_LIMIT_IS_A_STRICT_LIMIT", 1 );
const PegLimitTypeEnums::ItemType PegLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_PEG_LIMIT_IS_A_MINIMUM_AND_FOR_A_SELL_THE_PEG_LIMIT_IS_A_MAXIMUM( "OR_WORSE_FOR_A_BUY_THE_PEG_LIMIT_IS_A_MINIMUM_AND_FOR_A_SELL_THE_PEG_LIMIT_IS_A_MAXIMUM", 2 );

const PegRoundDirectionEnums::ItemType PegRoundDirectionEnums::BAD_ENUM( "BAD_ENUM", PegRoundDirectionEnums::ITEM_BAD_ENUM );
const PegRoundDirectionEnums::ItemType PegRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK( "MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK", 1 );
const PegRoundDirectionEnums::ItemType PegRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK( "MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK", 2 );

const PegScopeEnums::ItemType PegScopeEnums::BAD_ENUM( "BAD_ENUM", PegScopeEnums::ITEM_BAD_ENUM );
const PegScopeEnums::ItemType PegScopeEnums::LOCAL( "LOCAL", 1 );
const PegScopeEnums::ItemType PegScopeEnums::NATIONAL( "NATIONAL", 2 );
const PegScopeEnums::ItemType PegScopeEnums::GLOBAL( "GLOBAL", 3 );
const PegScopeEnums::ItemType PegScopeEnums::NATIONAL_EXCLUDING_LOCAL( "NATIONAL_EXCLUDING_LOCAL", 4 );

const DiscretionMoveTypeEnums::ItemType DiscretionMoveTypeEnums::BAD_ENUM( "BAD_ENUM", DiscretionMoveTypeEnums::ITEM_BAD_ENUM );
const DiscretionMoveTypeEnums::ItemType DiscretionMoveTypeEnums::FLOATING( "FLOATING", 0 );
const DiscretionMoveTypeEnums::ItemType DiscretionMoveTypeEnums::FIXED( "FIXED", 1 );

const DiscretionOffsetTypeEnums::ItemType DiscretionOffsetTypeEnums::BAD_ENUM( "BAD_ENUM", DiscretionOffsetTypeEnums::ITEM_BAD_ENUM );
const DiscretionOffsetTypeEnums::ItemType DiscretionOffsetTypeEnums::PRICE( "PRICE", 0 );
const DiscretionOffsetTypeEnums::ItemType DiscretionOffsetTypeEnums::BASIS_POINTS( "BASIS_POINTS", 1 );
const DiscretionOffsetTypeEnums::ItemType DiscretionOffsetTypeEnums::TICKS( "TICKS", 2 );
const DiscretionOffsetTypeEnums::ItemType DiscretionOffsetTypeEnums::PRICE_TIER( "PRICE_TIER", 3 );

const DiscretionLimitTypeEnums::ItemType DiscretionLimitTypeEnums::BAD_ENUM( "BAD_ENUM", DiscretionLimitTypeEnums::ITEM_BAD_ENUM );
const DiscretionLimitTypeEnums::ItemType DiscretionLimitTypeEnums::OR_BETTER( "OR_BETTER", 0 );
const DiscretionLimitTypeEnums::ItemType DiscretionLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT( "STRICT_LIMIT_IS_A_STRICT_LIMIT", 1 );
const DiscretionLimitTypeEnums::ItemType DiscretionLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_DISCRETION_PRICE_IS_A_MINIMUM_AND_FOR_A_SELL_THE_DISCRETION_PRICE_IS_A_MAXIMUM( "OR_WORSE_FOR_A_BUY_THE_DISCRETION_PRICE_IS_A_MINIMUM_AND_FOR_A_SELL_THE_DISCRETION_PRICE_IS_A_MAXIMUM", 2 );

const DiscretionRoundDirectionEnums::ItemType DiscretionRoundDirectionEnums::BAD_ENUM( "BAD_ENUM", DiscretionRoundDirectionEnums::ITEM_BAD_ENUM );
const DiscretionRoundDirectionEnums::ItemType DiscretionRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK( "MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK", 1 );
const DiscretionRoundDirectionEnums::ItemType DiscretionRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK( "MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK", 2 );

const DiscretionScopeEnums::ItemType DiscretionScopeEnums::BAD_ENUM( "BAD_ENUM", DiscretionScopeEnums::ITEM_BAD_ENUM );
const DiscretionScopeEnums::ItemType DiscretionScopeEnums::LOCAL( "LOCAL", 1 );
const DiscretionScopeEnums::ItemType DiscretionScopeEnums::NATIONAL( "NATIONAL", 2 );
const DiscretionScopeEnums::ItemType DiscretionScopeEnums::GLOBAL( "GLOBAL", 3 );
const DiscretionScopeEnums::ItemType DiscretionScopeEnums::NATIONAL_EXCLUDING_LOCAL( "NATIONAL_EXCLUDING_LOCAL", 4 );

const TargetStrategyEnums::ItemType TargetStrategyEnums::BAD_ENUM( "BAD_ENUM", TargetStrategyEnums::ITEM_BAD_ENUM );
const TargetStrategyEnums::ItemType TargetStrategyEnums::VWAP( "VWAP", 1 );
const TargetStrategyEnums::ItemType TargetStrategyEnums::PARTICIPATE( "PARTICIPATE", 2 );
const TargetStrategyEnums::ItemType TargetStrategyEnums::MININIZE_MARKET_IMPACT( "MININIZE_MARKET_IMPACT", 3 );

const LastLiquidityIndEnums::ItemType LastLiquidityIndEnums::BAD_ENUM( "BAD_ENUM", LastLiquidityIndEnums::ITEM_BAD_ENUM );
const LastLiquidityIndEnums::ItemType LastLiquidityIndEnums::ADDED_LIQUIDITY( "ADDED_LIQUIDITY", 1 );
const LastLiquidityIndEnums::ItemType LastLiquidityIndEnums::REMOVED_LIQUIDITY( "REMOVED_LIQUIDITY", 2 );
const LastLiquidityIndEnums::ItemType LastLiquidityIndEnums::LIQUIDITY_ROUTED_OUT( "LIQUIDITY_ROUTED_OUT", 3 );

const PublishTrdIndicatorEnums::ItemType PublishTrdIndicatorEnums::BAD_ENUM( "BAD_ENUM", PublishTrdIndicatorEnums::ITEM_BAD_ENUM );
const PublishTrdIndicatorEnums::ItemType PublishTrdIndicatorEnums::YES( "YES", 'Y' );
const PublishTrdIndicatorEnums::ItemType PublishTrdIndicatorEnums::NO( "NO", 'N' );

const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::BAD_ENUM( "BAD_ENUM", ShortSaleReasonEnums::ITEM_BAD_ENUM );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::DEALER_SOLD_SHORT( "DEALER_SOLD_SHORT", 0 );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::DEALER_SOLD_SHORT_EXEMPT( "DEALER_SOLD_SHORT_EXEMPT", 1 );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT( "SELLING_CUSTOMER_SOLD_SHORT", 2 );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT_EXEMPT( "SELLING_CUSTOMER_SOLD_SHORT_EXEMPT", 3 );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::QUALIFED_SERVICE_REPRESENTATIVE( "QUALIFED_SERVICE_REPRESENTATIVE", 4 );
const ShortSaleReasonEnums::ItemType ShortSaleReasonEnums::QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT( "QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT", 5 );

const QtyTypeEnums::ItemType QtyTypeEnums::BAD_ENUM( "BAD_ENUM", QtyTypeEnums::ITEM_BAD_ENUM );
const QtyTypeEnums::ItemType QtyTypeEnums::UNITS( "UNITS", 0 );
const QtyTypeEnums::ItemType QtyTypeEnums::CONTRACTS( "CONTRACTS", 1 );

const TradeReportTypeEnums::ItemType TradeReportTypeEnums::BAD_ENUM( "BAD_ENUM", TradeReportTypeEnums::ITEM_BAD_ENUM );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::SUBMIT( "SUBMIT", 0 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::ALLEGED( "ALLEGED", 1 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::ACCEPT( "ACCEPT", 2 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::DECLINE( "DECLINE", 3 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::ADDENDUM( "ADDENDUM", 4 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::NO_WAS( "NO_WAS", 5 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::TRADE_REPORT_CANCEL( "TRADE_REPORT_CANCEL", 6 );
const TradeReportTypeEnums::ItemType TradeReportTypeEnums::LOCKED_IN_TRADE_BREAK( "LOCKED_IN_TRADE_BREAK", 7 );

const AllocNoOrdersTypeEnums::ItemType AllocNoOrdersTypeEnums::BAD_ENUM( "BAD_ENUM", AllocNoOrdersTypeEnums::ITEM_BAD_ENUM );
const AllocNoOrdersTypeEnums::ItemType AllocNoOrdersTypeEnums::NOT_SPECIFIED( "NOT_SPECIFIED", 0 );
const AllocNoOrdersTypeEnums::ItemType AllocNoOrdersTypeEnums::EXPLICIT_LIST_PROVIDED( "EXPLICIT_LIST_PROVIDED", 1 );

const EventTypeEnums::ItemType EventTypeEnums::BAD_ENUM( "BAD_ENUM", EventTypeEnums::ITEM_BAD_ENUM );
const EventTypeEnums::ItemType EventTypeEnums::PUT( "PUT", 1 );
const EventTypeEnums::ItemType EventTypeEnums::CALL( "CALL", 2 );
const EventTypeEnums::ItemType EventTypeEnums::TENDER( "TENDER", 3 );
const EventTypeEnums::ItemType EventTypeEnums::SINKING_FUND_CALL( "SINKING_FUND_CALL", 4 );
const EventTypeEnums::ItemType EventTypeEnums::OTHER( "OTHER", 99 );

const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::BAD_ENUM( "BAD_ENUM", InstrAttribTypeEnums::ITEM_BAD_ENUM );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::FLAT( "FLAT", 1 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::ZERO_COUPON( "ZERO_COUPON", 2 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::INTEREST_BEARING( "INTEREST_BEARING", 3 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::NO_PERIODIC_PAYMENTS( "NO_PERIODIC_PAYMENTS", 4 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::VARIABLE_RATE( "VARIABLE_RATE", 5 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::LESS_FEE_FOR_PUT( "LESS_FEE_FOR_PUT", 6 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::STEPPED_COUPON( "STEPPED_COUPON", 7 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::COUPON_PERIOD( "COUPON_PERIOD", 8 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::WHEN_AND_IF_ISSUED( "WHEN_AND_IF_ISSUED", 9 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT( "ORIGINAL_ISSUE_DISCOUNT", 10 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::CALLABLE_PUTTABLE( "CALLABLE_PUTTABLE", 11 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::ESCROWED_TO_MATURITY( "ESCROWED_TO_MATURITY", 12 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::ESCROWED_TO_REDEMPTION_DATE_CALLABLE_SUPPLY_REDEMPTION_DATE_IN_THE_INSTRATTRIBVALUE( "ESCROWED_TO_REDEMPTION_DATE_CALLABLE_SUPPLY_REDEMPTION_DATE_IN_THE_INSTRATTRIBVALUE", 13 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::PREREFUNDED( "PREREFUNDED", 14 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::IN_DEFAULT( "IN_DEFAULT", 15 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::UNRATED( "UNRATED", 16 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::TAXABLE( "TAXABLE", 17 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::INDEXED( "INDEXED", 18 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX( "SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX", 19 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT_PRICE_SUPPLY_PRICE_IN_THE_INSTRATTRIBVALUE( "ORIGINAL_ISSUE_DISCOUNT_PRICE_SUPPLY_PRICE_IN_THE_INSTRATTRIBVALUE", 20 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::CALLABLE_BELOW_MATURITY_VALUE( "CALLABLE_BELOW_MATURITY_VALUE", 21 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::CALLABLE_WITHOUT_NOTICE_BY_MAIL_TO_HOLDER_UNLESS_REGISTERED( "CALLABLE_WITHOUT_NOTICE_BY_MAIL_TO_HOLDER_UNLESS_REGISTERED", 22 );
const InstrAttribTypeEnums::ItemType InstrAttribTypeEnums::TEXT_SUPPLY_THE_TEXT_OF_THE_ATTRIBUTE_OR_DISCLAIMER_IN_THE_INSTRATTRIBVALUE( "TEXT_SUPPLY_THE_TEXT_OF_THE_ATTRIBUTE_OR_DISCLAIMER_IN_THE_INSTRATTRIBVALUE", 99 );

const CPProgramEnums::ItemType CPProgramEnums::BAD_ENUM( "BAD_ENUM", CPProgramEnums::ITEM_BAD_ENUM );
const CPProgramEnums::ItemType CPProgramEnums::_3( "_3", 1 );
const CPProgramEnums::ItemType CPProgramEnums::_4( "_4", 2 );
const CPProgramEnums::ItemType CPProgramEnums::OTHER( "OTHER", 99 );

const MiscFeeBasisEnums::ItemType MiscFeeBasisEnums::BAD_ENUM( "BAD_ENUM", MiscFeeBasisEnums::ITEM_BAD_ENUM );
const MiscFeeBasisEnums::ItemType MiscFeeBasisEnums::ABSOLUTE( "ABSOLUTE", 0 );
const MiscFeeBasisEnums::ItemType MiscFeeBasisEnums::PER_UNIT( "PER_UNIT", 1 );
const MiscFeeBasisEnums::ItemType MiscFeeBasisEnums::PERCENTAGE( "PERCENTAGE", 2 );

const LastFragmentEnums::ItemType LastFragmentEnums::BAD_ENUM( "BAD_ENUM", LastFragmentEnums::ITEM_BAD_ENUM );
const LastFragmentEnums::ItemType LastFragmentEnums::YES( "YES", 'Y' );
const LastFragmentEnums::ItemType LastFragmentEnums::NO( "NO", 'N' );

const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::BAD_ENUM( "BAD_ENUM", CollAsgnReasonEnums::ITEM_BAD_ENUM );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::INITIAL( "INITIAL", 0 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::SCHEDULED( "SCHEDULED", 1 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::TIME_WARNING( "TIME_WARNING", 2 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::MARGIN_DEFICIENCY( "MARGIN_DEFICIENCY", 3 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::MARGIN_EXCESS( "MARGIN_EXCESS", 4 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::FORWARD_COLLATERAL_DEMAND( "FORWARD_COLLATERAL_DEMAND", 5 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::EVENT_OF_DEFAULT( "EVENT_OF_DEFAULT", 6 );
const CollAsgnReasonEnums::ItemType CollAsgnReasonEnums::ADVERSE_TAX_EVENT( "ADVERSE_TAX_EVENT", 7 );

const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::BAD_ENUM( "BAD_ENUM", CollInquiryQualifierEnums::ITEM_BAD_ENUM );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::TRADEDATE( "TRADEDATE", 0 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::GC_INSTRUMENT( "GC_INSTRUMENT", 1 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::COLLATERALINSTRUMENT( "COLLATERALINSTRUMENT", 2 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::SUBSTITUTION_ELIGIBLE( "SUBSTITUTION_ELIGIBLE", 3 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::NOT_ASSIGNED( "NOT_ASSIGNED", 4 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::PARTIALLY_ASSIGNED( "PARTIALLY_ASSIGNED", 5 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::FULLY_ASSIGNED( "FULLY_ASSIGNED", 6 );
const CollInquiryQualifierEnums::ItemType CollInquiryQualifierEnums::OUTSTANDING_TRADES( "OUTSTANDING_TRADES", 7 );

const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::BAD_ENUM( "BAD_ENUM", CollAsgnTransTypeEnums::ITEM_BAD_ENUM );
const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::NEW( "NEW", 0 );
const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::REPLACE( "REPLACE", 1 );
const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::CANCEL( "CANCEL", 2 );
const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::RELEASE( "RELEASE", 3 );
const CollAsgnTransTypeEnums::ItemType CollAsgnTransTypeEnums::REVERSE( "REVERSE", 4 );

const CollAsgnRespTypeEnums::ItemType CollAsgnRespTypeEnums::BAD_ENUM( "BAD_ENUM", CollAsgnRespTypeEnums::ITEM_BAD_ENUM );
const CollAsgnRespTypeEnums::ItemType CollAsgnRespTypeEnums::RECEIVED( "RECEIVED", 0 );
const CollAsgnRespTypeEnums::ItemType CollAsgnRespTypeEnums::ACCEPTED( "ACCEPTED", 1 );
const CollAsgnRespTypeEnums::ItemType CollAsgnRespTypeEnums::DECLINED( "DECLINED", 2 );
const CollAsgnRespTypeEnums::ItemType CollAsgnRespTypeEnums::REJECTED( "REJECTED", 3 );

const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::BAD_ENUM( "BAD_ENUM", CollAsgnRejectReasonEnums::ITEM_BAD_ENUM );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::UNKNOWN_DEAL( "UNKNOWN_DEAL", 0 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::UNKNOWN_OR_INVALID_INSTRUMENT( "UNKNOWN_OR_INVALID_INSTRUMENT", 1 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::UNAUTHORIZED_TRANSACTION( "UNAUTHORIZED_TRANSACTION", 2 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::INSUFFICIENT_COLLATERAL( "INSUFFICIENT_COLLATERAL", 3 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::INVALID_TYPE_OF_COLLATERAL( "INVALID_TYPE_OF_COLLATERAL", 4 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::EXCESSIVE_SUBSTITUTION( "EXCESSIVE_SUBSTITUTION", 5 );
const CollAsgnRejectReasonEnums::ItemType CollAsgnRejectReasonEnums::OTHER( "OTHER", 99 );

const CollStatusEnums::ItemType CollStatusEnums::BAD_ENUM( "BAD_ENUM", CollStatusEnums::ITEM_BAD_ENUM );
const CollStatusEnums::ItemType CollStatusEnums::UNASSIGNED( "UNASSIGNED", 0 );
const CollStatusEnums::ItemType CollStatusEnums::PARTIALLY_ASSIGNED( "PARTIALLY_ASSIGNED", 1 );
const CollStatusEnums::ItemType CollStatusEnums::ASSIGNMENT_PROPOSED( "ASSIGNMENT_PROPOSED", 2 );
const CollStatusEnums::ItemType CollStatusEnums::ASSIGNED( "ASSIGNED", 3 );
const CollStatusEnums::ItemType CollStatusEnums::CHALLENGED( "CHALLENGED", 4 );

const DeliveryTypeEnums::ItemType DeliveryTypeEnums::BAD_ENUM( "BAD_ENUM", DeliveryTypeEnums::ITEM_BAD_ENUM );
const DeliveryTypeEnums::ItemType DeliveryTypeEnums::VERSUS_PAYMENT_DELIVER( "VERSUS_PAYMENT_DELIVER", 0 );
const DeliveryTypeEnums::ItemType DeliveryTypeEnums::FREE_DELIVER( "FREE_DELIVER", 1 );
const DeliveryTypeEnums::ItemType DeliveryTypeEnums::TRI_PARTY( "TRI_PARTY", 2 );
const DeliveryTypeEnums::ItemType DeliveryTypeEnums::HOLD_IN_CUSTODY( "HOLD_IN_CUSTODY", 3 );

const UserRequestTypeEnums::ItemType UserRequestTypeEnums::BAD_ENUM( "BAD_ENUM", UserRequestTypeEnums::ITEM_BAD_ENUM );
const UserRequestTypeEnums::ItemType UserRequestTypeEnums::LOGONUSER( "LOGONUSER", 1 );
const UserRequestTypeEnums::ItemType UserRequestTypeEnums::LOGOFFUSER( "LOGOFFUSER", 2 );
const UserRequestTypeEnums::ItemType UserRequestTypeEnums::CHANGEPASSWORDFORUSER( "CHANGEPASSWORDFORUSER", 3 );
const UserRequestTypeEnums::ItemType UserRequestTypeEnums::REQUEST_INDIVIDUAL_USER_STATUS( "REQUEST_INDIVIDUAL_USER_STATUS", 4 );

const UserStatusEnums::ItemType UserStatusEnums::BAD_ENUM( "BAD_ENUM", UserStatusEnums::ITEM_BAD_ENUM );
const UserStatusEnums::ItemType UserStatusEnums::LOGGED_IN( "LOGGED_IN", 1 );
const UserStatusEnums::ItemType UserStatusEnums::NOT_LOGGED_IN( "NOT_LOGGED_IN", 2 );
const UserStatusEnums::ItemType UserStatusEnums::USER_NOT_RECOGNISED( "USER_NOT_RECOGNISED", 3 );
const UserStatusEnums::ItemType UserStatusEnums::PASSWORD_INCORRECT( "PASSWORD_INCORRECT", 4 );
const UserStatusEnums::ItemType UserStatusEnums::PASSWORD_CHANGED( "PASSWORD_CHANGED", 5 );
const UserStatusEnums::ItemType UserStatusEnums::OTHER( "OTHER", 6 );

const StatusValueEnums::ItemType StatusValueEnums::BAD_ENUM( "BAD_ENUM", StatusValueEnums::ITEM_BAD_ENUM );
const StatusValueEnums::ItemType StatusValueEnums::CONNECTED( "CONNECTED", 1 );
const StatusValueEnums::ItemType StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_UP( "NOT_CONNECTED_DOWN_EXPECTED_UP", 2 );
const StatusValueEnums::ItemType StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_DOWN( "NOT_CONNECTED_DOWN_EXPECTED_DOWN", 3 );
const StatusValueEnums::ItemType StatusValueEnums::IN_PROCESS( "IN_PROCESS", 4 );

const NetworkRequestTypeEnums::ItemType NetworkRequestTypeEnums::BAD_ENUM( "BAD_ENUM", NetworkRequestTypeEnums::ITEM_BAD_ENUM );
const NetworkRequestTypeEnums::ItemType NetworkRequestTypeEnums::SNAPSHOT( "SNAPSHOT", 1 );
const NetworkRequestTypeEnums::ItemType NetworkRequestTypeEnums::SUBSCRIBE( "SUBSCRIBE", 2 );
const NetworkRequestTypeEnums::ItemType NetworkRequestTypeEnums::STOP_SUBSCRIBING( "STOP_SUBSCRIBING", 4 );
const NetworkRequestTypeEnums::ItemType NetworkRequestTypeEnums::LEVEL_OF_DETAIL_THEN_NOCOMPIDS_BECOMES_REQUIRED( "LEVEL_OF_DETAIL_THEN_NOCOMPIDS_BECOMES_REQUIRED", 8 );

const NetworkStatusResponseTypeEnums::ItemType NetworkStatusResponseTypeEnums::BAD_ENUM( "BAD_ENUM", NetworkStatusResponseTypeEnums::ITEM_BAD_ENUM );
const NetworkStatusResponseTypeEnums::ItemType NetworkStatusResponseTypeEnums::FULL( "FULL", 1 );
const NetworkStatusResponseTypeEnums::ItemType NetworkStatusResponseTypeEnums::INCREMENTAL_UPDATE( "INCREMENTAL_UPDATE", 2 );

const TrdRptStatusEnums::ItemType TrdRptStatusEnums::BAD_ENUM( "BAD_ENUM", TrdRptStatusEnums::ITEM_BAD_ENUM );
const TrdRptStatusEnums::ItemType TrdRptStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const TrdRptStatusEnums::ItemType TrdRptStatusEnums::REJECTED( "REJECTED", 1 );

const AffirmStatusEnums::ItemType AffirmStatusEnums::BAD_ENUM( "BAD_ENUM", AffirmStatusEnums::ITEM_BAD_ENUM );
const AffirmStatusEnums::ItemType AffirmStatusEnums::RECEIVED( "RECEIVED", 1 );
const AffirmStatusEnums::ItemType AffirmStatusEnums::CONFIRM_REJECTED_IE_NOT_AFFIRMED( "CONFIRM_REJECTED_IE_NOT_AFFIRMED", 2 );
const AffirmStatusEnums::ItemType AffirmStatusEnums::AFFIRMED( "AFFIRMED", 3 );

const CollActionEnums::ItemType CollActionEnums::BAD_ENUM( "BAD_ENUM", CollActionEnums::ITEM_BAD_ENUM );
const CollActionEnums::ItemType CollActionEnums::RETAIN( "RETAIN", 0 );
const CollActionEnums::ItemType CollActionEnums::ADD( "ADD", 1 );
const CollActionEnums::ItemType CollActionEnums::REMOVE( "REMOVE", 2 );

const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::BAD_ENUM( "BAD_ENUM", CollInquiryStatusEnums::ITEM_BAD_ENUM );
const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::ACCEPTED( "ACCEPTED", 0 );
const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::ACCEPTED_WITH_WARNINGS( "ACCEPTED_WITH_WARNINGS", 1 );
const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::COMPLETED( "COMPLETED", 2 );
const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::COMPLETED_WITH_WARNINGS( "COMPLETED_WITH_WARNINGS", 3 );
const CollInquiryStatusEnums::ItemType CollInquiryStatusEnums::REJECTED( "REJECTED", 4 );

const CollInquiryResultEnums::ItemType CollInquiryResultEnums::BAD_ENUM( "BAD_ENUM", CollInquiryResultEnums::ITEM_BAD_ENUM );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::SUCCESSFUL( "SUCCESSFUL", 0 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT( "INVALID_OR_UNKNOWN_INSTRUMENT", 1 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::INVALID_OR_UNKNOWN_COLLATERAL_TYPE( "INVALID_OR_UNKNOWN_COLLATERAL_TYPE", 2 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::INVALID_PARTIES( "INVALID_PARTIES", 3 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED( "INVALID_TRANSPORT_TYPE_REQUESTED", 4 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::INVALID_DESTINATION_REQUESTED( "INVALID_DESTINATION_REQUESTED", 5 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED( "NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED", 6 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED( "NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED", 7 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED( "COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED", 8 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::UNAUTHORIZED_FOR_COLLATERAL_INQUIRY( "UNAUTHORIZED_FOR_COLLATERAL_INQUIRY", 9 );
const CollInquiryResultEnums::ItemType CollInquiryResultEnums::OTHER( "OTHER", 99 );

// ------------------------------- enum items and type names -------------------------------------

template<> const FieldEnumBase * const * FieldAccount::enumItems = nullptr;
template<> FieldType FieldAccount::getType() { return FieldType::STRING; }
template<> const std::string & FieldAccount::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdvId::enumItems = nullptr;
template<> FieldType FieldAdvId::getType() { return FieldType::STRING; }
template<> const std::string & FieldAdvId::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdvRefID::enumItems = nullptr;
template<> FieldType FieldAdvRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAdvRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdvSide::enumItems = nullptr;
template<> FieldType FieldAdvSide::getType() { return FieldType::CHAR; }
template<> const std::string & FieldAdvSide::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdvTransType::enumItems = nullptr;
template<> FieldType FieldAdvTransType::getType() { return FieldType::STRING; }
template<> const std::string & FieldAdvTransType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAvgPx::enumItems = nullptr;
template<> FieldType FieldAvgPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldAvgPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBeginSeqNo::enumItems = nullptr;
template<> FieldType FieldBeginSeqNo::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldBeginSeqNo::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldBeginString::enumItems = nullptr;
template<> FieldType FieldBeginString::getType() { return FieldType::STRING; }
template<> const std::string & FieldBeginString::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldBodyLength::enumItems = nullptr;
template<> FieldType FieldBodyLength::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldBodyLength::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldCheckSum::enumItems = nullptr;
template<> FieldType FieldCheckSum::getType() { return FieldType::STRING; }
template<> const std::string & FieldCheckSum::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldClOrdID::enumItems = nullptr;
template<> FieldType FieldClOrdID::getType() { return FieldType::STRING; }
template<> const std::string & FieldClOrdID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCommission::enumItems = nullptr;
template<> FieldType FieldCommission::getType() { return FieldType::AMT; }
template<> const std::string & FieldCommission::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCommType::enumItems = nullptr;
template<> FieldType FieldCommType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldCommType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldCumQty::enumItems = nullptr;
template<> FieldType FieldCumQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldCumQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldCurrency::enumItems = nullptr;
template<> FieldType FieldCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldEndSeqNo::enumItems = nullptr;
template<> FieldType FieldEndSeqNo::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldEndSeqNo::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecID::enumItems = nullptr;
template<> FieldType FieldExecID::getType() { return FieldType::STRING; }
template<> const std::string & FieldExecID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecInst::enumItems = nullptr;
template<> FieldType FieldExecInst::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldExecInst::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecRefID::enumItems = nullptr;
template<> FieldType FieldExecRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldExecRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldHandlInst::enumItems = nullptr;
template<> FieldType FieldHandlInst::getType() { return FieldType::CHAR; }
template<> const std::string & FieldHandlInst::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityIDSource::enumItems = nullptr;
template<> FieldType FieldSecurityIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOIID::enumItems = nullptr;
template<> FieldType FieldIOIID::getType() { return FieldType::STRING; }
template<> const std::string & FieldIOIID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOIQltyInd::enumItems = nullptr;
template<> FieldType FieldIOIQltyInd::getType() { return FieldType::CHAR; }
template<> const std::string & FieldIOIQltyInd::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOIRefID::enumItems = nullptr;
template<> FieldType FieldIOIRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldIOIRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOIQty::enumItems = nullptr;
template<> FieldType FieldIOIQty::getType() { return FieldType::STRING; }
template<> const std::string & FieldIOIQty::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOITransType::enumItems = nullptr;
template<> FieldType FieldIOITransType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldIOITransType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastCapacity::enumItems = nullptr;
template<> FieldType FieldLastCapacity::getType() { return FieldType::CHAR; }
template<> const std::string & FieldLastCapacity::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastMkt::enumItems = nullptr;
template<> FieldType FieldLastMkt::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldLastMkt::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastPx::enumItems = nullptr;
template<> FieldType FieldLastPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLastPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastQty::enumItems = nullptr;
template<> FieldType FieldLastQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldLastQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoLinesOfText::enumItems = nullptr;
template<> FieldType FieldNoLinesOfText::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoLinesOfText::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMsgSeqNum::enumItems = nullptr;
template<> FieldType FieldMsgSeqNum::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldMsgSeqNum::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldMsgType::enumItems = nullptr;
template<> FieldType FieldMsgType::getType() { return FieldType::STRING; }
template<> const std::string & FieldMsgType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNewSeqNo::enumItems = nullptr;
template<> FieldType FieldNewSeqNo::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldNewSeqNo::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderID::enumItems = nullptr;
template<> FieldType FieldOrderID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrderID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderQty::enumItems = nullptr;
template<> FieldType FieldOrderQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldOrderQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrdStatus::enumItems = nullptr;
template<> FieldType FieldOrdStatus::getType() { return FieldType::CHAR; }
template<> const std::string & FieldOrdStatus::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrdType::enumItems = nullptr;
template<> FieldType FieldOrdType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldOrdType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigClOrdID::enumItems = nullptr;
template<> FieldType FieldOrigClOrdID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrigClOrdID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigTime::enumItems = nullptr;
template<> FieldType FieldOrigTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldOrigTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldPossDupFlag::enumItems = nullptr;
template<> FieldType FieldPossDupFlag::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldPossDupFlag::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldPrice::enumItems = nullptr;
template<> FieldType FieldPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefSeqNum::enumItems = nullptr;
template<> FieldType FieldRefSeqNum::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldRefSeqNum::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityID::enumItems = nullptr;
template<> FieldType FieldSecurityID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSenderCompID::enumItems = nullptr;
template<> FieldType FieldSenderCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSenderCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSenderSubID::enumItems = nullptr;
template<> FieldType FieldSenderSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSenderSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSendingTime::enumItems = nullptr;
template<> FieldType FieldSendingTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldSendingTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuantity::enumItems = nullptr;
template<> FieldType FieldQuantity::getType() { return FieldType::QTY; }
template<> const std::string & FieldQuantity::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldSide::enumItems = nullptr;
template<> FieldType FieldSide::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSide::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSymbol::enumItems = nullptr;
template<> FieldType FieldSymbol::getType() { return FieldType::STRING; }
template<> const std::string & FieldSymbol::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetCompID::enumItems = nullptr;
template<> FieldType FieldTargetCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTargetCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetSubID::enumItems = nullptr;
template<> FieldType FieldTargetSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTargetSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldText::enumItems = nullptr;
template<> FieldType FieldText::getType() { return FieldType::STRING; }
template<> const std::string & FieldText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTimeInForce::enumItems = nullptr;
template<> FieldType FieldTimeInForce::getType() { return FieldType::CHAR; }
template<> const std::string & FieldTimeInForce::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldTransactTime::enumItems = nullptr;
template<> FieldType FieldTransactTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTransactTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldUrgency::enumItems = nullptr;
template<> FieldType FieldUrgency::getType() { return FieldType::CHAR; }
template<> const std::string & FieldUrgency::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldValidUntilTime::enumItems = nullptr;
template<> FieldType FieldValidUntilTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldValidUntilTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlType::enumItems = nullptr;
template<> FieldType FieldSettlType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlDate::enumItems = nullptr;
template<> FieldType FieldSettlDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldSettlDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldSymbolSfx::enumItems = nullptr;
template<> FieldType FieldSymbolSfx::getType() { return FieldType::STRING; }
template<> const std::string & FieldSymbolSfx::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldListID::enumItems = nullptr;
template<> FieldType FieldListID::getType() { return FieldType::STRING; }
template<> const std::string & FieldListID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldListSeqNo::enumItems = nullptr;
template<> FieldType FieldListSeqNo::getType() { return FieldType::INT; }
template<> const std::string & FieldListSeqNo::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoOrders::enumItems = nullptr;
template<> FieldType FieldTotNoOrders::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoOrders::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldListExecInst::enumItems = nullptr;
template<> FieldType FieldListExecInst::getType() { return FieldType::STRING; }
template<> const std::string & FieldListExecInst::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocID::enumItems = nullptr;
template<> FieldType FieldAllocID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocTransType::enumItems = nullptr;
template<> FieldType FieldAllocTransType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldAllocTransType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefAllocID::enumItems = nullptr;
template<> FieldType FieldRefAllocID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRefAllocID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoOrders::enumItems = nullptr;
template<> FieldType FieldNoOrders::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoOrders::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAvgPxPrecision::enumItems = nullptr;
template<> FieldType FieldAvgPxPrecision::getType() { return FieldType::INT; }
template<> const std::string & FieldAvgPxPrecision::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeDate::enumItems = nullptr;
template<> FieldType FieldTradeDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldTradeDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPositionEffect::enumItems = nullptr;
template<> FieldType FieldPositionEffect::getType() { return FieldType::CHAR; }
template<> const std::string & FieldPositionEffect::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoAllocs::enumItems = nullptr;
template<> FieldType FieldNoAllocs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoAllocs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocAccount::enumItems = nullptr;
template<> FieldType FieldAllocAccount::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocAccount::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocQty::enumItems = nullptr;
template<> FieldType FieldAllocQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldAllocQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldProcessCode::enumItems = nullptr;
template<> FieldType FieldProcessCode::getType() { return FieldType::CHAR; }
template<> const std::string & FieldProcessCode::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoRpts::enumItems = nullptr;
template<> FieldType FieldNoRpts::getType() { return FieldType::INT; }
template<> const std::string & FieldNoRpts::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRptSeq::enumItems = nullptr;
template<> FieldType FieldRptSeq::getType() { return FieldType::INT; }
template<> const std::string & FieldRptSeq::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCxlQty::enumItems = nullptr;
template<> FieldType FieldCxlQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldCxlQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoDlvyInst::enumItems = nullptr;
template<> FieldType FieldNoDlvyInst::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoDlvyInst::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocStatus::enumItems = nullptr;
template<> FieldType FieldAllocStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocRejCode::enumItems = nullptr;
template<> FieldType FieldAllocRejCode::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocRejCode::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSignature::enumItems = nullptr;
template<> FieldType FieldSignature::getType() { return FieldType::DATA; }
template<> const std::string & FieldSignature::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecureDataLen::enumItems = nullptr;
template<> FieldType FieldSecureDataLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldSecureDataLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecureData::enumItems = nullptr;
template<> FieldType FieldSecureData::getType() { return FieldType::DATA; }
template<> const std::string & FieldSecureData::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldSignatureLength::enumItems = nullptr;
template<> FieldType FieldSignatureLength::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldSignatureLength::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEmailType::enumItems = nullptr;
template<> FieldType FieldEmailType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldEmailType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldRawDataLength::enumItems = nullptr;
template<> FieldType FieldRawDataLength::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldRawDataLength::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldRawData::enumItems = nullptr;
template<> FieldType FieldRawData::getType() { return FieldType::DATA; }
template<> const std::string & FieldRawData::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldPossResend::enumItems = nullptr;
template<> FieldType FieldPossResend::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldPossResend::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncryptMethod::enumItems = nullptr;
template<> FieldType FieldEncryptMethod::getType() { return FieldType::INT; }
template<> const std::string & FieldEncryptMethod::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStopPx::enumItems = nullptr;
template<> FieldType FieldStopPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldStopPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldExDestination::enumItems = nullptr;
template<> FieldType FieldExDestination::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldExDestination::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCxlRejReason::enumItems = nullptr;
template<> FieldType FieldCxlRejReason::getType() { return FieldType::INT; }
template<> const std::string & FieldCxlRejReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrdRejReason::enumItems = nullptr;
template<> FieldType FieldOrdRejReason::getType() { return FieldType::INT; }
template<> const std::string & FieldOrdRejReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOIQualifier::enumItems = nullptr;
template<> FieldType FieldIOIQualifier::getType() { return FieldType::CHAR; }
template<> const std::string & FieldIOIQualifier::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldIssuer::enumItems = nullptr;
template<> FieldType FieldIssuer::getType() { return FieldType::STRING; }
template<> const std::string & FieldIssuer::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityDesc::enumItems = nullptr;
template<> FieldType FieldSecurityDesc::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityDesc::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldHeartBtInt::enumItems = nullptr;
template<> FieldType FieldHeartBtInt::getType() { return FieldType::INT; }
template<> const std::string & FieldHeartBtInt::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMinQty::enumItems = nullptr;
template<> FieldType FieldMinQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldMinQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaxFloor::enumItems = nullptr;
template<> FieldType FieldMaxFloor::getType() { return FieldType::QTY; }
template<> const std::string & FieldMaxFloor::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTestReqID::enumItems = nullptr;
template<> FieldType FieldTestReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTestReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldReportToExch::enumItems = nullptr;
template<> FieldType FieldReportToExch::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldReportToExch::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldLocateReqd::enumItems = nullptr;
template<> FieldType FieldLocateReqd::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldLocateReqd::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldOnBehalfOfCompID::enumItems = nullptr;
template<> FieldType FieldOnBehalfOfCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOnBehalfOfCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOnBehalfOfSubID::enumItems = nullptr;
template<> FieldType FieldOnBehalfOfSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOnBehalfOfSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteID::enumItems = nullptr;
template<> FieldType FieldQuoteID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetMoney::enumItems = nullptr;
template<> FieldType FieldNetMoney::getType() { return FieldType::AMT; }
template<> const std::string & FieldNetMoney::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrAmt::enumItems = nullptr;
template<> FieldType FieldSettlCurrAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldSettlCurrAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrency::enumItems = nullptr;
template<> FieldType FieldSettlCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldSettlCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldForexReq::enumItems = nullptr;
template<> FieldType FieldForexReq::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldForexReq::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigSendingTime::enumItems = nullptr;
template<> FieldType FieldOrigSendingTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldOrigSendingTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldGapFillFlag::enumItems = nullptr;
template<> FieldType FieldGapFillFlag::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldGapFillFlag::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoExecs::enumItems = nullptr;
template<> FieldType FieldNoExecs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoExecs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldExpireTime::enumItems = nullptr;
template<> FieldType FieldExpireTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldExpireTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldDKReason::enumItems = nullptr;
template<> FieldType FieldDKReason::getType() { return FieldType::CHAR; }
template<> const std::string & FieldDKReason::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliverToCompID::enumItems = nullptr;
template<> FieldType FieldDeliverToCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldDeliverToCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliverToSubID::enumItems = nullptr;
template<> FieldType FieldDeliverToSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldDeliverToSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIOINaturalFlag::enumItems = nullptr;
template<> FieldType FieldIOINaturalFlag::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldIOINaturalFlag::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteReqID::enumItems = nullptr;
template<> FieldType FieldQuoteReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidPx::enumItems = nullptr;
template<> FieldType FieldBidPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldBidPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferPx::enumItems = nullptr;
template<> FieldType FieldOfferPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldOfferPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidSize::enumItems = nullptr;
template<> FieldType FieldBidSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldBidSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferSize::enumItems = nullptr;
template<> FieldType FieldOfferSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldOfferSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoMiscFees::enumItems = nullptr;
template<> FieldType FieldNoMiscFees::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoMiscFees::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMiscFeeAmt::enumItems = nullptr;
template<> FieldType FieldMiscFeeAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldMiscFeeAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMiscFeeCurr::enumItems = nullptr;
template<> FieldType FieldMiscFeeCurr::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldMiscFeeCurr::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMiscFeeType::enumItems = nullptr;
template<> FieldType FieldMiscFeeType::getType() { return FieldType::STRING; }
template<> const std::string & FieldMiscFeeType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPrevClosePx::enumItems = nullptr;
template<> FieldType FieldPrevClosePx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldPrevClosePx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldResetSeqNumFlag::enumItems = nullptr;
template<> FieldType FieldResetSeqNumFlag::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldResetSeqNumFlag::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldSenderLocationID::enumItems = nullptr;
template<> FieldType FieldSenderLocationID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSenderLocationID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetLocationID::enumItems = nullptr;
template<> FieldType FieldTargetLocationID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTargetLocationID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOnBehalfOfLocationID::enumItems = nullptr;
template<> FieldType FieldOnBehalfOfLocationID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOnBehalfOfLocationID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliverToLocationID::enumItems = nullptr;
template<> FieldType FieldDeliverToLocationID::getType() { return FieldType::STRING; }
template<> const std::string & FieldDeliverToLocationID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoRelatedSym::enumItems = nullptr;
template<> FieldType FieldNoRelatedSym::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoRelatedSym::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldSubject::enumItems = nullptr;
template<> FieldType FieldSubject::getType() { return FieldType::STRING; }
template<> const std::string & FieldSubject::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldHeadline::enumItems = nullptr;
template<> FieldType FieldHeadline::getType() { return FieldType::STRING; }
template<> const std::string & FieldHeadline::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldURLLink::enumItems = nullptr;
template<> FieldType FieldURLLink::getType() { return FieldType::STRING; }
template<> const std::string & FieldURLLink::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecType::enumItems = nullptr;
template<> FieldType FieldExecType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldExecType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLeavesQty::enumItems = nullptr;
template<> FieldType FieldLeavesQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldLeavesQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashOrderQty::enumItems = nullptr;
template<> FieldType FieldCashOrderQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldCashOrderQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocAvgPx::enumItems = nullptr;
template<> FieldType FieldAllocAvgPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldAllocAvgPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocNetMoney::enumItems = nullptr;
template<> FieldType FieldAllocNetMoney::getType() { return FieldType::AMT; }
template<> const std::string & FieldAllocNetMoney::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrFxRate::enumItems = nullptr;
template<> FieldType FieldSettlCurrFxRate::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldSettlCurrFxRate::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrFxRateCalc::enumItems = nullptr;
template<> FieldType FieldSettlCurrFxRateCalc::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlCurrFxRateCalc::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNumDaysInterest::enumItems = nullptr;
template<> FieldType FieldNumDaysInterest::getType() { return FieldType::INT; }
template<> const std::string & FieldNumDaysInterest::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAccruedInterestRate::enumItems = nullptr;
template<> FieldType FieldAccruedInterestRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldAccruedInterestRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAccruedInterestAmt::enumItems = nullptr;
template<> FieldType FieldAccruedInterestAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldAccruedInterestAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstMode::enumItems = nullptr;
template<> FieldType FieldSettlInstMode::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlInstMode::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocText::enumItems = nullptr;
template<> FieldType FieldAllocText::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstID::enumItems = nullptr;
template<> FieldType FieldSettlInstID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlInstID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstTransType::enumItems = nullptr;
template<> FieldType FieldSettlInstTransType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlInstTransType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldEmailThreadID::enumItems = nullptr;
template<> FieldType FieldEmailThreadID::getType() { return FieldType::STRING; }
template<> const std::string & FieldEmailThreadID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstSource::enumItems = nullptr;
template<> FieldType FieldSettlInstSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlInstSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityType::enumItems = nullptr;
template<> FieldType FieldSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldEffectiveTime::enumItems = nullptr;
template<> FieldType FieldEffectiveTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldEffectiveTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldStandInstDbType::enumItems = nullptr;
template<> FieldType FieldStandInstDbType::getType() { return FieldType::INT; }
template<> const std::string & FieldStandInstDbType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStandInstDbName::enumItems = nullptr;
template<> FieldType FieldStandInstDbName::getType() { return FieldType::STRING; }
template<> const std::string & FieldStandInstDbName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldStandInstDbID::enumItems = nullptr;
template<> FieldType FieldStandInstDbID::getType() { return FieldType::STRING; }
template<> const std::string & FieldStandInstDbID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlDeliveryType::enumItems = nullptr;
template<> FieldType FieldSettlDeliveryType::getType() { return FieldType::INT; }
template<> const std::string & FieldSettlDeliveryType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidSpotRate::enumItems = nullptr;
template<> FieldType FieldBidSpotRate::getType() { return FieldType::PRICE; }
template<> const std::string & FieldBidSpotRate::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidForwardPoints::enumItems = nullptr;
template<> FieldType FieldBidForwardPoints::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldBidForwardPoints::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferSpotRate::enumItems = nullptr;
template<> FieldType FieldOfferSpotRate::getType() { return FieldType::PRICE; }
template<> const std::string & FieldOfferSpotRate::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferForwardPoints::enumItems = nullptr;
template<> FieldType FieldOfferForwardPoints::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldOfferForwardPoints::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderQty2::enumItems = nullptr;
template<> FieldType FieldOrderQty2::getType() { return FieldType::QTY; }
template<> const std::string & FieldOrderQty2::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlDate2::enumItems = nullptr;
template<> FieldType FieldSettlDate2::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldSettlDate2::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastSpotRate::enumItems = nullptr;
template<> FieldType FieldLastSpotRate::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLastSpotRate::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastForwardPoints::enumItems = nullptr;
template<> FieldType FieldLastForwardPoints::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldLastForwardPoints::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocLinkID::enumItems = nullptr;
template<> FieldType FieldAllocLinkID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocLinkID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocLinkType::enumItems = nullptr;
template<> FieldType FieldAllocLinkType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocLinkType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryOrderID::enumItems = nullptr;
template<> FieldType FieldSecondaryOrderID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryOrderID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoIOIQualifiers::enumItems = nullptr;
template<> FieldType FieldNoIOIQualifiers::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoIOIQualifiers::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaturityMonthYear::enumItems = nullptr;
template<> FieldType FieldMaturityMonthYear::getType() { return FieldType::MONTHYEAR; }
template<> const std::string & FieldMaturityMonthYear::getTypeName() { static const std::string fixType{ "MONTHYEAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldPutOrCall::enumItems = nullptr;
template<> FieldType FieldPutOrCall::getType() { return FieldType::INT; }
template<> const std::string & FieldPutOrCall::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStrikePrice::enumItems = nullptr;
template<> FieldType FieldStrikePrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldStrikePrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCoveredOrUncovered::enumItems = nullptr;
template<> FieldType FieldCoveredOrUncovered::getType() { return FieldType::INT; }
template<> const std::string & FieldCoveredOrUncovered::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOptAttribute::enumItems = nullptr;
template<> FieldType FieldOptAttribute::getType() { return FieldType::CHAR; }
template<> const std::string & FieldOptAttribute::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityExchange::enumItems = nullptr;
template<> FieldType FieldSecurityExchange::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldSecurityExchange::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNotifyBrokerOfCredit::enumItems = nullptr;
template<> FieldType FieldNotifyBrokerOfCredit::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldNotifyBrokerOfCredit::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocHandlInst::enumItems = nullptr;
template<> FieldType FieldAllocHandlInst::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocHandlInst::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaxShow::enumItems = nullptr;
template<> FieldType FieldMaxShow::getType() { return FieldType::QTY; }
template<> const std::string & FieldMaxShow::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegOffsetValue::enumItems = nullptr;
template<> FieldType FieldPegOffsetValue::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldPegOffsetValue::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldXmlDataLen::enumItems = nullptr;
template<> FieldType FieldXmlDataLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldXmlDataLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldXmlData::enumItems = nullptr;
template<> FieldType FieldXmlData::getType() { return FieldType::DATA; }
template<> const std::string & FieldXmlData::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstRefID::enumItems = nullptr;
template<> FieldType FieldSettlInstRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlInstRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoRoutingIDs::enumItems = nullptr;
template<> FieldType FieldNoRoutingIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoRoutingIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldRoutingType::enumItems = nullptr;
template<> FieldType FieldRoutingType::getType() { return FieldType::INT; }
template<> const std::string & FieldRoutingType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRoutingID::enumItems = nullptr;
template<> FieldType FieldRoutingID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRoutingID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSpread::enumItems = nullptr;
template<> FieldType FieldSpread::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldSpread::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkCurveCurrency::enumItems = nullptr;
template<> FieldType FieldBenchmarkCurveCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldBenchmarkCurveCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkCurveName::enumItems = nullptr;
template<> FieldType FieldBenchmarkCurveName::getType() { return FieldType::STRING; }
template<> const std::string & FieldBenchmarkCurveName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkCurvePoint::enumItems = nullptr;
template<> FieldType FieldBenchmarkCurvePoint::getType() { return FieldType::STRING; }
template<> const std::string & FieldBenchmarkCurvePoint::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCouponRate::enumItems = nullptr;
template<> FieldType FieldCouponRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldCouponRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCouponPaymentDate::enumItems = nullptr;
template<> FieldType FieldCouponPaymentDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldCouponPaymentDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldIssueDate::enumItems = nullptr;
template<> FieldType FieldIssueDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldIssueDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldRepurchaseTerm::enumItems = nullptr;
template<> FieldType FieldRepurchaseTerm::getType() { return FieldType::INT; }
template<> const std::string & FieldRepurchaseTerm::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRepurchaseRate::enumItems = nullptr;
template<> FieldType FieldRepurchaseRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldRepurchaseRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldFactor::enumItems = nullptr;
template<> FieldType FieldFactor::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldFactor::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeOriginationDate::enumItems = nullptr;
template<> FieldType FieldTradeOriginationDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldTradeOriginationDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldExDate::enumItems = nullptr;
template<> FieldType FieldExDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldExDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldContractMultiplier::enumItems = nullptr;
template<> FieldType FieldContractMultiplier::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldContractMultiplier::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoStipulations::enumItems = nullptr;
template<> FieldType FieldNoStipulations::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoStipulations::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldStipulationType::enumItems = nullptr;
template<> FieldType FieldStipulationType::getType() { return FieldType::STRING; }
template<> const std::string & FieldStipulationType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldStipulationValue::enumItems = nullptr;
template<> FieldType FieldStipulationValue::getType() { return FieldType::STRING; }
template<> const std::string & FieldStipulationValue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldYieldType::enumItems = nullptr;
template<> FieldType FieldYieldType::getType() { return FieldType::STRING; }
template<> const std::string & FieldYieldType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldYield::enumItems = nullptr;
template<> FieldType FieldYield::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldYield::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalTakedown::enumItems = nullptr;
template<> FieldType FieldTotalTakedown::getType() { return FieldType::AMT; }
template<> const std::string & FieldTotalTakedown::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldConcession::enumItems = nullptr;
template<> FieldType FieldConcession::getType() { return FieldType::AMT; }
template<> const std::string & FieldConcession::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRepoCollateralSecurityType::enumItems = nullptr;
template<> FieldType FieldRepoCollateralSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldRepoCollateralSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRedemptionDate::enumItems = nullptr;
template<> FieldType FieldRedemptionDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldRedemptionDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCouponPaymentDate::enumItems = nullptr;
template<> FieldType FieldUnderlyingCouponPaymentDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldUnderlyingCouponPaymentDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingIssueDate::enumItems = nullptr;
template<> FieldType FieldUnderlyingIssueDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldUnderlyingIssueDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingRepoCollateralSecurityType::enumItems = nullptr;
template<> FieldType FieldUnderlyingRepoCollateralSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingRepoCollateralSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingRepurchaseTerm::enumItems = nullptr;
template<> FieldType FieldUnderlyingRepurchaseTerm::getType() { return FieldType::INT; }
template<> const std::string & FieldUnderlyingRepurchaseTerm::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingRepurchaseRate::enumItems = nullptr;
template<> FieldType FieldUnderlyingRepurchaseRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldUnderlyingRepurchaseRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingFactor::enumItems = nullptr;
template<> FieldType FieldUnderlyingFactor::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldUnderlyingFactor::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingRedemptionDate::enumItems = nullptr;
template<> FieldType FieldUnderlyingRedemptionDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldUnderlyingRedemptionDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCouponPaymentDate::enumItems = nullptr;
template<> FieldType FieldLegCouponPaymentDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegCouponPaymentDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegIssueDate::enumItems = nullptr;
template<> FieldType FieldLegIssueDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegIssueDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRepoCollateralSecurityType::enumItems = nullptr;
template<> FieldType FieldLegRepoCollateralSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegRepoCollateralSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRepurchaseTerm::enumItems = nullptr;
template<> FieldType FieldLegRepurchaseTerm::getType() { return FieldType::INT; }
template<> const std::string & FieldLegRepurchaseTerm::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRepurchaseRate::enumItems = nullptr;
template<> FieldType FieldLegRepurchaseRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldLegRepurchaseRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegFactor::enumItems = nullptr;
template<> FieldType FieldLegFactor::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldLegFactor::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRedemptionDate::enumItems = nullptr;
template<> FieldType FieldLegRedemptionDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegRedemptionDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCreditRating::enumItems = nullptr;
template<> FieldType FieldCreditRating::getType() { return FieldType::STRING; }
template<> const std::string & FieldCreditRating::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCreditRating::enumItems = nullptr;
template<> FieldType FieldUnderlyingCreditRating::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingCreditRating::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCreditRating::enumItems = nullptr;
template<> FieldType FieldLegCreditRating::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegCreditRating::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradedFlatSwitch::enumItems = nullptr;
template<> FieldType FieldTradedFlatSwitch::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldTradedFlatSwitch::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldBasisFeatureDate::enumItems = nullptr;
template<> FieldType FieldBasisFeatureDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldBasisFeatureDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBasisFeaturePrice::enumItems = nullptr;
template<> FieldType FieldBasisFeaturePrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldBasisFeaturePrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDReqID::enumItems = nullptr;
template<> FieldType FieldMDReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSubscriptionRequestType::enumItems = nullptr;
template<> FieldType FieldSubscriptionRequestType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSubscriptionRequestType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMarketDepth::enumItems = nullptr;
template<> FieldType FieldMarketDepth::getType() { return FieldType::INT; }
template<> const std::string & FieldMarketDepth::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDUpdateType::enumItems = nullptr;
template<> FieldType FieldMDUpdateType::getType() { return FieldType::INT; }
template<> const std::string & FieldMDUpdateType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAggregatedBook::enumItems = nullptr;
template<> FieldType FieldAggregatedBook::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldAggregatedBook::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoMDEntryTypes::enumItems = nullptr;
template<> FieldType FieldNoMDEntryTypes::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoMDEntryTypes::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoMDEntries::enumItems = nullptr;
template<> FieldType FieldNoMDEntries::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoMDEntries::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryType::enumItems = nullptr;
template<> FieldType FieldMDEntryType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMDEntryType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryPx::enumItems = nullptr;
template<> FieldType FieldMDEntryPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldMDEntryPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntrySize::enumItems = nullptr;
template<> FieldType FieldMDEntrySize::getType() { return FieldType::QTY; }
template<> const std::string & FieldMDEntrySize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryDate::enumItems = nullptr;
template<> FieldType FieldMDEntryDate::getType() { return FieldType::UTCDATEONLY; }
template<> const std::string & FieldMDEntryDate::getTypeName() { static const std::string fixType{ "UTCDATEONLY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryTime::enumItems = nullptr;
template<> FieldType FieldMDEntryTime::getType() { return FieldType::UTCTIMEONLY; }
template<> const std::string & FieldMDEntryTime::getTypeName() { static const std::string fixType{ "UTCTIMEONLY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTickDirection::enumItems = nullptr;
template<> FieldType FieldTickDirection::getType() { return FieldType::CHAR; }
template<> const std::string & FieldTickDirection::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDMkt::enumItems = nullptr;
template<> FieldType FieldMDMkt::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldMDMkt::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteCondition::enumItems = nullptr;
template<> FieldType FieldQuoteCondition::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldQuoteCondition::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeCondition::enumItems = nullptr;
template<> FieldType FieldTradeCondition::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldTradeCondition::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryID::enumItems = nullptr;
template<> FieldType FieldMDEntryID::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDEntryID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDUpdateAction::enumItems = nullptr;
template<> FieldType FieldMDUpdateAction::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMDUpdateAction::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryRefID::enumItems = nullptr;
template<> FieldType FieldMDEntryRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDEntryRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDReqRejReason::enumItems = nullptr;
template<> FieldType FieldMDReqRejReason::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMDReqRejReason::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryOriginator::enumItems = nullptr;
template<> FieldType FieldMDEntryOriginator::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDEntryOriginator::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLocationID::enumItems = nullptr;
template<> FieldType FieldLocationID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLocationID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeskID::enumItems = nullptr;
template<> FieldType FieldDeskID::getType() { return FieldType::STRING; }
template<> const std::string & FieldDeskID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeleteReason::enumItems = nullptr;
template<> FieldType FieldDeleteReason::getType() { return FieldType::CHAR; }
template<> const std::string & FieldDeleteReason::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldOpenCloseSettlFlag::enumItems = nullptr;
template<> FieldType FieldOpenCloseSettlFlag::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldOpenCloseSettlFlag::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSellerDays::enumItems = nullptr;
template<> FieldType FieldSellerDays::getType() { return FieldType::INT; }
template<> const std::string & FieldSellerDays::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryBuyer::enumItems = nullptr;
template<> FieldType FieldMDEntryBuyer::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDEntryBuyer::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntrySeller::enumItems = nullptr;
template<> FieldType FieldMDEntrySeller::getType() { return FieldType::STRING; }
template<> const std::string & FieldMDEntrySeller::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDEntryPositionNo::enumItems = nullptr;
template<> FieldType FieldMDEntryPositionNo::getType() { return FieldType::INT; }
template<> const std::string & FieldMDEntryPositionNo::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldFinancialStatus::enumItems = nullptr;
template<> FieldType FieldFinancialStatus::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldFinancialStatus::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCorporateAction::enumItems = nullptr;
template<> FieldType FieldCorporateAction::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldCorporateAction::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDefBidSize::enumItems = nullptr;
template<> FieldType FieldDefBidSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldDefBidSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldDefOfferSize::enumItems = nullptr;
template<> FieldType FieldDefOfferSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldDefOfferSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoQuoteEntries::enumItems = nullptr;
template<> FieldType FieldNoQuoteEntries::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoQuoteEntries::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoQuoteSets::enumItems = nullptr;
template<> FieldType FieldNoQuoteSets::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoQuoteSets::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteStatus::enumItems = nullptr;
template<> FieldType FieldQuoteStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteCancelType::enumItems = nullptr;
template<> FieldType FieldQuoteCancelType::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteCancelType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteEntryID::enumItems = nullptr;
template<> FieldType FieldQuoteEntryID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteEntryID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteRejectReason::enumItems = nullptr;
template<> FieldType FieldQuoteRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteResponseLevel::enumItems = nullptr;
template<> FieldType FieldQuoteResponseLevel::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteResponseLevel::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteSetID::enumItems = nullptr;
template<> FieldType FieldQuoteSetID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteSetID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteRequestType::enumItems = nullptr;
template<> FieldType FieldQuoteRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoQuoteEntries::enumItems = nullptr;
template<> FieldType FieldTotNoQuoteEntries::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoQuoteEntries::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityIDSource::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingIssuer::enumItems = nullptr;
template<> FieldType FieldUnderlyingIssuer::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingIssuer::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityDesc::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityDesc::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityDesc::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityExchange::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityExchange::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldUnderlyingSecurityExchange::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityID::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityID::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityType::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSymbol::enumItems = nullptr;
template<> FieldType FieldUnderlyingSymbol::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSymbol::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSymbolSfx::enumItems = nullptr;
template<> FieldType FieldUnderlyingSymbolSfx::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSymbolSfx::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingMaturityMonthYear::enumItems = nullptr;
template<> FieldType FieldUnderlyingMaturityMonthYear::getType() { return FieldType::MONTHYEAR; }
template<> const std::string & FieldUnderlyingMaturityMonthYear::getTypeName() { static const std::string fixType{ "MONTHYEAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingPutOrCall::enumItems = nullptr;
template<> FieldType FieldUnderlyingPutOrCall::getType() { return FieldType::INT; }
template<> const std::string & FieldUnderlyingPutOrCall::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStrikePrice::enumItems = nullptr;
template<> FieldType FieldUnderlyingStrikePrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingStrikePrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingOptAttribute::enumItems = nullptr;
template<> FieldType FieldUnderlyingOptAttribute::getType() { return FieldType::CHAR; }
template<> const std::string & FieldUnderlyingOptAttribute::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCurrency::enumItems = nullptr;
template<> FieldType FieldUnderlyingCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldUnderlyingCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityReqID::enumItems = nullptr;
template<> FieldType FieldSecurityReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityRequestType::enumItems = nullptr;
template<> FieldType FieldSecurityRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldSecurityRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityResponseID::enumItems = nullptr;
template<> FieldType FieldSecurityResponseID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityResponseID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityResponseType::enumItems = nullptr;
template<> FieldType FieldSecurityResponseType::getType() { return FieldType::INT; }
template<> const std::string & FieldSecurityResponseType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityStatusReqID::enumItems = nullptr;
template<> FieldType FieldSecurityStatusReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityStatusReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnsolicitedIndicator::enumItems = nullptr;
template<> FieldType FieldUnsolicitedIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldUnsolicitedIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityTradingStatus::enumItems = nullptr;
template<> FieldType FieldSecurityTradingStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldSecurityTradingStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldHaltReasonChar::enumItems = nullptr;
template<> FieldType FieldHaltReasonChar::getType() { return FieldType::CHAR; }
template<> const std::string & FieldHaltReasonChar::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldInViewOfCommon::enumItems = nullptr;
template<> FieldType FieldInViewOfCommon::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldInViewOfCommon::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldDueToRelated::enumItems = nullptr;
template<> FieldType FieldDueToRelated::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldDueToRelated::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldBuyVolume::enumItems = nullptr;
template<> FieldType FieldBuyVolume::getType() { return FieldType::QTY; }
template<> const std::string & FieldBuyVolume::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldSellVolume::enumItems = nullptr;
template<> FieldType FieldSellVolume::getType() { return FieldType::QTY; }
template<> const std::string & FieldSellVolume::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldHighPx::enumItems = nullptr;
template<> FieldType FieldHighPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldHighPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLowPx::enumItems = nullptr;
template<> FieldType FieldLowPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLowPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdjustment::enumItems = nullptr;
template<> FieldType FieldAdjustment::getType() { return FieldType::INT; }
template<> const std::string & FieldAdjustment::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesReqID::enumItems = nullptr;
template<> FieldType FieldTradSesReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradSesReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradingSessionID::enumItems = nullptr;
template<> FieldType FieldTradingSessionID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradingSessionID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraTrader::enumItems = nullptr;
template<> FieldType FieldContraTrader::getType() { return FieldType::STRING; }
template<> const std::string & FieldContraTrader::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesMethod::enumItems = nullptr;
template<> FieldType FieldTradSesMethod::getType() { return FieldType::INT; }
template<> const std::string & FieldTradSesMethod::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesMode::enumItems = nullptr;
template<> FieldType FieldTradSesMode::getType() { return FieldType::INT; }
template<> const std::string & FieldTradSesMode::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesStatus::enumItems = nullptr;
template<> FieldType FieldTradSesStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldTradSesStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesStartTime::enumItems = nullptr;
template<> FieldType FieldTradSesStartTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTradSesStartTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesOpenTime::enumItems = nullptr;
template<> FieldType FieldTradSesOpenTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTradSesOpenTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesPreCloseTime::enumItems = nullptr;
template<> FieldType FieldTradSesPreCloseTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTradSesPreCloseTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesCloseTime::enumItems = nullptr;
template<> FieldType FieldTradSesCloseTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTradSesCloseTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesEndTime::enumItems = nullptr;
template<> FieldType FieldTradSesEndTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTradSesEndTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNumberOfOrders::enumItems = nullptr;
template<> FieldType FieldNumberOfOrders::getType() { return FieldType::INT; }
template<> const std::string & FieldNumberOfOrders::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMessageEncoding::enumItems = nullptr;
template<> FieldType FieldMessageEncoding::getType() { return FieldType::STRING; }
template<> const std::string & FieldMessageEncoding::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedIssuerLen::enumItems = nullptr;
template<> FieldType FieldEncodedIssuerLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedIssuerLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedIssuer::enumItems = nullptr;
template<> FieldType FieldEncodedIssuer::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedIssuer::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedSecurityDescLen::enumItems = nullptr;
template<> FieldType FieldEncodedSecurityDescLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedSecurityDescLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedSecurityDesc::enumItems = nullptr;
template<> FieldType FieldEncodedSecurityDesc::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedSecurityDesc::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedListExecInstLen::enumItems = nullptr;
template<> FieldType FieldEncodedListExecInstLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedListExecInstLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedListExecInst::enumItems = nullptr;
template<> FieldType FieldEncodedListExecInst::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedListExecInst::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedTextLen::enumItems = nullptr;
template<> FieldType FieldEncodedTextLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedTextLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedText::enumItems = nullptr;
template<> FieldType FieldEncodedText::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedText::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedSubjectLen::enumItems = nullptr;
template<> FieldType FieldEncodedSubjectLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedSubjectLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedSubject::enumItems = nullptr;
template<> FieldType FieldEncodedSubject::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedSubject::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedHeadlineLen::enumItems = nullptr;
template<> FieldType FieldEncodedHeadlineLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedHeadlineLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedHeadline::enumItems = nullptr;
template<> FieldType FieldEncodedHeadline::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedHeadline::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedAllocTextLen::enumItems = nullptr;
template<> FieldType FieldEncodedAllocTextLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedAllocTextLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedAllocText::enumItems = nullptr;
template<> FieldType FieldEncodedAllocText::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedAllocText::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedUnderlyingIssuerLen::enumItems = nullptr;
template<> FieldType FieldEncodedUnderlyingIssuerLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedUnderlyingIssuerLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedUnderlyingIssuer::enumItems = nullptr;
template<> FieldType FieldEncodedUnderlyingIssuer::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedUnderlyingIssuer::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedUnderlyingSecurityDescLen::enumItems = nullptr;
template<> FieldType FieldEncodedUnderlyingSecurityDescLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedUnderlyingSecurityDescLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedUnderlyingSecurityDesc::enumItems = nullptr;
template<> FieldType FieldEncodedUnderlyingSecurityDesc::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedUnderlyingSecurityDesc::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocPrice::enumItems = nullptr;
template<> FieldType FieldAllocPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldAllocPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteSetValidUntilTime::enumItems = nullptr;
template<> FieldType FieldQuoteSetValidUntilTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldQuoteSetValidUntilTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteEntryRejectReason::enumItems = nullptr;
template<> FieldType FieldQuoteEntryRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteEntryRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastMsgSeqNumProcessed::enumItems = nullptr;
template<> FieldType FieldLastMsgSeqNumProcessed::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldLastMsgSeqNumProcessed::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefTagID::enumItems = nullptr;
template<> FieldType FieldRefTagID::getType() { return FieldType::INT; }
template<> const std::string & FieldRefTagID::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefMsgType::enumItems = nullptr;
template<> FieldType FieldRefMsgType::getType() { return FieldType::STRING; }
template<> const std::string & FieldRefMsgType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSessionRejectReason::enumItems = nullptr;
template<> FieldType FieldSessionRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldSessionRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidRequestTransType::enumItems = nullptr;
template<> FieldType FieldBidRequestTransType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldBidRequestTransType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraBroker::enumItems = nullptr;
template<> FieldType FieldContraBroker::getType() { return FieldType::STRING; }
template<> const std::string & FieldContraBroker::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldComplianceID::enumItems = nullptr;
template<> FieldType FieldComplianceID::getType() { return FieldType::STRING; }
template<> const std::string & FieldComplianceID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSolicitedFlag::enumItems = nullptr;
template<> FieldType FieldSolicitedFlag::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldSolicitedFlag::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecRestatementReason::enumItems = nullptr;
template<> FieldType FieldExecRestatementReason::getType() { return FieldType::INT; }
template<> const std::string & FieldExecRestatementReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBusinessRejectRefID::enumItems = nullptr;
template<> FieldType FieldBusinessRejectRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldBusinessRejectRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldBusinessRejectReason::enumItems = nullptr;
template<> FieldType FieldBusinessRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldBusinessRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldGrossTradeAmt::enumItems = nullptr;
template<> FieldType FieldGrossTradeAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldGrossTradeAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoContraBrokers::enumItems = nullptr;
template<> FieldType FieldNoContraBrokers::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoContraBrokers::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaxMessageSize::enumItems = nullptr;
template<> FieldType FieldMaxMessageSize::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldMaxMessageSize::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoMsgTypes::enumItems = nullptr;
template<> FieldType FieldNoMsgTypes::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoMsgTypes::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMsgDirection::enumItems = nullptr;
template<> FieldType FieldMsgDirection::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMsgDirection::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoTradingSessions::enumItems = nullptr;
template<> FieldType FieldNoTradingSessions::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoTradingSessions::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalVolumeTraded::enumItems = nullptr;
template<> FieldType FieldTotalVolumeTraded::getType() { return FieldType::QTY; }
template<> const std::string & FieldTotalVolumeTraded::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionInst::enumItems = nullptr;
template<> FieldType FieldDiscretionInst::getType() { return FieldType::CHAR; }
template<> const std::string & FieldDiscretionInst::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionOffsetValue::enumItems = nullptr;
template<> FieldType FieldDiscretionOffsetValue::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldDiscretionOffsetValue::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidID::enumItems = nullptr;
template<> FieldType FieldBidID::getType() { return FieldType::STRING; }
template<> const std::string & FieldBidID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldClientBidID::enumItems = nullptr;
template<> FieldType FieldClientBidID::getType() { return FieldType::STRING; }
template<> const std::string & FieldClientBidID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldListName::enumItems = nullptr;
template<> FieldType FieldListName::getType() { return FieldType::STRING; }
template<> const std::string & FieldListName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoRelatedSym::enumItems = nullptr;
template<> FieldType FieldTotNoRelatedSym::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoRelatedSym::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidType::enumItems = nullptr;
template<> FieldType FieldBidType::getType() { return FieldType::INT; }
template<> const std::string & FieldBidType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNumTickets::enumItems = nullptr;
template<> FieldType FieldNumTickets::getType() { return FieldType::INT; }
template<> const std::string & FieldNumTickets::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSideValue1::enumItems = nullptr;
template<> FieldType FieldSideValue1::getType() { return FieldType::AMT; }
template<> const std::string & FieldSideValue1::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSideValue2::enumItems = nullptr;
template<> FieldType FieldSideValue2::getType() { return FieldType::AMT; }
template<> const std::string & FieldSideValue2::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoBidDescriptors::enumItems = nullptr;
template<> FieldType FieldNoBidDescriptors::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoBidDescriptors::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidDescriptorType::enumItems = nullptr;
template<> FieldType FieldBidDescriptorType::getType() { return FieldType::INT; }
template<> const std::string & FieldBidDescriptorType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidDescriptor::enumItems = nullptr;
template<> FieldType FieldBidDescriptor::getType() { return FieldType::STRING; }
template<> const std::string & FieldBidDescriptor::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSideValueInd::enumItems = nullptr;
template<> FieldType FieldSideValueInd::getType() { return FieldType::INT; }
template<> const std::string & FieldSideValueInd::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLiquidityPctLow::enumItems = nullptr;
template<> FieldType FieldLiquidityPctLow::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldLiquidityPctLow::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLiquidityPctHigh::enumItems = nullptr;
template<> FieldType FieldLiquidityPctHigh::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldLiquidityPctHigh::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLiquidityValue::enumItems = nullptr;
template<> FieldType FieldLiquidityValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldLiquidityValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldEFPTrackingError::enumItems = nullptr;
template<> FieldType FieldEFPTrackingError::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldEFPTrackingError::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldFairValue::enumItems = nullptr;
template<> FieldType FieldFairValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldFairValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOutsideIndexPct::enumItems = nullptr;
template<> FieldType FieldOutsideIndexPct::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldOutsideIndexPct::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldValueOfFutures::enumItems = nullptr;
template<> FieldType FieldValueOfFutures::getType() { return FieldType::AMT; }
template<> const std::string & FieldValueOfFutures::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLiquidityIndType::enumItems = nullptr;
template<> FieldType FieldLiquidityIndType::getType() { return FieldType::INT; }
template<> const std::string & FieldLiquidityIndType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldWtAverageLiquidity::enumItems = nullptr;
template<> FieldType FieldWtAverageLiquidity::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldWtAverageLiquidity::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldExchangeForPhysical::enumItems = nullptr;
template<> FieldType FieldExchangeForPhysical::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldExchangeForPhysical::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldOutMainCntryUIndex::enumItems = nullptr;
template<> FieldType FieldOutMainCntryUIndex::getType() { return FieldType::AMT; }
template<> const std::string & FieldOutMainCntryUIndex::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCrossPercent::enumItems = nullptr;
template<> FieldType FieldCrossPercent::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldCrossPercent::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldProgRptReqs::enumItems = nullptr;
template<> FieldType FieldProgRptReqs::getType() { return FieldType::INT; }
template<> const std::string & FieldProgRptReqs::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldProgPeriodInterval::enumItems = nullptr;
template<> FieldType FieldProgPeriodInterval::getType() { return FieldType::INT; }
template<> const std::string & FieldProgPeriodInterval::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldIncTaxInd::enumItems = nullptr;
template<> FieldType FieldIncTaxInd::getType() { return FieldType::INT; }
template<> const std::string & FieldIncTaxInd::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNumBidders::enumItems = nullptr;
template<> FieldType FieldNumBidders::getType() { return FieldType::INT; }
template<> const std::string & FieldNumBidders::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidTradeType::enumItems = nullptr;
template<> FieldType FieldBidTradeType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldBidTradeType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldBasisPxType::enumItems = nullptr;
template<> FieldType FieldBasisPxType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldBasisPxType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoBidComponents::enumItems = nullptr;
template<> FieldType FieldNoBidComponents::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoBidComponents::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldCountry::enumItems = nullptr;
template<> FieldType FieldCountry::getType() { return FieldType::COUNTRY; }
template<> const std::string & FieldCountry::getTypeName() { static const std::string fixType{ "COUNTRY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoStrikes::enumItems = nullptr;
template<> FieldType FieldTotNoStrikes::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoStrikes::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriceType::enumItems = nullptr;
template<> FieldType FieldPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDayOrderQty::enumItems = nullptr;
template<> FieldType FieldDayOrderQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldDayOrderQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldDayCumQty::enumItems = nullptr;
template<> FieldType FieldDayCumQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldDayCumQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldDayAvgPx::enumItems = nullptr;
template<> FieldType FieldDayAvgPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldDayAvgPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldGTBookingInst::enumItems = nullptr;
template<> FieldType FieldGTBookingInst::getType() { return FieldType::INT; }
template<> const std::string & FieldGTBookingInst::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoStrikes::enumItems = nullptr;
template<> FieldType FieldNoStrikes::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoStrikes::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldListStatusType::enumItems = nullptr;
template<> FieldType FieldListStatusType::getType() { return FieldType::INT; }
template<> const std::string & FieldListStatusType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetGrossInd::enumItems = nullptr;
template<> FieldType FieldNetGrossInd::getType() { return FieldType::INT; }
template<> const std::string & FieldNetGrossInd::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldListOrderStatus::enumItems = nullptr;
template<> FieldType FieldListOrderStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldListOrderStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldExpireDate::enumItems = nullptr;
template<> FieldType FieldExpireDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldExpireDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldListExecInstType::enumItems = nullptr;
template<> FieldType FieldListExecInstType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldListExecInstType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldCxlRejResponseTo::enumItems = nullptr;
template<> FieldType FieldCxlRejResponseTo::getType() { return FieldType::CHAR; }
template<> const std::string & FieldCxlRejResponseTo::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCouponRate::enumItems = nullptr;
template<> FieldType FieldUnderlyingCouponRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldUnderlyingCouponRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingContractMultiplier::enumItems = nullptr;
template<> FieldType FieldUnderlyingContractMultiplier::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldUnderlyingContractMultiplier::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraTradeQty::enumItems = nullptr;
template<> FieldType FieldContraTradeQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldContraTradeQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraTradeTime::enumItems = nullptr;
template<> FieldType FieldContraTradeTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldContraTradeTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLiquidityNumSecurities::enumItems = nullptr;
template<> FieldType FieldLiquidityNumSecurities::getType() { return FieldType::INT; }
template<> const std::string & FieldLiquidityNumSecurities::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMultiLegReportingType::enumItems = nullptr;
template<> FieldType FieldMultiLegReportingType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMultiLegReportingType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldStrikeTime::enumItems = nullptr;
template<> FieldType FieldStrikeTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldStrikeTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldListStatusText::enumItems = nullptr;
template<> FieldType FieldListStatusText::getType() { return FieldType::STRING; }
template<> const std::string & FieldListStatusText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedListStatusTextLen::enumItems = nullptr;
template<> FieldType FieldEncodedListStatusTextLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedListStatusTextLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedListStatusText::enumItems = nullptr;
template<> FieldType FieldEncodedListStatusText::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedListStatusText::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldPartyIDSource::enumItems = nullptr;
template<> FieldType FieldPartyIDSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldPartyIDSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldPartyID::enumItems = nullptr;
template<> FieldType FieldPartyID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPartyID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetChgPrevDay::enumItems = nullptr;
template<> FieldType FieldNetChgPrevDay::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldNetChgPrevDay::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldPartyRole::enumItems = nullptr;
template<> FieldType FieldPartyRole::getType() { return FieldType::INT; }
template<> const std::string & FieldPartyRole::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoPartyIDs::enumItems = nullptr;
template<> FieldType FieldNoPartyIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoPartyIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSecurityAltID::enumItems = nullptr;
template<> FieldType FieldNoSecurityAltID::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSecurityAltID::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityAltID::enumItems = nullptr;
template<> FieldType FieldSecurityAltID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityAltID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityAltIDSource::enumItems = nullptr;
template<> FieldType FieldSecurityAltIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecurityAltIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoUnderlyingSecurityAltID::enumItems = nullptr;
template<> FieldType FieldNoUnderlyingSecurityAltID::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoUnderlyingSecurityAltID::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityAltID::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityAltID::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityAltID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecurityAltIDSource::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecurityAltIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecurityAltIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldProduct::enumItems = nullptr;
template<> FieldType FieldProduct::getType() { return FieldType::INT; }
template<> const std::string & FieldProduct::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCFICode::enumItems = nullptr;
template<> FieldType FieldCFICode::getType() { return FieldType::STRING; }
template<> const std::string & FieldCFICode::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingProduct::enumItems = nullptr;
template<> FieldType FieldUnderlyingProduct::getType() { return FieldType::INT; }
template<> const std::string & FieldUnderlyingProduct::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCFICode::enumItems = nullptr;
template<> FieldType FieldUnderlyingCFICode::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingCFICode::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTestMessageIndicator::enumItems = nullptr;
template<> FieldType FieldTestMessageIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldTestMessageIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldBookingRefID::enumItems = nullptr;
template<> FieldType FieldBookingRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldBookingRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldIndividualAllocID::enumItems = nullptr;
template<> FieldType FieldIndividualAllocID::getType() { return FieldType::STRING; }
template<> const std::string & FieldIndividualAllocID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRoundingDirection::enumItems = nullptr;
template<> FieldType FieldRoundingDirection::getType() { return FieldType::CHAR; }
template<> const std::string & FieldRoundingDirection::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldRoundingModulus::enumItems = nullptr;
template<> FieldType FieldRoundingModulus::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldRoundingModulus::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCountryOfIssue::enumItems = nullptr;
template<> FieldType FieldCountryOfIssue::getType() { return FieldType::COUNTRY; }
template<> const std::string & FieldCountryOfIssue::getTypeName() { static const std::string fixType{ "COUNTRY" }; return fixType; }
template<> const FieldEnumBase * const * FieldStateOrProvinceOfIssue::enumItems = nullptr;
template<> FieldType FieldStateOrProvinceOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldStateOrProvinceOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLocaleOfIssue::enumItems = nullptr;
template<> FieldType FieldLocaleOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldLocaleOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoRegistDtls::enumItems = nullptr;
template<> FieldType FieldNoRegistDtls::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoRegistDtls::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMailingDtls::enumItems = nullptr;
template<> FieldType FieldMailingDtls::getType() { return FieldType::STRING; }
template<> const std::string & FieldMailingDtls::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldInvestorCountryOfResidence::enumItems = nullptr;
template<> FieldType FieldInvestorCountryOfResidence::getType() { return FieldType::COUNTRY; }
template<> const std::string & FieldInvestorCountryOfResidence::getTypeName() { static const std::string fixType{ "COUNTRY" }; return fixType; }
template<> const FieldEnumBase * const * FieldPaymentRef::enumItems = nullptr;
template<> FieldType FieldPaymentRef::getType() { return FieldType::STRING; }
template<> const std::string & FieldPaymentRef::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDistribPaymentMethod::enumItems = nullptr;
template<> FieldType FieldDistribPaymentMethod::getType() { return FieldType::INT; }
template<> const std::string & FieldDistribPaymentMethod::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribCurr::enumItems = nullptr;
template<> FieldType FieldCashDistribCurr::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldCashDistribCurr::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldCommCurrency::enumItems = nullptr;
template<> FieldType FieldCommCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldCommCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldCancellationRights::enumItems = nullptr;
template<> FieldType FieldCancellationRights::getType() { return FieldType::CHAR; }
template<> const std::string & FieldCancellationRights::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMoneyLaunderingStatus::enumItems = nullptr;
template<> FieldType FieldMoneyLaunderingStatus::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMoneyLaunderingStatus::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMailingInst::enumItems = nullptr;
template<> FieldType FieldMailingInst::getType() { return FieldType::STRING; }
template<> const std::string & FieldMailingInst::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTransBkdTime::enumItems = nullptr;
template<> FieldType FieldTransBkdTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTransBkdTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecPriceType::enumItems = nullptr;
template<> FieldType FieldExecPriceType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldExecPriceType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecPriceAdjustment::enumItems = nullptr;
template<> FieldType FieldExecPriceAdjustment::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldExecPriceAdjustment::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDateOfBirth::enumItems = nullptr;
template<> FieldType FieldDateOfBirth::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldDateOfBirth::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeReportTransType::enumItems = nullptr;
template<> FieldType FieldTradeReportTransType::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeReportTransType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCardHolderName::enumItems = nullptr;
template<> FieldType FieldCardHolderName::getType() { return FieldType::STRING; }
template<> const std::string & FieldCardHolderName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCardNumber::enumItems = nullptr;
template<> FieldType FieldCardNumber::getType() { return FieldType::STRING; }
template<> const std::string & FieldCardNumber::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCardExpDate::enumItems = nullptr;
template<> FieldType FieldCardExpDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldCardExpDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCardIssNum::enumItems = nullptr;
template<> FieldType FieldCardIssNum::getType() { return FieldType::STRING; }
template<> const std::string & FieldCardIssNum::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPaymentMethod::enumItems = nullptr;
template<> FieldType FieldPaymentMethod::getType() { return FieldType::INT; }
template<> const std::string & FieldPaymentMethod::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistAcctType::enumItems = nullptr;
template<> FieldType FieldRegistAcctType::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistAcctType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDesignation::enumItems = nullptr;
template<> FieldType FieldDesignation::getType() { return FieldType::STRING; }
template<> const std::string & FieldDesignation::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTaxAdvantageType::enumItems = nullptr;
template<> FieldType FieldTaxAdvantageType::getType() { return FieldType::INT; }
template<> const std::string & FieldTaxAdvantageType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistRejReasonText::enumItems = nullptr;
template<> FieldType FieldRegistRejReasonText::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistRejReasonText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldFundRenewWaiv::enumItems = nullptr;
template<> FieldType FieldFundRenewWaiv::getType() { return FieldType::CHAR; }
template<> const std::string & FieldFundRenewWaiv::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribAgentName::enumItems = nullptr;
template<> FieldType FieldCashDistribAgentName::getType() { return FieldType::STRING; }
template<> const std::string & FieldCashDistribAgentName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribAgentCode::enumItems = nullptr;
template<> FieldType FieldCashDistribAgentCode::getType() { return FieldType::STRING; }
template<> const std::string & FieldCashDistribAgentCode::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribAgentAcctNumber::enumItems = nullptr;
template<> FieldType FieldCashDistribAgentAcctNumber::getType() { return FieldType::STRING; }
template<> const std::string & FieldCashDistribAgentAcctNumber::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribPayRef::enumItems = nullptr;
template<> FieldType FieldCashDistribPayRef::getType() { return FieldType::STRING; }
template<> const std::string & FieldCashDistribPayRef::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashDistribAgentAcctName::enumItems = nullptr;
template<> FieldType FieldCashDistribAgentAcctName::getType() { return FieldType::STRING; }
template<> const std::string & FieldCashDistribAgentAcctName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCardStartDate::enumItems = nullptr;
template<> FieldType FieldCardStartDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldCardStartDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPaymentDate::enumItems = nullptr;
template<> FieldType FieldPaymentDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldPaymentDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPaymentRemitterID::enumItems = nullptr;
template<> FieldType FieldPaymentRemitterID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPaymentRemitterID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistStatus::enumItems = nullptr;
template<> FieldType FieldRegistStatus::getType() { return FieldType::CHAR; }
template<> const std::string & FieldRegistStatus::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistRejReasonCode::enumItems = nullptr;
template<> FieldType FieldRegistRejReasonCode::getType() { return FieldType::INT; }
template<> const std::string & FieldRegistRejReasonCode::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistRefID::enumItems = nullptr;
template<> FieldType FieldRegistRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistDtls::enumItems = nullptr;
template<> FieldType FieldRegistDtls::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistDtls::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoDistribInsts::enumItems = nullptr;
template<> FieldType FieldNoDistribInsts::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoDistribInsts::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistEmail::enumItems = nullptr;
template<> FieldType FieldRegistEmail::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistEmail::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDistribPercentage::enumItems = nullptr;
template<> FieldType FieldDistribPercentage::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldDistribPercentage::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistID::enumItems = nullptr;
template<> FieldType FieldRegistID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRegistID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRegistTransType::enumItems = nullptr;
template<> FieldType FieldRegistTransType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldRegistTransType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldExecValuationPoint::enumItems = nullptr;
template<> FieldType FieldExecValuationPoint::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldExecValuationPoint::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderPercent::enumItems = nullptr;
template<> FieldType FieldOrderPercent::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldOrderPercent::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldOwnershipType::enumItems = nullptr;
template<> FieldType FieldOwnershipType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldOwnershipType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoContAmts::enumItems = nullptr;
template<> FieldType FieldNoContAmts::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoContAmts::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldContAmtType::enumItems = nullptr;
template<> FieldType FieldContAmtType::getType() { return FieldType::INT; }
template<> const std::string & FieldContAmtType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldContAmtValue::enumItems = nullptr;
template<> FieldType FieldContAmtValue::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldContAmtValue::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldContAmtCurr::enumItems = nullptr;
template<> FieldType FieldContAmtCurr::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldContAmtCurr::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldOwnerType::enumItems = nullptr;
template<> FieldType FieldOwnerType::getType() { return FieldType::INT; }
template<> const std::string & FieldOwnerType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPartySubID::enumItems = nullptr;
template<> FieldType FieldPartySubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPartySubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNestedPartyID::enumItems = nullptr;
template<> FieldType FieldNestedPartyID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNestedPartyID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNestedPartyIDSource::enumItems = nullptr;
template<> FieldType FieldNestedPartyIDSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldNestedPartyIDSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryClOrdID::enumItems = nullptr;
template<> FieldType FieldSecondaryClOrdID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryClOrdID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryExecID::enumItems = nullptr;
template<> FieldType FieldSecondaryExecID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryExecID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderCapacity::enumItems = nullptr;
template<> FieldType FieldOrderCapacity::getType() { return FieldType::CHAR; }
template<> const std::string & FieldOrderCapacity::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderRestrictions::enumItems = nullptr;
template<> FieldType FieldOrderRestrictions::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldOrderRestrictions::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMassCancelRequestType::enumItems = nullptr;
template<> FieldType FieldMassCancelRequestType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMassCancelRequestType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMassCancelResponse::enumItems = nullptr;
template<> FieldType FieldMassCancelResponse::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMassCancelResponse::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMassCancelRejectReason::enumItems = nullptr;
template<> FieldType FieldMassCancelRejectReason::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMassCancelRejectReason::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalAffectedOrders::enumItems = nullptr;
template<> FieldType FieldTotalAffectedOrders::getType() { return FieldType::INT; }
template<> const std::string & FieldTotalAffectedOrders::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoAffectedOrders::enumItems = nullptr;
template<> FieldType FieldNoAffectedOrders::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoAffectedOrders::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAffectedOrderID::enumItems = nullptr;
template<> FieldType FieldAffectedOrderID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAffectedOrderID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAffectedSecondaryOrderID::enumItems = nullptr;
template<> FieldType FieldAffectedSecondaryOrderID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAffectedSecondaryOrderID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteType::enumItems = nullptr;
template<> FieldType FieldQuoteType::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNestedPartyRole::enumItems = nullptr;
template<> FieldType FieldNestedPartyRole::getType() { return FieldType::INT; }
template<> const std::string & FieldNestedPartyRole::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNestedPartyIDs::enumItems = nullptr;
template<> FieldType FieldNoNestedPartyIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNestedPartyIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalAccruedInterestAmt::enumItems = nullptr;
template<> FieldType FieldTotalAccruedInterestAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldTotalAccruedInterestAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaturityDate::enumItems = nullptr;
template<> FieldType FieldMaturityDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldMaturityDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingMaturityDate::enumItems = nullptr;
template<> FieldType FieldUnderlyingMaturityDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldUnderlyingMaturityDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldInstrRegistry::enumItems = nullptr;
template<> FieldType FieldInstrRegistry::getType() { return FieldType::STRING; }
template<> const std::string & FieldInstrRegistry::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashMargin::enumItems = nullptr;
template<> FieldType FieldCashMargin::getType() { return FieldType::CHAR; }
template<> const std::string & FieldCashMargin::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNestedPartySubID::enumItems = nullptr;
template<> FieldType FieldNestedPartySubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNestedPartySubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldScope::enumItems = nullptr;
template<> FieldType FieldScope::getType() { return FieldType::MULTIPLEVALUESTRING; }
template<> const std::string & FieldScope::getTypeName() { static const std::string fixType{ "MULTIPLEVALUESTRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMDImplicitDelete::enumItems = nullptr;
template<> FieldType FieldMDImplicitDelete::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldMDImplicitDelete::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldCrossID::enumItems = nullptr;
template<> FieldType FieldCrossID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCrossID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCrossType::enumItems = nullptr;
template<> FieldType FieldCrossType::getType() { return FieldType::INT; }
template<> const std::string & FieldCrossType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCrossPrioritization::enumItems = nullptr;
template<> FieldType FieldCrossPrioritization::getType() { return FieldType::INT; }
template<> const std::string & FieldCrossPrioritization::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigCrossID::enumItems = nullptr;
template<> FieldType FieldOrigCrossID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrigCrossID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSides::enumItems = nullptr;
template<> FieldType FieldNoSides::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSides::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldUsername::enumItems = nullptr;
template<> FieldType FieldUsername::getType() { return FieldType::STRING; }
template<> const std::string & FieldUsername::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPassword::enumItems = nullptr;
template<> FieldType FieldPassword::getType() { return FieldType::STRING; }
template<> const std::string & FieldPassword::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoLegs::enumItems = nullptr;
template<> FieldType FieldNoLegs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoLegs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCurrency::enumItems = nullptr;
template<> FieldType FieldLegCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldLegCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoSecurityTypes::enumItems = nullptr;
template<> FieldType FieldTotNoSecurityTypes::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoSecurityTypes::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSecurityTypes::enumItems = nullptr;
template<> FieldType FieldNoSecurityTypes::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSecurityTypes::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityListRequestType::enumItems = nullptr;
template<> FieldType FieldSecurityListRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldSecurityListRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecurityRequestResult::enumItems = nullptr;
template<> FieldType FieldSecurityRequestResult::getType() { return FieldType::INT; }
template<> const std::string & FieldSecurityRequestResult::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldRoundLot::enumItems = nullptr;
template<> FieldType FieldRoundLot::getType() { return FieldType::QTY; }
template<> const std::string & FieldRoundLot::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMinTradeVol::enumItems = nullptr;
template<> FieldType FieldMinTradeVol::getType() { return FieldType::QTY; }
template<> const std::string & FieldMinTradeVol::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMultiLegRptTypeReq::enumItems = nullptr;
template<> FieldType FieldMultiLegRptTypeReq::getType() { return FieldType::INT; }
template<> const std::string & FieldMultiLegRptTypeReq::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegPositionEffect::enumItems = nullptr;
template<> FieldType FieldLegPositionEffect::getType() { return FieldType::CHAR; }
template<> const std::string & FieldLegPositionEffect::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCoveredOrUncovered::enumItems = nullptr;
template<> FieldType FieldLegCoveredOrUncovered::getType() { return FieldType::INT; }
template<> const std::string & FieldLegCoveredOrUncovered::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegPrice::enumItems = nullptr;
template<> FieldType FieldLegPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradSesStatusRejReason::enumItems = nullptr;
template<> FieldType FieldTradSesStatusRejReason::getType() { return FieldType::INT; }
template<> const std::string & FieldTradSesStatusRejReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeRequestID::enumItems = nullptr;
template<> FieldType FieldTradeRequestID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeRequestID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeRequestType::enumItems = nullptr;
template<> FieldType FieldTradeRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPreviouslyReported::enumItems = nullptr;
template<> FieldType FieldPreviouslyReported::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldPreviouslyReported::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeReportID::enumItems = nullptr;
template<> FieldType FieldTradeReportID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeReportID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeReportRefID::enumItems = nullptr;
template<> FieldType FieldTradeReportRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeReportRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMatchStatus::enumItems = nullptr;
template<> FieldType FieldMatchStatus::getType() { return FieldType::CHAR; }
template<> const std::string & FieldMatchStatus::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldMatchType::enumItems = nullptr;
template<> FieldType FieldMatchType::getType() { return FieldType::STRING; }
template<> const std::string & FieldMatchType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOddLot::enumItems = nullptr;
template<> FieldType FieldOddLot::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldOddLot::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoClearingInstructions::enumItems = nullptr;
template<> FieldType FieldNoClearingInstructions::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoClearingInstructions::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldClearingInstruction::enumItems = nullptr;
template<> FieldType FieldClearingInstruction::getType() { return FieldType::INT; }
template<> const std::string & FieldClearingInstruction::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeInputSource::enumItems = nullptr;
template<> FieldType FieldTradeInputSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeInputSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeInputDevice::enumItems = nullptr;
template<> FieldType FieldTradeInputDevice::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeInputDevice::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoDates::enumItems = nullptr;
template<> FieldType FieldNoDates::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoDates::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAccountType::enumItems = nullptr;
template<> FieldType FieldAccountType::getType() { return FieldType::INT; }
template<> const std::string & FieldAccountType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCustOrderCapacity::enumItems = nullptr;
template<> FieldType FieldCustOrderCapacity::getType() { return FieldType::INT; }
template<> const std::string & FieldCustOrderCapacity::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldClOrdLinkID::enumItems = nullptr;
template<> FieldType FieldClOrdLinkID::getType() { return FieldType::STRING; }
template<> const std::string & FieldClOrdLinkID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMassStatusReqID::enumItems = nullptr;
template<> FieldType FieldMassStatusReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldMassStatusReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMassStatusReqType::enumItems = nullptr;
template<> FieldType FieldMassStatusReqType::getType() { return FieldType::INT; }
template<> const std::string & FieldMassStatusReqType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigOrdModTime::enumItems = nullptr;
template<> FieldType FieldOrigOrdModTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldOrigOrdModTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSettlType::enumItems = nullptr;
template<> FieldType FieldLegSettlType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldLegSettlType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSettlDate::enumItems = nullptr;
template<> FieldType FieldLegSettlDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegSettlDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldDayBookingInst::enumItems = nullptr;
template<> FieldType FieldDayBookingInst::getType() { return FieldType::CHAR; }
template<> const std::string & FieldDayBookingInst::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldBookingUnit::enumItems = nullptr;
template<> FieldType FieldBookingUnit::getType() { return FieldType::CHAR; }
template<> const std::string & FieldBookingUnit::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldPreallocMethod::enumItems = nullptr;
template<> FieldType FieldPreallocMethod::getType() { return FieldType::CHAR; }
template<> const std::string & FieldPreallocMethod::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCountryOfIssue::enumItems = nullptr;
template<> FieldType FieldUnderlyingCountryOfIssue::getType() { return FieldType::COUNTRY; }
template<> const std::string & FieldUnderlyingCountryOfIssue::getTypeName() { static const std::string fixType{ "COUNTRY" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStateOrProvinceOfIssue::enumItems = nullptr;
template<> FieldType FieldUnderlyingStateOrProvinceOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingStateOrProvinceOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingLocaleOfIssue::enumItems = nullptr;
template<> FieldType FieldUnderlyingLocaleOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingLocaleOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingInstrRegistry::enumItems = nullptr;
template<> FieldType FieldUnderlyingInstrRegistry::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingInstrRegistry::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCountryOfIssue::enumItems = nullptr;
template<> FieldType FieldLegCountryOfIssue::getType() { return FieldType::COUNTRY; }
template<> const std::string & FieldLegCountryOfIssue::getTypeName() { static const std::string fixType{ "COUNTRY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegStateOrProvinceOfIssue::enumItems = nullptr;
template<> FieldType FieldLegStateOrProvinceOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegStateOrProvinceOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegLocaleOfIssue::enumItems = nullptr;
template<> FieldType FieldLegLocaleOfIssue::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegLocaleOfIssue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegInstrRegistry::enumItems = nullptr;
template<> FieldType FieldLegInstrRegistry::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegInstrRegistry::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSymbol::enumItems = nullptr;
template<> FieldType FieldLegSymbol::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSymbol::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSymbolSfx::enumItems = nullptr;
template<> FieldType FieldLegSymbolSfx::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSymbolSfx::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityID::enumItems = nullptr;
template<> FieldType FieldLegSecurityID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityIDSource::enumItems = nullptr;
template<> FieldType FieldLegSecurityIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoLegSecurityAltID::enumItems = nullptr;
template<> FieldType FieldNoLegSecurityAltID::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoLegSecurityAltID::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityAltID::enumItems = nullptr;
template<> FieldType FieldLegSecurityAltID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityAltID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityAltIDSource::enumItems = nullptr;
template<> FieldType FieldLegSecurityAltIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityAltIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegProduct::enumItems = nullptr;
template<> FieldType FieldLegProduct::getType() { return FieldType::INT; }
template<> const std::string & FieldLegProduct::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCFICode::enumItems = nullptr;
template<> FieldType FieldLegCFICode::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegCFICode::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityType::enumItems = nullptr;
template<> FieldType FieldLegSecurityType::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegMaturityMonthYear::enumItems = nullptr;
template<> FieldType FieldLegMaturityMonthYear::getType() { return FieldType::MONTHYEAR; }
template<> const std::string & FieldLegMaturityMonthYear::getTypeName() { static const std::string fixType{ "MONTHYEAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegMaturityDate::enumItems = nullptr;
template<> FieldType FieldLegMaturityDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegMaturityDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegStrikePrice::enumItems = nullptr;
template<> FieldType FieldLegStrikePrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegStrikePrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegOptAttribute::enumItems = nullptr;
template<> FieldType FieldLegOptAttribute::getType() { return FieldType::CHAR; }
template<> const std::string & FieldLegOptAttribute::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegContractMultiplier::enumItems = nullptr;
template<> FieldType FieldLegContractMultiplier::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldLegContractMultiplier::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegCouponRate::enumItems = nullptr;
template<> FieldType FieldLegCouponRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldLegCouponRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityExchange::enumItems = nullptr;
template<> FieldType FieldLegSecurityExchange::getType() { return FieldType::EXCHANGE; }
template<> const std::string & FieldLegSecurityExchange::getTypeName() { static const std::string fixType{ "EXCHANGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegIssuer::enumItems = nullptr;
template<> FieldType FieldLegIssuer::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegIssuer::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedLegIssuerLen::enumItems = nullptr;
template<> FieldType FieldEncodedLegIssuerLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedLegIssuerLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedLegIssuer::enumItems = nullptr;
template<> FieldType FieldEncodedLegIssuer::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedLegIssuer::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecurityDesc::enumItems = nullptr;
template<> FieldType FieldLegSecurityDesc::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecurityDesc::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedLegSecurityDescLen::enumItems = nullptr;
template<> FieldType FieldEncodedLegSecurityDescLen::getType() { return FieldType::LENGTH; }
template<> const std::string & FieldEncodedLegSecurityDescLen::getTypeName() { static const std::string fixType{ "LENGTH" }; return fixType; }
template<> const FieldEnumBase * const * FieldEncodedLegSecurityDesc::enumItems = nullptr;
template<> FieldType FieldEncodedLegSecurityDesc::getType() { return FieldType::DATA; }
template<> const std::string & FieldEncodedLegSecurityDesc::getTypeName() { static const std::string fixType{ "DATA" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRatioQty::enumItems = nullptr;
template<> FieldType FieldLegRatioQty::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldLegRatioQty::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSide::enumItems = nullptr;
template<> FieldType FieldLegSide::getType() { return FieldType::CHAR; }
template<> const std::string & FieldLegSide::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradingSessionSubID::enumItems = nullptr;
template<> FieldType FieldTradingSessionSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradingSessionSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocType::enumItems = nullptr;
template<> FieldType FieldAllocType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoHops::enumItems = nullptr;
template<> FieldType FieldNoHops::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoHops::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldHopCompID::enumItems = nullptr;
template<> FieldType FieldHopCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldHopCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldHopSendingTime::enumItems = nullptr;
template<> FieldType FieldHopSendingTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldHopSendingTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldHopRefID::enumItems = nullptr;
template<> FieldType FieldHopRefID::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldHopRefID::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldMidPx::enumItems = nullptr;
template<> FieldType FieldMidPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldMidPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidYield::enumItems = nullptr;
template<> FieldType FieldBidYield::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldBidYield::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMidYield::enumItems = nullptr;
template<> FieldType FieldMidYield::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldMidYield::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferYield::enumItems = nullptr;
template<> FieldType FieldOfferYield::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldOfferYield::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldClearingFeeIndicator::enumItems = nullptr;
template<> FieldType FieldClearingFeeIndicator::getType() { return FieldType::STRING; }
template<> const std::string & FieldClearingFeeIndicator::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldWorkingIndicator::enumItems = nullptr;
template<> FieldType FieldWorkingIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldWorkingIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegLastPx::enumItems = nullptr;
template<> FieldType FieldLegLastPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegLastPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriorityIndicator::enumItems = nullptr;
template<> FieldType FieldPriorityIndicator::getType() { return FieldType::INT; }
template<> const std::string & FieldPriorityIndicator::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriceImprovement::enumItems = nullptr;
template<> FieldType FieldPriceImprovement::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldPriceImprovement::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldPrice2::enumItems = nullptr;
template<> FieldType FieldPrice2::getType() { return FieldType::PRICE; }
template<> const std::string & FieldPrice2::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastForwardPoints2::enumItems = nullptr;
template<> FieldType FieldLastForwardPoints2::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldLastForwardPoints2::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldBidForwardPoints2::enumItems = nullptr;
template<> FieldType FieldBidForwardPoints2::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldBidForwardPoints2::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldOfferForwardPoints2::enumItems = nullptr;
template<> FieldType FieldOfferForwardPoints2::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldOfferForwardPoints2::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldRFQReqID::enumItems = nullptr;
template<> FieldType FieldRFQReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRFQReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMktBidPx::enumItems = nullptr;
template<> FieldType FieldMktBidPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldMktBidPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMktOfferPx::enumItems = nullptr;
template<> FieldType FieldMktOfferPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldMktOfferPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMinBidSize::enumItems = nullptr;
template<> FieldType FieldMinBidSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldMinBidSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldMinOfferSize::enumItems = nullptr;
template<> FieldType FieldMinOfferSize::getType() { return FieldType::QTY; }
template<> const std::string & FieldMinOfferSize::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteStatusReqID::enumItems = nullptr;
template<> FieldType FieldQuoteStatusReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteStatusReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegalConfirm::enumItems = nullptr;
template<> FieldType FieldLegalConfirm::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldLegalConfirm::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingLastPx::enumItems = nullptr;
template<> FieldType FieldUnderlyingLastPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingLastPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingLastQty::enumItems = nullptr;
template<> FieldType FieldUnderlyingLastQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldUnderlyingLastQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegRefID::enumItems = nullptr;
template<> FieldType FieldLegRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraLegRefID::enumItems = nullptr;
template<> FieldType FieldContraLegRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldContraLegRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrBidFxRate::enumItems = nullptr;
template<> FieldType FieldSettlCurrBidFxRate::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldSettlCurrBidFxRate::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlCurrOfferFxRate::enumItems = nullptr;
template<> FieldType FieldSettlCurrOfferFxRate::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldSettlCurrOfferFxRate::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteRequestRejectReason::enumItems = nullptr;
template<> FieldType FieldQuoteRequestRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteRequestRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSideComplianceID::enumItems = nullptr;
template<> FieldType FieldSideComplianceID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSideComplianceID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAcctIDSource::enumItems = nullptr;
template<> FieldType FieldAcctIDSource::getType() { return FieldType::INT; }
template<> const std::string & FieldAcctIDSource::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocAcctIDSource::enumItems = nullptr;
template<> FieldType FieldAllocAcctIDSource::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocAcctIDSource::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkPrice::enumItems = nullptr;
template<> FieldType FieldBenchmarkPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldBenchmarkPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkPriceType::enumItems = nullptr;
template<> FieldType FieldBenchmarkPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldBenchmarkPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmID::enumItems = nullptr;
template<> FieldType FieldConfirmID::getType() { return FieldType::STRING; }
template<> const std::string & FieldConfirmID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmStatus::enumItems = nullptr;
template<> FieldType FieldConfirmStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldConfirmStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmTransType::enumItems = nullptr;
template<> FieldType FieldConfirmTransType::getType() { return FieldType::INT; }
template<> const std::string & FieldConfirmTransType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldContractSettlMonth::enumItems = nullptr;
template<> FieldType FieldContractSettlMonth::getType() { return FieldType::MONTHYEAR; }
template<> const std::string & FieldContractSettlMonth::getTypeName() { static const std::string fixType{ "MONTHYEAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliveryForm::enumItems = nullptr;
template<> FieldType FieldDeliveryForm::getType() { return FieldType::INT; }
template<> const std::string & FieldDeliveryForm::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastParPx::enumItems = nullptr;
template<> FieldType FieldLastParPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLastParPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoLegAllocs::enumItems = nullptr;
template<> FieldType FieldNoLegAllocs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoLegAllocs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegAllocAccount::enumItems = nullptr;
template<> FieldType FieldLegAllocAccount::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegAllocAccount::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegIndividualAllocID::enumItems = nullptr;
template<> FieldType FieldLegIndividualAllocID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegIndividualAllocID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegAllocQty::enumItems = nullptr;
template<> FieldType FieldLegAllocQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldLegAllocQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegAllocAcctIDSource::enumItems = nullptr;
template<> FieldType FieldLegAllocAcctIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegAllocAcctIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSettlCurrency::enumItems = nullptr;
template<> FieldType FieldLegSettlCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldLegSettlCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBenchmarkCurveCurrency::enumItems = nullptr;
template<> FieldType FieldLegBenchmarkCurveCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldLegBenchmarkCurveCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBenchmarkCurveName::enumItems = nullptr;
template<> FieldType FieldLegBenchmarkCurveName::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegBenchmarkCurveName::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBenchmarkCurvePoint::enumItems = nullptr;
template<> FieldType FieldLegBenchmarkCurvePoint::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegBenchmarkCurvePoint::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBenchmarkPrice::enumItems = nullptr;
template<> FieldType FieldLegBenchmarkPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegBenchmarkPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBenchmarkPriceType::enumItems = nullptr;
template<> FieldType FieldLegBenchmarkPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldLegBenchmarkPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegBidPx::enumItems = nullptr;
template<> FieldType FieldLegBidPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegBidPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegIOIQty::enumItems = nullptr;
template<> FieldType FieldLegIOIQty::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegIOIQty::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoLegStipulations::enumItems = nullptr;
template<> FieldType FieldNoLegStipulations::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoLegStipulations::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegOfferPx::enumItems = nullptr;
template<> FieldType FieldLegOfferPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldLegOfferPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegPriceType::enumItems = nullptr;
template<> FieldType FieldLegPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldLegPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegQty::enumItems = nullptr;
template<> FieldType FieldLegQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldLegQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegStipulationType::enumItems = nullptr;
template<> FieldType FieldLegStipulationType::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegStipulationType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegStipulationValue::enumItems = nullptr;
template<> FieldType FieldLegStipulationValue::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegStipulationValue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSwapType::enumItems = nullptr;
template<> FieldType FieldLegSwapType::getType() { return FieldType::INT; }
template<> const std::string & FieldLegSwapType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPool::enumItems = nullptr;
template<> FieldType FieldPool::getType() { return FieldType::STRING; }
template<> const std::string & FieldPool::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuotePriceType::enumItems = nullptr;
template<> FieldType FieldQuotePriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldQuotePriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteRespID::enumItems = nullptr;
template<> FieldType FieldQuoteRespID::getType() { return FieldType::STRING; }
template<> const std::string & FieldQuoteRespID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteRespType::enumItems = nullptr;
template<> FieldType FieldQuoteRespType::getType() { return FieldType::INT; }
template<> const std::string & FieldQuoteRespType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQuoteQualifier::enumItems = nullptr;
template<> FieldType FieldQuoteQualifier::getType() { return FieldType::CHAR; }
template<> const std::string & FieldQuoteQualifier::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldYieldRedemptionDate::enumItems = nullptr;
template<> FieldType FieldYieldRedemptionDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldYieldRedemptionDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldYieldRedemptionPrice::enumItems = nullptr;
template<> FieldType FieldYieldRedemptionPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldYieldRedemptionPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldYieldRedemptionPriceType::enumItems = nullptr;
template<> FieldType FieldYieldRedemptionPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldYieldRedemptionPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkSecurityID::enumItems = nullptr;
template<> FieldType FieldBenchmarkSecurityID::getType() { return FieldType::STRING; }
template<> const std::string & FieldBenchmarkSecurityID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldReversalIndicator::enumItems = nullptr;
template<> FieldType FieldReversalIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldReversalIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldYieldCalcDate::enumItems = nullptr;
template<> FieldType FieldYieldCalcDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldYieldCalcDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoPositions::enumItems = nullptr;
template<> FieldType FieldNoPositions::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoPositions::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosType::enumItems = nullptr;
template<> FieldType FieldPosType::getType() { return FieldType::STRING; }
template<> const std::string & FieldPosType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLongQty::enumItems = nullptr;
template<> FieldType FieldLongQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldLongQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldShortQty::enumItems = nullptr;
template<> FieldType FieldShortQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldShortQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosQtyStatus::enumItems = nullptr;
template<> FieldType FieldPosQtyStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldPosQtyStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosAmtType::enumItems = nullptr;
template<> FieldType FieldPosAmtType::getType() { return FieldType::STRING; }
template<> const std::string & FieldPosAmtType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosAmt::enumItems = nullptr;
template<> FieldType FieldPosAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldPosAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosTransType::enumItems = nullptr;
template<> FieldType FieldPosTransType::getType() { return FieldType::INT; }
template<> const std::string & FieldPosTransType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosReqID::enumItems = nullptr;
template<> FieldType FieldPosReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPosReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoUnderlyings::enumItems = nullptr;
template<> FieldType FieldNoUnderlyings::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoUnderlyings::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosMaintAction::enumItems = nullptr;
template<> FieldType FieldPosMaintAction::getType() { return FieldType::INT; }
template<> const std::string & FieldPosMaintAction::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrigPosReqRefID::enumItems = nullptr;
template<> FieldType FieldOrigPosReqRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrigPosReqRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosMaintRptRefID::enumItems = nullptr;
template<> FieldType FieldPosMaintRptRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPosMaintRptRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldClearingBusinessDate::enumItems = nullptr;
template<> FieldType FieldClearingBusinessDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldClearingBusinessDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlSessID::enumItems = nullptr;
template<> FieldType FieldSettlSessID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlSessID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlSessSubID::enumItems = nullptr;
template<> FieldType FieldSettlSessSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlSessSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAdjustmentType::enumItems = nullptr;
template<> FieldType FieldAdjustmentType::getType() { return FieldType::INT; }
template<> const std::string & FieldAdjustmentType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldContraryInstructionIndicator::enumItems = nullptr;
template<> FieldType FieldContraryInstructionIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldContraryInstructionIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriorSpreadIndicator::enumItems = nullptr;
template<> FieldType FieldPriorSpreadIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldPriorSpreadIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosMaintRptID::enumItems = nullptr;
template<> FieldType FieldPosMaintRptID::getType() { return FieldType::STRING; }
template<> const std::string & FieldPosMaintRptID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosMaintStatus::enumItems = nullptr;
template<> FieldType FieldPosMaintStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldPosMaintStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosMaintResult::enumItems = nullptr;
template<> FieldType FieldPosMaintResult::getType() { return FieldType::INT; }
template<> const std::string & FieldPosMaintResult::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosReqType::enumItems = nullptr;
template<> FieldType FieldPosReqType::getType() { return FieldType::INT; }
template<> const std::string & FieldPosReqType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldResponseTransportType::enumItems = nullptr;
template<> FieldType FieldResponseTransportType::getType() { return FieldType::INT; }
template<> const std::string & FieldResponseTransportType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldResponseDestination::enumItems = nullptr;
template<> FieldType FieldResponseDestination::getType() { return FieldType::STRING; }
template<> const std::string & FieldResponseDestination::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalNumPosReports::enumItems = nullptr;
template<> FieldType FieldTotalNumPosReports::getType() { return FieldType::INT; }
template<> const std::string & FieldTotalNumPosReports::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosReqResult::enumItems = nullptr;
template<> FieldType FieldPosReqResult::getType() { return FieldType::INT; }
template<> const std::string & FieldPosReqResult::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPosReqStatus::enumItems = nullptr;
template<> FieldType FieldPosReqStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldPosReqStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPrice::enumItems = nullptr;
template<> FieldType FieldSettlPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldSettlPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPriceType::enumItems = nullptr;
template<> FieldType FieldSettlPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldSettlPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSettlPrice::enumItems = nullptr;
template<> FieldType FieldUnderlyingSettlPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingSettlPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSettlPriceType::enumItems = nullptr;
template<> FieldType FieldUnderlyingSettlPriceType::getType() { return FieldType::INT; }
template<> const std::string & FieldUnderlyingSettlPriceType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriorSettlPrice::enumItems = nullptr;
template<> FieldType FieldPriorSettlPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldPriorSettlPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoQuoteQualifiers::enumItems = nullptr;
template<> FieldType FieldNoQuoteQualifiers::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoQuoteQualifiers::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocSettlCurrency::enumItems = nullptr;
template<> FieldType FieldAllocSettlCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldAllocSettlCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocSettlCurrAmt::enumItems = nullptr;
template<> FieldType FieldAllocSettlCurrAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldAllocSettlCurrAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldInterestAtMaturity::enumItems = nullptr;
template<> FieldType FieldInterestAtMaturity::getType() { return FieldType::AMT; }
template<> const std::string & FieldInterestAtMaturity::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegDatedDate::enumItems = nullptr;
template<> FieldType FieldLegDatedDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegDatedDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegPool::enumItems = nullptr;
template<> FieldType FieldLegPool::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegPool::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocInterestAtMaturity::enumItems = nullptr;
template<> FieldType FieldAllocInterestAtMaturity::getType() { return FieldType::AMT; }
template<> const std::string & FieldAllocInterestAtMaturity::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocAccruedInterestAmt::enumItems = nullptr;
template<> FieldType FieldAllocAccruedInterestAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldAllocAccruedInterestAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliveryDate::enumItems = nullptr;
template<> FieldType FieldDeliveryDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldDeliveryDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAssignmentMethod::enumItems = nullptr;
template<> FieldType FieldAssignmentMethod::getType() { return FieldType::CHAR; }
template<> const std::string & FieldAssignmentMethod::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldAssignmentUnit::enumItems = nullptr;
template<> FieldType FieldAssignmentUnit::getType() { return FieldType::QTY; }
template<> const std::string & FieldAssignmentUnit::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldOpenInterest::enumItems = nullptr;
template<> FieldType FieldOpenInterest::getType() { return FieldType::AMT; }
template<> const std::string & FieldOpenInterest::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldExerciseMethod::enumItems = nullptr;
template<> FieldType FieldExerciseMethod::getType() { return FieldType::CHAR; }
template<> const std::string & FieldExerciseMethod::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNumTradeReports::enumItems = nullptr;
template<> FieldType FieldTotNumTradeReports::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNumTradeReports::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeRequestResult::enumItems = nullptr;
template<> FieldType FieldTradeRequestResult::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeRequestResult::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeRequestStatus::enumItems = nullptr;
template<> FieldType FieldTradeRequestStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeRequestStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeReportRejectReason::enumItems = nullptr;
template<> FieldType FieldTradeReportRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeReportRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSideMultiLegReportingType::enumItems = nullptr;
template<> FieldType FieldSideMultiLegReportingType::getType() { return FieldType::INT; }
template<> const std::string & FieldSideMultiLegReportingType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoPosAmt::enumItems = nullptr;
template<> FieldType FieldNoPosAmt::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoPosAmt::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAutoAcceptIndicator::enumItems = nullptr;
template<> FieldType FieldAutoAcceptIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldAutoAcceptIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocReportID::enumItems = nullptr;
template<> FieldType FieldAllocReportID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocReportID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNested2PartyIDs::enumItems = nullptr;
template<> FieldType FieldNoNested2PartyIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNested2PartyIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested2PartyID::enumItems = nullptr;
template<> FieldType FieldNested2PartyID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNested2PartyID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested2PartyIDSource::enumItems = nullptr;
template<> FieldType FieldNested2PartyIDSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldNested2PartyIDSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested2PartyRole::enumItems = nullptr;
template<> FieldType FieldNested2PartyRole::getType() { return FieldType::INT; }
template<> const std::string & FieldNested2PartyRole::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested2PartySubID::enumItems = nullptr;
template<> FieldType FieldNested2PartySubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNested2PartySubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldBenchmarkSecurityIDSource::enumItems = nullptr;
template<> FieldType FieldBenchmarkSecurityIDSource::getType() { return FieldType::STRING; }
template<> const std::string & FieldBenchmarkSecurityIDSource::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecuritySubType::enumItems = nullptr;
template<> FieldType FieldSecuritySubType::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecuritySubType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingSecuritySubType::enumItems = nullptr;
template<> FieldType FieldUnderlyingSecuritySubType::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingSecuritySubType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegSecuritySubType::enumItems = nullptr;
template<> FieldType FieldLegSecuritySubType::getType() { return FieldType::STRING; }
template<> const std::string & FieldLegSecuritySubType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllowableOneSidednessPct::enumItems = nullptr;
template<> FieldType FieldAllowableOneSidednessPct::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldAllowableOneSidednessPct::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllowableOneSidednessValue::enumItems = nullptr;
template<> FieldType FieldAllowableOneSidednessValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldAllowableOneSidednessValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllowableOneSidednessCurr::enumItems = nullptr;
template<> FieldType FieldAllowableOneSidednessCurr::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldAllowableOneSidednessCurr::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoTrdRegTimestamps::enumItems = nullptr;
template<> FieldType FieldNoTrdRegTimestamps::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoTrdRegTimestamps::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdRegTimestamp::enumItems = nullptr;
template<> FieldType FieldTrdRegTimestamp::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldTrdRegTimestamp::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdRegTimestampType::enumItems = nullptr;
template<> FieldType FieldTrdRegTimestampType::getType() { return FieldType::INT; }
template<> const std::string & FieldTrdRegTimestampType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdRegTimestampOrigin::enumItems = nullptr;
template<> FieldType FieldTrdRegTimestampOrigin::getType() { return FieldType::STRING; }
template<> const std::string & FieldTrdRegTimestampOrigin::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmRefID::enumItems = nullptr;
template<> FieldType FieldConfirmRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldConfirmRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmType::enumItems = nullptr;
template<> FieldType FieldConfirmType::getType() { return FieldType::INT; }
template<> const std::string & FieldConfirmType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmRejReason::enumItems = nullptr;
template<> FieldType FieldConfirmRejReason::getType() { return FieldType::INT; }
template<> const std::string & FieldConfirmRejReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldBookingType::enumItems = nullptr;
template<> FieldType FieldBookingType::getType() { return FieldType::INT; }
template<> const std::string & FieldBookingType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldIndividualAllocRejCode::enumItems = nullptr;
template<> FieldType FieldIndividualAllocRejCode::getType() { return FieldType::INT; }
template<> const std::string & FieldIndividualAllocRejCode::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstMsgID::enumItems = nullptr;
template<> FieldType FieldSettlInstMsgID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlInstMsgID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSettlInst::enumItems = nullptr;
template<> FieldType FieldNoSettlInst::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSettlInst::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastUpdateTime::enumItems = nullptr;
template<> FieldType FieldLastUpdateTime::getType() { return FieldType::UTCTIMESTAMP; }
template<> const std::string & FieldLastUpdateTime::getTypeName() { static const std::string fixType{ "UTCTIMESTAMP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocSettlInstType::enumItems = nullptr;
template<> FieldType FieldAllocSettlInstType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocSettlInstType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSettlPartyIDs::enumItems = nullptr;
template<> FieldType FieldNoSettlPartyIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSettlPartyIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPartyID::enumItems = nullptr;
template<> FieldType FieldSettlPartyID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlPartyID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPartyIDSource::enumItems = nullptr;
template<> FieldType FieldSettlPartyIDSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldSettlPartyIDSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPartyRole::enumItems = nullptr;
template<> FieldType FieldSettlPartyRole::getType() { return FieldType::INT; }
template<> const std::string & FieldSettlPartyRole::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPartySubID::enumItems = nullptr;
template<> FieldType FieldSettlPartySubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlPartySubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlPartySubIDType::enumItems = nullptr;
template<> FieldType FieldSettlPartySubIDType::getType() { return FieldType::INT; }
template<> const std::string & FieldSettlPartySubIDType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDlvyInstType::enumItems = nullptr;
template<> FieldType FieldDlvyInstType::getType() { return FieldType::CHAR; }
template<> const std::string & FieldDlvyInstType::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldTerminationType::enumItems = nullptr;
template<> FieldType FieldTerminationType::getType() { return FieldType::INT; }
template<> const std::string & FieldTerminationType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNextExpectedMsgSeqNum::enumItems = nullptr;
template<> FieldType FieldNextExpectedMsgSeqNum::getType() { return FieldType::SEQNUM; }
template<> const std::string & FieldNextExpectedMsgSeqNum::getTypeName() { static const std::string fixType{ "SEQNUM" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrdStatusReqID::enumItems = nullptr;
template<> FieldType FieldOrdStatusReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrdStatusReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstReqID::enumItems = nullptr;
template<> FieldType FieldSettlInstReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSettlInstReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSettlInstReqRejCode::enumItems = nullptr;
template<> FieldType FieldSettlInstReqRejCode::getType() { return FieldType::INT; }
template<> const std::string & FieldSettlInstReqRejCode::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryAllocID::enumItems = nullptr;
template<> FieldType FieldSecondaryAllocID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryAllocID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocReportType::enumItems = nullptr;
template<> FieldType FieldAllocReportType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocReportType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocReportRefID::enumItems = nullptr;
template<> FieldType FieldAllocReportRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAllocReportRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocCancReplaceReason::enumItems = nullptr;
template<> FieldType FieldAllocCancReplaceReason::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocCancReplaceReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCopyMsgIndicator::enumItems = nullptr;
template<> FieldType FieldCopyMsgIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldCopyMsgIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocAccountType::enumItems = nullptr;
template<> FieldType FieldAllocAccountType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocAccountType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderAvgPx::enumItems = nullptr;
template<> FieldType FieldOrderAvgPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldOrderAvgPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderBookingQty::enumItems = nullptr;
template<> FieldType FieldOrderBookingQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldOrderBookingQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoSettlPartySubIDs::enumItems = nullptr;
template<> FieldType FieldNoSettlPartySubIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoSettlPartySubIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoPartySubIDs::enumItems = nullptr;
template<> FieldType FieldNoPartySubIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoPartySubIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldPartySubIDType::enumItems = nullptr;
template<> FieldType FieldPartySubIDType::getType() { return FieldType::INT; }
template<> const std::string & FieldPartySubIDType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNestedPartySubIDs::enumItems = nullptr;
template<> FieldType FieldNoNestedPartySubIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNestedPartySubIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNestedPartySubIDType::enumItems = nullptr;
template<> FieldType FieldNestedPartySubIDType::getType() { return FieldType::INT; }
template<> const std::string & FieldNestedPartySubIDType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNested2PartySubIDs::enumItems = nullptr;
template<> FieldType FieldNoNested2PartySubIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNested2PartySubIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested2PartySubIDType::enumItems = nullptr;
template<> FieldType FieldNested2PartySubIDType::getType() { return FieldType::INT; }
template<> const std::string & FieldNested2PartySubIDType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocIntermedReqType::enumItems = nullptr;
template<> FieldType FieldAllocIntermedReqType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocIntermedReqType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingPx::enumItems = nullptr;
template<> FieldType FieldUnderlyingPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPriceDelta::enumItems = nullptr;
template<> FieldType FieldPriceDelta::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldPriceDelta::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldApplQueueMax::enumItems = nullptr;
template<> FieldType FieldApplQueueMax::getType() { return FieldType::INT; }
template<> const std::string & FieldApplQueueMax::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldApplQueueDepth::enumItems = nullptr;
template<> FieldType FieldApplQueueDepth::getType() { return FieldType::INT; }
template<> const std::string & FieldApplQueueDepth::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldApplQueueResolution::enumItems = nullptr;
template<> FieldType FieldApplQueueResolution::getType() { return FieldType::INT; }
template<> const std::string & FieldApplQueueResolution::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldApplQueueAction::enumItems = nullptr;
template<> FieldType FieldApplQueueAction::getType() { return FieldType::INT; }
template<> const std::string & FieldApplQueueAction::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoAltMDSource::enumItems = nullptr;
template<> FieldType FieldNoAltMDSource::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoAltMDSource::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldAltMDSourceID::enumItems = nullptr;
template<> FieldType FieldAltMDSourceID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAltMDSourceID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryTradeReportID::enumItems = nullptr;
template<> FieldType FieldSecondaryTradeReportID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryTradeReportID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAvgPxIndicator::enumItems = nullptr;
template<> FieldType FieldAvgPxIndicator::getType() { return FieldType::INT; }
template<> const std::string & FieldAvgPxIndicator::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeLinkID::enumItems = nullptr;
template<> FieldType FieldTradeLinkID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeLinkID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderInputDevice::enumItems = nullptr;
template<> FieldType FieldOrderInputDevice::getType() { return FieldType::STRING; }
template<> const std::string & FieldOrderInputDevice::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingTradingSessionID::enumItems = nullptr;
template<> FieldType FieldUnderlyingTradingSessionID::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingTradingSessionID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingTradingSessionSubID::enumItems = nullptr;
template<> FieldType FieldUnderlyingTradingSessionSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingTradingSessionSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeLegRefID::enumItems = nullptr;
template<> FieldType FieldTradeLegRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTradeLegRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldExchangeRule::enumItems = nullptr;
template<> FieldType FieldExchangeRule::getType() { return FieldType::STRING; }
template<> const std::string & FieldExchangeRule::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeAllocIndicator::enumItems = nullptr;
template<> FieldType FieldTradeAllocIndicator::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeAllocIndicator::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldExpirationCycle::enumItems = nullptr;
template<> FieldType FieldExpirationCycle::getType() { return FieldType::INT; }
template<> const std::string & FieldExpirationCycle::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdType::enumItems = nullptr;
template<> FieldType FieldTrdType::getType() { return FieldType::INT; }
template<> const std::string & FieldTrdType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdSubType::enumItems = nullptr;
template<> FieldType FieldTrdSubType::getType() { return FieldType::INT; }
template<> const std::string & FieldTrdSubType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTransferReason::enumItems = nullptr;
template<> FieldType FieldTransferReason::getType() { return FieldType::STRING; }
template<> const std::string & FieldTransferReason::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNumAssignmentReports::enumItems = nullptr;
template<> FieldType FieldTotNumAssignmentReports::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNumAssignmentReports::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAsgnRptID::enumItems = nullptr;
template<> FieldType FieldAsgnRptID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAsgnRptID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldThresholdAmount::enumItems = nullptr;
template<> FieldType FieldThresholdAmount::getType() { return FieldType::PRICEOFFSET; }
template<> const std::string & FieldThresholdAmount::getTypeName() { static const std::string fixType{ "PRICEOFFSET" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegMoveType::enumItems = nullptr;
template<> FieldType FieldPegMoveType::getType() { return FieldType::INT; }
template<> const std::string & FieldPegMoveType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegOffsetType::enumItems = nullptr;
template<> FieldType FieldPegOffsetType::getType() { return FieldType::INT; }
template<> const std::string & FieldPegOffsetType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegLimitType::enumItems = nullptr;
template<> FieldType FieldPegLimitType::getType() { return FieldType::INT; }
template<> const std::string & FieldPegLimitType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegRoundDirection::enumItems = nullptr;
template<> FieldType FieldPegRoundDirection::getType() { return FieldType::INT; }
template<> const std::string & FieldPegRoundDirection::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPeggedPrice::enumItems = nullptr;
template<> FieldType FieldPeggedPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldPeggedPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldPegScope::enumItems = nullptr;
template<> FieldType FieldPegScope::getType() { return FieldType::INT; }
template<> const std::string & FieldPegScope::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionMoveType::enumItems = nullptr;
template<> FieldType FieldDiscretionMoveType::getType() { return FieldType::INT; }
template<> const std::string & FieldDiscretionMoveType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionOffsetType::enumItems = nullptr;
template<> FieldType FieldDiscretionOffsetType::getType() { return FieldType::INT; }
template<> const std::string & FieldDiscretionOffsetType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionLimitType::enumItems = nullptr;
template<> FieldType FieldDiscretionLimitType::getType() { return FieldType::INT; }
template<> const std::string & FieldDiscretionLimitType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionRoundDirection::enumItems = nullptr;
template<> FieldType FieldDiscretionRoundDirection::getType() { return FieldType::INT; }
template<> const std::string & FieldDiscretionRoundDirection::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionPrice::enumItems = nullptr;
template<> FieldType FieldDiscretionPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldDiscretionPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldDiscretionScope::enumItems = nullptr;
template<> FieldType FieldDiscretionScope::getType() { return FieldType::INT; }
template<> const std::string & FieldDiscretionScope::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetStrategy::enumItems = nullptr;
template<> FieldType FieldTargetStrategy::getType() { return FieldType::INT; }
template<> const std::string & FieldTargetStrategy::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetStrategyParameters::enumItems = nullptr;
template<> FieldType FieldTargetStrategyParameters::getType() { return FieldType::STRING; }
template<> const std::string & FieldTargetStrategyParameters::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldParticipationRate::enumItems = nullptr;
template<> FieldType FieldParticipationRate::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldParticipationRate::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldTargetStrategyPerformance::enumItems = nullptr;
template<> FieldType FieldTargetStrategyPerformance::getType() { return FieldType::FLOAT; }
template<> const std::string & FieldTargetStrategyPerformance::getTypeName() { static const std::string fixType{ "FLOAT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastLiquidityInd::enumItems = nullptr;
template<> FieldType FieldLastLiquidityInd::getType() { return FieldType::INT; }
template<> const std::string & FieldLastLiquidityInd::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldPublishTrdIndicator::enumItems = nullptr;
template<> FieldType FieldPublishTrdIndicator::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldPublishTrdIndicator::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldShortSaleReason::enumItems = nullptr;
template<> FieldType FieldShortSaleReason::getType() { return FieldType::INT; }
template<> const std::string & FieldShortSaleReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldQtyType::enumItems = nullptr;
template<> FieldType FieldQtyType::getType() { return FieldType::INT; }
template<> const std::string & FieldQtyType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryTrdType::enumItems = nullptr;
template<> FieldType FieldSecondaryTrdType::getType() { return FieldType::INT; }
template<> const std::string & FieldSecondaryTrdType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTradeReportType::enumItems = nullptr;
template<> FieldType FieldTradeReportType::getType() { return FieldType::INT; }
template<> const std::string & FieldTradeReportType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAllocNoOrdersType::enumItems = nullptr;
template<> FieldType FieldAllocNoOrdersType::getType() { return FieldType::INT; }
template<> const std::string & FieldAllocNoOrdersType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldSharedCommission::enumItems = nullptr;
template<> FieldType FieldSharedCommission::getType() { return FieldType::AMT; }
template<> const std::string & FieldSharedCommission::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldConfirmReqID::enumItems = nullptr;
template<> FieldType FieldConfirmReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldConfirmReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAvgParPx::enumItems = nullptr;
template<> FieldType FieldAvgParPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldAvgParPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldReportedPx::enumItems = nullptr;
template<> FieldType FieldReportedPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldReportedPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoCapacities::enumItems = nullptr;
template<> FieldType FieldNoCapacities::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoCapacities::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldOrderCapacityQty::enumItems = nullptr;
template<> FieldType FieldOrderCapacityQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldOrderCapacityQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoEvents::enumItems = nullptr;
template<> FieldType FieldNoEvents::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoEvents::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldEventType::enumItems = nullptr;
template<> FieldType FieldEventType::getType() { return FieldType::INT; }
template<> const std::string & FieldEventType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldEventDate::enumItems = nullptr;
template<> FieldType FieldEventDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldEventDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldEventPx::enumItems = nullptr;
template<> FieldType FieldEventPx::getType() { return FieldType::PRICE; }
template<> const std::string & FieldEventPx::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldEventText::enumItems = nullptr;
template<> FieldType FieldEventText::getType() { return FieldType::STRING; }
template<> const std::string & FieldEventText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldPctAtRisk::enumItems = nullptr;
template<> FieldType FieldPctAtRisk::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldPctAtRisk::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoInstrAttrib::enumItems = nullptr;
template<> FieldType FieldNoInstrAttrib::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoInstrAttrib::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldInstrAttribType::enumItems = nullptr;
template<> FieldType FieldInstrAttribType::getType() { return FieldType::INT; }
template<> const std::string & FieldInstrAttribType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldInstrAttribValue::enumItems = nullptr;
template<> FieldType FieldInstrAttribValue::getType() { return FieldType::STRING; }
template<> const std::string & FieldInstrAttribValue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldDatedDate::enumItems = nullptr;
template<> FieldType FieldDatedDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldDatedDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldInterestAccrualDate::enumItems = nullptr;
template<> FieldType FieldInterestAccrualDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldInterestAccrualDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldCPProgram::enumItems = nullptr;
template<> FieldType FieldCPProgram::getType() { return FieldType::INT; }
template<> const std::string & FieldCPProgram::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCPRegType::enumItems = nullptr;
template<> FieldType FieldCPRegType::getType() { return FieldType::STRING; }
template<> const std::string & FieldCPRegType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCPProgram::enumItems = nullptr;
template<> FieldType FieldUnderlyingCPProgram::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingCPProgram::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCPRegType::enumItems = nullptr;
template<> FieldType FieldUnderlyingCPRegType::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingCPRegType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingQty::enumItems = nullptr;
template<> FieldType FieldUnderlyingQty::getType() { return FieldType::QTY; }
template<> const std::string & FieldUnderlyingQty::getTypeName() { static const std::string fixType{ "QTY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdMatchID::enumItems = nullptr;
template<> FieldType FieldTrdMatchID::getType() { return FieldType::STRING; }
template<> const std::string & FieldTrdMatchID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldSecondaryTradeReportRefID::enumItems = nullptr;
template<> FieldType FieldSecondaryTradeReportRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldSecondaryTradeReportRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingDirtyPrice::enumItems = nullptr;
template<> FieldType FieldUnderlyingDirtyPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingDirtyPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingEndPrice::enumItems = nullptr;
template<> FieldType FieldUnderlyingEndPrice::getType() { return FieldType::PRICE; }
template<> const std::string & FieldUnderlyingEndPrice::getTypeName() { static const std::string fixType{ "PRICE" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStartValue::enumItems = nullptr;
template<> FieldType FieldUnderlyingStartValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldUnderlyingStartValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingCurrentValue::enumItems = nullptr;
template<> FieldType FieldUnderlyingCurrentValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldUnderlyingCurrentValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingEndValue::enumItems = nullptr;
template<> FieldType FieldUnderlyingEndValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldUnderlyingEndValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoUnderlyingStips::enumItems = nullptr;
template<> FieldType FieldNoUnderlyingStips::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoUnderlyingStips::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStipType::enumItems = nullptr;
template<> FieldType FieldUnderlyingStipType::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingStipType::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStipValue::enumItems = nullptr;
template<> FieldType FieldUnderlyingStipValue::getType() { return FieldType::STRING; }
template<> const std::string & FieldUnderlyingStipValue::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldMaturityNetMoney::enumItems = nullptr;
template<> FieldType FieldMaturityNetMoney::getType() { return FieldType::AMT; }
template<> const std::string & FieldMaturityNetMoney::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldMiscFeeBasis::enumItems = nullptr;
template<> FieldType FieldMiscFeeBasis::getType() { return FieldType::INT; }
template<> const std::string & FieldMiscFeeBasis::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNoAllocs::enumItems = nullptr;
template<> FieldType FieldTotNoAllocs::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNoAllocs::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastFragment::enumItems = nullptr;
template<> FieldType FieldLastFragment::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldLastFragment::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollReqID::enumItems = nullptr;
template<> FieldType FieldCollReqID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollReqID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnReason::enumItems = nullptr;
template<> FieldType FieldCollAsgnReason::getType() { return FieldType::INT; }
template<> const std::string & FieldCollAsgnReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollInquiryQualifier::enumItems = nullptr;
template<> FieldType FieldCollInquiryQualifier::getType() { return FieldType::INT; }
template<> const std::string & FieldCollInquiryQualifier::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoTrades::enumItems = nullptr;
template<> FieldType FieldNoTrades::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoTrades::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldMarginRatio::enumItems = nullptr;
template<> FieldType FieldMarginRatio::getType() { return FieldType::PERCENTAGE; }
template<> const std::string & FieldMarginRatio::getTypeName() { static const std::string fixType{ "PERCENTAGE" }; return fixType; }
template<> const FieldEnumBase * const * FieldMarginExcess::enumItems = nullptr;
template<> FieldType FieldMarginExcess::getType() { return FieldType::AMT; }
template<> const std::string & FieldMarginExcess::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotalNetValue::enumItems = nullptr;
template<> FieldType FieldTotalNetValue::getType() { return FieldType::AMT; }
template<> const std::string & FieldTotalNetValue::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCashOutstanding::enumItems = nullptr;
template<> FieldType FieldCashOutstanding::getType() { return FieldType::AMT; }
template<> const std::string & FieldCashOutstanding::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnID::enumItems = nullptr;
template<> FieldType FieldCollAsgnID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollAsgnID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnTransType::enumItems = nullptr;
template<> FieldType FieldCollAsgnTransType::getType() { return FieldType::INT; }
template<> const std::string & FieldCollAsgnTransType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollRespID::enumItems = nullptr;
template<> FieldType FieldCollRespID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollRespID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnRespType::enumItems = nullptr;
template<> FieldType FieldCollAsgnRespType::getType() { return FieldType::INT; }
template<> const std::string & FieldCollAsgnRespType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnRejectReason::enumItems = nullptr;
template<> FieldType FieldCollAsgnRejectReason::getType() { return FieldType::INT; }
template<> const std::string & FieldCollAsgnRejectReason::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAsgnRefID::enumItems = nullptr;
template<> FieldType FieldCollAsgnRefID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollAsgnRefID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollRptID::enumItems = nullptr;
template<> FieldType FieldCollRptID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollRptID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollInquiryID::enumItems = nullptr;
template<> FieldType FieldCollInquiryID::getType() { return FieldType::STRING; }
template<> const std::string & FieldCollInquiryID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollStatus::enumItems = nullptr;
template<> FieldType FieldCollStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldCollStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldTotNumReports::enumItems = nullptr;
template<> FieldType FieldTotNumReports::getType() { return FieldType::INT; }
template<> const std::string & FieldTotNumReports::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastRptRequested::enumItems = nullptr;
template<> FieldType FieldLastRptRequested::getType() { return FieldType::BOOLEAN; }
template<> const std::string & FieldLastRptRequested::getTypeName() { static const std::string fixType{ "BOOLEAN" }; return fixType; }
template<> const FieldEnumBase * const * FieldAgreementDesc::enumItems = nullptr;
template<> FieldType FieldAgreementDesc::getType() { return FieldType::STRING; }
template<> const std::string & FieldAgreementDesc::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAgreementID::enumItems = nullptr;
template<> FieldType FieldAgreementID::getType() { return FieldType::STRING; }
template<> const std::string & FieldAgreementID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldAgreementDate::enumItems = nullptr;
template<> FieldType FieldAgreementDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldAgreementDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldStartDate::enumItems = nullptr;
template<> FieldType FieldStartDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldStartDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldEndDate::enumItems = nullptr;
template<> FieldType FieldEndDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldEndDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }
template<> const FieldEnumBase * const * FieldAgreementCurrency::enumItems = nullptr;
template<> FieldType FieldAgreementCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldAgreementCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldDeliveryType::enumItems = nullptr;
template<> FieldType FieldDeliveryType::getType() { return FieldType::INT; }
template<> const std::string & FieldDeliveryType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldEndAccruedInterestAmt::enumItems = nullptr;
template<> FieldType FieldEndAccruedInterestAmt::getType() { return FieldType::AMT; }
template<> const std::string & FieldEndAccruedInterestAmt::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStartCash::enumItems = nullptr;
template<> FieldType FieldStartCash::getType() { return FieldType::AMT; }
template<> const std::string & FieldStartCash::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldEndCash::enumItems = nullptr;
template<> FieldType FieldEndCash::getType() { return FieldType::AMT; }
template<> const std::string & FieldEndCash::getTypeName() { static const std::string fixType{ "AMT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUserRequestID::enumItems = nullptr;
template<> FieldType FieldUserRequestID::getType() { return FieldType::STRING; }
template<> const std::string & FieldUserRequestID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUserRequestType::enumItems = nullptr;
template<> FieldType FieldUserRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldUserRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNewPassword::enumItems = nullptr;
template<> FieldType FieldNewPassword::getType() { return FieldType::STRING; }
template<> const std::string & FieldNewPassword::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldUserStatus::enumItems = nullptr;
template<> FieldType FieldUserStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldUserStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUserStatusText::enumItems = nullptr;
template<> FieldType FieldUserStatusText::getType() { return FieldType::STRING; }
template<> const std::string & FieldUserStatusText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldStatusValue::enumItems = nullptr;
template<> FieldType FieldStatusValue::getType() { return FieldType::INT; }
template<> const std::string & FieldStatusValue::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStatusText::enumItems = nullptr;
template<> FieldType FieldStatusText::getType() { return FieldType::STRING; }
template<> const std::string & FieldStatusText::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefCompID::enumItems = nullptr;
template<> FieldType FieldRefCompID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRefCompID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldRefSubID::enumItems = nullptr;
template<> FieldType FieldRefSubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldRefSubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetworkResponseID::enumItems = nullptr;
template<> FieldType FieldNetworkResponseID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNetworkResponseID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetworkRequestID::enumItems = nullptr;
template<> FieldType FieldNetworkRequestID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNetworkRequestID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldLastNetworkResponseID::enumItems = nullptr;
template<> FieldType FieldLastNetworkResponseID::getType() { return FieldType::STRING; }
template<> const std::string & FieldLastNetworkResponseID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetworkRequestType::enumItems = nullptr;
template<> FieldType FieldNetworkRequestType::getType() { return FieldType::INT; }
template<> const std::string & FieldNetworkRequestType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoCompIDs::enumItems = nullptr;
template<> FieldType FieldNoCompIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoCompIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNetworkStatusResponseType::enumItems = nullptr;
template<> FieldType FieldNetworkStatusResponseType::getType() { return FieldType::INT; }
template<> const std::string & FieldNetworkStatusResponseType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoCollInquiryQualifier::enumItems = nullptr;
template<> FieldType FieldNoCollInquiryQualifier::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoCollInquiryQualifier::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldTrdRptStatus::enumItems = nullptr;
template<> FieldType FieldTrdRptStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldTrdRptStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldAffirmStatus::enumItems = nullptr;
template<> FieldType FieldAffirmStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldAffirmStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldUnderlyingStrikeCurrency::enumItems = nullptr;
template<> FieldType FieldUnderlyingStrikeCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldUnderlyingStrikeCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegStrikeCurrency::enumItems = nullptr;
template<> FieldType FieldLegStrikeCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldLegStrikeCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldTimeBracket::enumItems = nullptr;
template<> FieldType FieldTimeBracket::getType() { return FieldType::STRING; }
template<> const std::string & FieldTimeBracket::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollAction::enumItems = nullptr;
template<> FieldType FieldCollAction::getType() { return FieldType::INT; }
template<> const std::string & FieldCollAction::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollInquiryStatus::enumItems = nullptr;
template<> FieldType FieldCollInquiryStatus::getType() { return FieldType::INT; }
template<> const std::string & FieldCollInquiryStatus::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldCollInquiryResult::enumItems = nullptr;
template<> FieldType FieldCollInquiryResult::getType() { return FieldType::INT; }
template<> const std::string & FieldCollInquiryResult::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldStrikeCurrency::enumItems = nullptr;
template<> FieldType FieldStrikeCurrency::getType() { return FieldType::CURRENCY; }
template<> const std::string & FieldStrikeCurrency::getTypeName() { static const std::string fixType{ "CURRENCY" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNested3PartyIDs::enumItems = nullptr;
template<> FieldType FieldNoNested3PartyIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNested3PartyIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested3PartyID::enumItems = nullptr;
template<> FieldType FieldNested3PartyID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNested3PartyID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested3PartyIDSource::enumItems = nullptr;
template<> FieldType FieldNested3PartyIDSource::getType() { return FieldType::CHAR; }
template<> const std::string & FieldNested3PartyIDSource::getTypeName() { static const std::string fixType{ "CHAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested3PartyRole::enumItems = nullptr;
template<> FieldType FieldNested3PartyRole::getType() { return FieldType::INT; }
template<> const std::string & FieldNested3PartyRole::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldNoNested3PartySubIDs::enumItems = nullptr;
template<> FieldType FieldNoNested3PartySubIDs::getType() { return FieldType::NUMINGROUP; }
template<> const std::string & FieldNoNested3PartySubIDs::getTypeName() { static const std::string fixType{ "NUMINGROUP" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested3PartySubID::enumItems = nullptr;
template<> FieldType FieldNested3PartySubID::getType() { return FieldType::STRING; }
template<> const std::string & FieldNested3PartySubID::getTypeName() { static const std::string fixType{ "STRING" }; return fixType; }
template<> const FieldEnumBase * const * FieldNested3PartySubIDType::enumItems = nullptr;
template<> FieldType FieldNested3PartySubIDType::getType() { return FieldType::INT; }
template<> const std::string & FieldNested3PartySubIDType::getTypeName() { static const std::string fixType{ "INT" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegContractSettlMonth::enumItems = nullptr;
template<> FieldType FieldLegContractSettlMonth::getType() { return FieldType::MONTHYEAR; }
template<> const std::string & FieldLegContractSettlMonth::getTypeName() { static const std::string fixType{ "MONTHYEAR" }; return fixType; }
template<> const FieldEnumBase * const * FieldLegInterestAccrualDate::enumItems = nullptr;
template<> FieldType FieldLegInterestAccrualDate::getType() { return FieldType::LOCALMKTDATE; }
template<> const std::string & FieldLegInterestAccrualDate::getTypeName() { static const std::string fixType{ "LOCALMKTDATE" }; return fixType; }

const char * AdvSideEnums::getFieldName() const { return FixAdvSide; }
const FieldEnumBase * AdvSideEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AdvSideEnums::ValueType * AdvSideEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AdvSideEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AdvSideEnums::getEnumMapByRaw() const { return AdvSideEnums::itemByRaw; }
const FieldEnumBase ** AdvSideEnums::getEnums() const { return items; }
const AdvSideEnums AdvSideEnums::instance;
const FieldEnumBase * AdvSideEnums::items[] = {
& AdvSideEnums::BUY,
& AdvSideEnums::SELL,
& AdvSideEnums::CROSS,
& AdvSideEnums::TRADE,
nullptr };

const char * AdvTransTypeEnums::getFieldName() const { return FixAdvTransType; }
const FieldEnumBase * AdvTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AdvTransTypeEnums::ValueType * AdvTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AdvTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AdvTransTypeEnums::getEnumMapByRaw() const { return AdvTransTypeEnums::itemByRaw; }
const FieldEnumBase ** AdvTransTypeEnums::getEnums() const { return items; }
const AdvTransTypeEnums AdvTransTypeEnums::instance;
const FieldEnumBase * AdvTransTypeEnums::items[] = {
& AdvTransTypeEnums::NEW,
& AdvTransTypeEnums::CANCEL,
& AdvTransTypeEnums::REPLACE,
nullptr };

const char * CommTypeEnums::getFieldName() const { return FixCommType; }
const FieldEnumBase * CommTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CommTypeEnums::ValueType * CommTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CommTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CommTypeEnums::getEnumMapByRaw() const { return CommTypeEnums::itemByRaw; }
const FieldEnumBase ** CommTypeEnums::getEnums() const { return items; }
const CommTypeEnums CommTypeEnums::instance;
const FieldEnumBase * CommTypeEnums::items[] = {
& CommTypeEnums::PER_UNIT,
& CommTypeEnums::PERCENTAGE,
& CommTypeEnums::ABSOLUTE,
& CommTypeEnums::_4,
& CommTypeEnums::_5,
& CommTypeEnums::POINTS_PER_BOND_OR_CONTRACT_SUPPLY_CONTRACTMULTIPLIER,
nullptr };

const char * ExecInstEnums::getFieldName() const { return FixExecInst; }
const FieldEnumBase * ExecInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExecInstEnums::ValueType * ExecInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExecInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExecInstEnums::getEnumMapByRaw() const { return ExecInstEnums::itemByRaw; }
const FieldEnumBase ** ExecInstEnums::getEnums() const { return items; }
const ExecInstEnums ExecInstEnums::instance;
const FieldEnumBase * ExecInstEnums::items[] = {
& ExecInstEnums::NOT_HELD,
& ExecInstEnums::WORK,
& ExecInstEnums::GO_ALONG,
& ExecInstEnums::OVER_THE_DAY,
& ExecInstEnums::HELD,
& ExecInstEnums::PARTICIPATE_DONT_INITIATE,
& ExecInstEnums::STRICT_SCALE,
& ExecInstEnums::TRY_TO_SCALE,
& ExecInstEnums::STAY_ON_BIDSIDE,
& ExecInstEnums::STAY_ON_OFFERSIDE,
& ExecInstEnums::NO_CROSS,
& ExecInstEnums::OK_TO_CROSS,
& ExecInstEnums::CALL_FIRST,
& ExecInstEnums::PERCENT_OF_VOLUME,
& ExecInstEnums::DO_NOT_INCREASE,
& ExecInstEnums::DO_NOT_REDUCE,
& ExecInstEnums::ALL_OR_NONE,
& ExecInstEnums::REINSTATE_ON_SYSTEM_FAILURE,
& ExecInstEnums::INSTITUTIONS_ONLY,
& ExecInstEnums::REINSTATE_ON_TRADING_HALT,
& ExecInstEnums::CANCEL_ON_TRADING_HALT,
& ExecInstEnums::LAST_PEG,
& ExecInstEnums::MID_PRICE_PEG,
& ExecInstEnums::NON_NEGOTIABLE,
& ExecInstEnums::OPENING_PEG,
& ExecInstEnums::MARKET_PEG,
& ExecInstEnums::CANCEL_ON_SYSTEM_FAILURE,
& ExecInstEnums::PRIMARY_PEG,
& ExecInstEnums::SUSPEND,
& ExecInstEnums::CUSTOMER_DISPLAY_INSTRUCTION,
& ExecInstEnums::NETTING,
& ExecInstEnums::PEG_TO_VWAP,
& ExecInstEnums::TRADE_ALONG,
& ExecInstEnums::TRY_TO_STOP,
& ExecInstEnums::CANCEL_IF_NOT_BEST,
& ExecInstEnums::TRAILING_STOP_PEG,
& ExecInstEnums::STRICT_LIMIT,
& ExecInstEnums::IGNORE_PRICE_VALIDITY_CHECKS,
& ExecInstEnums::PEG_TO_LIMIT_PRICE,
& ExecInstEnums::WORK_TO_TARGET_STRATEGY,
nullptr };

const char * HandlInstEnums::getFieldName() const { return FixHandlInst; }
const FieldEnumBase * HandlInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const HandlInstEnums::ValueType * HandlInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * HandlInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & HandlInstEnums::getEnumMapByRaw() const { return HandlInstEnums::itemByRaw; }
const FieldEnumBase ** HandlInstEnums::getEnums() const { return items; }
const HandlInstEnums HandlInstEnums::instance;
const FieldEnumBase * HandlInstEnums::items[] = {
& HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION,
& HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PUBLIC_BROKER_INTERVENTION_OK,
& HandlInstEnums::MANUAL_ORDER_BEST_EXECUTION,
nullptr };

const char * SecurityIDSourceEnums::getFieldName() const { return FixSecurityIDSource; }
const FieldEnumBase * SecurityIDSourceEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityIDSourceEnums::ValueType * SecurityIDSourceEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityIDSourceEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityIDSourceEnums::getEnumMapByRaw() const { return SecurityIDSourceEnums::itemByRaw; }
const FieldEnumBase ** SecurityIDSourceEnums::getEnums() const { return items; }
const SecurityIDSourceEnums SecurityIDSourceEnums::instance;
const FieldEnumBase * SecurityIDSourceEnums::items[] = {
& SecurityIDSourceEnums::CUSIP,
& SecurityIDSourceEnums::SEDOL,
& SecurityIDSourceEnums::QUIK,
& SecurityIDSourceEnums::ISIN_NUMBER,
& SecurityIDSourceEnums::RIC_CODE,
& SecurityIDSourceEnums::ISO_CURRENCY_CODE,
& SecurityIDSourceEnums::ISO_COUNTRY_CODE,
& SecurityIDSourceEnums::EXCHANGE_SYMBOL,
& SecurityIDSourceEnums::CONSOLIDATED_TAPE_ASSOCIATION,
& SecurityIDSourceEnums::BLOOMBERG_SYMBOL,
& SecurityIDSourceEnums::WERTPAPIER,
& SecurityIDSourceEnums::DUTCH,
& SecurityIDSourceEnums::VALOREN,
& SecurityIDSourceEnums::SICOVAM,
& SecurityIDSourceEnums::BELGIAN,
& SecurityIDSourceEnums::COMMON,
& SecurityIDSourceEnums::CLEARING_HOUSE,
& SecurityIDSourceEnums::ISDA_FPML_PRODUCT_SPECIFICATION,
& SecurityIDSourceEnums::OPTIONS_PRICE_REPORTING_AUTHORITY,
nullptr };

const char * IOIQltyIndEnums::getFieldName() const { return FixIOIQltyInd; }
const FieldEnumBase * IOIQltyIndEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IOIQltyIndEnums::ValueType * IOIQltyIndEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IOIQltyIndEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IOIQltyIndEnums::getEnumMapByRaw() const { return IOIQltyIndEnums::itemByRaw; }
const FieldEnumBase ** IOIQltyIndEnums::getEnums() const { return items; }
const IOIQltyIndEnums IOIQltyIndEnums::instance;
const FieldEnumBase * IOIQltyIndEnums::items[] = {
& IOIQltyIndEnums::LOW,
& IOIQltyIndEnums::MEDIUM,
& IOIQltyIndEnums::HIGH,
nullptr };

const char * IOIQtyEnums::getFieldName() const { return FixIOIQty; }
const FieldEnumBase * IOIQtyEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IOIQtyEnums::ValueType * IOIQtyEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IOIQtyEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IOIQtyEnums::getEnumMapByRaw() const { return IOIQtyEnums::itemByRaw; }
const FieldEnumBase ** IOIQtyEnums::getEnums() const { return items; }
const IOIQtyEnums IOIQtyEnums::instance;
const FieldEnumBase * IOIQtyEnums::items[] = {
& IOIQtyEnums::SMALL,
& IOIQtyEnums::MEDIUM,
& IOIQtyEnums::LARGE,
nullptr };

const char * IOITransTypeEnums::getFieldName() const { return FixIOITransType; }
const FieldEnumBase * IOITransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IOITransTypeEnums::ValueType * IOITransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IOITransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IOITransTypeEnums::getEnumMapByRaw() const { return IOITransTypeEnums::itemByRaw; }
const FieldEnumBase ** IOITransTypeEnums::getEnums() const { return items; }
const IOITransTypeEnums IOITransTypeEnums::instance;
const FieldEnumBase * IOITransTypeEnums::items[] = {
& IOITransTypeEnums::NEW,
& IOITransTypeEnums::CANCEL,
& IOITransTypeEnums::REPLACE,
nullptr };

const char * LastCapacityEnums::getFieldName() const { return FixLastCapacity; }
const FieldEnumBase * LastCapacityEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LastCapacityEnums::ValueType * LastCapacityEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LastCapacityEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LastCapacityEnums::getEnumMapByRaw() const { return LastCapacityEnums::itemByRaw; }
const FieldEnumBase ** LastCapacityEnums::getEnums() const { return items; }
const LastCapacityEnums LastCapacityEnums::instance;
const FieldEnumBase * LastCapacityEnums::items[] = {
& LastCapacityEnums::AGENT,
& LastCapacityEnums::CROSS_AS_AGENT,
& LastCapacityEnums::CROSS_AS_PRINCIPAL,
& LastCapacityEnums::PRINCIPAL,
nullptr };

const char * MsgTypeEnums::getFieldName() const { return FixMsgType; }
const FieldEnumBase * MsgTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MsgTypeEnums::ValueType * MsgTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MsgTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MsgTypeEnums::getEnumMapByRaw() const { return MsgTypeEnums::itemByRaw; }
const FieldEnumBase ** MsgTypeEnums::getEnums() const { return items; }
const MsgTypeEnums MsgTypeEnums::instance;
const FieldEnumBase * MsgTypeEnums::items[] = {
& MsgTypeEnums::HEARTBEAT,
& MsgTypeEnums::TEST_REQUEST,
& MsgTypeEnums::RESEND_REQUEST,
& MsgTypeEnums::REJECT,
& MsgTypeEnums::SEQUENCE_RESET,
& MsgTypeEnums::LOGOUT,
& MsgTypeEnums::INDICATION_OF_INTEREST,
& MsgTypeEnums::ADVERTISEMENT,
& MsgTypeEnums::EXECUTION_REPORT,
& MsgTypeEnums::ORDER_CANCEL_REJECT,
& MsgTypeEnums::LOGON,
& MsgTypeEnums::NEWS,
& MsgTypeEnums::EMAIL,
& MsgTypeEnums::ORDER_SINGLE,
& MsgTypeEnums::ORDER_LIST,
& MsgTypeEnums::ORDER_CANCEL_REQUEST,
& MsgTypeEnums::ORDER_CANCEL_REPLACE_REQUEST,
& MsgTypeEnums::ORDER_STATUS_REQUEST,
& MsgTypeEnums::ALLOCATION_INSTRUCTION,
& MsgTypeEnums::LIST_CANCEL_REQUEST,
& MsgTypeEnums::LIST_EXECUTE,
& MsgTypeEnums::LIST_STATUS_REQUEST,
& MsgTypeEnums::LIST_STATUS,
& MsgTypeEnums::ALLOCATION_INSTRUCTION_ACK,
& MsgTypeEnums::DONT_KNOW_TRADE,
& MsgTypeEnums::QUOTE_REQUEST,
& MsgTypeEnums::QUOTE,
& MsgTypeEnums::SETTLEMENT_INSTRUCTIONS,
& MsgTypeEnums::MARKET_DATA_REQUEST,
& MsgTypeEnums::MARKET_DATA_SNAPSHOT_FULL_REFRESH,
& MsgTypeEnums::MARKET_DATA_INCREMENTAL_REFRESH,
& MsgTypeEnums::MARKET_DATA_REQUEST_REJECT,
& MsgTypeEnums::QUOTE_CANCEL,
& MsgTypeEnums::QUOTE_STATUS_REQUEST,
& MsgTypeEnums::MASS_QUOTE_ACKNOWLEDGEMENT,
& MsgTypeEnums::SECURITY_DEFINITION_REQUEST,
& MsgTypeEnums::SECURITY_DEFINITION,
& MsgTypeEnums::SECURITY_STATUS_REQUEST,
& MsgTypeEnums::SECURITY_STATUS,
& MsgTypeEnums::TRADING_SESSION_STATUS_REQUEST,
& MsgTypeEnums::TRADING_SESSION_STATUS,
& MsgTypeEnums::MASS_QUOTE,
& MsgTypeEnums::BUSINESS_MESSAGE_REJECT,
& MsgTypeEnums::BID_REQUEST,
& MsgTypeEnums::BID_RESPONSE,
& MsgTypeEnums::LIST_STRIKE_PRICE,
& MsgTypeEnums::XML_MESSAGE,
& MsgTypeEnums::REGISTRATION_INSTRUCTIONS,
& MsgTypeEnums::REGISTRATION_INSTRUCTIONS_RESPONSE,
& MsgTypeEnums::ORDER_MASS_CANCEL_REQUEST,
& MsgTypeEnums::ORDER_MASS_CANCEL_REPORT,
& MsgTypeEnums::NEW_ORDER_s,
& MsgTypeEnums::CROSS_ORDER_CANCEL_REPLACE_REQUEST,
& MsgTypeEnums::CROSS_ORDER_CANCEL_REQUEST,
& MsgTypeEnums::SECURITY_TYPE_REQUEST,
& MsgTypeEnums::SECURITY_TYPES,
& MsgTypeEnums::SECURITY_LIST_REQUEST,
& MsgTypeEnums::SECURITY_LIST,
& MsgTypeEnums::DERIVATIVE_SECURITY_LIST_REQUEST,
& MsgTypeEnums::DERIVATIVE_SECURITY_LIST,
& MsgTypeEnums::NEW_ORDER_AB,
& MsgTypeEnums::MULTILEG_ORDER_CANCEL_REPLACE,
& MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST,
& MsgTypeEnums::TRADE_CAPTURE_REPORT,
& MsgTypeEnums::ORDER_MASS_STATUS_REQUEST,
& MsgTypeEnums::QUOTE_REQUEST_REJECT,
& MsgTypeEnums::RFQ_REQUEST,
& MsgTypeEnums::QUOTE_STATUS_REPORT,
& MsgTypeEnums::QUOTE_RESPONSE,
& MsgTypeEnums::CONFIRMATION,
& MsgTypeEnums::POSITION_MAINTENANCE_REQUEST,
& MsgTypeEnums::POSITION_MAINTENANCE_REPORT,
& MsgTypeEnums::REQUEST_FOR_POSITIONS,
& MsgTypeEnums::REQUEST_FOR_POSITIONS_ACK,
& MsgTypeEnums::POSITION_REPORT,
& MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST_ACK,
& MsgTypeEnums::TRADE_CAPTURE_REPORT_ACK,
& MsgTypeEnums::ALLOCATION_REPORT,
& MsgTypeEnums::ALLOCATION_REPORT_ACK,
& MsgTypeEnums::CONFIRMATION_ACK,
& MsgTypeEnums::SETTLEMENT_INSTRUCTION_REQUEST,
& MsgTypeEnums::ASSIGNMENT_REPORT,
& MsgTypeEnums::COLLATERAL_REQUEST,
& MsgTypeEnums::COLLATERAL_ASSIGNMENT,
& MsgTypeEnums::COLLATERAL_RESPONSE,
& MsgTypeEnums::COLLATERAL_REPORT,
& MsgTypeEnums::COLLATERAL_INQUIRY,
& MsgTypeEnums::NETWORK_BC,
& MsgTypeEnums::NETWORK_BD,
& MsgTypeEnums::USER_REQUEST,
& MsgTypeEnums::USER_RESPONSE,
& MsgTypeEnums::COLLATERAL_INQUIRY_ACK,
& MsgTypeEnums::CONFIRMATION_REQUEST,
nullptr };

const char * OrdStatusEnums::getFieldName() const { return FixOrdStatus; }
const FieldEnumBase * OrdStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OrdStatusEnums::ValueType * OrdStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OrdStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OrdStatusEnums::getEnumMapByRaw() const { return OrdStatusEnums::itemByRaw; }
const FieldEnumBase ** OrdStatusEnums::getEnums() const { return items; }
const OrdStatusEnums OrdStatusEnums::instance;
const FieldEnumBase * OrdStatusEnums::items[] = {
& OrdStatusEnums::NEW,
& OrdStatusEnums::PARTIALLY_FILLED,
& OrdStatusEnums::FILLED,
& OrdStatusEnums::DONE_FOR_DAY,
& OrdStatusEnums::CANCELED,
& OrdStatusEnums::PENDING_CANCEL,
& OrdStatusEnums::STOPPED,
& OrdStatusEnums::REJECTED,
& OrdStatusEnums::SUSPENDED,
& OrdStatusEnums::PENDING_NEW,
& OrdStatusEnums::CALCULATED,
& OrdStatusEnums::EXPIRED,
& OrdStatusEnums::ACCEPTED_FOR_BIDDING,
& OrdStatusEnums::PENDING_REPLACE,
nullptr };

const char * OrdTypeEnums::getFieldName() const { return FixOrdType; }
const FieldEnumBase * OrdTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OrdTypeEnums::ValueType * OrdTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OrdTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OrdTypeEnums::getEnumMapByRaw() const { return OrdTypeEnums::itemByRaw; }
const FieldEnumBase ** OrdTypeEnums::getEnums() const { return items; }
const OrdTypeEnums OrdTypeEnums::instance;
const FieldEnumBase * OrdTypeEnums::items[] = {
& OrdTypeEnums::MARKET,
& OrdTypeEnums::LIMIT,
& OrdTypeEnums::STOP,
& OrdTypeEnums::STOP_LIMIT,
& OrdTypeEnums::WITH_OR_WITHOUT,
& OrdTypeEnums::LIMIT_OR_BETTER,
& OrdTypeEnums::LIMIT_WITH_OR_WITHOUT,
& OrdTypeEnums::ON_BASIS,
& OrdTypeEnums::PREVIOUSLY_QUOTED,
& OrdTypeEnums::PREVIOUSLY_INDICATED,
& OrdTypeEnums::FOREX,
& OrdTypeEnums::FUNARI,
& OrdTypeEnums::MARKET_IF_TOUCHED,
& OrdTypeEnums::MARKET_WITH_LEFTOVER_AS_LIMIT,
& OrdTypeEnums::PREVIOUS_FUND_VALUATION_POINT,
& OrdTypeEnums::NEXT_FUND_VALUATION_POINT,
& OrdTypeEnums::PEGGED,
nullptr };

const char * PossDupFlagEnums::getFieldName() const { return FixPossDupFlag; }
const FieldEnumBase * PossDupFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PossDupFlagEnums::ValueType * PossDupFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PossDupFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PossDupFlagEnums::getEnumMapByRaw() const { return PossDupFlagEnums::itemByRaw; }
const FieldEnumBase ** PossDupFlagEnums::getEnums() const { return items; }
const PossDupFlagEnums PossDupFlagEnums::instance;
const FieldEnumBase * PossDupFlagEnums::items[] = {
& PossDupFlagEnums::YES,
& PossDupFlagEnums::NO,
nullptr };

const char * SideEnums::getFieldName() const { return FixSide; }
const FieldEnumBase * SideEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SideEnums::ValueType * SideEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SideEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SideEnums::getEnumMapByRaw() const { return SideEnums::itemByRaw; }
const FieldEnumBase ** SideEnums::getEnums() const { return items; }
const SideEnums SideEnums::instance;
const FieldEnumBase * SideEnums::items[] = {
& SideEnums::BUY,
& SideEnums::SELL,
& SideEnums::BUY_MINUS,
& SideEnums::SELL_PLUS,
& SideEnums::SELL_SHORT,
& SideEnums::SELL_SHORT_EXEMPT,
& SideEnums::UNDISCLOSED,
& SideEnums::CROSS,
& SideEnums::CROSS_SHORT,
& SideEnums::CROSS_SHORT_EXEMPT,
& SideEnums::AS_DEFINED,
& SideEnums::OPPOSITE,
& SideEnums::SUBSCRIBE,
& SideEnums::REDEEM,
& SideEnums::LEND,
& SideEnums::BORROW,
nullptr };

const char * TimeInForceEnums::getFieldName() const { return FixTimeInForce; }
const FieldEnumBase * TimeInForceEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TimeInForceEnums::ValueType * TimeInForceEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TimeInForceEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TimeInForceEnums::getEnumMapByRaw() const { return TimeInForceEnums::itemByRaw; }
const FieldEnumBase ** TimeInForceEnums::getEnums() const { return items; }
const TimeInForceEnums TimeInForceEnums::instance;
const FieldEnumBase * TimeInForceEnums::items[] = {
& TimeInForceEnums::DAY,
& TimeInForceEnums::GOOD_TILL_CANCEL,
& TimeInForceEnums::AT_THE_OPENING,
& TimeInForceEnums::IMMEDIATE_OR_CANCEL,
& TimeInForceEnums::FILL_OR_KILL,
& TimeInForceEnums::GOOD_TILL_CROSSING,
& TimeInForceEnums::GOOD_TILL_DATE,
& TimeInForceEnums::AT_THE_CLOSE,
nullptr };

const char * UrgencyEnums::getFieldName() const { return FixUrgency; }
const FieldEnumBase * UrgencyEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const UrgencyEnums::ValueType * UrgencyEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * UrgencyEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & UrgencyEnums::getEnumMapByRaw() const { return UrgencyEnums::itemByRaw; }
const FieldEnumBase ** UrgencyEnums::getEnums() const { return items; }
const UrgencyEnums UrgencyEnums::instance;
const FieldEnumBase * UrgencyEnums::items[] = {
& UrgencyEnums::NORMAL,
& UrgencyEnums::FLASH,
& UrgencyEnums::BACKGROUND,
nullptr };

const char * SettlTypeEnums::getFieldName() const { return FixSettlType; }
const FieldEnumBase * SettlTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlTypeEnums::ValueType * SettlTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlTypeEnums::getEnumMapByRaw() const { return SettlTypeEnums::itemByRaw; }
const FieldEnumBase ** SettlTypeEnums::getEnums() const { return items; }
const SettlTypeEnums SettlTypeEnums::instance;
const FieldEnumBase * SettlTypeEnums::items[] = {
& SettlTypeEnums::REGULAR,
& SettlTypeEnums::CASH,
& SettlTypeEnums::NEXT_DAY,
& SettlTypeEnums::T_PLUS_2,
& SettlTypeEnums::T_PLUS_3,
& SettlTypeEnums::T_PLUS_4,
& SettlTypeEnums::FUTURE,
& SettlTypeEnums::WHEN_AND_IF_ISSUED,
& SettlTypeEnums::SELLERS_OPTION,
& SettlTypeEnums::T_PLUS_5,
nullptr };

const char * AllocTransTypeEnums::getFieldName() const { return FixAllocTransType; }
const FieldEnumBase * AllocTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocTransTypeEnums::ValueType * AllocTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocTransTypeEnums::getEnumMapByRaw() const { return AllocTransTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocTransTypeEnums::getEnums() const { return items; }
const AllocTransTypeEnums AllocTransTypeEnums::instance;
const FieldEnumBase * AllocTransTypeEnums::items[] = {
& AllocTransTypeEnums::NEW,
& AllocTransTypeEnums::REPLACE,
& AllocTransTypeEnums::CANCEL,
nullptr };

const char * PositionEffectEnums::getFieldName() const { return FixPositionEffect; }
const FieldEnumBase * PositionEffectEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PositionEffectEnums::ValueType * PositionEffectEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PositionEffectEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PositionEffectEnums::getEnumMapByRaw() const { return PositionEffectEnums::itemByRaw; }
const FieldEnumBase ** PositionEffectEnums::getEnums() const { return items; }
const PositionEffectEnums PositionEffectEnums::instance;
const FieldEnumBase * PositionEffectEnums::items[] = {
& PositionEffectEnums::OPEN,
& PositionEffectEnums::CLOSE,
& PositionEffectEnums::ROLLED,
& PositionEffectEnums::FIFO,
nullptr };

const char * ProcessCodeEnums::getFieldName() const { return FixProcessCode; }
const FieldEnumBase * ProcessCodeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ProcessCodeEnums::ValueType * ProcessCodeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ProcessCodeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ProcessCodeEnums::getEnumMapByRaw() const { return ProcessCodeEnums::itemByRaw; }
const FieldEnumBase ** ProcessCodeEnums::getEnums() const { return items; }
const ProcessCodeEnums ProcessCodeEnums::instance;
const FieldEnumBase * ProcessCodeEnums::items[] = {
& ProcessCodeEnums::REGULAR,
& ProcessCodeEnums::SOFT_DOLLAR,
& ProcessCodeEnums::STEP_IN,
& ProcessCodeEnums::STEP_OUT,
& ProcessCodeEnums::SOFT_DOLLAR_STEP_IN,
& ProcessCodeEnums::SOFT_DOLLAR_STEP_OUT,
& ProcessCodeEnums::PLAN_SPONSOR,
nullptr };

const char * AllocStatusEnums::getFieldName() const { return FixAllocStatus; }
const FieldEnumBase * AllocStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocStatusEnums::ValueType * AllocStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocStatusEnums::getEnumMapByRaw() const { return AllocStatusEnums::itemByRaw; }
const FieldEnumBase ** AllocStatusEnums::getEnums() const { return items; }
const AllocStatusEnums AllocStatusEnums::instance;
const FieldEnumBase * AllocStatusEnums::items[] = {
& AllocStatusEnums::ACCEPTED,
& AllocStatusEnums::BLOCK_LEVEL_REJECT,
& AllocStatusEnums::ACCOUNT_LEVEL_REJECT,
& AllocStatusEnums::RECEIVED,
& AllocStatusEnums::INCOMPLETE,
& AllocStatusEnums::REJECTED_BY_INTERMEDIARY,
nullptr };

const char * AllocRejCodeEnums::getFieldName() const { return FixAllocRejCode; }
const FieldEnumBase * AllocRejCodeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocRejCodeEnums::ValueType * AllocRejCodeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocRejCodeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocRejCodeEnums::getEnumMapByRaw() const { return AllocRejCodeEnums::itemByRaw; }
const FieldEnumBase ** AllocRejCodeEnums::getEnums() const { return items; }
const AllocRejCodeEnums AllocRejCodeEnums::instance;
const FieldEnumBase * AllocRejCodeEnums::items[] = {
& AllocRejCodeEnums::UNKNOWN_ACCOUNT,
& AllocRejCodeEnums::INCORRECT_QUANTITY,
& AllocRejCodeEnums::INCORRECT_AVERAGE_PRICE,
& AllocRejCodeEnums::UNKNOWN_EXECUTING_BROKER_MNEMONIC,
& AllocRejCodeEnums::COMMISSION_DIFFERENCE,
& AllocRejCodeEnums::UNKNOWN_ORDERID,
& AllocRejCodeEnums::UNKNOWN_LISTID,
& AllocRejCodeEnums::OTHER,
& AllocRejCodeEnums::INCORRECT_ALLOCATED_QUANTITY,
& AllocRejCodeEnums::CALCULATION_DIFFERENCE,
& AllocRejCodeEnums::UNKNOWN_OR_STALE_EXECID,
& AllocRejCodeEnums::MISMATCHED_DATA_VALUE,
& AllocRejCodeEnums::UNKNOWN_CLORDID,
& AllocRejCodeEnums::WAREHOUSE_REQUEST_REJECTED,
nullptr };

const char * EmailTypeEnums::getFieldName() const { return FixEmailType; }
const FieldEnumBase * EmailTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const EmailTypeEnums::ValueType * EmailTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * EmailTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & EmailTypeEnums::getEnumMapByRaw() const { return EmailTypeEnums::itemByRaw; }
const FieldEnumBase ** EmailTypeEnums::getEnums() const { return items; }
const EmailTypeEnums EmailTypeEnums::instance;
const FieldEnumBase * EmailTypeEnums::items[] = {
& EmailTypeEnums::NEW,
& EmailTypeEnums::REPLY,
& EmailTypeEnums::ADMIN_REPLY,
nullptr };

const char * PossResendEnums::getFieldName() const { return FixPossResend; }
const FieldEnumBase * PossResendEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PossResendEnums::ValueType * PossResendEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PossResendEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PossResendEnums::getEnumMapByRaw() const { return PossResendEnums::itemByRaw; }
const FieldEnumBase ** PossResendEnums::getEnums() const { return items; }
const PossResendEnums PossResendEnums::instance;
const FieldEnumBase * PossResendEnums::items[] = {
& PossResendEnums::YES,
& PossResendEnums::NO,
nullptr };

const char * EncryptMethodEnums::getFieldName() const { return FixEncryptMethod; }
const FieldEnumBase * EncryptMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const EncryptMethodEnums::ValueType * EncryptMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * EncryptMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & EncryptMethodEnums::getEnumMapByRaw() const { return EncryptMethodEnums::itemByRaw; }
const FieldEnumBase ** EncryptMethodEnums::getEnums() const { return items; }
const EncryptMethodEnums EncryptMethodEnums::instance;
const FieldEnumBase * EncryptMethodEnums::items[] = {
& EncryptMethodEnums::NONE,
& EncryptMethodEnums::PKCS,
& EncryptMethodEnums::DES,
& EncryptMethodEnums::PKCS_DES,
& EncryptMethodEnums::PGP_DES,
& EncryptMethodEnums::PGP_DES_MD5,
& EncryptMethodEnums::PEM_DES_MD5,
nullptr };

const char * CxlRejReasonEnums::getFieldName() const { return FixCxlRejReason; }
const FieldEnumBase * CxlRejReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CxlRejReasonEnums::ValueType * CxlRejReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CxlRejReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CxlRejReasonEnums::getEnumMapByRaw() const { return CxlRejReasonEnums::itemByRaw; }
const FieldEnumBase ** CxlRejReasonEnums::getEnums() const { return items; }
const CxlRejReasonEnums CxlRejReasonEnums::instance;
const FieldEnumBase * CxlRejReasonEnums::items[] = {
& CxlRejReasonEnums::TOO_LATE_TO_CANCEL,
& CxlRejReasonEnums::UNKNOWN_ORDER,
& CxlRejReasonEnums::BROKER,
& CxlRejReasonEnums::ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS,
& CxlRejReasonEnums::UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST,
& CxlRejReasonEnums::ORIGORDMODTIME,
& CxlRejReasonEnums::DUPLICATE_CLORDID,
& CxlRejReasonEnums::OTHER,
nullptr };

const char * OrdRejReasonEnums::getFieldName() const { return FixOrdRejReason; }
const FieldEnumBase * OrdRejReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OrdRejReasonEnums::ValueType * OrdRejReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OrdRejReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OrdRejReasonEnums::getEnumMapByRaw() const { return OrdRejReasonEnums::itemByRaw; }
const FieldEnumBase ** OrdRejReasonEnums::getEnums() const { return items; }
const OrdRejReasonEnums OrdRejReasonEnums::instance;
const FieldEnumBase * OrdRejReasonEnums::items[] = {
& OrdRejReasonEnums::BROKER,
& OrdRejReasonEnums::UNKNOWN_SYMBOL,
& OrdRejReasonEnums::EXCHANGE_CLOSED,
& OrdRejReasonEnums::ORDER_EXCEEDS_LIMIT,
& OrdRejReasonEnums::TOO_LATE_TO_ENTER,
& OrdRejReasonEnums::UNKNOWN_ORDER,
& OrdRejReasonEnums::DUPLICATE_ORDER,
& OrdRejReasonEnums::DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER,
& OrdRejReasonEnums::STALE_ORDER,
& OrdRejReasonEnums::TRADE_ALONG_REQUIRED,
& OrdRejReasonEnums::INVALID_INVESTOR_ID,
& OrdRejReasonEnums::UNSUPPORTED_ORDER_CHARACTERISTIC12_SURVEILLENCE_OPTION,
& OrdRejReasonEnums::INCORRECT_QUANTITY,
& OrdRejReasonEnums::INCORRECT_ALLOCATED_QUANTITY,
& OrdRejReasonEnums::UNKNOWN_ACCOUNT,
& OrdRejReasonEnums::OTHER,
nullptr };

const char * IOIQualifierEnums::getFieldName() const { return FixIOIQualifier; }
const FieldEnumBase * IOIQualifierEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IOIQualifierEnums::ValueType * IOIQualifierEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IOIQualifierEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IOIQualifierEnums::getEnumMapByRaw() const { return IOIQualifierEnums::itemByRaw; }
const FieldEnumBase ** IOIQualifierEnums::getEnums() const { return items; }
const IOIQualifierEnums IOIQualifierEnums::instance;
const FieldEnumBase * IOIQualifierEnums::items[] = {
& IOIQualifierEnums::ALL_OR_NONE,
& IOIQualifierEnums::MARKET_ON_CLOSE,
& IOIQualifierEnums::AT_THE_CLOSE,
& IOIQualifierEnums::VWAP,
& IOIQualifierEnums::IN_TOUCH_WITH,
& IOIQualifierEnums::LIMIT,
& IOIQualifierEnums::MORE_BEHIND,
& IOIQualifierEnums::AT_THE_OPEN,
& IOIQualifierEnums::TAKING_A_POSITION,
& IOIQualifierEnums::AT_THE_MARKET,
& IOIQualifierEnums::READY_TO_TRADE,
& IOIQualifierEnums::PORTFOLIO_SHOWN,
& IOIQualifierEnums::THROUGH_THE_DAY,
& IOIQualifierEnums::VERSUS,
& IOIQualifierEnums::INDICATION,
& IOIQualifierEnums::CROSSING_OPPORTUNITY,
& IOIQualifierEnums::AT_THE_MIDPOINT,
& IOIQualifierEnums::PRE_OPEN,
nullptr };

const char * ReportToExchEnums::getFieldName() const { return FixReportToExch; }
const FieldEnumBase * ReportToExchEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ReportToExchEnums::ValueType * ReportToExchEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ReportToExchEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ReportToExchEnums::getEnumMapByRaw() const { return ReportToExchEnums::itemByRaw; }
const FieldEnumBase ** ReportToExchEnums::getEnums() const { return items; }
const ReportToExchEnums ReportToExchEnums::instance;
const FieldEnumBase * ReportToExchEnums::items[] = {
& ReportToExchEnums::YES,
& ReportToExchEnums::NO,
nullptr };

const char * LocateReqdEnums::getFieldName() const { return FixLocateReqd; }
const FieldEnumBase * LocateReqdEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LocateReqdEnums::ValueType * LocateReqdEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LocateReqdEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LocateReqdEnums::getEnumMapByRaw() const { return LocateReqdEnums::itemByRaw; }
const FieldEnumBase ** LocateReqdEnums::getEnums() const { return items; }
const LocateReqdEnums LocateReqdEnums::instance;
const FieldEnumBase * LocateReqdEnums::items[] = {
& LocateReqdEnums::YES,
& LocateReqdEnums::NO,
nullptr };

const char * ForexReqEnums::getFieldName() const { return FixForexReq; }
const FieldEnumBase * ForexReqEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ForexReqEnums::ValueType * ForexReqEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ForexReqEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ForexReqEnums::getEnumMapByRaw() const { return ForexReqEnums::itemByRaw; }
const FieldEnumBase ** ForexReqEnums::getEnums() const { return items; }
const ForexReqEnums ForexReqEnums::instance;
const FieldEnumBase * ForexReqEnums::items[] = {
& ForexReqEnums::YES,
& ForexReqEnums::NO,
nullptr };

const char * GapFillFlagEnums::getFieldName() const { return FixGapFillFlag; }
const FieldEnumBase * GapFillFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const GapFillFlagEnums::ValueType * GapFillFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * GapFillFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & GapFillFlagEnums::getEnumMapByRaw() const { return GapFillFlagEnums::itemByRaw; }
const FieldEnumBase ** GapFillFlagEnums::getEnums() const { return items; }
const GapFillFlagEnums GapFillFlagEnums::instance;
const FieldEnumBase * GapFillFlagEnums::items[] = {
& GapFillFlagEnums::YES,
& GapFillFlagEnums::NO,
nullptr };

const char * DKReasonEnums::getFieldName() const { return FixDKReason; }
const FieldEnumBase * DKReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DKReasonEnums::ValueType * DKReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DKReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DKReasonEnums::getEnumMapByRaw() const { return DKReasonEnums::itemByRaw; }
const FieldEnumBase ** DKReasonEnums::getEnums() const { return items; }
const DKReasonEnums DKReasonEnums::instance;
const FieldEnumBase * DKReasonEnums::items[] = {
& DKReasonEnums::UNKNOWN_SYMBOL,
& DKReasonEnums::WRONG_SIDE,
& DKReasonEnums::QUANTITY_EXCEEDS_ORDER,
& DKReasonEnums::NO_MATCHING_ORDER,
& DKReasonEnums::PRICE_EXCEEDS_LIMIT,
& DKReasonEnums::CALCULATION_DIFFERENCE,
& DKReasonEnums::OTHER,
nullptr };

const char * IOINaturalFlagEnums::getFieldName() const { return FixIOINaturalFlag; }
const FieldEnumBase * IOINaturalFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IOINaturalFlagEnums::ValueType * IOINaturalFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IOINaturalFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IOINaturalFlagEnums::getEnumMapByRaw() const { return IOINaturalFlagEnums::itemByRaw; }
const FieldEnumBase ** IOINaturalFlagEnums::getEnums() const { return items; }
const IOINaturalFlagEnums IOINaturalFlagEnums::instance;
const FieldEnumBase * IOINaturalFlagEnums::items[] = {
& IOINaturalFlagEnums::YES,
& IOINaturalFlagEnums::NO,
nullptr };

const char * MiscFeeTypeEnums::getFieldName() const { return FixMiscFeeType; }
const FieldEnumBase * MiscFeeTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MiscFeeTypeEnums::ValueType * MiscFeeTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MiscFeeTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MiscFeeTypeEnums::getEnumMapByRaw() const { return MiscFeeTypeEnums::itemByRaw; }
const FieldEnumBase ** MiscFeeTypeEnums::getEnums() const { return items; }
const MiscFeeTypeEnums MiscFeeTypeEnums::instance;
const FieldEnumBase * MiscFeeTypeEnums::items[] = {
& MiscFeeTypeEnums::REGULATORY,
& MiscFeeTypeEnums::TAX,
& MiscFeeTypeEnums::LOCAL_COMMISSION,
& MiscFeeTypeEnums::EXCHANGE_FEES,
& MiscFeeTypeEnums::STAMP,
& MiscFeeTypeEnums::LEVY,
& MiscFeeTypeEnums::OTHER,
& MiscFeeTypeEnums::MARKUP,
& MiscFeeTypeEnums::CONSUMPTION_TAX,
& MiscFeeTypeEnums::PER_TRANSACTION,
& MiscFeeTypeEnums::CONVERSION,
& MiscFeeTypeEnums::AGENT,
nullptr };

const char * ResetSeqNumFlagEnums::getFieldName() const { return FixResetSeqNumFlag; }
const FieldEnumBase * ResetSeqNumFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ResetSeqNumFlagEnums::ValueType * ResetSeqNumFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ResetSeqNumFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ResetSeqNumFlagEnums::getEnumMapByRaw() const { return ResetSeqNumFlagEnums::itemByRaw; }
const FieldEnumBase ** ResetSeqNumFlagEnums::getEnums() const { return items; }
const ResetSeqNumFlagEnums ResetSeqNumFlagEnums::instance;
const FieldEnumBase * ResetSeqNumFlagEnums::items[] = {
& ResetSeqNumFlagEnums::YES,
& ResetSeqNumFlagEnums::NO,
nullptr };

const char * ExecTypeEnums::getFieldName() const { return FixExecType; }
const FieldEnumBase * ExecTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExecTypeEnums::ValueType * ExecTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExecTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExecTypeEnums::getEnumMapByRaw() const { return ExecTypeEnums::itemByRaw; }
const FieldEnumBase ** ExecTypeEnums::getEnums() const { return items; }
const ExecTypeEnums ExecTypeEnums::instance;
const FieldEnumBase * ExecTypeEnums::items[] = {
& ExecTypeEnums::NEW,
& ExecTypeEnums::DONE_FOR_DAY,
& ExecTypeEnums::CANCELED,
& ExecTypeEnums::REPLACE,
& ExecTypeEnums::PENDING_CANCEL,
& ExecTypeEnums::STOPPED,
& ExecTypeEnums::REJECTED,
& ExecTypeEnums::SUSPENDED,
& ExecTypeEnums::PENDING_NEW,
& ExecTypeEnums::CALCULATED,
& ExecTypeEnums::EXPIRED,
& ExecTypeEnums::RESTATED,
& ExecTypeEnums::PENDING_REPLACE,
& ExecTypeEnums::TRADE,
& ExecTypeEnums::TRADE_CORRECT,
& ExecTypeEnums::TRADE_CANCEL,
& ExecTypeEnums::ORDER_STATUS,
nullptr };

const char * SettlCurrFxRateCalcEnums::getFieldName() const { return FixSettlCurrFxRateCalc; }
const FieldEnumBase * SettlCurrFxRateCalcEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlCurrFxRateCalcEnums::ValueType * SettlCurrFxRateCalcEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlCurrFxRateCalcEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlCurrFxRateCalcEnums::getEnumMapByRaw() const { return SettlCurrFxRateCalcEnums::itemByRaw; }
const FieldEnumBase ** SettlCurrFxRateCalcEnums::getEnums() const { return items; }
const SettlCurrFxRateCalcEnums SettlCurrFxRateCalcEnums::instance;
const FieldEnumBase * SettlCurrFxRateCalcEnums::items[] = {
& SettlCurrFxRateCalcEnums::MULTIPLY,
& SettlCurrFxRateCalcEnums::DIVIDE,
nullptr };

const char * SettlInstModeEnums::getFieldName() const { return FixSettlInstMode; }
const FieldEnumBase * SettlInstModeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlInstModeEnums::ValueType * SettlInstModeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlInstModeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlInstModeEnums::getEnumMapByRaw() const { return SettlInstModeEnums::itemByRaw; }
const FieldEnumBase ** SettlInstModeEnums::getEnums() const { return items; }
const SettlInstModeEnums SettlInstModeEnums::instance;
const FieldEnumBase * SettlInstModeEnums::items[] = {
& SettlInstModeEnums::STANDING_INSTRUCTIONS_PROVIDED,
& SettlInstModeEnums::SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT,
& SettlInstModeEnums::REQUEST_REJECT,
nullptr };

const char * SettlInstTransTypeEnums::getFieldName() const { return FixSettlInstTransType; }
const FieldEnumBase * SettlInstTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlInstTransTypeEnums::ValueType * SettlInstTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlInstTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlInstTransTypeEnums::getEnumMapByRaw() const { return SettlInstTransTypeEnums::itemByRaw; }
const FieldEnumBase ** SettlInstTransTypeEnums::getEnums() const { return items; }
const SettlInstTransTypeEnums SettlInstTransTypeEnums::instance;
const FieldEnumBase * SettlInstTransTypeEnums::items[] = {
& SettlInstTransTypeEnums::NEW,
& SettlInstTransTypeEnums::CANCEL,
& SettlInstTransTypeEnums::REPLACE,
& SettlInstTransTypeEnums::RESTATE,
nullptr };

const char * SettlInstSourceEnums::getFieldName() const { return FixSettlInstSource; }
const FieldEnumBase * SettlInstSourceEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlInstSourceEnums::ValueType * SettlInstSourceEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlInstSourceEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlInstSourceEnums::getEnumMapByRaw() const { return SettlInstSourceEnums::itemByRaw; }
const FieldEnumBase ** SettlInstSourceEnums::getEnums() const { return items; }
const SettlInstSourceEnums SettlInstSourceEnums::instance;
const FieldEnumBase * SettlInstSourceEnums::items[] = {
& SettlInstSourceEnums::BROKERS_INSTRUCTIONS,
& SettlInstSourceEnums::INSTITUTIONS_INSTRUCTIONS,
& SettlInstSourceEnums::INVESTOR,
nullptr };

const char * SecurityTypeEnums::getFieldName() const { return FixSecurityType; }
const FieldEnumBase * SecurityTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityTypeEnums::ValueType * SecurityTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityTypeEnums::getEnumMapByRaw() const { return SecurityTypeEnums::itemByRaw; }
const FieldEnumBase ** SecurityTypeEnums::getEnums() const { return items; }
const SecurityTypeEnums SecurityTypeEnums::instance;
const FieldEnumBase * SecurityTypeEnums::items[] = {
& SecurityTypeEnums::FUTURE,
& SecurityTypeEnums::OPTION,
& SecurityTypeEnums::EURO_SUPRANATIONAL_COUPONS,
& SecurityTypeEnums::FEDERAL_AGENCY_COUPON,
& SecurityTypeEnums::FEDERAL_AGENCY_DISCOUNT_NOTE,
& SecurityTypeEnums::PRIVATE_EXPORT_FUNDING,
& SecurityTypeEnums::USD_SUPRANATIONAL_COUPONS,
& SecurityTypeEnums::CORPORATE_BOND,
& SecurityTypeEnums::CORPORATE_PRIVATE_PLACEMENT,
& SecurityTypeEnums::CONVERTIBLE_BOND,
& SecurityTypeEnums::DUAL_CURRENCY,
& SecurityTypeEnums::EURO_CORPORATE_BOND,
& SecurityTypeEnums::INDEXED_LINKED,
& SecurityTypeEnums::STRUCTURED_NOTES,
& SecurityTypeEnums::YANKEE_CORPORATE_BOND,
& SecurityTypeEnums::FOREIGN_EXCHANGE_CONTRACT,
& SecurityTypeEnums::COMMON_STOCK,
& SecurityTypeEnums::PREFERRED_STOCK,
& SecurityTypeEnums::BRADY_BOND,
& SecurityTypeEnums::EURO_SOVEREIGNS,
& SecurityTypeEnums::US_TREASURY_BOND,
& SecurityTypeEnums::INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE,
& SecurityTypeEnums::TREASURY_INFLATION_PROTECTED_SECURITIES,
& SecurityTypeEnums::PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE,
& SecurityTypeEnums::PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE,
& SecurityTypeEnums::US_TREASURY_NOTE_UST,
& SecurityTypeEnums::US_TREASURY_BILL_USTB,
& SecurityTypeEnums::US_TREASURY_NOTE_TNOTE,
& SecurityTypeEnums::US_TREASURY_BILL_TBILL,
& SecurityTypeEnums::REPURCHASE,
& SecurityTypeEnums::FORWARD,
& SecurityTypeEnums::BUY_SELLBACK,
& SecurityTypeEnums::SECURITIES_LOAN,
& SecurityTypeEnums::SECURITIES_PLEDGE,
& SecurityTypeEnums::TERM_LOAN,
& SecurityTypeEnums::REVOLVER_LOAN,
& SecurityTypeEnums::REVOLVER_TERM_LOAN,
& SecurityTypeEnums::BRIDGE_LOAN,
& SecurityTypeEnums::LETTER_OF_CREDIT,
& SecurityTypeEnums::SWING_LINE_FACILITY,
& SecurityTypeEnums::DEBTOR_IN_POSSESSION,
& SecurityTypeEnums::DEFAULTED,
& SecurityTypeEnums::WITHDRAWN,
& SecurityTypeEnums::REPLACED,
& SecurityTypeEnums::MATURED,
& SecurityTypeEnums::AMENDED_RESTATED,
& SecurityTypeEnums::RETIRED,
& SecurityTypeEnums::BANKERS_ACCEPTANCE,
& SecurityTypeEnums::BANK_NOTES,
& SecurityTypeEnums::BILL_OF_EXCHANGES,
& SecurityTypeEnums::CERTIFICATE_OF_DEPOSIT,
& SecurityTypeEnums::CALL_LOANS,
& SecurityTypeEnums::COMMERCIAL_PAPER,
& SecurityTypeEnums::DEPOSIT_NOTES,
& SecurityTypeEnums::EURO_CERTIFICATE_OF_DEPOSIT,
& SecurityTypeEnums::EURO_COMMERCIAL_PAPER,
& SecurityTypeEnums::LIQUIDITY_NOTE,
& SecurityTypeEnums::MEDIUM_TERM_NOTES,
& SecurityTypeEnums::OVERNIGHT,
& SecurityTypeEnums::PROMISSORY_NOTE,
& SecurityTypeEnums::PLAZOS_FIJOS,
& SecurityTypeEnums::SHORT_TERM_LOAN_NOTE,
& SecurityTypeEnums::TIME_DEPOSIT,
& SecurityTypeEnums::EXTENDED_COMM_NOTE,
& SecurityTypeEnums::YANKEE_CERTIFICATE_OF_DEPOSIT,
& SecurityTypeEnums::ASSET_BACKED_SECURITIES,
& SecurityTypeEnums::CORP_MORTGAGE_BACKED_SECURITIES,
& SecurityTypeEnums::COLLATERALIZED_MORTGAGE_OBLIGATION,
& SecurityTypeEnums::IOETTE_MORTGAGE,
& SecurityTypeEnums::MORTGAGE_BACKED_SECURITIES,
& SecurityTypeEnums::MORTGAGE_INTEREST_ONLY,
& SecurityTypeEnums::MORTGAGE_PRINCIPAL_ONLY,
& SecurityTypeEnums::MORTGAGE_PRIVATE_PLACEMENT,
& SecurityTypeEnums::MISCELLANEOUS_PASS_THROUGH,
& SecurityTypeEnums::PFANDBRIEFE,
& SecurityTypeEnums::TO_BE_ANNOUNCED,
& SecurityTypeEnums::OTHER_ANTICIPATION_NOTES_BAN_GAN_ETC,
& SecurityTypeEnums::CERTIFICATE_OF_OBLIGATION,
& SecurityTypeEnums::CERTIFICATE_OF_PARTICIPATION,
& SecurityTypeEnums::GENERAL_OBLIGATION_BONDS,
& SecurityTypeEnums::MANDATORY_TENDER,
& SecurityTypeEnums::REVENUE_ANTICIPATION_NOTE,
& SecurityTypeEnums::REVENUE_BONDS,
& SecurityTypeEnums::SPECIAL_ASSESSMENT,
& SecurityTypeEnums::SPECIAL_OBLIGATION,
& SecurityTypeEnums::SPECIAL_TAX,
& SecurityTypeEnums::TAX_ANTICIPATION_NOTE,
& SecurityTypeEnums::TAX_ALLOCATION,
& SecurityTypeEnums::TAX_EXEMPT_COMMERCIAL_PAPER,
& SecurityTypeEnums::TAX_REVENUE_ANTICIPATION_NOTE,
& SecurityTypeEnums::VARIABLE_RATE_DEMAND_NOTE,
& SecurityTypeEnums::WARRANT,
& SecurityTypeEnums::MUTUAL_FUND,
& SecurityTypeEnums::MULTI_LEG_INSTRUMENT,
& SecurityTypeEnums::NO_SECURITY_TYPE,
nullptr };

const char * StandInstDbTypeEnums::getFieldName() const { return FixStandInstDbType; }
const FieldEnumBase * StandInstDbTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const StandInstDbTypeEnums::ValueType * StandInstDbTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * StandInstDbTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & StandInstDbTypeEnums::getEnumMapByRaw() const { return StandInstDbTypeEnums::itemByRaw; }
const FieldEnumBase ** StandInstDbTypeEnums::getEnums() const { return items; }
const StandInstDbTypeEnums StandInstDbTypeEnums::instance;
const FieldEnumBase * StandInstDbTypeEnums::items[] = {
& StandInstDbTypeEnums::OTHER,
& StandInstDbTypeEnums::DTC_SID,
& StandInstDbTypeEnums::THOMSON_ALERT,
& StandInstDbTypeEnums::A_GLOBAL_CUSTODIAN,
& StandInstDbTypeEnums::ACCOUNTNET,
nullptr };

const char * SettlDeliveryTypeEnums::getFieldName() const { return FixSettlDeliveryType; }
const FieldEnumBase * SettlDeliveryTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlDeliveryTypeEnums::ValueType * SettlDeliveryTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlDeliveryTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlDeliveryTypeEnums::getEnumMapByRaw() const { return SettlDeliveryTypeEnums::itemByRaw; }
const FieldEnumBase ** SettlDeliveryTypeEnums::getEnums() const { return items; }
const SettlDeliveryTypeEnums SettlDeliveryTypeEnums::instance;
const FieldEnumBase * SettlDeliveryTypeEnums::items[] = {
& SettlDeliveryTypeEnums::VERSUS_PAYMENT_DELIVER,
& SettlDeliveryTypeEnums::FREE_DELIVER,
& SettlDeliveryTypeEnums::TRI_PARTY,
& SettlDeliveryTypeEnums::HOLD_IN_CUSTODY,
nullptr };

const char * AllocLinkTypeEnums::getFieldName() const { return FixAllocLinkType; }
const FieldEnumBase * AllocLinkTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocLinkTypeEnums::ValueType * AllocLinkTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocLinkTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocLinkTypeEnums::getEnumMapByRaw() const { return AllocLinkTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocLinkTypeEnums::getEnums() const { return items; }
const AllocLinkTypeEnums AllocLinkTypeEnums::instance;
const FieldEnumBase * AllocLinkTypeEnums::items[] = {
& AllocLinkTypeEnums::F_X_NETTING,
& AllocLinkTypeEnums::F_X_SWAP,
nullptr };

const char * PutOrCallEnums::getFieldName() const { return FixPutOrCall; }
const FieldEnumBase * PutOrCallEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PutOrCallEnums::ValueType * PutOrCallEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PutOrCallEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PutOrCallEnums::getEnumMapByRaw() const { return PutOrCallEnums::itemByRaw; }
const FieldEnumBase ** PutOrCallEnums::getEnums() const { return items; }
const PutOrCallEnums PutOrCallEnums::instance;
const FieldEnumBase * PutOrCallEnums::items[] = {
& PutOrCallEnums::PUT,
& PutOrCallEnums::CALL,
nullptr };

const char * CoveredOrUncoveredEnums::getFieldName() const { return FixCoveredOrUncovered; }
const FieldEnumBase * CoveredOrUncoveredEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CoveredOrUncoveredEnums::ValueType * CoveredOrUncoveredEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CoveredOrUncoveredEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CoveredOrUncoveredEnums::getEnumMapByRaw() const { return CoveredOrUncoveredEnums::itemByRaw; }
const FieldEnumBase ** CoveredOrUncoveredEnums::getEnums() const { return items; }
const CoveredOrUncoveredEnums CoveredOrUncoveredEnums::instance;
const FieldEnumBase * CoveredOrUncoveredEnums::items[] = {
& CoveredOrUncoveredEnums::COVERED,
& CoveredOrUncoveredEnums::UNCOVERED,
nullptr };

const char * NotifyBrokerOfCreditEnums::getFieldName() const { return FixNotifyBrokerOfCredit; }
const FieldEnumBase * NotifyBrokerOfCreditEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const NotifyBrokerOfCreditEnums::ValueType * NotifyBrokerOfCreditEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * NotifyBrokerOfCreditEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & NotifyBrokerOfCreditEnums::getEnumMapByRaw() const { return NotifyBrokerOfCreditEnums::itemByRaw; }
const FieldEnumBase ** NotifyBrokerOfCreditEnums::getEnums() const { return items; }
const NotifyBrokerOfCreditEnums NotifyBrokerOfCreditEnums::instance;
const FieldEnumBase * NotifyBrokerOfCreditEnums::items[] = {
& NotifyBrokerOfCreditEnums::YES,
& NotifyBrokerOfCreditEnums::NO,
nullptr };

const char * AllocHandlInstEnums::getFieldName() const { return FixAllocHandlInst; }
const FieldEnumBase * AllocHandlInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocHandlInstEnums::ValueType * AllocHandlInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocHandlInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocHandlInstEnums::getEnumMapByRaw() const { return AllocHandlInstEnums::itemByRaw; }
const FieldEnumBase ** AllocHandlInstEnums::getEnums() const { return items; }
const AllocHandlInstEnums AllocHandlInstEnums::instance;
const FieldEnumBase * AllocHandlInstEnums::items[] = {
& AllocHandlInstEnums::MATCH,
& AllocHandlInstEnums::FORWARD,
& AllocHandlInstEnums::FORWARD_AND_MATCH,
nullptr };

const char * RoutingTypeEnums::getFieldName() const { return FixRoutingType; }
const FieldEnumBase * RoutingTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const RoutingTypeEnums::ValueType * RoutingTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * RoutingTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & RoutingTypeEnums::getEnumMapByRaw() const { return RoutingTypeEnums::itemByRaw; }
const FieldEnumBase ** RoutingTypeEnums::getEnums() const { return items; }
const RoutingTypeEnums RoutingTypeEnums::instance;
const FieldEnumBase * RoutingTypeEnums::items[] = {
& RoutingTypeEnums::TARGET_FIRM,
& RoutingTypeEnums::TARGET_LIST,
& RoutingTypeEnums::BLOCK_FIRM,
& RoutingTypeEnums::BLOCK_LIST,
nullptr };

const char * StipulationTypeEnums::getFieldName() const { return FixStipulationType; }
const FieldEnumBase * StipulationTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const StipulationTypeEnums::ValueType * StipulationTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * StipulationTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & StipulationTypeEnums::getEnumMapByRaw() const { return StipulationTypeEnums::itemByRaw; }
const FieldEnumBase ** StipulationTypeEnums::getEnums() const { return items; }
const StipulationTypeEnums StipulationTypeEnums::instance;
const FieldEnumBase * StipulationTypeEnums::items[] = {
& StipulationTypeEnums::AMT,
& StipulationTypeEnums::AUTO_REINVESTMENT_AT_RATE_OR_BETTER,
& StipulationTypeEnums::BANK_QUALIFIED,
& StipulationTypeEnums::BARGAIN_CONDITIONS_SEE,
& StipulationTypeEnums::COUPON_RANGE,
& StipulationTypeEnums::ISO_CURRENCY_CODE,
& StipulationTypeEnums::CUSTOM_START_END_DATE,
& StipulationTypeEnums::GEOGRAPHICS_AND_RANGE,
& StipulationTypeEnums::VALUATION_DISCOUNT,
& StipulationTypeEnums::INSURED,
& StipulationTypeEnums::YEAR_OR_YEAR_MONTH_OF_ISSUE,
& StipulationTypeEnums::ISSUERS_TICKER,
& StipulationTypeEnums::ISSUE_SIZE_RANGE,
& StipulationTypeEnums::LOOKBACK_DAYS,
& StipulationTypeEnums::EXPLICIT_LOT_IDENTIFIER,
& StipulationTypeEnums::LOT_VARIANCE,
& StipulationTypeEnums::MATURITY_YEAR_AND_MONTH,
& StipulationTypeEnums::MATURITY_RANGE,
& StipulationTypeEnums::MAXIMUM_SUBSTITUTIONS,
& StipulationTypeEnums::MINIMUM_QUANTITY,
& StipulationTypeEnums::MINIMUM_INCREMENT,
& StipulationTypeEnums::MINIMUM_DENOMINATION,
& StipulationTypeEnums::PAYMENT_FREQUENCY_CALENDAR,
& StipulationTypeEnums::NUMBER_OF_PIECES,
& StipulationTypeEnums::POOLS_MAXIMUM,
& StipulationTypeEnums::POOLS_PER_MILLION,
& StipulationTypeEnums::POOLS_PER_LOT,
& StipulationTypeEnums::POOLS_PER_TRADE,
& StipulationTypeEnums::PRICE_RANGE,
& StipulationTypeEnums::PRICING_FREQUENCY,
& StipulationTypeEnums::PRODUCTION_YEAR,
& StipulationTypeEnums::CALL_PROTECTION,
& StipulationTypeEnums::PURPOSE,
& StipulationTypeEnums::BENCHMARK_PRICE_SOURCE,
& StipulationTypeEnums::RATING_SOURCE_AND_RANGE,
& StipulationTypeEnums::TYPE_OF_REDEMPTION_VALUES_ARE_NONCALLABLE_CALLABLE_PREFUNDED_ESCROWEDTOMATURITY_PUTABLE_CONVERTIBLE,
& StipulationTypeEnums::RESTRICTED,
& StipulationTypeEnums::MARKET_SECTOR,
& StipulationTypeEnums::SECURITYTYPE_INCLUDED_OR_EXCLUDED,
& StipulationTypeEnums::STRUCTURE,
& StipulationTypeEnums::SUBSTITUTIONS_FREQUENCY,
& StipulationTypeEnums::SUBSTITUTIONS_LEFT,
& StipulationTypeEnums::FREEFORM_TEXT,
& StipulationTypeEnums::TRADE_VARIANCE,
& StipulationTypeEnums::WEIGHTED_AVERAGE_COUPONVALUE_IN_PERCENT,
& StipulationTypeEnums::WEIGHTED_AVERAGE_LIFE_COUPON_VALUE_IN_PERCENT,
& StipulationTypeEnums::WEIGHTED_AVERAGE_LOAN_AGE_VALUE_IN_MONTHS,
& StipulationTypeEnums::WEIGHTED_AVERAGE_MATURITY_VALUE_IN_MONTHS,
& StipulationTypeEnums::WHOLE_POOL,
& StipulationTypeEnums::YIELD_RANGE,
nullptr };

const char * YieldTypeEnums::getFieldName() const { return FixYieldType; }
const FieldEnumBase * YieldTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const YieldTypeEnums::ValueType * YieldTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * YieldTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & YieldTypeEnums::getEnumMapByRaw() const { return YieldTypeEnums::itemByRaw; }
const FieldEnumBase ** YieldTypeEnums::getEnums() const { return items; }
const YieldTypeEnums YieldTypeEnums::instance;
const FieldEnumBase * YieldTypeEnums::items[] = {
& YieldTypeEnums::AFTER_TAX_YIELD,
& YieldTypeEnums::ANNUAL_YIELD,
& YieldTypeEnums::YIELD_AT_ISSUE,
& YieldTypeEnums::YIELD_TO_AVERAGE_MATURITY,
& YieldTypeEnums::BOOK_YIELD,
& YieldTypeEnums::YIELD_TO_NEXT_CALL,
& YieldTypeEnums::YIELD_CHANGE_SINCE_CLOSE,
& YieldTypeEnums::CLOSING_YIELD,
& YieldTypeEnums::COMPOUND_YIELD,
& YieldTypeEnums::CURRENT_YIELD,
& YieldTypeEnums::TRUE_GROSS_YIELD,
& YieldTypeEnums::GOVERNMENT_EQUIVALENT_YIELD,
& YieldTypeEnums::YIELD_WITH_INFLATION_ASSUMPTION,
& YieldTypeEnums::INVERSE_FLOATER_BOND_YIELD,
& YieldTypeEnums::MOST_RECENT_CLOSING_YIELD,
& YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_MONTH,
& YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_QUARTER,
& YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_YEAR,
& YieldTypeEnums::YIELD_TO_LONGEST_AVERAGE_LIFE,
& YieldTypeEnums::MARK_TO_MARKET_YIELD,
& YieldTypeEnums::YIELD_TO_MATURITY,
& YieldTypeEnums::YIELD_TO_NEXT_REFUND,
& YieldTypeEnums::OPEN_AVERAGE_YIELD,
& YieldTypeEnums::YIELD_TO_NEXT_PUT,
& YieldTypeEnums::PREVIOUS_CLOSE_YIELD,
& YieldTypeEnums::PROCEEDS_YIELD,
& YieldTypeEnums::SEMI_ANNUAL_YIELD,
& YieldTypeEnums::YIELD_TO_SHORTEST_AVERAGE_LIFE,
& YieldTypeEnums::SIMPLE_YIELD,
& YieldTypeEnums::TAX_EQUIVALENT_YIELD,
& YieldTypeEnums::YIELD_TO_TENDER_DATE,
& YieldTypeEnums::TRUE_YIELD,
& YieldTypeEnums::YIELD_VALUE_OF_1_32,
& YieldTypeEnums::YIELD_TO_WORST,
nullptr };

const char * TradedFlatSwitchEnums::getFieldName() const { return FixTradedFlatSwitch; }
const FieldEnumBase * TradedFlatSwitchEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradedFlatSwitchEnums::ValueType * TradedFlatSwitchEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradedFlatSwitchEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradedFlatSwitchEnums::getEnumMapByRaw() const { return TradedFlatSwitchEnums::itemByRaw; }
const FieldEnumBase ** TradedFlatSwitchEnums::getEnums() const { return items; }
const TradedFlatSwitchEnums TradedFlatSwitchEnums::instance;
const FieldEnumBase * TradedFlatSwitchEnums::items[] = {
& TradedFlatSwitchEnums::YES,
& TradedFlatSwitchEnums::NO,
nullptr };

const char * SubscriptionRequestTypeEnums::getFieldName() const { return FixSubscriptionRequestType; }
const FieldEnumBase * SubscriptionRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SubscriptionRequestTypeEnums::ValueType * SubscriptionRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SubscriptionRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SubscriptionRequestTypeEnums::getEnumMapByRaw() const { return SubscriptionRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** SubscriptionRequestTypeEnums::getEnums() const { return items; }
const SubscriptionRequestTypeEnums SubscriptionRequestTypeEnums::instance;
const FieldEnumBase * SubscriptionRequestTypeEnums::items[] = {
& SubscriptionRequestTypeEnums::SNAPSHOT,
& SubscriptionRequestTypeEnums::SNAPSHOT_PLUS_UPDATES,
& SubscriptionRequestTypeEnums::DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST,
nullptr };

const char * MDUpdateTypeEnums::getFieldName() const { return FixMDUpdateType; }
const FieldEnumBase * MDUpdateTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MDUpdateTypeEnums::ValueType * MDUpdateTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MDUpdateTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MDUpdateTypeEnums::getEnumMapByRaw() const { return MDUpdateTypeEnums::itemByRaw; }
const FieldEnumBase ** MDUpdateTypeEnums::getEnums() const { return items; }
const MDUpdateTypeEnums MDUpdateTypeEnums::instance;
const FieldEnumBase * MDUpdateTypeEnums::items[] = {
& MDUpdateTypeEnums::FULL_REFRESH,
& MDUpdateTypeEnums::INCREMENTAL_REFRESH,
nullptr };

const char * AggregatedBookEnums::getFieldName() const { return FixAggregatedBook; }
const FieldEnumBase * AggregatedBookEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AggregatedBookEnums::ValueType * AggregatedBookEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AggregatedBookEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AggregatedBookEnums::getEnumMapByRaw() const { return AggregatedBookEnums::itemByRaw; }
const FieldEnumBase ** AggregatedBookEnums::getEnums() const { return items; }
const AggregatedBookEnums AggregatedBookEnums::instance;
const FieldEnumBase * AggregatedBookEnums::items[] = {
& AggregatedBookEnums::YES,
& AggregatedBookEnums::NO,
nullptr };

const char * MDEntryTypeEnums::getFieldName() const { return FixMDEntryType; }
const FieldEnumBase * MDEntryTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MDEntryTypeEnums::ValueType * MDEntryTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MDEntryTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MDEntryTypeEnums::getEnumMapByRaw() const { return MDEntryTypeEnums::itemByRaw; }
const FieldEnumBase ** MDEntryTypeEnums::getEnums() const { return items; }
const MDEntryTypeEnums MDEntryTypeEnums::instance;
const FieldEnumBase * MDEntryTypeEnums::items[] = {
& MDEntryTypeEnums::BID,
& MDEntryTypeEnums::OFFER,
& MDEntryTypeEnums::TRADE,
& MDEntryTypeEnums::INDEX_VALUE,
& MDEntryTypeEnums::OPENING_PRICE,
& MDEntryTypeEnums::CLOSING_PRICE,
& MDEntryTypeEnums::SETTLEMENT_PRICE,
& MDEntryTypeEnums::TRADING_SESSION_HIGH_PRICE,
& MDEntryTypeEnums::TRADING_SESSION_LOW_PRICE,
& MDEntryTypeEnums::TRADING_SESSION_VWAP_PRICE,
& MDEntryTypeEnums::IMBALANCE,
& MDEntryTypeEnums::TRADE_VOLUME,
& MDEntryTypeEnums::OPEN_INTEREST,
nullptr };

const char * TickDirectionEnums::getFieldName() const { return FixTickDirection; }
const FieldEnumBase * TickDirectionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TickDirectionEnums::ValueType * TickDirectionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TickDirectionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TickDirectionEnums::getEnumMapByRaw() const { return TickDirectionEnums::itemByRaw; }
const FieldEnumBase ** TickDirectionEnums::getEnums() const { return items; }
const TickDirectionEnums TickDirectionEnums::instance;
const FieldEnumBase * TickDirectionEnums::items[] = {
& TickDirectionEnums::PLUS_TICK,
& TickDirectionEnums::ZERO_PLUS_TICK,
& TickDirectionEnums::MINUS_TICK,
& TickDirectionEnums::ZERO_MINUS_TICK,
nullptr };

const char * QuoteConditionEnums::getFieldName() const { return FixQuoteCondition; }
const FieldEnumBase * QuoteConditionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteConditionEnums::ValueType * QuoteConditionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteConditionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteConditionEnums::getEnumMapByRaw() const { return QuoteConditionEnums::itemByRaw; }
const FieldEnumBase ** QuoteConditionEnums::getEnums() const { return items; }
const QuoteConditionEnums QuoteConditionEnums::instance;
const FieldEnumBase * QuoteConditionEnums::items[] = {
& QuoteConditionEnums::OPEN,
& QuoteConditionEnums::CLOSED,
& QuoteConditionEnums::EXCHANGE_BEST,
& QuoteConditionEnums::CONSOLIDATED_BEST,
& QuoteConditionEnums::LOCKED,
& QuoteConditionEnums::CROSSED,
& QuoteConditionEnums::DEPTH,
& QuoteConditionEnums::FAST_TRADING,
& QuoteConditionEnums::NON_FIRM,
nullptr };

const char * TradeConditionEnums::getFieldName() const { return FixTradeCondition; }
const FieldEnumBase * TradeConditionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeConditionEnums::ValueType * TradeConditionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeConditionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeConditionEnums::getEnumMapByRaw() const { return TradeConditionEnums::itemByRaw; }
const FieldEnumBase ** TradeConditionEnums::getEnums() const { return items; }
const TradeConditionEnums TradeConditionEnums::instance;
const FieldEnumBase * TradeConditionEnums::items[] = {
& TradeConditionEnums::CASH,
& TradeConditionEnums::AVERAGE_PRICE_TRADE,
& TradeConditionEnums::CASH_TRADE,
& TradeConditionEnums::NEXT_DAY,
& TradeConditionEnums::OPENING,
& TradeConditionEnums::INTRADAY_TRADE_DETAIL,
& TradeConditionEnums::RULE_127_TRADE,
& TradeConditionEnums::RULE_155_TRADE,
& TradeConditionEnums::SOLD_LAST,
& TradeConditionEnums::NEXT_DAY_TRADE,
& TradeConditionEnums::OPENED,
& TradeConditionEnums::SELLER,
& TradeConditionEnums::SOLD,
& TradeConditionEnums::STOPPED_STOCK,
& TradeConditionEnums::IMBALANCE_MORE_BUYERS,
& TradeConditionEnums::IMBALANCE_MORE_SELLERS,
& TradeConditionEnums::OPENING_PRICE,
nullptr };

const char * MDUpdateActionEnums::getFieldName() const { return FixMDUpdateAction; }
const FieldEnumBase * MDUpdateActionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MDUpdateActionEnums::ValueType * MDUpdateActionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MDUpdateActionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MDUpdateActionEnums::getEnumMapByRaw() const { return MDUpdateActionEnums::itemByRaw; }
const FieldEnumBase ** MDUpdateActionEnums::getEnums() const { return items; }
const MDUpdateActionEnums MDUpdateActionEnums::instance;
const FieldEnumBase * MDUpdateActionEnums::items[] = {
& MDUpdateActionEnums::NEW,
& MDUpdateActionEnums::CHANGE,
& MDUpdateActionEnums::DELETE,
nullptr };

const char * MDReqRejReasonEnums::getFieldName() const { return FixMDReqRejReason; }
const FieldEnumBase * MDReqRejReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MDReqRejReasonEnums::ValueType * MDReqRejReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MDReqRejReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MDReqRejReasonEnums::getEnumMapByRaw() const { return MDReqRejReasonEnums::itemByRaw; }
const FieldEnumBase ** MDReqRejReasonEnums::getEnums() const { return items; }
const MDReqRejReasonEnums MDReqRejReasonEnums::instance;
const FieldEnumBase * MDReqRejReasonEnums::items[] = {
& MDReqRejReasonEnums::UNKNOWN_SYMBOL,
& MDReqRejReasonEnums::DUPLICATE_MDREQID,
& MDReqRejReasonEnums::INSUFFICIENT_BANDWIDTH,
& MDReqRejReasonEnums::INSUFFICIENT_PERMISSIONS,
& MDReqRejReasonEnums::UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE,
& MDReqRejReasonEnums::UNSUPPORTED_MARKETDEPTH,
& MDReqRejReasonEnums::UNSUPPORTED_MDUPDATETYPE,
& MDReqRejReasonEnums::UNSUPPORTED_AGGREGATEDBOOK,
& MDReqRejReasonEnums::UNSUPPORTED_MDENTRYTYPE,
& MDReqRejReasonEnums::UNSUPPORTED_TRADINGSESSIONID,
& MDReqRejReasonEnums::UNSUPPORTED_SCOPE,
& MDReqRejReasonEnums::UNSUPPORTED_OPENCLOSESETTLEFLAG,
& MDReqRejReasonEnums::UNSUPPORTED_MDIMPLICITDELETE,
nullptr };

const char * DeleteReasonEnums::getFieldName() const { return FixDeleteReason; }
const FieldEnumBase * DeleteReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DeleteReasonEnums::ValueType * DeleteReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DeleteReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DeleteReasonEnums::getEnumMapByRaw() const { return DeleteReasonEnums::itemByRaw; }
const FieldEnumBase ** DeleteReasonEnums::getEnums() const { return items; }
const DeleteReasonEnums DeleteReasonEnums::instance;
const FieldEnumBase * DeleteReasonEnums::items[] = {
& DeleteReasonEnums::CANCELATION,
& DeleteReasonEnums::ERROR,
nullptr };

const char * OpenCloseSettlFlagEnums::getFieldName() const { return FixOpenCloseSettlFlag; }
const FieldEnumBase * OpenCloseSettlFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OpenCloseSettlFlagEnums::ValueType * OpenCloseSettlFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OpenCloseSettlFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OpenCloseSettlFlagEnums::getEnumMapByRaw() const { return OpenCloseSettlFlagEnums::itemByRaw; }
const FieldEnumBase ** OpenCloseSettlFlagEnums::getEnums() const { return items; }
const OpenCloseSettlFlagEnums OpenCloseSettlFlagEnums::instance;
const FieldEnumBase * OpenCloseSettlFlagEnums::items[] = {
& OpenCloseSettlFlagEnums::DAILY_OPEN,
& OpenCloseSettlFlagEnums::SESSION_OPEN,
& OpenCloseSettlFlagEnums::DELIVERY_SETTLEMENT_ENTRY,
& OpenCloseSettlFlagEnums::EXPECTED_ENTRY,
& OpenCloseSettlFlagEnums::ENTRY_FROM_PREVIOUS_BUSINESS_DAY,
& OpenCloseSettlFlagEnums::THEORETICAL_PRICE_VALUE,
nullptr };

const char * FinancialStatusEnums::getFieldName() const { return FixFinancialStatus; }
const FieldEnumBase * FinancialStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const FinancialStatusEnums::ValueType * FinancialStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * FinancialStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & FinancialStatusEnums::getEnumMapByRaw() const { return FinancialStatusEnums::itemByRaw; }
const FieldEnumBase ** FinancialStatusEnums::getEnums() const { return items; }
const FinancialStatusEnums FinancialStatusEnums::instance;
const FieldEnumBase * FinancialStatusEnums::items[] = {
& FinancialStatusEnums::BANKRUPT,
& FinancialStatusEnums::PENDING_DELISTING,
nullptr };

const char * CorporateActionEnums::getFieldName() const { return FixCorporateAction; }
const FieldEnumBase * CorporateActionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CorporateActionEnums::ValueType * CorporateActionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CorporateActionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CorporateActionEnums::getEnumMapByRaw() const { return CorporateActionEnums::itemByRaw; }
const FieldEnumBase ** CorporateActionEnums::getEnums() const { return items; }
const CorporateActionEnums CorporateActionEnums::instance;
const FieldEnumBase * CorporateActionEnums::items[] = {
& CorporateActionEnums::EX_DIVIDEND,
& CorporateActionEnums::EX_DISTRIBUTION,
& CorporateActionEnums::EX_RIGHTS,
& CorporateActionEnums::NEW,
& CorporateActionEnums::EX_INTEREST,
nullptr };

const char * QuoteStatusEnums::getFieldName() const { return FixQuoteStatus; }
const FieldEnumBase * QuoteStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteStatusEnums::ValueType * QuoteStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteStatusEnums::getEnumMapByRaw() const { return QuoteStatusEnums::itemByRaw; }
const FieldEnumBase ** QuoteStatusEnums::getEnums() const { return items; }
const QuoteStatusEnums QuoteStatusEnums::instance;
const FieldEnumBase * QuoteStatusEnums::items[] = {
& QuoteStatusEnums::ACCEPTED,
& QuoteStatusEnums::CANCELED_FOR_SYMBOL,
& QuoteStatusEnums::CANCELED_FOR_SECURITY_TYPE,
& QuoteStatusEnums::CANCELED_FOR_UNDERLYING,
& QuoteStatusEnums::CANCELED_ALL,
& QuoteStatusEnums::REJECTED,
& QuoteStatusEnums::REMOVED_FROM_MARKET,
& QuoteStatusEnums::EXPIRED,
& QuoteStatusEnums::QUERY,
& QuoteStatusEnums::QUOTE_NOT_FOUND,
& QuoteStatusEnums::PENDING,
& QuoteStatusEnums::PASS,
& QuoteStatusEnums::LOCKED_MARKET_WARNING,
& QuoteStatusEnums::CROSS_MARKET_WARNING,
& QuoteStatusEnums::CANCELED_DUE_TO_LOCK_MARKET,
& QuoteStatusEnums::CANCELED_DUE_TO_CROSS_MARKET,
nullptr };

const char * QuoteCancelTypeEnums::getFieldName() const { return FixQuoteCancelType; }
const FieldEnumBase * QuoteCancelTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteCancelTypeEnums::ValueType * QuoteCancelTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteCancelTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteCancelTypeEnums::getEnumMapByRaw() const { return QuoteCancelTypeEnums::itemByRaw; }
const FieldEnumBase ** QuoteCancelTypeEnums::getEnums() const { return items; }
const QuoteCancelTypeEnums QuoteCancelTypeEnums::instance;
const FieldEnumBase * QuoteCancelTypeEnums::items[] = {
& QuoteCancelTypeEnums::CANCEL_FOR_SYMBOL,
& QuoteCancelTypeEnums::CANCEL_FOR_SECURITY_TYPE,
& QuoteCancelTypeEnums::CANCEL_FOR_UNDERLYING_SYMBOL,
& QuoteCancelTypeEnums::CANCEL_ALL_QUOTES,
nullptr };

const char * QuoteRejectReasonEnums::getFieldName() const { return FixQuoteRejectReason; }
const FieldEnumBase * QuoteRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteRejectReasonEnums::ValueType * QuoteRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteRejectReasonEnums::getEnumMapByRaw() const { return QuoteRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** QuoteRejectReasonEnums::getEnums() const { return items; }
const QuoteRejectReasonEnums QuoteRejectReasonEnums::instance;
const FieldEnumBase * QuoteRejectReasonEnums::items[] = {
& QuoteRejectReasonEnums::UNKNOWN_SYMBOL,
& QuoteRejectReasonEnums::EXCHANGE,
& QuoteRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT,
& QuoteRejectReasonEnums::TOO_LATE_TO_ENTER,
& QuoteRejectReasonEnums::UNKNOWN_QUOTE,
& QuoteRejectReasonEnums::DUPLICATE_QUOTE,
& QuoteRejectReasonEnums::INVALID_BID_ASK_SPREAD,
& QuoteRejectReasonEnums::INVALID_PRICE,
& QuoteRejectReasonEnums::NOT_AUTHORIZED_TO_QUOTE_SECURITY,
& QuoteRejectReasonEnums::OTHER,
nullptr };

const char * QuoteResponseLevelEnums::getFieldName() const { return FixQuoteResponseLevel; }
const FieldEnumBase * QuoteResponseLevelEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteResponseLevelEnums::ValueType * QuoteResponseLevelEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteResponseLevelEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteResponseLevelEnums::getEnumMapByRaw() const { return QuoteResponseLevelEnums::itemByRaw; }
const FieldEnumBase ** QuoteResponseLevelEnums::getEnums() const { return items; }
const QuoteResponseLevelEnums QuoteResponseLevelEnums::instance;
const FieldEnumBase * QuoteResponseLevelEnums::items[] = {
& QuoteResponseLevelEnums::NO_ACKNOWLEDGEMENT,
& QuoteResponseLevelEnums::ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES,
& QuoteResponseLevelEnums::ACKNOWLEDGE_EACH_QUOTE_MESSAGES,
nullptr };

const char * QuoteRequestTypeEnums::getFieldName() const { return FixQuoteRequestType; }
const FieldEnumBase * QuoteRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteRequestTypeEnums::ValueType * QuoteRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteRequestTypeEnums::getEnumMapByRaw() const { return QuoteRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** QuoteRequestTypeEnums::getEnums() const { return items; }
const QuoteRequestTypeEnums QuoteRequestTypeEnums::instance;
const FieldEnumBase * QuoteRequestTypeEnums::items[] = {
& QuoteRequestTypeEnums::MANUAL,
& QuoteRequestTypeEnums::AUTOMATIC,
nullptr };

const char * SecurityRequestTypeEnums::getFieldName() const { return FixSecurityRequestType; }
const FieldEnumBase * SecurityRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityRequestTypeEnums::ValueType * SecurityRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityRequestTypeEnums::getEnumMapByRaw() const { return SecurityRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** SecurityRequestTypeEnums::getEnums() const { return items; }
const SecurityRequestTypeEnums SecurityRequestTypeEnums::instance;
const FieldEnumBase * SecurityRequestTypeEnums::items[] = {
& SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS,
& SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED,
& SecurityRequestTypeEnums::REQUEST_LIST_SECURITY_TYPES,
& SecurityRequestTypeEnums::REQUEST_LIST_SECURITIES,
nullptr };

const char * SecurityResponseTypeEnums::getFieldName() const { return FixSecurityResponseType; }
const FieldEnumBase * SecurityResponseTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityResponseTypeEnums::ValueType * SecurityResponseTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityResponseTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityResponseTypeEnums::getEnumMapByRaw() const { return SecurityResponseTypeEnums::itemByRaw; }
const FieldEnumBase ** SecurityResponseTypeEnums::getEnums() const { return items; }
const SecurityResponseTypeEnums SecurityResponseTypeEnums::instance;
const FieldEnumBase * SecurityResponseTypeEnums::items[] = {
& SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_AS_IS,
& SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE,
& SecurityResponseTypeEnums::REJECT_SECURITY_PROPOSAL,
& SecurityResponseTypeEnums::CAN_NOT_MATCH_SELECTION_CRITERIA,
nullptr };

const char * UnsolicitedIndicatorEnums::getFieldName() const { return FixUnsolicitedIndicator; }
const FieldEnumBase * UnsolicitedIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const UnsolicitedIndicatorEnums::ValueType * UnsolicitedIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * UnsolicitedIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & UnsolicitedIndicatorEnums::getEnumMapByRaw() const { return UnsolicitedIndicatorEnums::itemByRaw; }
const FieldEnumBase ** UnsolicitedIndicatorEnums::getEnums() const { return items; }
const UnsolicitedIndicatorEnums UnsolicitedIndicatorEnums::instance;
const FieldEnumBase * UnsolicitedIndicatorEnums::items[] = {
& UnsolicitedIndicatorEnums::YES,
& UnsolicitedIndicatorEnums::NO,
nullptr };

const char * SecurityTradingStatusEnums::getFieldName() const { return FixSecurityTradingStatus; }
const FieldEnumBase * SecurityTradingStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityTradingStatusEnums::ValueType * SecurityTradingStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityTradingStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityTradingStatusEnums::getEnumMapByRaw() const { return SecurityTradingStatusEnums::itemByRaw; }
const FieldEnumBase ** SecurityTradingStatusEnums::getEnums() const { return items; }
const SecurityTradingStatusEnums SecurityTradingStatusEnums::instance;
const FieldEnumBase * SecurityTradingStatusEnums::items[] = {
& SecurityTradingStatusEnums::OPENING_DELAY,
& SecurityTradingStatusEnums::TRADING_HALT,
& SecurityTradingStatusEnums::RESUME,
& SecurityTradingStatusEnums::NO_OPEN_NO_RESUME,
& SecurityTradingStatusEnums::PRICE_INDICATION,
& SecurityTradingStatusEnums::TRADING_RANGE_INDICATION,
& SecurityTradingStatusEnums::MARKET_IMBALANCE_BUY,
& SecurityTradingStatusEnums::MARKET_IMBALANCE_SELL,
& SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_BUY,
& SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_SELL,
& SecurityTradingStatusEnums::NO_MARKET_IMBALANCE,
& SecurityTradingStatusEnums::NO_MARKET_ON_CLOSE_IMBALANCE,
& SecurityTradingStatusEnums::ITS_PRE_OPENING,
& SecurityTradingStatusEnums::NEW_PRICE_INDICATION,
& SecurityTradingStatusEnums::TRADE_DISSEMINATION_TIME,
& SecurityTradingStatusEnums::READY_TO_TRADE,
& SecurityTradingStatusEnums::NOT_AVAILABLE_FOR_TRADING,
& SecurityTradingStatusEnums::NOT_TRADED_ON_THIS_MARKET,
& SecurityTradingStatusEnums::UNKNOWN_OR_INVALID,
& SecurityTradingStatusEnums::PRE_OPEN,
& SecurityTradingStatusEnums::OPENING_ROTATION,
& SecurityTradingStatusEnums::FAST_MARKET,
nullptr };

const char * HaltReasonCharEnums::getFieldName() const { return FixHaltReasonChar; }
const FieldEnumBase * HaltReasonCharEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const HaltReasonCharEnums::ValueType * HaltReasonCharEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * HaltReasonCharEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & HaltReasonCharEnums::getEnumMapByRaw() const { return HaltReasonCharEnums::itemByRaw; }
const FieldEnumBase ** HaltReasonCharEnums::getEnums() const { return items; }
const HaltReasonCharEnums HaltReasonCharEnums::instance;
const FieldEnumBase * HaltReasonCharEnums::items[] = {
& HaltReasonCharEnums::ORDER_IMBALANCE,
& HaltReasonCharEnums::EQUIPMENT_CHANGEOVER,
& HaltReasonCharEnums::NEWS_PENDING,
& HaltReasonCharEnums::NEWS_DISSEMINATION,
& HaltReasonCharEnums::ORDER_INFLUX,
& HaltReasonCharEnums::ADDITIONAL_INFORMATION,
nullptr };

const char * InViewOfCommonEnums::getFieldName() const { return FixInViewOfCommon; }
const FieldEnumBase * InViewOfCommonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const InViewOfCommonEnums::ValueType * InViewOfCommonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * InViewOfCommonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & InViewOfCommonEnums::getEnumMapByRaw() const { return InViewOfCommonEnums::itemByRaw; }
const FieldEnumBase ** InViewOfCommonEnums::getEnums() const { return items; }
const InViewOfCommonEnums InViewOfCommonEnums::instance;
const FieldEnumBase * InViewOfCommonEnums::items[] = {
& InViewOfCommonEnums::YES,
& InViewOfCommonEnums::NO,
nullptr };

const char * DueToRelatedEnums::getFieldName() const { return FixDueToRelated; }
const FieldEnumBase * DueToRelatedEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DueToRelatedEnums::ValueType * DueToRelatedEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DueToRelatedEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DueToRelatedEnums::getEnumMapByRaw() const { return DueToRelatedEnums::itemByRaw; }
const FieldEnumBase ** DueToRelatedEnums::getEnums() const { return items; }
const DueToRelatedEnums DueToRelatedEnums::instance;
const FieldEnumBase * DueToRelatedEnums::items[] = {
& DueToRelatedEnums::YES,
& DueToRelatedEnums::NO,
nullptr };

const char * AdjustmentEnums::getFieldName() const { return FixAdjustment; }
const FieldEnumBase * AdjustmentEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AdjustmentEnums::ValueType * AdjustmentEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AdjustmentEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AdjustmentEnums::getEnumMapByRaw() const { return AdjustmentEnums::itemByRaw; }
const FieldEnumBase ** AdjustmentEnums::getEnums() const { return items; }
const AdjustmentEnums AdjustmentEnums::instance;
const FieldEnumBase * AdjustmentEnums::items[] = {
& AdjustmentEnums::CANCEL,
& AdjustmentEnums::ERROR,
& AdjustmentEnums::CORRECTION,
nullptr };

const char * TradSesMethodEnums::getFieldName() const { return FixTradSesMethod; }
const FieldEnumBase * TradSesMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradSesMethodEnums::ValueType * TradSesMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradSesMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradSesMethodEnums::getEnumMapByRaw() const { return TradSesMethodEnums::itemByRaw; }
const FieldEnumBase ** TradSesMethodEnums::getEnums() const { return items; }
const TradSesMethodEnums TradSesMethodEnums::instance;
const FieldEnumBase * TradSesMethodEnums::items[] = {
& TradSesMethodEnums::ELECTRONIC,
& TradSesMethodEnums::OPEN_OUTCRY,
& TradSesMethodEnums::TWO_PARTY,
nullptr };

const char * TradSesModeEnums::getFieldName() const { return FixTradSesMode; }
const FieldEnumBase * TradSesModeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradSesModeEnums::ValueType * TradSesModeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradSesModeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradSesModeEnums::getEnumMapByRaw() const { return TradSesModeEnums::itemByRaw; }
const FieldEnumBase ** TradSesModeEnums::getEnums() const { return items; }
const TradSesModeEnums TradSesModeEnums::instance;
const FieldEnumBase * TradSesModeEnums::items[] = {
& TradSesModeEnums::TESTING,
& TradSesModeEnums::SIMULATED,
& TradSesModeEnums::PRODUCTION,
nullptr };

const char * TradSesStatusEnums::getFieldName() const { return FixTradSesStatus; }
const FieldEnumBase * TradSesStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradSesStatusEnums::ValueType * TradSesStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradSesStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradSesStatusEnums::getEnumMapByRaw() const { return TradSesStatusEnums::itemByRaw; }
const FieldEnumBase ** TradSesStatusEnums::getEnums() const { return items; }
const TradSesStatusEnums TradSesStatusEnums::instance;
const FieldEnumBase * TradSesStatusEnums::items[] = {
& TradSesStatusEnums::UNKNOWN,
& TradSesStatusEnums::HALTED,
& TradSesStatusEnums::OPEN,
& TradSesStatusEnums::CLOSED,
& TradSesStatusEnums::PRE_OPEN,
& TradSesStatusEnums::PRE_CLOSE,
& TradSesStatusEnums::REQUEST_REJECTED,
nullptr };

const char * MessageEncodingEnums::getFieldName() const { return FixMessageEncoding; }
const FieldEnumBase * MessageEncodingEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MessageEncodingEnums::ValueType * MessageEncodingEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MessageEncodingEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MessageEncodingEnums::getEnumMapByRaw() const { return MessageEncodingEnums::itemByRaw; }
const FieldEnumBase ** MessageEncodingEnums::getEnums() const { return items; }
const MessageEncodingEnums MessageEncodingEnums::instance;
const FieldEnumBase * MessageEncodingEnums::items[] = {
& MessageEncodingEnums::JIS,
& MessageEncodingEnums::EUC,
& MessageEncodingEnums::FOR_USING_SJIS,
& MessageEncodingEnums::UNICODE,
nullptr };

const char * SessionRejectReasonEnums::getFieldName() const { return FixSessionRejectReason; }
const FieldEnumBase * SessionRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SessionRejectReasonEnums::ValueType * SessionRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SessionRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SessionRejectReasonEnums::getEnumMapByRaw() const { return SessionRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** SessionRejectReasonEnums::getEnums() const { return items; }
const SessionRejectReasonEnums SessionRejectReasonEnums::instance;
const FieldEnumBase * SessionRejectReasonEnums::items[] = {
& SessionRejectReasonEnums::INVALID_TAG_NUMBER,
& SessionRejectReasonEnums::REQUIRED_TAG_MISSING,
& SessionRejectReasonEnums::TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE,
& SessionRejectReasonEnums::UNDEFINED_TAG,
& SessionRejectReasonEnums::TAG_SPECIFIED_WITHOUT_A_VALUE,
& SessionRejectReasonEnums::VALUE_IS_INCORRECT,
& SessionRejectReasonEnums::INCORRECT_DATA_FORMAT_FOR_VALUE,
& SessionRejectReasonEnums::DECRYPTION_PROBLEM,
& SessionRejectReasonEnums::SIGNATURE_PROBLEM,
& SessionRejectReasonEnums::COMPID_PROBLEM,
& SessionRejectReasonEnums::SENDINGTIME_ACCURACY_PROBLEM,
& SessionRejectReasonEnums::INVALID_MSGTYPE,
& SessionRejectReasonEnums::XML_VALIDATION_ERROR,
& SessionRejectReasonEnums::TAG_APPEARS_MORE_THAN_ONCE,
& SessionRejectReasonEnums::TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER,
& SessionRejectReasonEnums::REPEATING_GROUP_FIELDS_OUT_OF_ORDER,
& SessionRejectReasonEnums::INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP,
& SessionRejectReasonEnums::NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER,
& SessionRejectReasonEnums::OTHER,
nullptr };

const char * BidRequestTransTypeEnums::getFieldName() const { return FixBidRequestTransType; }
const FieldEnumBase * BidRequestTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BidRequestTransTypeEnums::ValueType * BidRequestTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BidRequestTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BidRequestTransTypeEnums::getEnumMapByRaw() const { return BidRequestTransTypeEnums::itemByRaw; }
const FieldEnumBase ** BidRequestTransTypeEnums::getEnums() const { return items; }
const BidRequestTransTypeEnums BidRequestTransTypeEnums::instance;
const FieldEnumBase * BidRequestTransTypeEnums::items[] = {
& BidRequestTransTypeEnums::NEW,
& BidRequestTransTypeEnums::CANCEL,
nullptr };

const char * SolicitedFlagEnums::getFieldName() const { return FixSolicitedFlag; }
const FieldEnumBase * SolicitedFlagEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SolicitedFlagEnums::ValueType * SolicitedFlagEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SolicitedFlagEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SolicitedFlagEnums::getEnumMapByRaw() const { return SolicitedFlagEnums::itemByRaw; }
const FieldEnumBase ** SolicitedFlagEnums::getEnums() const { return items; }
const SolicitedFlagEnums SolicitedFlagEnums::instance;
const FieldEnumBase * SolicitedFlagEnums::items[] = {
& SolicitedFlagEnums::YES,
& SolicitedFlagEnums::NO,
nullptr };

const char * ExecRestatementReasonEnums::getFieldName() const { return FixExecRestatementReason; }
const FieldEnumBase * ExecRestatementReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExecRestatementReasonEnums::ValueType * ExecRestatementReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExecRestatementReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExecRestatementReasonEnums::getEnumMapByRaw() const { return ExecRestatementReasonEnums::itemByRaw; }
const FieldEnumBase ** ExecRestatementReasonEnums::getEnums() const { return items; }
const ExecRestatementReasonEnums ExecRestatementReasonEnums::instance;
const FieldEnumBase * ExecRestatementReasonEnums::items[] = {
& ExecRestatementReasonEnums::GT_CORPORATE_ACTION,
& ExecRestatementReasonEnums::GT_RENEWAL,
& ExecRestatementReasonEnums::VERBAL_CHANGE,
& ExecRestatementReasonEnums::REPRICING_OF_ORDER,
& ExecRestatementReasonEnums::BROKER_OPTION,
& ExecRestatementReasonEnums::PARTIAL_DECLINE_OF_ORDERQTY,
& ExecRestatementReasonEnums::CANCEL_ON_TRADING_HALT,
& ExecRestatementReasonEnums::CANCEL_ON_SYSTEM_FAILURE,
& ExecRestatementReasonEnums::MARKET,
& ExecRestatementReasonEnums::CANCELED_NOT_BEST,
& ExecRestatementReasonEnums::WAREHOUSE_RECAP,
& ExecRestatementReasonEnums::OTHER,
nullptr };

const char * BusinessRejectReasonEnums::getFieldName() const { return FixBusinessRejectReason; }
const FieldEnumBase * BusinessRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BusinessRejectReasonEnums::ValueType * BusinessRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BusinessRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BusinessRejectReasonEnums::getEnumMapByRaw() const { return BusinessRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** BusinessRejectReasonEnums::getEnums() const { return items; }
const BusinessRejectReasonEnums BusinessRejectReasonEnums::instance;
const FieldEnumBase * BusinessRejectReasonEnums::items[] = {
& BusinessRejectReasonEnums::OTHER,
& BusinessRejectReasonEnums::UNKOWN_ID,
& BusinessRejectReasonEnums::UNKNOWN_SECURITY,
& BusinessRejectReasonEnums::UNSUPPORTED_MESSAGE_TYPE,
& BusinessRejectReasonEnums::APPLICATION_NOT_AVAILABLE,
& BusinessRejectReasonEnums::CONDITIONALLY_REQUIRED_FIELD_MISSING,
& BusinessRejectReasonEnums::NOT_AUTHORIZED,
& BusinessRejectReasonEnums::DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME,
nullptr };

const char * MsgDirectionEnums::getFieldName() const { return FixMsgDirection; }
const FieldEnumBase * MsgDirectionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MsgDirectionEnums::ValueType * MsgDirectionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MsgDirectionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MsgDirectionEnums::getEnumMapByRaw() const { return MsgDirectionEnums::itemByRaw; }
const FieldEnumBase ** MsgDirectionEnums::getEnums() const { return items; }
const MsgDirectionEnums MsgDirectionEnums::instance;
const FieldEnumBase * MsgDirectionEnums::items[] = {
& MsgDirectionEnums::SEND,
& MsgDirectionEnums::RECEIVE,
nullptr };

const char * DiscretionInstEnums::getFieldName() const { return FixDiscretionInst; }
const FieldEnumBase * DiscretionInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionInstEnums::ValueType * DiscretionInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionInstEnums::getEnumMapByRaw() const { return DiscretionInstEnums::itemByRaw; }
const FieldEnumBase ** DiscretionInstEnums::getEnums() const { return items; }
const DiscretionInstEnums DiscretionInstEnums::instance;
const FieldEnumBase * DiscretionInstEnums::items[] = {
& DiscretionInstEnums::RELATED_TO_DISPLAYED_PRICE,
& DiscretionInstEnums::RELATED_TO_MARKET_PRICE,
& DiscretionInstEnums::RELATED_TO_PRIMARY_PRICE,
& DiscretionInstEnums::RELATED_TO_LOCAL_PRIMARY_PRICE,
& DiscretionInstEnums::RELATED_TO_MIDPOINT_PRICE,
& DiscretionInstEnums::RELATED_TO_LAST_TRADE_PRICE,
& DiscretionInstEnums::RELATED_TO_VWAP,
nullptr };

const char * BidTypeEnums::getFieldName() const { return FixBidType; }
const FieldEnumBase * BidTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BidTypeEnums::ValueType * BidTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BidTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BidTypeEnums::getEnumMapByRaw() const { return BidTypeEnums::itemByRaw; }
const FieldEnumBase ** BidTypeEnums::getEnums() const { return items; }
const BidTypeEnums BidTypeEnums::instance;
const FieldEnumBase * BidTypeEnums::items[] = {
& BidTypeEnums::NON_DISCLOSED_STYLE,
& BidTypeEnums::DISCLOSED_STYLE,
& BidTypeEnums::NO_BIDDING_PROCESS,
nullptr };

const char * BidDescriptorTypeEnums::getFieldName() const { return FixBidDescriptorType; }
const FieldEnumBase * BidDescriptorTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BidDescriptorTypeEnums::ValueType * BidDescriptorTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BidDescriptorTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BidDescriptorTypeEnums::getEnumMapByRaw() const { return BidDescriptorTypeEnums::itemByRaw; }
const FieldEnumBase ** BidDescriptorTypeEnums::getEnums() const { return items; }
const BidDescriptorTypeEnums BidDescriptorTypeEnums::instance;
const FieldEnumBase * BidDescriptorTypeEnums::items[] = {
& BidDescriptorTypeEnums::SECTOR,
& BidDescriptorTypeEnums::COUNTRY,
& BidDescriptorTypeEnums::INDEX,
nullptr };

const char * SideValueIndEnums::getFieldName() const { return FixSideValueInd; }
const FieldEnumBase * SideValueIndEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SideValueIndEnums::ValueType * SideValueIndEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SideValueIndEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SideValueIndEnums::getEnumMapByRaw() const { return SideValueIndEnums::itemByRaw; }
const FieldEnumBase ** SideValueIndEnums::getEnums() const { return items; }
const SideValueIndEnums SideValueIndEnums::instance;
const FieldEnumBase * SideValueIndEnums::items[] = {
& SideValueIndEnums::SIDEVALUE1,
& SideValueIndEnums::SIDEVALUE_2,
nullptr };

const char * LiquidityIndTypeEnums::getFieldName() const { return FixLiquidityIndType; }
const FieldEnumBase * LiquidityIndTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LiquidityIndTypeEnums::ValueType * LiquidityIndTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LiquidityIndTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LiquidityIndTypeEnums::getEnumMapByRaw() const { return LiquidityIndTypeEnums::itemByRaw; }
const FieldEnumBase ** LiquidityIndTypeEnums::getEnums() const { return items; }
const LiquidityIndTypeEnums LiquidityIndTypeEnums::instance;
const FieldEnumBase * LiquidityIndTypeEnums::items[] = {
& LiquidityIndTypeEnums::_5DAY_MOVING_AVERAGE,
& LiquidityIndTypeEnums::_20_DAY_MOVING_AVERAGE,
& LiquidityIndTypeEnums::NORMAL_MARKET_SIZE,
& LiquidityIndTypeEnums::OTHER,
nullptr };

const char * ExchangeForPhysicalEnums::getFieldName() const { return FixExchangeForPhysical; }
const FieldEnumBase * ExchangeForPhysicalEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExchangeForPhysicalEnums::ValueType * ExchangeForPhysicalEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExchangeForPhysicalEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExchangeForPhysicalEnums::getEnumMapByRaw() const { return ExchangeForPhysicalEnums::itemByRaw; }
const FieldEnumBase ** ExchangeForPhysicalEnums::getEnums() const { return items; }
const ExchangeForPhysicalEnums ExchangeForPhysicalEnums::instance;
const FieldEnumBase * ExchangeForPhysicalEnums::items[] = {
& ExchangeForPhysicalEnums::YES,
& ExchangeForPhysicalEnums::NO,
nullptr };

const char * ProgRptReqsEnums::getFieldName() const { return FixProgRptReqs; }
const FieldEnumBase * ProgRptReqsEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ProgRptReqsEnums::ValueType * ProgRptReqsEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ProgRptReqsEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ProgRptReqsEnums::getEnumMapByRaw() const { return ProgRptReqsEnums::itemByRaw; }
const FieldEnumBase ** ProgRptReqsEnums::getEnums() const { return items; }
const ProgRptReqsEnums ProgRptReqsEnums::instance;
const FieldEnumBase * ProgRptReqsEnums::items[] = {
& ProgRptReqsEnums::BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST,
& ProgRptReqsEnums::SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_PERIOD_OPTIONALLY_SPECIFIED_IN_PROGRESSPERIOD,
& ProgRptReqsEnums::REAL_TIME_EXECUTION_REPORTS,
nullptr };

const char * IncTaxIndEnums::getFieldName() const { return FixIncTaxInd; }
const FieldEnumBase * IncTaxIndEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const IncTaxIndEnums::ValueType * IncTaxIndEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * IncTaxIndEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & IncTaxIndEnums::getEnumMapByRaw() const { return IncTaxIndEnums::itemByRaw; }
const FieldEnumBase ** IncTaxIndEnums::getEnums() const { return items; }
const IncTaxIndEnums IncTaxIndEnums::instance;
const FieldEnumBase * IncTaxIndEnums::items[] = {
& IncTaxIndEnums::NET,
& IncTaxIndEnums::GROSS,
nullptr };

const char * BidTradeTypeEnums::getFieldName() const { return FixBidTradeType; }
const FieldEnumBase * BidTradeTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BidTradeTypeEnums::ValueType * BidTradeTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BidTradeTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BidTradeTypeEnums::getEnumMapByRaw() const { return BidTradeTypeEnums::itemByRaw; }
const FieldEnumBase ** BidTradeTypeEnums::getEnums() const { return items; }
const BidTradeTypeEnums BidTradeTypeEnums::instance;
const FieldEnumBase * BidTradeTypeEnums::items[] = {
& BidTradeTypeEnums::RISK_TRADE,
& BidTradeTypeEnums::VWAP_GUARANTEE,
& BidTradeTypeEnums::AGENCY,
& BidTradeTypeEnums::GUARANTEED_CLOSE,
nullptr };

const char * BasisPxTypeEnums::getFieldName() const { return FixBasisPxType; }
const FieldEnumBase * BasisPxTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BasisPxTypeEnums::ValueType * BasisPxTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BasisPxTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BasisPxTypeEnums::getEnumMapByRaw() const { return BasisPxTypeEnums::itemByRaw; }
const FieldEnumBase ** BasisPxTypeEnums::getEnums() const { return items; }
const BasisPxTypeEnums BasisPxTypeEnums::instance;
const FieldEnumBase * BasisPxTypeEnums::items[] = {
& BasisPxTypeEnums::CLOSING_PRICE_AT_MORNING_SESSION,
& BasisPxTypeEnums::CLOSING_PRICE,
& BasisPxTypeEnums::CURRENT_PRICE,
& BasisPxTypeEnums::SQ,
& BasisPxTypeEnums::VWAP_THROUGH_A_DAY,
& BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION,
& BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION,
& BasisPxTypeEnums::VWAP_THROUGH_A_DAY_EXCEPT_YORI,
& BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI,
& BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI,
& BasisPxTypeEnums::STRIKE,
& BasisPxTypeEnums::OPEN,
& BasisPxTypeEnums::OTHERS,
nullptr };

const char * PriceTypeEnums::getFieldName() const { return FixPriceType; }
const FieldEnumBase * PriceTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PriceTypeEnums::ValueType * PriceTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PriceTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PriceTypeEnums::getEnumMapByRaw() const { return PriceTypeEnums::itemByRaw; }
const FieldEnumBase ** PriceTypeEnums::getEnums() const { return items; }
const PriceTypeEnums PriceTypeEnums::instance;
const FieldEnumBase * PriceTypeEnums::items[] = {
& PriceTypeEnums::PERCENTAGE,
& PriceTypeEnums::PER_UNIT,
& PriceTypeEnums::FIXED_AMOUNT,
& PriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR,
& PriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR,
& PriceTypeEnums::SPREAD,
& PriceTypeEnums::TED_PRICE,
& PriceTypeEnums::TED_YIELD,
& PriceTypeEnums::YIELD,
& PriceTypeEnums::FIXED_CABINET_TRADE_PRICE,
& PriceTypeEnums::VARIABLE_CABINET_TRADE_PRICE,
nullptr };

const char * GTBookingInstEnums::getFieldName() const { return FixGTBookingInst; }
const FieldEnumBase * GTBookingInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const GTBookingInstEnums::ValueType * GTBookingInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * GTBookingInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & GTBookingInstEnums::getEnumMapByRaw() const { return GTBookingInstEnums::itemByRaw; }
const FieldEnumBase ** GTBookingInstEnums::getEnums() const { return items; }
const GTBookingInstEnums GTBookingInstEnums::instance;
const FieldEnumBase * GTBookingInstEnums::items[] = {
& GTBookingInstEnums::BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION,
& GTBookingInstEnums::ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES,
& GTBookingInstEnums::ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE,
nullptr };

const char * ListStatusTypeEnums::getFieldName() const { return FixListStatusType; }
const FieldEnumBase * ListStatusTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ListStatusTypeEnums::ValueType * ListStatusTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ListStatusTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ListStatusTypeEnums::getEnumMapByRaw() const { return ListStatusTypeEnums::itemByRaw; }
const FieldEnumBase ** ListStatusTypeEnums::getEnums() const { return items; }
const ListStatusTypeEnums ListStatusTypeEnums::instance;
const FieldEnumBase * ListStatusTypeEnums::items[] = {
& ListStatusTypeEnums::ACK,
& ListStatusTypeEnums::RESPONSE,
& ListStatusTypeEnums::TIMED,
& ListStatusTypeEnums::EXECSTARTED,
& ListStatusTypeEnums::ALLDONE,
& ListStatusTypeEnums::ALERT,
nullptr };

const char * NetGrossIndEnums::getFieldName() const { return FixNetGrossInd; }
const FieldEnumBase * NetGrossIndEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const NetGrossIndEnums::ValueType * NetGrossIndEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * NetGrossIndEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & NetGrossIndEnums::getEnumMapByRaw() const { return NetGrossIndEnums::itemByRaw; }
const FieldEnumBase ** NetGrossIndEnums::getEnums() const { return items; }
const NetGrossIndEnums NetGrossIndEnums::instance;
const FieldEnumBase * NetGrossIndEnums::items[] = {
& NetGrossIndEnums::NET,
& NetGrossIndEnums::GROSS,
nullptr };

const char * ListOrderStatusEnums::getFieldName() const { return FixListOrderStatus; }
const FieldEnumBase * ListOrderStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ListOrderStatusEnums::ValueType * ListOrderStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ListOrderStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ListOrderStatusEnums::getEnumMapByRaw() const { return ListOrderStatusEnums::itemByRaw; }
const FieldEnumBase ** ListOrderStatusEnums::getEnums() const { return items; }
const ListOrderStatusEnums ListOrderStatusEnums::instance;
const FieldEnumBase * ListOrderStatusEnums::items[] = {
& ListOrderStatusEnums::INBIDDINGPROCESS,
& ListOrderStatusEnums::RECEIVEDFOREXECUTION,
& ListOrderStatusEnums::EXECUTING,
& ListOrderStatusEnums::CANCELING,
& ListOrderStatusEnums::ALERT,
& ListOrderStatusEnums::ALL_DONE,
& ListOrderStatusEnums::REJECT,
nullptr };

const char * ListExecInstTypeEnums::getFieldName() const { return FixListExecInstType; }
const FieldEnumBase * ListExecInstTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ListExecInstTypeEnums::ValueType * ListExecInstTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ListExecInstTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ListExecInstTypeEnums::getEnumMapByRaw() const { return ListExecInstTypeEnums::itemByRaw; }
const FieldEnumBase ** ListExecInstTypeEnums::getEnums() const { return items; }
const ListExecInstTypeEnums ListExecInstTypeEnums::instance;
const FieldEnumBase * ListExecInstTypeEnums::items[] = {
& ListExecInstTypeEnums::IMMEDIATE,
& ListExecInstTypeEnums::WAIT_FOR_EXECUTE_INSTRUCTION,
& ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN,
& ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP,
& ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW,
nullptr };

const char * CxlRejResponseToEnums::getFieldName() const { return FixCxlRejResponseTo; }
const FieldEnumBase * CxlRejResponseToEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CxlRejResponseToEnums::ValueType * CxlRejResponseToEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CxlRejResponseToEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CxlRejResponseToEnums::getEnumMapByRaw() const { return CxlRejResponseToEnums::itemByRaw; }
const FieldEnumBase ** CxlRejResponseToEnums::getEnums() const { return items; }
const CxlRejResponseToEnums CxlRejResponseToEnums::instance;
const FieldEnumBase * CxlRejResponseToEnums::items[] = {
& CxlRejResponseToEnums::ORDER_CANCEL_REQUEST,
& CxlRejResponseToEnums::ORDER_CANCEL_REPLACE_REQUEST,
nullptr };

const char * MultiLegReportingTypeEnums::getFieldName() const { return FixMultiLegReportingType; }
const FieldEnumBase * MultiLegReportingTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MultiLegReportingTypeEnums::ValueType * MultiLegReportingTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MultiLegReportingTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MultiLegReportingTypeEnums::getEnumMapByRaw() const { return MultiLegReportingTypeEnums::itemByRaw; }
const FieldEnumBase ** MultiLegReportingTypeEnums::getEnums() const { return items; }
const MultiLegReportingTypeEnums MultiLegReportingTypeEnums::instance;
const FieldEnumBase * MultiLegReportingTypeEnums::items[] = {
& MultiLegReportingTypeEnums::SINGLE_SECURITY,
& MultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY,
& MultiLegReportingTypeEnums::MULTI_LEG_SECURITY,
nullptr };

const char * PartyIDSourceEnums::getFieldName() const { return FixPartyIDSource; }
const FieldEnumBase * PartyIDSourceEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PartyIDSourceEnums::ValueType * PartyIDSourceEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PartyIDSourceEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PartyIDSourceEnums::getEnumMapByRaw() const { return PartyIDSourceEnums::itemByRaw; }
const FieldEnumBase ** PartyIDSourceEnums::getEnums() const { return items; }
const PartyIDSourceEnums PartyIDSourceEnums::instance;
const FieldEnumBase * PartyIDSourceEnums::items[] = {
& PartyIDSourceEnums::BIC,
& PartyIDSourceEnums::GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER,
& PartyIDSourceEnums::PROPRIETARY_CUSTOM_CODE,
& PartyIDSourceEnums::ISO_COUNTRY_CODE,
& PartyIDSourceEnums::SETTLEMENT_ENTITY_LOCATION,
& PartyIDSourceEnums::MIC,
& PartyIDSourceEnums::CSD_PARTICIPANT_MEMBER_CODE,
& PartyIDSourceEnums::KOREAN_INVESTOR_ID,
& PartyIDSourceEnums::TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII,
& PartyIDSourceEnums::TAIWANESE_TRADING_ACCOUNT,
& PartyIDSourceEnums::MALAYSIAN_CENTRAL_DEPOSITORY,
& PartyIDSourceEnums::CHINESE_B_SHARE,
& PartyIDSourceEnums::UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER,
& PartyIDSourceEnums::US_SOCIAL_SECURITY_NUMBER,
& PartyIDSourceEnums::US_EMPLOYER_IDENTIFICATION_NUMBER,
& PartyIDSourceEnums::AUSTRALIAN_BUSINESS_NUMBER,
& PartyIDSourceEnums::AUSTRALIAN_TAX_FILE_NUMBER,
& PartyIDSourceEnums::DIRECTED_BROKER_THREE_CHARACTER_ACRONYM_AS_DEFINED_IN_ISITC_ETC_BEST_PRACTICE_GUIDELINES_DOCUMENT,
nullptr };

const char * PartyRoleEnums::getFieldName() const { return FixPartyRole; }
const FieldEnumBase * PartyRoleEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PartyRoleEnums::ValueType * PartyRoleEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PartyRoleEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PartyRoleEnums::getEnumMapByRaw() const { return PartyRoleEnums::itemByRaw; }
const FieldEnumBase ** PartyRoleEnums::getEnums() const { return items; }
const PartyRoleEnums PartyRoleEnums::instance;
const FieldEnumBase * PartyRoleEnums::items[] = {
& PartyRoleEnums::EXECUTING_FIRM,
& PartyRoleEnums::BROKER_OF_CREDIT,
& PartyRoleEnums::CLIENT_ID,
& PartyRoleEnums::CLEARING_FIRM,
& PartyRoleEnums::INVESTOR_ID,
& PartyRoleEnums::INTRODUCING_FIRM,
& PartyRoleEnums::ENTERING_FIRM,
& PartyRoleEnums::LOCATE_LENDING_FIRM,
& PartyRoleEnums::FUND_MANAGER_CLIENT_ID,
& PartyRoleEnums::SETTLEMENT_LOCATION,
& PartyRoleEnums::ORDER_ORIGINATION_TRADER,
& PartyRoleEnums::EXECUTING_TRADER,
& PartyRoleEnums::ORDER_ORIGINATION_FIRM,
& PartyRoleEnums::GIVEUP_CLEARING_FIRM,
& PartyRoleEnums::CORRESPONDANT_CLEARING_FIRM,
& PartyRoleEnums::EXECUTING_SYSTEM,
& PartyRoleEnums::CONTRA_FIRM,
& PartyRoleEnums::CONTRA_CLEARING_FIRM,
& PartyRoleEnums::SPONSORING_FIRM,
& PartyRoleEnums::UNDERLYING_CONTRA_FIRM,
& PartyRoleEnums::CLEARING_ORGANIZATION,
& PartyRoleEnums::EXCHANGE,
& PartyRoleEnums::CUSTOMER_ACCOUNT,
& PartyRoleEnums::CORRESPONDENT_CLEARING_ORGANIZATION,
& PartyRoleEnums::CORRESPONDENT_BROKER,
& PartyRoleEnums::BUYER_SELLER,
& PartyRoleEnums::CUSTODIAN,
& PartyRoleEnums::INTERMEDIARY,
& PartyRoleEnums::AGENT,
& PartyRoleEnums::SUB_CUSTODIAN,
& PartyRoleEnums::BENEFICIARY,
& PartyRoleEnums::INTERESTED_PARTY,
& PartyRoleEnums::REGULATORY_BODY,
& PartyRoleEnums::LIQUIDITY_PROVIDER,
& PartyRoleEnums::ENTERING_TRADER,
& PartyRoleEnums::CONTRA_TRADER,
& PartyRoleEnums::POSITION_ACCOUNT,
nullptr };

const char * ProductEnums::getFieldName() const { return FixProduct; }
const FieldEnumBase * ProductEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ProductEnums::ValueType * ProductEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ProductEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ProductEnums::getEnumMapByRaw() const { return ProductEnums::itemByRaw; }
const FieldEnumBase ** ProductEnums::getEnums() const { return items; }
const ProductEnums ProductEnums::instance;
const FieldEnumBase * ProductEnums::items[] = {
& ProductEnums::AGENCY,
& ProductEnums::COMMODITY,
& ProductEnums::CORPORATE,
& ProductEnums::CURRENCY,
& ProductEnums::EQUITY,
& ProductEnums::GOVERNMENT,
& ProductEnums::INDEX,
& ProductEnums::LOAN,
& ProductEnums::MONEYMARKET,
& ProductEnums::MORTGAGE,
& ProductEnums::MUNICIPAL,
& ProductEnums::OTHER,
& ProductEnums::FINANCING,
nullptr };

const char * TestMessageIndicatorEnums::getFieldName() const { return FixTestMessageIndicator; }
const FieldEnumBase * TestMessageIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TestMessageIndicatorEnums::ValueType * TestMessageIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TestMessageIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TestMessageIndicatorEnums::getEnumMapByRaw() const { return TestMessageIndicatorEnums::itemByRaw; }
const FieldEnumBase ** TestMessageIndicatorEnums::getEnums() const { return items; }
const TestMessageIndicatorEnums TestMessageIndicatorEnums::instance;
const FieldEnumBase * TestMessageIndicatorEnums::items[] = {
& TestMessageIndicatorEnums::YES,
& TestMessageIndicatorEnums::NO,
nullptr };

const char * RoundingDirectionEnums::getFieldName() const { return FixRoundingDirection; }
const FieldEnumBase * RoundingDirectionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const RoundingDirectionEnums::ValueType * RoundingDirectionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * RoundingDirectionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & RoundingDirectionEnums::getEnumMapByRaw() const { return RoundingDirectionEnums::itemByRaw; }
const FieldEnumBase ** RoundingDirectionEnums::getEnums() const { return items; }
const RoundingDirectionEnums RoundingDirectionEnums::instance;
const FieldEnumBase * RoundingDirectionEnums::items[] = {
& RoundingDirectionEnums::ROUND_TO_NEAREST,
& RoundingDirectionEnums::ROUND_DOWN,
& RoundingDirectionEnums::ROUND_UP,
nullptr };

const char * DistribPaymentMethodEnums::getFieldName() const { return FixDistribPaymentMethod; }
const FieldEnumBase * DistribPaymentMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DistribPaymentMethodEnums::ValueType * DistribPaymentMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DistribPaymentMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DistribPaymentMethodEnums::getEnumMapByRaw() const { return DistribPaymentMethodEnums::itemByRaw; }
const FieldEnumBase ** DistribPaymentMethodEnums::getEnums() const { return items; }
const DistribPaymentMethodEnums DistribPaymentMethodEnums::instance;
const FieldEnumBase * DistribPaymentMethodEnums::items[] = {
& DistribPaymentMethodEnums::CREST,
& DistribPaymentMethodEnums::NSCC,
& DistribPaymentMethodEnums::EUROCLEAR,
& DistribPaymentMethodEnums::CLEARSTREAM,
& DistribPaymentMethodEnums::CHEQUE,
& DistribPaymentMethodEnums::TELEGRAPHIC_TRANSFER,
& DistribPaymentMethodEnums::FEDWIRE,
& DistribPaymentMethodEnums::DIRECT_CREDIT,
& DistribPaymentMethodEnums::ACH_CREDIT,
& DistribPaymentMethodEnums::BPAY,
& DistribPaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM,
& DistribPaymentMethodEnums::REINVEST_IN_FUND,
nullptr };

const char * CancellationRightsEnums::getFieldName() const { return FixCancellationRights; }
const FieldEnumBase * CancellationRightsEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CancellationRightsEnums::ValueType * CancellationRightsEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CancellationRightsEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CancellationRightsEnums::getEnumMapByRaw() const { return CancellationRightsEnums::itemByRaw; }
const FieldEnumBase ** CancellationRightsEnums::getEnums() const { return items; }
const CancellationRightsEnums CancellationRightsEnums::instance;
const FieldEnumBase * CancellationRightsEnums::items[] = {
& CancellationRightsEnums::YES,
& CancellationRightsEnums::NO_EXECUTION_ONLY,
& CancellationRightsEnums::NO_WAIVER_AGREEMENT,
& CancellationRightsEnums::NO_INSTITUTIONAL,
nullptr };

const char * MoneyLaunderingStatusEnums::getFieldName() const { return FixMoneyLaunderingStatus; }
const FieldEnumBase * MoneyLaunderingStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MoneyLaunderingStatusEnums::ValueType * MoneyLaunderingStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MoneyLaunderingStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MoneyLaunderingStatusEnums::getEnumMapByRaw() const { return MoneyLaunderingStatusEnums::itemByRaw; }
const FieldEnumBase ** MoneyLaunderingStatusEnums::getEnums() const { return items; }
const MoneyLaunderingStatusEnums MoneyLaunderingStatusEnums::instance;
const FieldEnumBase * MoneyLaunderingStatusEnums::items[] = {
& MoneyLaunderingStatusEnums::PASSED,
& MoneyLaunderingStatusEnums::NOT_CHECKED,
& MoneyLaunderingStatusEnums::EXEMPT_BELOW_THE_LIMIT,
& MoneyLaunderingStatusEnums::EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION,
& MoneyLaunderingStatusEnums::EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION,
nullptr };

const char * ExecPriceTypeEnums::getFieldName() const { return FixExecPriceType; }
const FieldEnumBase * ExecPriceTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExecPriceTypeEnums::ValueType * ExecPriceTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExecPriceTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExecPriceTypeEnums::getEnumMapByRaw() const { return ExecPriceTypeEnums::itemByRaw; }
const FieldEnumBase ** ExecPriceTypeEnums::getEnums() const { return items; }
const ExecPriceTypeEnums ExecPriceTypeEnums::instance;
const FieldEnumBase * ExecPriceTypeEnums::items[] = {
& ExecPriceTypeEnums::BID_PRICE,
& ExecPriceTypeEnums::CREATION_PRICE,
& ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT,
& ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT,
& ExecPriceTypeEnums::OFFER_PRICE,
& ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT,
& ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT,
& ExecPriceTypeEnums::SINGLE_PRICE,
nullptr };

const char * PaymentMethodEnums::getFieldName() const { return FixPaymentMethod; }
const FieldEnumBase * PaymentMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PaymentMethodEnums::ValueType * PaymentMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PaymentMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PaymentMethodEnums::getEnumMapByRaw() const { return PaymentMethodEnums::itemByRaw; }
const FieldEnumBase ** PaymentMethodEnums::getEnums() const { return items; }
const PaymentMethodEnums PaymentMethodEnums::instance;
const FieldEnumBase * PaymentMethodEnums::items[] = {
& PaymentMethodEnums::CREST,
& PaymentMethodEnums::NSCC,
& PaymentMethodEnums::EUROCLEAR,
& PaymentMethodEnums::CLEARSTREAM,
& PaymentMethodEnums::CHEQUE,
& PaymentMethodEnums::TELEGRAPHIC_TRANSFER,
& PaymentMethodEnums::FEDWIRE,
& PaymentMethodEnums::DEBIT_CARD,
& PaymentMethodEnums::DIRECT_DEBIT,
& PaymentMethodEnums::DIRECT_CREDIT,
& PaymentMethodEnums::CREDIT_CARD,
& PaymentMethodEnums::ACH_DEBIT,
& PaymentMethodEnums::ACH_CREDIT,
& PaymentMethodEnums::BPAY,
& PaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM,
nullptr };

const char * TaxAdvantageTypeEnums::getFieldName() const { return FixTaxAdvantageType; }
const FieldEnumBase * TaxAdvantageTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TaxAdvantageTypeEnums::ValueType * TaxAdvantageTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TaxAdvantageTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TaxAdvantageTypeEnums::getEnumMapByRaw() const { return TaxAdvantageTypeEnums::itemByRaw; }
const FieldEnumBase ** TaxAdvantageTypeEnums::getEnums() const { return items; }
const TaxAdvantageTypeEnums TaxAdvantageTypeEnums::instance;
const FieldEnumBase * TaxAdvantageTypeEnums::items[] = {
& TaxAdvantageTypeEnums::NONE_NOT_APPLICABLE,
& TaxAdvantageTypeEnums::MAXI_ISA,
& TaxAdvantageTypeEnums::TESSA,
& TaxAdvantageTypeEnums::MINI_CASH_ISA,
& TaxAdvantageTypeEnums::MINI_STOCKS_AND_SHARES_ISA,
& TaxAdvantageTypeEnums::MINI_INSURANCE_ISA,
& TaxAdvantageTypeEnums::CURRENT_YEAR_PAYMENT,
& TaxAdvantageTypeEnums::PRIOR_YEAR_PAYMENT,
& TaxAdvantageTypeEnums::ASSET_TRANSFER,
& TaxAdvantageTypeEnums::EMPLOYEE,
& TaxAdvantageTypeEnums::EMPLOYEE_CURRENT_YEAR,
& TaxAdvantageTypeEnums::EMPLOYER,
& TaxAdvantageTypeEnums::EMPLOYER_CURRENT_YEAR,
& TaxAdvantageTypeEnums::NON_FUND_PROTOTYPE_IRA,
& TaxAdvantageTypeEnums::NON_FUND_QUALIFIED_PLAN,
& TaxAdvantageTypeEnums::DEFINED_CONTRIBUTION_PLAN,
& TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT,
& TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT_ROLLOVER,
& TaxAdvantageTypeEnums::KEOGH,
& TaxAdvantageTypeEnums::PROFIT_SHARING_PLAN,
& TaxAdvantageTypeEnums::_401K,
& TaxAdvantageTypeEnums::SELF_DIRECTED_IRA,
& TaxAdvantageTypeEnums::_403,
& TaxAdvantageTypeEnums::_457,
& TaxAdvantageTypeEnums::ROTH_IRA_24,
& TaxAdvantageTypeEnums::ROTH_IRA_25,
& TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_26,
& TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_27,
& TaxAdvantageTypeEnums::EDUCATION_IRA_28,
& TaxAdvantageTypeEnums::EDUCATION_IRA_29,
nullptr };

const char * FundRenewWaivEnums::getFieldName() const { return FixFundRenewWaiv; }
const FieldEnumBase * FundRenewWaivEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const FundRenewWaivEnums::ValueType * FundRenewWaivEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * FundRenewWaivEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & FundRenewWaivEnums::getEnumMapByRaw() const { return FundRenewWaivEnums::itemByRaw; }
const FieldEnumBase ** FundRenewWaivEnums::getEnums() const { return items; }
const FundRenewWaivEnums FundRenewWaivEnums::instance;
const FieldEnumBase * FundRenewWaivEnums::items[] = {
& FundRenewWaivEnums::YES,
& FundRenewWaivEnums::NO,
nullptr };

const char * RegistStatusEnums::getFieldName() const { return FixRegistStatus; }
const FieldEnumBase * RegistStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const RegistStatusEnums::ValueType * RegistStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * RegistStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & RegistStatusEnums::getEnumMapByRaw() const { return RegistStatusEnums::itemByRaw; }
const FieldEnumBase ** RegistStatusEnums::getEnums() const { return items; }
const RegistStatusEnums RegistStatusEnums::instance;
const FieldEnumBase * RegistStatusEnums::items[] = {
& RegistStatusEnums::ACCEPTED,
& RegistStatusEnums::REJECTED,
& RegistStatusEnums::HELD,
& RegistStatusEnums::REMINDER_IE_REGISTRATION_INSTRUCTIONS_ARE_STILL_OUTSTANDING,
nullptr };

const char * RegistRejReasonCodeEnums::getFieldName() const { return FixRegistRejReasonCode; }
const FieldEnumBase * RegistRejReasonCodeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const RegistRejReasonCodeEnums::ValueType * RegistRejReasonCodeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * RegistRejReasonCodeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & RegistRejReasonCodeEnums::getEnumMapByRaw() const { return RegistRejReasonCodeEnums::itemByRaw; }
const FieldEnumBase ** RegistRejReasonCodeEnums::getEnums() const { return items; }
const RegistRejReasonCodeEnums RegistRejReasonCodeEnums::instance;
const FieldEnumBase * RegistRejReasonCodeEnums::items[] = {
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_ACCOUNT_TYPE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_OWNERSHIP_TYPE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NO_REG_DETLS,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_SEQ_NO,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_DTLS,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_DTLS,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_INST,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DATE_OF_BIRTH,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NODISTRIBINSTNS,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE,
& RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM,
& RegistRejReasonCodeEnums::OTHER,
nullptr };

const char * RegistTransTypeEnums::getFieldName() const { return FixRegistTransType; }
const FieldEnumBase * RegistTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const RegistTransTypeEnums::ValueType * RegistTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * RegistTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & RegistTransTypeEnums::getEnumMapByRaw() const { return RegistTransTypeEnums::itemByRaw; }
const FieldEnumBase ** RegistTransTypeEnums::getEnums() const { return items; }
const RegistTransTypeEnums RegistTransTypeEnums::instance;
const FieldEnumBase * RegistTransTypeEnums::items[] = {
& RegistTransTypeEnums::NEW,
& RegistTransTypeEnums::REPLACE,
& RegistTransTypeEnums::CANCEL,
nullptr };

const char * OwnershipTypeEnums::getFieldName() const { return FixOwnershipType; }
const FieldEnumBase * OwnershipTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OwnershipTypeEnums::ValueType * OwnershipTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OwnershipTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OwnershipTypeEnums::getEnumMapByRaw() const { return OwnershipTypeEnums::itemByRaw; }
const FieldEnumBase ** OwnershipTypeEnums::getEnums() const { return items; }
const OwnershipTypeEnums OwnershipTypeEnums::instance;
const FieldEnumBase * OwnershipTypeEnums::items[] = {
& OwnershipTypeEnums::JOINT_INVESTORS,
& OwnershipTypeEnums::TENANTS_IN_COMMON,
& OwnershipTypeEnums::JOINT_TRUSTEES,
nullptr };

const char * ContAmtTypeEnums::getFieldName() const { return FixContAmtType; }
const FieldEnumBase * ContAmtTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ContAmtTypeEnums::ValueType * ContAmtTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ContAmtTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ContAmtTypeEnums::getEnumMapByRaw() const { return ContAmtTypeEnums::itemByRaw; }
const FieldEnumBase ** ContAmtTypeEnums::getEnums() const { return items; }
const ContAmtTypeEnums ContAmtTypeEnums::instance;
const FieldEnumBase * ContAmtTypeEnums::items[] = {
& ContAmtTypeEnums::COMMISSION_AMOUNT,
& ContAmtTypeEnums::COMMISSION,
& ContAmtTypeEnums::INITIAL_CHARGE_AMOUNT,
& ContAmtTypeEnums::INITIAL_CHARGE,
& ContAmtTypeEnums::DISCOUNT_AMOUNT,
& ContAmtTypeEnums::DISCOUNT,
& ContAmtTypeEnums::DILUTION_LEVY_AMOUNT,
& ContAmtTypeEnums::DILUTION_LEVY,
& ContAmtTypeEnums::EXIT_CHARGE_AMOUNT,
& ContAmtTypeEnums::EXIT_CHARGE,
& ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION,
& ContAmtTypeEnums::PROJECTED_FUND_VALUE,
& ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_13,
& ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_14,
& ContAmtTypeEnums::NET_SETTLEMENT_AMOUNT,
nullptr };

const char * OwnerTypeEnums::getFieldName() const { return FixOwnerType; }
const FieldEnumBase * OwnerTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OwnerTypeEnums::ValueType * OwnerTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OwnerTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OwnerTypeEnums::getEnumMapByRaw() const { return OwnerTypeEnums::itemByRaw; }
const FieldEnumBase ** OwnerTypeEnums::getEnums() const { return items; }
const OwnerTypeEnums OwnerTypeEnums::instance;
const FieldEnumBase * OwnerTypeEnums::items[] = {
& OwnerTypeEnums::INDIVIDUAL_INVESTOR,
& OwnerTypeEnums::PUBLIC_COMPANY,
& OwnerTypeEnums::PRIVATE_COMPANY,
& OwnerTypeEnums::INDIVIDUAL_TRUSTEE,
& OwnerTypeEnums::COMPANY_TRUSTEE,
& OwnerTypeEnums::PENSION_PLAN,
& OwnerTypeEnums::CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT,
& OwnerTypeEnums::TRUSTS,
& OwnerTypeEnums::FIDUCIARIES,
& OwnerTypeEnums::NETWORKING_SUB_ACCOUNT,
& OwnerTypeEnums::NON_PROFIT_ORGANIZATION,
& OwnerTypeEnums::CORPORATE_BODY,
& OwnerTypeEnums::NOMINEE,
nullptr };

const char * OrderCapacityEnums::getFieldName() const { return FixOrderCapacity; }
const FieldEnumBase * OrderCapacityEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OrderCapacityEnums::ValueType * OrderCapacityEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OrderCapacityEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OrderCapacityEnums::getEnumMapByRaw() const { return OrderCapacityEnums::itemByRaw; }
const FieldEnumBase ** OrderCapacityEnums::getEnums() const { return items; }
const OrderCapacityEnums OrderCapacityEnums::instance;
const FieldEnumBase * OrderCapacityEnums::items[] = {
& OrderCapacityEnums::AGENCY,
& OrderCapacityEnums::PROPRIETARY,
& OrderCapacityEnums::INDIVIDUAL,
& OrderCapacityEnums::PRINCIPAL,
& OrderCapacityEnums::RISKLESS_PRINCIPAL,
& OrderCapacityEnums::AGENT_FOR_OTHER_MEMBER,
nullptr };

const char * OrderRestrictionsEnums::getFieldName() const { return FixOrderRestrictions; }
const FieldEnumBase * OrderRestrictionsEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OrderRestrictionsEnums::ValueType * OrderRestrictionsEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OrderRestrictionsEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OrderRestrictionsEnums::getEnumMapByRaw() const { return OrderRestrictionsEnums::itemByRaw; }
const FieldEnumBase ** OrderRestrictionsEnums::getEnums() const { return items; }
const OrderRestrictionsEnums OrderRestrictionsEnums::instance;
const FieldEnumBase * OrderRestrictionsEnums::items[] = {
& OrderRestrictionsEnums::PROGRAM_TRADE,
& OrderRestrictionsEnums::INDEX_ARBITRAGE,
& OrderRestrictionsEnums::NON_INDEX_ARBITRAGE,
& OrderRestrictionsEnums::COMPETING_MARKET_MAKER,
& OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY,
& OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY,
& OrderRestrictionsEnums::FOREIGN_ENTITY,
& OrderRestrictionsEnums::EXTERNAL_MARKET_PARTICIPANT,
& OrderRestrictionsEnums::EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE,
& OrderRestrictionsEnums::RISKLESS_ARBITRAGE,
nullptr };

const char * MassCancelRequestTypeEnums::getFieldName() const { return FixMassCancelRequestType; }
const FieldEnumBase * MassCancelRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MassCancelRequestTypeEnums::ValueType * MassCancelRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MassCancelRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MassCancelRequestTypeEnums::getEnumMapByRaw() const { return MassCancelRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** MassCancelRequestTypeEnums::getEnums() const { return items; }
const MassCancelRequestTypeEnums MassCancelRequestTypeEnums::instance;
const FieldEnumBase * MassCancelRequestTypeEnums::items[] = {
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITY,
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY,
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_PRODUCT,
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_CFICODE,
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE,
& MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION,
& MassCancelRequestTypeEnums::CANCEL_ALL_ORDERS,
nullptr };

const char * MassCancelResponseEnums::getFieldName() const { return FixMassCancelResponse; }
const FieldEnumBase * MassCancelResponseEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MassCancelResponseEnums::ValueType * MassCancelResponseEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MassCancelResponseEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MassCancelResponseEnums::getEnumMapByRaw() const { return MassCancelResponseEnums::itemByRaw; }
const FieldEnumBase ** MassCancelResponseEnums::getEnums() const { return items; }
const MassCancelResponseEnums MassCancelResponseEnums::instance;
const FieldEnumBase * MassCancelResponseEnums::items[] = {
& MassCancelResponseEnums::CANCEL_REQUEST_REJECTED,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITY,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_PRODUCT,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_CFICODE,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE,
& MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION,
& MassCancelResponseEnums::CANCEL_ALL_ORDERS,
nullptr };

const char * MassCancelRejectReasonEnums::getFieldName() const { return FixMassCancelRejectReason; }
const FieldEnumBase * MassCancelRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MassCancelRejectReasonEnums::ValueType * MassCancelRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MassCancelRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MassCancelRejectReasonEnums::getEnumMapByRaw() const { return MassCancelRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** MassCancelRejectReasonEnums::getEnums() const { return items; }
const MassCancelRejectReasonEnums MassCancelRejectReasonEnums::instance;
const FieldEnumBase * MassCancelRejectReasonEnums::items[] = {
& MassCancelRejectReasonEnums::MASS_CANCEL_NOT_SUPPORTED,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_UNDERLYING,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_PRODUCT,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_CFICODE,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY_TYPE,
& MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_TRADING_SESSION,
& MassCancelRejectReasonEnums::OTHER,
nullptr };

const char * QuoteTypeEnums::getFieldName() const { return FixQuoteType; }
const FieldEnumBase * QuoteTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteTypeEnums::ValueType * QuoteTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteTypeEnums::getEnumMapByRaw() const { return QuoteTypeEnums::itemByRaw; }
const FieldEnumBase ** QuoteTypeEnums::getEnums() const { return items; }
const QuoteTypeEnums QuoteTypeEnums::instance;
const FieldEnumBase * QuoteTypeEnums::items[] = {
& QuoteTypeEnums::INDICATIVE,
& QuoteTypeEnums::TRADEABLE,
& QuoteTypeEnums::RESTRICTED_TRADEABLE,
& QuoteTypeEnums::COUNTER,
nullptr };

const char * CashMarginEnums::getFieldName() const { return FixCashMargin; }
const FieldEnumBase * CashMarginEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CashMarginEnums::ValueType * CashMarginEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CashMarginEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CashMarginEnums::getEnumMapByRaw() const { return CashMarginEnums::itemByRaw; }
const FieldEnumBase ** CashMarginEnums::getEnums() const { return items; }
const CashMarginEnums CashMarginEnums::instance;
const FieldEnumBase * CashMarginEnums::items[] = {
& CashMarginEnums::CASH,
& CashMarginEnums::MARGIN_OPEN,
& CashMarginEnums::MARGIN_CLOSE,
nullptr };

const char * ScopeEnums::getFieldName() const { return FixScope; }
const FieldEnumBase * ScopeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ScopeEnums::ValueType * ScopeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ScopeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ScopeEnums::getEnumMapByRaw() const { return ScopeEnums::itemByRaw; }
const FieldEnumBase ** ScopeEnums::getEnums() const { return items; }
const ScopeEnums ScopeEnums::instance;
const FieldEnumBase * ScopeEnums::items[] = {
& ScopeEnums::LOCAL,
& ScopeEnums::NATIONAL,
& ScopeEnums::GLOBAL,
nullptr };

const char * MDImplicitDeleteEnums::getFieldName() const { return FixMDImplicitDelete; }
const FieldEnumBase * MDImplicitDeleteEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MDImplicitDeleteEnums::ValueType * MDImplicitDeleteEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MDImplicitDeleteEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MDImplicitDeleteEnums::getEnumMapByRaw() const { return MDImplicitDeleteEnums::itemByRaw; }
const FieldEnumBase ** MDImplicitDeleteEnums::getEnums() const { return items; }
const MDImplicitDeleteEnums MDImplicitDeleteEnums::instance;
const FieldEnumBase * MDImplicitDeleteEnums::items[] = {
& MDImplicitDeleteEnums::YES,
& MDImplicitDeleteEnums::NO,
nullptr };

const char * CrossTypeEnums::getFieldName() const { return FixCrossType; }
const FieldEnumBase * CrossTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CrossTypeEnums::ValueType * CrossTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CrossTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CrossTypeEnums::getEnumMapByRaw() const { return CrossTypeEnums::itemByRaw; }
const FieldEnumBase ** CrossTypeEnums::getEnums() const { return items; }
const CrossTypeEnums CrossTypeEnums::instance;
const FieldEnumBase * CrossTypeEnums::items[] = {
& CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_BOTH_SIDES_ARE_TREATED_IN_THE_SAME_MANNER_THIS_IS_EQUIVALENT_TO_AN_ALL_OR_NONE,
& CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_ONE_SIDE_IS_FULLY_EXECUTED_THE_OTHER_SIDE_IS_PARTIALLY_EXECUTED_WITH_THE_REMAINDER_BEING_CANCELLED_THIS_IS_EQUIVALENT_TO_AN_IMMEDIATE_OR_CANCEL_ON_THE_OTHER_SIDE_NOTE_THE_CROSSPRIORITZATION,
& CrossTypeEnums::CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_ONE_SIDE_OF_THE_CROSS_IS_FULLY_EXECUTED,
& CrossTypeEnums::CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_IN_THE_CASE_OTHER_ORDERS_EXIST_WITH_THE_SAME_PRICE_THE_QUANTITY_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_EXISTING_ORDERS_AND_QUOTES_THE_REMAINDER_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_OTHER_SIDE_OF_THE_CROSS_THE_TWO_SIDES_POTENTIALLY_HAVE_DIFFERENT_QUANTITIES,
nullptr };

const char * CrossPrioritizationEnums::getFieldName() const { return FixCrossPrioritization; }
const FieldEnumBase * CrossPrioritizationEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CrossPrioritizationEnums::ValueType * CrossPrioritizationEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CrossPrioritizationEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CrossPrioritizationEnums::getEnumMapByRaw() const { return CrossPrioritizationEnums::itemByRaw; }
const FieldEnumBase ** CrossPrioritizationEnums::getEnums() const { return items; }
const CrossPrioritizationEnums CrossPrioritizationEnums::instance;
const FieldEnumBase * CrossPrioritizationEnums::items[] = {
& CrossPrioritizationEnums::NONE,
& CrossPrioritizationEnums::BUY_SIDE_IS_PRIORITIZED,
& CrossPrioritizationEnums::SELL_SIDE_IS_PRIORITIZED,
nullptr };

const char * NoSidesEnums::getFieldName() const { return FixNoSides; }
const FieldEnumBase * NoSidesEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const NoSidesEnums::ValueType * NoSidesEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * NoSidesEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & NoSidesEnums::getEnumMapByRaw() const { return NoSidesEnums::itemByRaw; }
const FieldEnumBase ** NoSidesEnums::getEnums() const { return items; }
const NoSidesEnums NoSidesEnums::instance;
const FieldEnumBase * NoSidesEnums::items[] = {
& NoSidesEnums::ONE_SIDE,
& NoSidesEnums::BOTH_SIDES,
nullptr };

const char * SecurityListRequestTypeEnums::getFieldName() const { return FixSecurityListRequestType; }
const FieldEnumBase * SecurityListRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityListRequestTypeEnums::ValueType * SecurityListRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityListRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityListRequestTypeEnums::getEnumMapByRaw() const { return SecurityListRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** SecurityListRequestTypeEnums::getEnums() const { return items; }
const SecurityListRequestTypeEnums SecurityListRequestTypeEnums::instance;
const FieldEnumBase * SecurityListRequestTypeEnums::items[] = {
& SecurityListRequestTypeEnums::SYMBOL,
& SecurityListRequestTypeEnums::SECURITYTYPE_AND_OR_CFICODE,
& SecurityListRequestTypeEnums::PRODUCT,
& SecurityListRequestTypeEnums::TRADINGSESSIONID,
& SecurityListRequestTypeEnums::ALL_SECURITIES,
nullptr };

const char * SecurityRequestResultEnums::getFieldName() const { return FixSecurityRequestResult; }
const FieldEnumBase * SecurityRequestResultEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SecurityRequestResultEnums::ValueType * SecurityRequestResultEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SecurityRequestResultEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SecurityRequestResultEnums::getEnumMapByRaw() const { return SecurityRequestResultEnums::itemByRaw; }
const FieldEnumBase ** SecurityRequestResultEnums::getEnums() const { return items; }
const SecurityRequestResultEnums SecurityRequestResultEnums::instance;
const FieldEnumBase * SecurityRequestResultEnums::items[] = {
& SecurityRequestResultEnums::VALID_REQUEST,
& SecurityRequestResultEnums::INVALID_OR_UNSUPPORTED_REQUEST,
& SecurityRequestResultEnums::NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA,
& SecurityRequestResultEnums::NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA,
& SecurityRequestResultEnums::INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE,
& SecurityRequestResultEnums::REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED,
nullptr };

const char * MultiLegRptTypeReqEnums::getFieldName() const { return FixMultiLegRptTypeReq; }
const FieldEnumBase * MultiLegRptTypeReqEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MultiLegRptTypeReqEnums::ValueType * MultiLegRptTypeReqEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MultiLegRptTypeReqEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MultiLegRptTypeReqEnums::getEnumMapByRaw() const { return MultiLegRptTypeReqEnums::itemByRaw; }
const FieldEnumBase ** MultiLegRptTypeReqEnums::getEnums() const { return items; }
const MultiLegRptTypeReqEnums MultiLegRptTypeReqEnums::instance;
const FieldEnumBase * MultiLegRptTypeReqEnums::items[] = {
& MultiLegRptTypeReqEnums::REPORT_BY_MULITLEG_SECURITY_ONLY,
& MultiLegRptTypeReqEnums::REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY,
& MultiLegRptTypeReqEnums::REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY,
nullptr };

const char * TradSesStatusRejReasonEnums::getFieldName() const { return FixTradSesStatusRejReason; }
const FieldEnumBase * TradSesStatusRejReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradSesStatusRejReasonEnums::ValueType * TradSesStatusRejReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradSesStatusRejReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradSesStatusRejReasonEnums::getEnumMapByRaw() const { return TradSesStatusRejReasonEnums::itemByRaw; }
const FieldEnumBase ** TradSesStatusRejReasonEnums::getEnums() const { return items; }
const TradSesStatusRejReasonEnums TradSesStatusRejReasonEnums::instance;
const FieldEnumBase * TradSesStatusRejReasonEnums::items[] = {
& TradSesStatusRejReasonEnums::UNKNOWN_OR_INVALID_TRADINGSESSIONID,
& TradSesStatusRejReasonEnums::OTHER,
nullptr };

const char * TradeRequestTypeEnums::getFieldName() const { return FixTradeRequestType; }
const FieldEnumBase * TradeRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeRequestTypeEnums::ValueType * TradeRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeRequestTypeEnums::getEnumMapByRaw() const { return TradeRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** TradeRequestTypeEnums::getEnums() const { return items; }
const TradeRequestTypeEnums TradeRequestTypeEnums::instance;
const FieldEnumBase * TradeRequestTypeEnums::items[] = {
& TradeRequestTypeEnums::ALL_TRADES,
& TradeRequestTypeEnums::MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST,
& TradeRequestTypeEnums::UNMATCHED_TRADES_THAT_MATCH_CRITERIA,
& TradeRequestTypeEnums::UNREPORTED_TRADES_THAT_MATCH_CRITERIA,
& TradeRequestTypeEnums::ADVISORIES_THAT_MATCH_CRITERIA,
nullptr };

const char * PreviouslyReportedEnums::getFieldName() const { return FixPreviouslyReported; }
const FieldEnumBase * PreviouslyReportedEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PreviouslyReportedEnums::ValueType * PreviouslyReportedEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PreviouslyReportedEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PreviouslyReportedEnums::getEnumMapByRaw() const { return PreviouslyReportedEnums::itemByRaw; }
const FieldEnumBase ** PreviouslyReportedEnums::getEnums() const { return items; }
const PreviouslyReportedEnums PreviouslyReportedEnums::instance;
const FieldEnumBase * PreviouslyReportedEnums::items[] = {
& PreviouslyReportedEnums::YES,
& PreviouslyReportedEnums::NO,
nullptr };

const char * MatchStatusEnums::getFieldName() const { return FixMatchStatus; }
const FieldEnumBase * MatchStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MatchStatusEnums::ValueType * MatchStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MatchStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MatchStatusEnums::getEnumMapByRaw() const { return MatchStatusEnums::itemByRaw; }
const FieldEnumBase ** MatchStatusEnums::getEnums() const { return items; }
const MatchStatusEnums MatchStatusEnums::instance;
const FieldEnumBase * MatchStatusEnums::items[] = {
& MatchStatusEnums::COMPARED_MATCHED_OR_AFFIRMED,
& MatchStatusEnums::UNCOMPARED_UNMATCHED_OR_UNAFFIRMED,
& MatchStatusEnums::ADVISORY_OR_ALERT,
nullptr };

const char * MatchTypeEnums::getFieldName() const { return FixMatchType; }
const FieldEnumBase * MatchTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MatchTypeEnums::ValueType * MatchTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MatchTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MatchTypeEnums::getEnumMapByRaw() const { return MatchTypeEnums::itemByRaw; }
const FieldEnumBase ** MatchTypeEnums::getEnums() const { return items; }
const MatchTypeEnums MatchTypeEnums::instance;
const FieldEnumBase * MatchTypeEnums::items[] = {
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES_AND_EXECUTION_TIME,
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES,
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES_AND_EXECUTION_TIME,
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES,
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_EXECUTION_TIME,
& MatchTypeEnums::COMPARED_RECORDS_RESULTING_FROM_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_PAIR_OFFS,
& MatchTypeEnums::SUMMARIZED_MATCH_USING_A1_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED,
& MatchTypeEnums::SUMMARIZED_MATCH_USING_A2_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED,
& MatchTypeEnums::SUMMARIZED_MATCH_USING_A3_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED,
& MatchTypeEnums::SUMMARIZED_MATCH_USING_A4_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED,
& MatchTypeEnums::SUMMARIZED_MATCH_USING_A5_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED,
& MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_MINUS_BADGES_AND_TIMES_ACT_M1_MATCH,
& MatchTypeEnums::SUMMARIZED_MATCH_MINUS_BADGES_AND_TIMES_ACT_M2_MATCH,
& MatchTypeEnums::OCS_LOCKED_IN_NON_ACT,
& MatchTypeEnums::ACT_ACCEPTED_TRADE,
& MatchTypeEnums::ACT_DEFAULT_TRADE,
& MatchTypeEnums::ACT_DEFAULT_AFTER_M2,
& MatchTypeEnums::ACT_M6_MATCH,
nullptr };

const char * OddLotEnums::getFieldName() const { return FixOddLot; }
const FieldEnumBase * OddLotEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const OddLotEnums::ValueType * OddLotEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * OddLotEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & OddLotEnums::getEnumMapByRaw() const { return OddLotEnums::itemByRaw; }
const FieldEnumBase ** OddLotEnums::getEnums() const { return items; }
const OddLotEnums OddLotEnums::instance;
const FieldEnumBase * OddLotEnums::items[] = {
& OddLotEnums::YES,
& OddLotEnums::NO,
nullptr };

const char * ClearingInstructionEnums::getFieldName() const { return FixClearingInstruction; }
const FieldEnumBase * ClearingInstructionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ClearingInstructionEnums::ValueType * ClearingInstructionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ClearingInstructionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ClearingInstructionEnums::getEnumMapByRaw() const { return ClearingInstructionEnums::itemByRaw; }
const FieldEnumBase ** ClearingInstructionEnums::getEnums() const { return items; }
const ClearingInstructionEnums ClearingInstructionEnums::instance;
const FieldEnumBase * ClearingInstructionEnums::items[] = {
& ClearingInstructionEnums::PROCESS_NORMALLY,
& ClearingInstructionEnums::EXCLUDE_FROM_ALL_NETTING,
& ClearingInstructionEnums::BILATERAL_NETTING_ONLY,
& ClearingInstructionEnums::EX_CLEARING,
& ClearingInstructionEnums::SPECIAL_TRADE,
& ClearingInstructionEnums::MULTILATERAL_NETTING,
& ClearingInstructionEnums::CLEAR_AGAINST_CENTRAL_COUNTERPARTY,
& ClearingInstructionEnums::EXCLUDE_FROM_CENTRAL_COUNTERPARTY,
& ClearingInstructionEnums::MANUAL_MODE,
& ClearingInstructionEnums::AUTOMATIC_POSTING_MODE,
& ClearingInstructionEnums::AUTOMATIC_GIVE_UP_MODE,
& ClearingInstructionEnums::QUALIFIED_SERVICE_REPRESENTATIVE,
& ClearingInstructionEnums::CUSTOMER_TRADE,
& ClearingInstructionEnums::SELF_CLEARING,
nullptr };

const char * AccountTypeEnums::getFieldName() const { return FixAccountType; }
const FieldEnumBase * AccountTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AccountTypeEnums::ValueType * AccountTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AccountTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AccountTypeEnums::getEnumMapByRaw() const { return AccountTypeEnums::itemByRaw; }
const FieldEnumBase ** AccountTypeEnums::getEnums() const { return items; }
const AccountTypeEnums AccountTypeEnums::instance;
const FieldEnumBase * AccountTypeEnums::items[] = {
& AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS,
& AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS,
& AccountTypeEnums::HOUSE_TRADER,
& AccountTypeEnums::FLOOR_TRADER,
& AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED,
& AccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED,
& AccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT,
nullptr };

const char * CustOrderCapacityEnums::getFieldName() const { return FixCustOrderCapacity; }
const FieldEnumBase * CustOrderCapacityEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CustOrderCapacityEnums::ValueType * CustOrderCapacityEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CustOrderCapacityEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CustOrderCapacityEnums::getEnumMapByRaw() const { return CustOrderCapacityEnums::itemByRaw; }
const FieldEnumBase ** CustOrderCapacityEnums::getEnums() const { return items; }
const CustOrderCapacityEnums CustOrderCapacityEnums::instance;
const FieldEnumBase * CustOrderCapacityEnums::items[] = {
& CustOrderCapacityEnums::MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT,
& CustOrderCapacityEnums::CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT,
& CustOrderCapacityEnums::MEMBER_TRADING_FOR_ANOTHER_MEMBER,
& CustOrderCapacityEnums::ALL_OTHER,
nullptr };

const char * MassStatusReqTypeEnums::getFieldName() const { return FixMassStatusReqType; }
const FieldEnumBase * MassStatusReqTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MassStatusReqTypeEnums::ValueType * MassStatusReqTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MassStatusReqTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MassStatusReqTypeEnums::getEnumMapByRaw() const { return MassStatusReqTypeEnums::itemByRaw; }
const FieldEnumBase ** MassStatusReqTypeEnums::getEnums() const { return items; }
const MassStatusReqTypeEnums MassStatusReqTypeEnums::instance;
const FieldEnumBase * MassStatusReqTypeEnums::items[] = {
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITY,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PRODUCT,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_CFICODE,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION,
& MassStatusReqTypeEnums::STATUS_FOR_ALL_ORDERS,
& MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PARTYID,
nullptr };

const char * DayBookingInstEnums::getFieldName() const { return FixDayBookingInst; }
const FieldEnumBase * DayBookingInstEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DayBookingInstEnums::ValueType * DayBookingInstEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DayBookingInstEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DayBookingInstEnums::getEnumMapByRaw() const { return DayBookingInstEnums::itemByRaw; }
const FieldEnumBase ** DayBookingInstEnums::getEnums() const { return items; }
const DayBookingInstEnums DayBookingInstEnums::instance;
const FieldEnumBase * DayBookingInstEnums::items[] = {
& DayBookingInstEnums::CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR,
& DayBookingInstEnums::SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING,
& DayBookingInstEnums::ACCUMULATE,
nullptr };

const char * BookingUnitEnums::getFieldName() const { return FixBookingUnit; }
const FieldEnumBase * BookingUnitEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BookingUnitEnums::ValueType * BookingUnitEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BookingUnitEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BookingUnitEnums::getEnumMapByRaw() const { return BookingUnitEnums::itemByRaw; }
const FieldEnumBase ** BookingUnitEnums::getEnums() const { return items; }
const BookingUnitEnums BookingUnitEnums::instance;
const FieldEnumBase * BookingUnitEnums::items[] = {
& BookingUnitEnums::EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT,
& BookingUnitEnums::AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER,
& BookingUnitEnums::AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE,
nullptr };

const char * PreallocMethodEnums::getFieldName() const { return FixPreallocMethod; }
const FieldEnumBase * PreallocMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PreallocMethodEnums::ValueType * PreallocMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PreallocMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PreallocMethodEnums::getEnumMapByRaw() const { return PreallocMethodEnums::itemByRaw; }
const FieldEnumBase ** PreallocMethodEnums::getEnums() const { return items; }
const PreallocMethodEnums PreallocMethodEnums::instance;
const FieldEnumBase * PreallocMethodEnums::items[] = {
& PreallocMethodEnums::PRO_RATA,
& PreallocMethodEnums::DO_NOT_PRO_RATA_DISCUSS_FIRST,
nullptr };

const char * AllocTypeEnums::getFieldName() const { return FixAllocType; }
const FieldEnumBase * AllocTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocTypeEnums::ValueType * AllocTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocTypeEnums::getEnumMapByRaw() const { return AllocTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocTypeEnums::getEnums() const { return items; }
const AllocTypeEnums AllocTypeEnums::instance;
const FieldEnumBase * AllocTypeEnums::items[] = {
& AllocTypeEnums::CALCULATED,
& AllocTypeEnums::PRELIMINARY,
& AllocTypeEnums::READY_TO_BOOK,
& AllocTypeEnums::WAREHOUSE_INSTRUCTION,
& AllocTypeEnums::REQUEST_TO_INTERMEDIARY,
nullptr };

const char * ClearingFeeIndicatorEnums::getFieldName() const { return FixClearingFeeIndicator; }
const FieldEnumBase * ClearingFeeIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ClearingFeeIndicatorEnums::ValueType * ClearingFeeIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ClearingFeeIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ClearingFeeIndicatorEnums::getEnumMapByRaw() const { return ClearingFeeIndicatorEnums::itemByRaw; }
const FieldEnumBase ** ClearingFeeIndicatorEnums::getEnums() const { return items; }
const ClearingFeeIndicatorEnums ClearingFeeIndicatorEnums::instance;
const FieldEnumBase * ClearingFeeIndicatorEnums::items[] = {
& ClearingFeeIndicatorEnums::CBOE_MEMBER,
& ClearingFeeIndicatorEnums::NON_MEMBER_AND_CUSTOMER,
& ClearingFeeIndicatorEnums::EQUITY_MEMBER_AND_CLEARING_MEMBER,
& ClearingFeeIndicatorEnums::FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS,
& ClearingFeeIndicatorEnums::_106H_AND_106J_FIRMS,
& ClearingFeeIndicatorEnums::GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS,
& ClearingFeeIndicatorEnums::LESSEE_AND_106F_EMPLOYEES,
& ClearingFeeIndicatorEnums::ALL_OTHER_OWNERSHIP_TYPES,
& ClearingFeeIndicatorEnums::_1ST_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
& ClearingFeeIndicatorEnums::_2ND_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
& ClearingFeeIndicatorEnums::_3RD_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
& ClearingFeeIndicatorEnums::_4TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
& ClearingFeeIndicatorEnums::_5TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
& ClearingFeeIndicatorEnums::_6TH_YEAR_AND_BEYOND_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT,
nullptr };

const char * WorkingIndicatorEnums::getFieldName() const { return FixWorkingIndicator; }
const FieldEnumBase * WorkingIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const WorkingIndicatorEnums::ValueType * WorkingIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * WorkingIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & WorkingIndicatorEnums::getEnumMapByRaw() const { return WorkingIndicatorEnums::itemByRaw; }
const FieldEnumBase ** WorkingIndicatorEnums::getEnums() const { return items; }
const WorkingIndicatorEnums WorkingIndicatorEnums::instance;
const FieldEnumBase * WorkingIndicatorEnums::items[] = {
& WorkingIndicatorEnums::YES,
& WorkingIndicatorEnums::NO,
nullptr };

const char * PriorityIndicatorEnums::getFieldName() const { return FixPriorityIndicator; }
const FieldEnumBase * PriorityIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PriorityIndicatorEnums::ValueType * PriorityIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PriorityIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PriorityIndicatorEnums::getEnumMapByRaw() const { return PriorityIndicatorEnums::itemByRaw; }
const FieldEnumBase ** PriorityIndicatorEnums::getEnums() const { return items; }
const PriorityIndicatorEnums PriorityIndicatorEnums::instance;
const FieldEnumBase * PriorityIndicatorEnums::items[] = {
& PriorityIndicatorEnums::PRIORITY_UNCHANGED,
& PriorityIndicatorEnums::LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE,
nullptr };

const char * LegalConfirmEnums::getFieldName() const { return FixLegalConfirm; }
const FieldEnumBase * LegalConfirmEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LegalConfirmEnums::ValueType * LegalConfirmEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LegalConfirmEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LegalConfirmEnums::getEnumMapByRaw() const { return LegalConfirmEnums::itemByRaw; }
const FieldEnumBase ** LegalConfirmEnums::getEnums() const { return items; }
const LegalConfirmEnums LegalConfirmEnums::instance;
const FieldEnumBase * LegalConfirmEnums::items[] = {
& LegalConfirmEnums::YES,
& LegalConfirmEnums::NO,
nullptr };

const char * QuoteRequestRejectReasonEnums::getFieldName() const { return FixQuoteRequestRejectReason; }
const FieldEnumBase * QuoteRequestRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteRequestRejectReasonEnums::ValueType * QuoteRequestRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteRequestRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteRequestRejectReasonEnums::getEnumMapByRaw() const { return QuoteRequestRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** QuoteRequestRejectReasonEnums::getEnums() const { return items; }
const QuoteRequestRejectReasonEnums QuoteRequestRejectReasonEnums::instance;
const FieldEnumBase * QuoteRequestRejectReasonEnums::items[] = {
& QuoteRequestRejectReasonEnums::UNKNOWN_SYMBOL,
& QuoteRequestRejectReasonEnums::EXCHANGE,
& QuoteRequestRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT,
& QuoteRequestRejectReasonEnums::TOO_LATE_TO_ENTER,
& QuoteRequestRejectReasonEnums::INVALID_PRICE,
& QuoteRequestRejectReasonEnums::NOT_AUTHORIZED_TO_REQUEST_QUOTE,
& QuoteRequestRejectReasonEnums::NO_MATCH_FOR_INQUIRY,
& QuoteRequestRejectReasonEnums::NO_MARKET_FOR_INSTRUMENT,
& QuoteRequestRejectReasonEnums::NO_INVENTORY,
& QuoteRequestRejectReasonEnums::PASS,
& QuoteRequestRejectReasonEnums::OTHER,
nullptr };

const char * AcctIDSourceEnums::getFieldName() const { return FixAcctIDSource; }
const FieldEnumBase * AcctIDSourceEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AcctIDSourceEnums::ValueType * AcctIDSourceEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AcctIDSourceEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AcctIDSourceEnums::getEnumMapByRaw() const { return AcctIDSourceEnums::itemByRaw; }
const FieldEnumBase ** AcctIDSourceEnums::getEnums() const { return items; }
const AcctIDSourceEnums AcctIDSourceEnums::instance;
const FieldEnumBase * AcctIDSourceEnums::items[] = {
& AcctIDSourceEnums::BIC,
& AcctIDSourceEnums::SID_CODE,
& AcctIDSourceEnums::TFM,
& AcctIDSourceEnums::OMGEO,
& AcctIDSourceEnums::DTCC_CODE,
& AcctIDSourceEnums::OTHER,
nullptr };

const char * ConfirmStatusEnums::getFieldName() const { return FixConfirmStatus; }
const FieldEnumBase * ConfirmStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ConfirmStatusEnums::ValueType * ConfirmStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ConfirmStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ConfirmStatusEnums::getEnumMapByRaw() const { return ConfirmStatusEnums::itemByRaw; }
const FieldEnumBase ** ConfirmStatusEnums::getEnums() const { return items; }
const ConfirmStatusEnums ConfirmStatusEnums::instance;
const FieldEnumBase * ConfirmStatusEnums::items[] = {
& ConfirmStatusEnums::RECEIVED,
& ConfirmStatusEnums::MISMATCHED_ACCOUNT,
& ConfirmStatusEnums::MISSING_SETTLEMENT_INSTRUCTIONS,
& ConfirmStatusEnums::CONFIRMED,
& ConfirmStatusEnums::REQUEST_REJECTED,
nullptr };

const char * ConfirmTransTypeEnums::getFieldName() const { return FixConfirmTransType; }
const FieldEnumBase * ConfirmTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ConfirmTransTypeEnums::ValueType * ConfirmTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ConfirmTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ConfirmTransTypeEnums::getEnumMapByRaw() const { return ConfirmTransTypeEnums::itemByRaw; }
const FieldEnumBase ** ConfirmTransTypeEnums::getEnums() const { return items; }
const ConfirmTransTypeEnums ConfirmTransTypeEnums::instance;
const FieldEnumBase * ConfirmTransTypeEnums::items[] = {
& ConfirmTransTypeEnums::NEW,
& ConfirmTransTypeEnums::REPLACE,
& ConfirmTransTypeEnums::CANCEL,
nullptr };

const char * DeliveryFormEnums::getFieldName() const { return FixDeliveryForm; }
const FieldEnumBase * DeliveryFormEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DeliveryFormEnums::ValueType * DeliveryFormEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DeliveryFormEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DeliveryFormEnums::getEnumMapByRaw() const { return DeliveryFormEnums::itemByRaw; }
const FieldEnumBase ** DeliveryFormEnums::getEnums() const { return items; }
const DeliveryFormEnums DeliveryFormEnums::instance;
const FieldEnumBase * DeliveryFormEnums::items[] = {
& DeliveryFormEnums::BOOKENTRY,
& DeliveryFormEnums::BEARER,
nullptr };

const char * LegSwapTypeEnums::getFieldName() const { return FixLegSwapType; }
const FieldEnumBase * LegSwapTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LegSwapTypeEnums::ValueType * LegSwapTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LegSwapTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LegSwapTypeEnums::getEnumMapByRaw() const { return LegSwapTypeEnums::itemByRaw; }
const FieldEnumBase ** LegSwapTypeEnums::getEnums() const { return items; }
const LegSwapTypeEnums LegSwapTypeEnums::instance;
const FieldEnumBase * LegSwapTypeEnums::items[] = {
& LegSwapTypeEnums::PAR_FOR_PAR,
& LegSwapTypeEnums::MODIFIED_DURATION,
& LegSwapTypeEnums::RISK,
& LegSwapTypeEnums::PROCEEDS,
nullptr };

const char * QuotePriceTypeEnums::getFieldName() const { return FixQuotePriceType; }
const FieldEnumBase * QuotePriceTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuotePriceTypeEnums::ValueType * QuotePriceTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuotePriceTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuotePriceTypeEnums::getEnumMapByRaw() const { return QuotePriceTypeEnums::itemByRaw; }
const FieldEnumBase ** QuotePriceTypeEnums::getEnums() const { return items; }
const QuotePriceTypeEnums QuotePriceTypeEnums::instance;
const FieldEnumBase * QuotePriceTypeEnums::items[] = {
& QuotePriceTypeEnums::PERCENT,
& QuotePriceTypeEnums::PER_SHARE,
& QuotePriceTypeEnums::FIXED_AMOUNT,
& QuotePriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR,
& QuotePriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR,
& QuotePriceTypeEnums::BASIS_POINTS_RELATIVE_TO_BENCHMARK,
& QuotePriceTypeEnums::TED_PRICE,
& QuotePriceTypeEnums::TED_YIELD,
& QuotePriceTypeEnums::YIELD_SPREAD,
& QuotePriceTypeEnums::YIELD,
nullptr };

const char * QuoteRespTypeEnums::getFieldName() const { return FixQuoteRespType; }
const FieldEnumBase * QuoteRespTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QuoteRespTypeEnums::ValueType * QuoteRespTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QuoteRespTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QuoteRespTypeEnums::getEnumMapByRaw() const { return QuoteRespTypeEnums::itemByRaw; }
const FieldEnumBase ** QuoteRespTypeEnums::getEnums() const { return items; }
const QuoteRespTypeEnums QuoteRespTypeEnums::instance;
const FieldEnumBase * QuoteRespTypeEnums::items[] = {
& QuoteRespTypeEnums::HIT_LIFT,
& QuoteRespTypeEnums::COUNTER,
& QuoteRespTypeEnums::EXPIRED,
& QuoteRespTypeEnums::COVER,
& QuoteRespTypeEnums::DONE_AWAY,
& QuoteRespTypeEnums::PASS,
nullptr };

const char * PosTypeEnums::getFieldName() const { return FixPosType; }
const FieldEnumBase * PosTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosTypeEnums::ValueType * PosTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosTypeEnums::getEnumMapByRaw() const { return PosTypeEnums::itemByRaw; }
const FieldEnumBase ** PosTypeEnums::getEnums() const { return items; }
const PosTypeEnums PosTypeEnums::instance;
const FieldEnumBase * PosTypeEnums::items[] = {
& PosTypeEnums::TRANSACTION_QUANTITY,
& PosTypeEnums::INTRA_SPREAD_QTY,
& PosTypeEnums::INTER_SPREAD_QTY,
& PosTypeEnums::END_OF_DAY_QTY,
& PosTypeEnums::START_OF_DAY_QTY,
& PosTypeEnums::OPTION_EXERCISE_QTY,
& PosTypeEnums::OPTION_ASSIGNMENT,
& PosTypeEnums::TRANSACTION_FROM_EXERCISE,
& PosTypeEnums::TRANSACTION_FROM_ASSIGNMENT,
& PosTypeEnums::PIT_TRADE_QTY,
& PosTypeEnums::TRANSFER_TRADE_QTY,
& PosTypeEnums::ELECTRONIC_TRADE_QTY,
& PosTypeEnums::ALLOCATION_TRADE_QTY,
& PosTypeEnums::ADJUSTMENT_QTY,
& PosTypeEnums::AS_OF_TRADE_QTY,
& PosTypeEnums::DELIVERY_QTY,
& PosTypeEnums::TOTAL_TRANSACTION_QTY,
& PosTypeEnums::CROSS_MARGIN_QTY,
& PosTypeEnums::INTEGRAL_SPLIT,
nullptr };

const char * PosQtyStatusEnums::getFieldName() const { return FixPosQtyStatus; }
const FieldEnumBase * PosQtyStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosQtyStatusEnums::ValueType * PosQtyStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosQtyStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosQtyStatusEnums::getEnumMapByRaw() const { return PosQtyStatusEnums::itemByRaw; }
const FieldEnumBase ** PosQtyStatusEnums::getEnums() const { return items; }
const PosQtyStatusEnums PosQtyStatusEnums::instance;
const FieldEnumBase * PosQtyStatusEnums::items[] = {
& PosQtyStatusEnums::SUBMITTED,
& PosQtyStatusEnums::ACCEPTED,
& PosQtyStatusEnums::REJECTED,
nullptr };

const char * PosAmtTypeEnums::getFieldName() const { return FixPosAmtType; }
const FieldEnumBase * PosAmtTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosAmtTypeEnums::ValueType * PosAmtTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosAmtTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosAmtTypeEnums::getEnumMapByRaw() const { return PosAmtTypeEnums::itemByRaw; }
const FieldEnumBase ** PosAmtTypeEnums::getEnums() const { return items; }
const PosAmtTypeEnums PosAmtTypeEnums::instance;
const FieldEnumBase * PosAmtTypeEnums::items[] = {
& PosAmtTypeEnums::FINAL_MARK_TO_MARKET_AMOUNT,
& PosAmtTypeEnums::INCREMENTAL_MARK_TO_MARKET_AMOUNT,
& PosAmtTypeEnums::TRADE_VARIATION_AMOUNT,
& PosAmtTypeEnums::START_OF_DAY_MARK_TO_MARKET_AMOUNT,
& PosAmtTypeEnums::PREMIUM_AMOUNT,
& PosAmtTypeEnums::CASH_RESIDUAL_AMOUNT,
& PosAmtTypeEnums::CASH_AMOUNT,
& PosAmtTypeEnums::VALUE_ADJUSTED_AMOUNT,
nullptr };

const char * PosTransTypeEnums::getFieldName() const { return FixPosTransType; }
const FieldEnumBase * PosTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosTransTypeEnums::ValueType * PosTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosTransTypeEnums::getEnumMapByRaw() const { return PosTransTypeEnums::itemByRaw; }
const FieldEnumBase ** PosTransTypeEnums::getEnums() const { return items; }
const PosTransTypeEnums PosTransTypeEnums::instance;
const FieldEnumBase * PosTransTypeEnums::items[] = {
& PosTransTypeEnums::EXERCISE,
& PosTransTypeEnums::DO_NOT_EXERCISE,
& PosTransTypeEnums::POSITION_ADJUSTMENT,
& PosTransTypeEnums::POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION,
& PosTransTypeEnums::PLEDGE,
nullptr };

const char * PosMaintActionEnums::getFieldName() const { return FixPosMaintAction; }
const FieldEnumBase * PosMaintActionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosMaintActionEnums::ValueType * PosMaintActionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosMaintActionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosMaintActionEnums::getEnumMapByRaw() const { return PosMaintActionEnums::itemByRaw; }
const FieldEnumBase ** PosMaintActionEnums::getEnums() const { return items; }
const PosMaintActionEnums PosMaintActionEnums::instance;
const FieldEnumBase * PosMaintActionEnums::items[] = {
& PosMaintActionEnums::NEW_USED_TO_INCREMENT_THE_OVERALL_TRANSACTION_QUANTITY,
& PosMaintActionEnums::REPLACE_USED_TO_OVERRIDE_THE_OVERALL_TRANSACTION_QUANTITY_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_THE_REFERENCE_ID,
& PosMaintActionEnums::CANCEL_USED_TO_REMOVE_THE_OVERALL_TRANSACTION_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_REFERENCE_ID,
nullptr };

const char * SettlSessIDEnums::getFieldName() const { return FixSettlSessID; }
const FieldEnumBase * SettlSessIDEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlSessIDEnums::ValueType * SettlSessIDEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlSessIDEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlSessIDEnums::getEnumMapByRaw() const { return SettlSessIDEnums::itemByRaw; }
const FieldEnumBase ** SettlSessIDEnums::getEnums() const { return items; }
const SettlSessIDEnums SettlSessIDEnums::instance;
const FieldEnumBase * SettlSessIDEnums::items[] = {
& SettlSessIDEnums::INTRADAY,
& SettlSessIDEnums::REGULAR_TRADING_HOURS,
& SettlSessIDEnums::ELECTRONIC_TRADING_HOURS,
nullptr };

const char * AdjustmentTypeEnums::getFieldName() const { return FixAdjustmentType; }
const FieldEnumBase * AdjustmentTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AdjustmentTypeEnums::ValueType * AdjustmentTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AdjustmentTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AdjustmentTypeEnums::getEnumMapByRaw() const { return AdjustmentTypeEnums::itemByRaw; }
const FieldEnumBase ** AdjustmentTypeEnums::getEnums() const { return items; }
const AdjustmentTypeEnums AdjustmentTypeEnums::instance;
const FieldEnumBase * AdjustmentTypeEnums::items[] = {
& AdjustmentTypeEnums::PROCESS_REQUEST_AS_MARGIN_DISPOSITION,
& AdjustmentTypeEnums::DELTA_PLUS,
& AdjustmentTypeEnums::DELTA_MINUS,
& AdjustmentTypeEnums::FINAL,
nullptr };

const char * PosMaintStatusEnums::getFieldName() const { return FixPosMaintStatus; }
const FieldEnumBase * PosMaintStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosMaintStatusEnums::ValueType * PosMaintStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosMaintStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosMaintStatusEnums::getEnumMapByRaw() const { return PosMaintStatusEnums::itemByRaw; }
const FieldEnumBase ** PosMaintStatusEnums::getEnums() const { return items; }
const PosMaintStatusEnums PosMaintStatusEnums::instance;
const FieldEnumBase * PosMaintStatusEnums::items[] = {
& PosMaintStatusEnums::ACCEPTED,
& PosMaintStatusEnums::ACCEPTED_WITH_WARNINGS,
& PosMaintStatusEnums::REJECTED,
& PosMaintStatusEnums::COMPLETED,
& PosMaintStatusEnums::COMPLETED_WITH_WARNINGS,
nullptr };

const char * PosMaintResultEnums::getFieldName() const { return FixPosMaintResult; }
const FieldEnumBase * PosMaintResultEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosMaintResultEnums::ValueType * PosMaintResultEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosMaintResultEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosMaintResultEnums::getEnumMapByRaw() const { return PosMaintResultEnums::itemByRaw; }
const FieldEnumBase ** PosMaintResultEnums::getEnums() const { return items; }
const PosMaintResultEnums PosMaintResultEnums::instance;
const FieldEnumBase * PosMaintResultEnums::items[] = {
& PosMaintResultEnums::SUCCESSFUL_COMPLETION,
& PosMaintResultEnums::REJECTED,
& PosMaintResultEnums::OTHER,
nullptr };

const char * PosReqTypeEnums::getFieldName() const { return FixPosReqType; }
const FieldEnumBase * PosReqTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosReqTypeEnums::ValueType * PosReqTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosReqTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosReqTypeEnums::getEnumMapByRaw() const { return PosReqTypeEnums::itemByRaw; }
const FieldEnumBase ** PosReqTypeEnums::getEnums() const { return items; }
const PosReqTypeEnums PosReqTypeEnums::instance;
const FieldEnumBase * PosReqTypeEnums::items[] = {
& PosReqTypeEnums::POSITIONS,
& PosReqTypeEnums::TRADES,
& PosReqTypeEnums::EXERCISES,
& PosReqTypeEnums::ASSIGNMENTS,
nullptr };

const char * ResponseTransportTypeEnums::getFieldName() const { return FixResponseTransportType; }
const FieldEnumBase * ResponseTransportTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ResponseTransportTypeEnums::ValueType * ResponseTransportTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ResponseTransportTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ResponseTransportTypeEnums::getEnumMapByRaw() const { return ResponseTransportTypeEnums::itemByRaw; }
const FieldEnumBase ** ResponseTransportTypeEnums::getEnums() const { return items; }
const ResponseTransportTypeEnums ResponseTransportTypeEnums::instance;
const FieldEnumBase * ResponseTransportTypeEnums::items[] = {
& ResponseTransportTypeEnums::INBAND_TRANSPORT_THE_REQUEST_WAS_SENT_OVER,
& ResponseTransportTypeEnums::OUT_OF_BAND_PRE_ARRANGED_OUT_OF_BAND_DELIVERY_MECHANISM,
nullptr };

const char * PosReqResultEnums::getFieldName() const { return FixPosReqResult; }
const FieldEnumBase * PosReqResultEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosReqResultEnums::ValueType * PosReqResultEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosReqResultEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosReqResultEnums::getEnumMapByRaw() const { return PosReqResultEnums::itemByRaw; }
const FieldEnumBase ** PosReqResultEnums::getEnums() const { return items; }
const PosReqResultEnums PosReqResultEnums::instance;
const FieldEnumBase * PosReqResultEnums::items[] = {
& PosReqResultEnums::VALID_REQUEST,
& PosReqResultEnums::INVALID_OR_UNSUPPORTED_REQUEST,
& PosReqResultEnums::NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA,
& PosReqResultEnums::NOT_AUTHORIZED_TO_REQUEST_POSITIONS,
& PosReqResultEnums::REQUEST_FOR_POSITION_NOT_SUPPORTED,
& PosReqResultEnums::OTHER,
nullptr };

const char * PosReqStatusEnums::getFieldName() const { return FixPosReqStatus; }
const FieldEnumBase * PosReqStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PosReqStatusEnums::ValueType * PosReqStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PosReqStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PosReqStatusEnums::getEnumMapByRaw() const { return PosReqStatusEnums::itemByRaw; }
const FieldEnumBase ** PosReqStatusEnums::getEnums() const { return items; }
const PosReqStatusEnums PosReqStatusEnums::instance;
const FieldEnumBase * PosReqStatusEnums::items[] = {
& PosReqStatusEnums::COMPLETED,
& PosReqStatusEnums::COMPLETED_WITH_WARNINGS,
& PosReqStatusEnums::REJECTED,
nullptr };

const char * SettlPriceTypeEnums::getFieldName() const { return FixSettlPriceType; }
const FieldEnumBase * SettlPriceTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlPriceTypeEnums::ValueType * SettlPriceTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlPriceTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlPriceTypeEnums::getEnumMapByRaw() const { return SettlPriceTypeEnums::itemByRaw; }
const FieldEnumBase ** SettlPriceTypeEnums::getEnums() const { return items; }
const SettlPriceTypeEnums SettlPriceTypeEnums::instance;
const FieldEnumBase * SettlPriceTypeEnums::items[] = {
& SettlPriceTypeEnums::FINAL,
& SettlPriceTypeEnums::THEORETICAL,
nullptr };

const char * AssignmentMethodEnums::getFieldName() const { return FixAssignmentMethod; }
const FieldEnumBase * AssignmentMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AssignmentMethodEnums::ValueType * AssignmentMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AssignmentMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AssignmentMethodEnums::getEnumMapByRaw() const { return AssignmentMethodEnums::itemByRaw; }
const FieldEnumBase ** AssignmentMethodEnums::getEnums() const { return items; }
const AssignmentMethodEnums AssignmentMethodEnums::instance;
const FieldEnumBase * AssignmentMethodEnums::items[] = {
& AssignmentMethodEnums::RANDOM,
& AssignmentMethodEnums::PRORATA,
nullptr };

const char * ExerciseMethodEnums::getFieldName() const { return FixExerciseMethod; }
const FieldEnumBase * ExerciseMethodEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExerciseMethodEnums::ValueType * ExerciseMethodEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExerciseMethodEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExerciseMethodEnums::getEnumMapByRaw() const { return ExerciseMethodEnums::itemByRaw; }
const FieldEnumBase ** ExerciseMethodEnums::getEnums() const { return items; }
const ExerciseMethodEnums ExerciseMethodEnums::instance;
const FieldEnumBase * ExerciseMethodEnums::items[] = {
& ExerciseMethodEnums::AUTOMATIC,
& ExerciseMethodEnums::MANUAL,
nullptr };

const char * TradeRequestResultEnums::getFieldName() const { return FixTradeRequestResult; }
const FieldEnumBase * TradeRequestResultEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeRequestResultEnums::ValueType * TradeRequestResultEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeRequestResultEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeRequestResultEnums::getEnumMapByRaw() const { return TradeRequestResultEnums::itemByRaw; }
const FieldEnumBase ** TradeRequestResultEnums::getEnums() const { return items; }
const TradeRequestResultEnums TradeRequestResultEnums::instance;
const FieldEnumBase * TradeRequestResultEnums::items[] = {
& TradeRequestResultEnums::SUCCESSFUL,
& TradeRequestResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT,
& TradeRequestResultEnums::INVALID_TYPE_OF_TRADE_REQUESTED,
& TradeRequestResultEnums::INVALID_PARTIES,
& TradeRequestResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED,
& TradeRequestResultEnums::INVALID_DESTINATION_REQUESTED,
& TradeRequestResultEnums::TRADEREQUESTTYPE_NOT_SUPPORTED,
& TradeRequestResultEnums::UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST,
& TradeRequestResultEnums::OTHER,
nullptr };

const char * TradeRequestStatusEnums::getFieldName() const { return FixTradeRequestStatus; }
const FieldEnumBase * TradeRequestStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeRequestStatusEnums::ValueType * TradeRequestStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeRequestStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeRequestStatusEnums::getEnumMapByRaw() const { return TradeRequestStatusEnums::itemByRaw; }
const FieldEnumBase ** TradeRequestStatusEnums::getEnums() const { return items; }
const TradeRequestStatusEnums TradeRequestStatusEnums::instance;
const FieldEnumBase * TradeRequestStatusEnums::items[] = {
& TradeRequestStatusEnums::ACCEPTED,
& TradeRequestStatusEnums::COMPLETED,
& TradeRequestStatusEnums::REJECTED,
nullptr };

const char * TradeReportRejectReasonEnums::getFieldName() const { return FixTradeReportRejectReason; }
const FieldEnumBase * TradeReportRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeReportRejectReasonEnums::ValueType * TradeReportRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeReportRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeReportRejectReasonEnums::getEnumMapByRaw() const { return TradeReportRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** TradeReportRejectReasonEnums::getEnums() const { return items; }
const TradeReportRejectReasonEnums TradeReportRejectReasonEnums::instance;
const FieldEnumBase * TradeReportRejectReasonEnums::items[] = {
& TradeReportRejectReasonEnums::SUCCESSFUL,
& TradeReportRejectReasonEnums::INVALID_PARTY_INFORMATION,
& TradeReportRejectReasonEnums::UNKNOWN_INSTRUMENT,
& TradeReportRejectReasonEnums::UNAUTHORIZED_TO_REPORT_TRADES,
& TradeReportRejectReasonEnums::INVALID_TRADE_TYPE,
& TradeReportRejectReasonEnums::OTHER,
nullptr };

const char * SideMultiLegReportingTypeEnums::getFieldName() const { return FixSideMultiLegReportingType; }
const FieldEnumBase * SideMultiLegReportingTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SideMultiLegReportingTypeEnums::ValueType * SideMultiLegReportingTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SideMultiLegReportingTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SideMultiLegReportingTypeEnums::getEnumMapByRaw() const { return SideMultiLegReportingTypeEnums::itemByRaw; }
const FieldEnumBase ** SideMultiLegReportingTypeEnums::getEnums() const { return items; }
const SideMultiLegReportingTypeEnums SideMultiLegReportingTypeEnums::instance;
const FieldEnumBase * SideMultiLegReportingTypeEnums::items[] = {
& SideMultiLegReportingTypeEnums::SINGLE_SECURITY,
& SideMultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY,
& SideMultiLegReportingTypeEnums::MULTI_LEG_SECURITY,
nullptr };

const char * TrdRegTimestampTypeEnums::getFieldName() const { return FixTrdRegTimestampType; }
const FieldEnumBase * TrdRegTimestampTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TrdRegTimestampTypeEnums::ValueType * TrdRegTimestampTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TrdRegTimestampTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TrdRegTimestampTypeEnums::getEnumMapByRaw() const { return TrdRegTimestampTypeEnums::itemByRaw; }
const FieldEnumBase ** TrdRegTimestampTypeEnums::getEnums() const { return items; }
const TrdRegTimestampTypeEnums TrdRegTimestampTypeEnums::instance;
const FieldEnumBase * TrdRegTimestampTypeEnums::items[] = {
& TrdRegTimestampTypeEnums::EXECUTION_TIME,
& TrdRegTimestampTypeEnums::TIME_IN,
& TrdRegTimestampTypeEnums::TIME_OUT,
& TrdRegTimestampTypeEnums::BROKER_RECEIPT,
& TrdRegTimestampTypeEnums::BROKER_EXECUTION,
nullptr };

const char * ConfirmTypeEnums::getFieldName() const { return FixConfirmType; }
const FieldEnumBase * ConfirmTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ConfirmTypeEnums::ValueType * ConfirmTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ConfirmTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ConfirmTypeEnums::getEnumMapByRaw() const { return ConfirmTypeEnums::itemByRaw; }
const FieldEnumBase ** ConfirmTypeEnums::getEnums() const { return items; }
const ConfirmTypeEnums ConfirmTypeEnums::instance;
const FieldEnumBase * ConfirmTypeEnums::items[] = {
& ConfirmTypeEnums::STATUS,
& ConfirmTypeEnums::CONFIRMATION,
& ConfirmTypeEnums::CONFIRMATION_REQUEST_REJECTED,
nullptr };

const char * ConfirmRejReasonEnums::getFieldName() const { return FixConfirmRejReason; }
const FieldEnumBase * ConfirmRejReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ConfirmRejReasonEnums::ValueType * ConfirmRejReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ConfirmRejReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ConfirmRejReasonEnums::getEnumMapByRaw() const { return ConfirmRejReasonEnums::itemByRaw; }
const FieldEnumBase ** ConfirmRejReasonEnums::getEnums() const { return items; }
const ConfirmRejReasonEnums ConfirmRejReasonEnums::instance;
const FieldEnumBase * ConfirmRejReasonEnums::items[] = {
& ConfirmRejReasonEnums::MISMATCHED_ACCOUNT,
& ConfirmRejReasonEnums::MISSING_SETTLEMENT_INSTRUCTIONS,
& ConfirmRejReasonEnums::OTHER,
nullptr };

const char * BookingTypeEnums::getFieldName() const { return FixBookingType; }
const FieldEnumBase * BookingTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const BookingTypeEnums::ValueType * BookingTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * BookingTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & BookingTypeEnums::getEnumMapByRaw() const { return BookingTypeEnums::itemByRaw; }
const FieldEnumBase ** BookingTypeEnums::getEnums() const { return items; }
const BookingTypeEnums BookingTypeEnums::instance;
const FieldEnumBase * BookingTypeEnums::items[] = {
& BookingTypeEnums::REGULAR_BOOKING,
& BookingTypeEnums::CFD,
& BookingTypeEnums::TOTAL_RETURN_SWAP,
nullptr };

const char * AllocSettlInstTypeEnums::getFieldName() const { return FixAllocSettlInstType; }
const FieldEnumBase * AllocSettlInstTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocSettlInstTypeEnums::ValueType * AllocSettlInstTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocSettlInstTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocSettlInstTypeEnums::getEnumMapByRaw() const { return AllocSettlInstTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocSettlInstTypeEnums::getEnums() const { return items; }
const AllocSettlInstTypeEnums AllocSettlInstTypeEnums::instance;
const FieldEnumBase * AllocSettlInstTypeEnums::items[] = {
& AllocSettlInstTypeEnums::USE_DEFAULT_INSTRUCTIONS,
& AllocSettlInstTypeEnums::DERIVE_FROM_PARAMETERS_PROVIDED,
& AllocSettlInstTypeEnums::FULL_DETAILS_PROVIDED,
& AllocSettlInstTypeEnums::SSI_DB_IDS_PROVIDED,
& AllocSettlInstTypeEnums::PHONE_FOR_INSTRUCTIONS,
nullptr };

const char * DlvyInstTypeEnums::getFieldName() const { return FixDlvyInstType; }
const FieldEnumBase * DlvyInstTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DlvyInstTypeEnums::ValueType * DlvyInstTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DlvyInstTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DlvyInstTypeEnums::getEnumMapByRaw() const { return DlvyInstTypeEnums::itemByRaw; }
const FieldEnumBase ** DlvyInstTypeEnums::getEnums() const { return items; }
const DlvyInstTypeEnums DlvyInstTypeEnums::instance;
const FieldEnumBase * DlvyInstTypeEnums::items[] = {
& DlvyInstTypeEnums::SECURITIES,
& DlvyInstTypeEnums::CASH,
nullptr };

const char * TerminationTypeEnums::getFieldName() const { return FixTerminationType; }
const FieldEnumBase * TerminationTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TerminationTypeEnums::ValueType * TerminationTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TerminationTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TerminationTypeEnums::getEnumMapByRaw() const { return TerminationTypeEnums::itemByRaw; }
const FieldEnumBase ** TerminationTypeEnums::getEnums() const { return items; }
const TerminationTypeEnums TerminationTypeEnums::instance;
const FieldEnumBase * TerminationTypeEnums::items[] = {
& TerminationTypeEnums::OVERNIGHT,
& TerminationTypeEnums::TERM,
& TerminationTypeEnums::FLEXIBLE,
& TerminationTypeEnums::OPEN,
nullptr };

const char * SettlInstReqRejCodeEnums::getFieldName() const { return FixSettlInstReqRejCode; }
const FieldEnumBase * SettlInstReqRejCodeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const SettlInstReqRejCodeEnums::ValueType * SettlInstReqRejCodeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * SettlInstReqRejCodeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & SettlInstReqRejCodeEnums::getEnumMapByRaw() const { return SettlInstReqRejCodeEnums::itemByRaw; }
const FieldEnumBase ** SettlInstReqRejCodeEnums::getEnums() const { return items; }
const SettlInstReqRejCodeEnums SettlInstReqRejCodeEnums::instance;
const FieldEnumBase * SettlInstReqRejCodeEnums::items[] = {
& SettlInstReqRejCodeEnums::UNABLE_TO_PROCESS_REQUEST,
& SettlInstReqRejCodeEnums::UNKNOWN_ACCOUNT,
& SettlInstReqRejCodeEnums::NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND,
& SettlInstReqRejCodeEnums::OTHER,
nullptr };

const char * AllocReportTypeEnums::getFieldName() const { return FixAllocReportType; }
const FieldEnumBase * AllocReportTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocReportTypeEnums::ValueType * AllocReportTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocReportTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocReportTypeEnums::getEnumMapByRaw() const { return AllocReportTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocReportTypeEnums::getEnums() const { return items; }
const AllocReportTypeEnums AllocReportTypeEnums::instance;
const FieldEnumBase * AllocReportTypeEnums::items[] = {
& AllocReportTypeEnums::SELLSIDE_CALCULATED_USING_PRELIMINARY,
& AllocReportTypeEnums::SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY,
& AllocReportTypeEnums::WAREHOUSE_RECAP,
& AllocReportTypeEnums::REQUEST_TO_INTERMEDIARY,
nullptr };

const char * AllocCancReplaceReasonEnums::getFieldName() const { return FixAllocCancReplaceReason; }
const FieldEnumBase * AllocCancReplaceReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocCancReplaceReasonEnums::ValueType * AllocCancReplaceReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocCancReplaceReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocCancReplaceReasonEnums::getEnumMapByRaw() const { return AllocCancReplaceReasonEnums::itemByRaw; }
const FieldEnumBase ** AllocCancReplaceReasonEnums::getEnums() const { return items; }
const AllocCancReplaceReasonEnums AllocCancReplaceReasonEnums::instance;
const FieldEnumBase * AllocCancReplaceReasonEnums::items[] = {
& AllocCancReplaceReasonEnums::ORIGINAL_DETAILS_INCOMPLETE_INCORRECT,
& AllocCancReplaceReasonEnums::CHANGE_IN_UNDERLYING_ORDER_DETAILS,
& AllocCancReplaceReasonEnums::OTHER,
nullptr };

const char * AllocAccountTypeEnums::getFieldName() const { return FixAllocAccountType; }
const FieldEnumBase * AllocAccountTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocAccountTypeEnums::ValueType * AllocAccountTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocAccountTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocAccountTypeEnums::getEnumMapByRaw() const { return AllocAccountTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocAccountTypeEnums::getEnums() const { return items; }
const AllocAccountTypeEnums AllocAccountTypeEnums::instance;
const FieldEnumBase * AllocAccountTypeEnums::items[] = {
& AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS,
& AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS,
& AllocAccountTypeEnums::HOUSE_TRADER,
& AllocAccountTypeEnums::FLOOR_TRADER,
& AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED,
& AllocAccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED,
& AllocAccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT,
nullptr };

const char * PartySubIDTypeEnums::getFieldName() const { return FixPartySubIDType; }
const FieldEnumBase * PartySubIDTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PartySubIDTypeEnums::ValueType * PartySubIDTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PartySubIDTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PartySubIDTypeEnums::getEnumMapByRaw() const { return PartySubIDTypeEnums::itemByRaw; }
const FieldEnumBase ** PartySubIDTypeEnums::getEnums() const { return items; }
const PartySubIDTypeEnums PartySubIDTypeEnums::instance;
const FieldEnumBase * PartySubIDTypeEnums::items[] = {
& PartySubIDTypeEnums::FIRM,
& PartySubIDTypeEnums::PERSON,
& PartySubIDTypeEnums::SYSTEM,
& PartySubIDTypeEnums::APPLICATION,
& PartySubIDTypeEnums::FULL_LEGAL_NAME_OF_FIRM,
& PartySubIDTypeEnums::POSTAL_ADDRESS,
& PartySubIDTypeEnums::PHONE_NUMBER,
& PartySubIDTypeEnums::EMAIL_ADDRESS,
& PartySubIDTypeEnums::CONTACT_NAME,
& PartySubIDTypeEnums::SECURITIES_ACCOUNT_NUMBER,
& PartySubIDTypeEnums::REGISTRATION_NUMBER,
& PartySubIDTypeEnums::REGISTERED_ADDRESS_12,
& PartySubIDTypeEnums::REGULATORY_STATUS,
& PartySubIDTypeEnums::REGISTRATION_NAME,
& PartySubIDTypeEnums::CASH_ACCOUNT_NUMBER,
& PartySubIDTypeEnums::BIC,
& PartySubIDTypeEnums::CSD_PARTICIPANT_MEMBER_CODE,
& PartySubIDTypeEnums::REGISTERED_ADDRESS_18,
& PartySubIDTypeEnums::FUND_ACCOUNT_NAME,
& PartySubIDTypeEnums::TELEX_NUMBER,
& PartySubIDTypeEnums::FAX_NUMBER,
& PartySubIDTypeEnums::SECURITIES_ACCOUNT_NAME,
& PartySubIDTypeEnums::CASH_ACCOUNT_NAME,
& PartySubIDTypeEnums::DEPARTMENT,
& PartySubIDTypeEnums::LOCATION,
& PartySubIDTypeEnums::POSITION_ACCOUNT_TYPE,
nullptr };

const char * AllocIntermedReqTypeEnums::getFieldName() const { return FixAllocIntermedReqType; }
const FieldEnumBase * AllocIntermedReqTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocIntermedReqTypeEnums::ValueType * AllocIntermedReqTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocIntermedReqTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocIntermedReqTypeEnums::getEnumMapByRaw() const { return AllocIntermedReqTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocIntermedReqTypeEnums::getEnums() const { return items; }
const AllocIntermedReqTypeEnums AllocIntermedReqTypeEnums::instance;
const FieldEnumBase * AllocIntermedReqTypeEnums::items[] = {
& AllocIntermedReqTypeEnums::PENDING_ACCEPT,
& AllocIntermedReqTypeEnums::PENDING_RELEASE,
& AllocIntermedReqTypeEnums::PENDING_REVERSAL,
& AllocIntermedReqTypeEnums::ACCEPT,
& AllocIntermedReqTypeEnums::BLOCK_LEVEL_REJECT,
& AllocIntermedReqTypeEnums::ACCOUNT_LEVEL_REJECT,
nullptr };

const char * ApplQueueResolutionEnums::getFieldName() const { return FixApplQueueResolution; }
const FieldEnumBase * ApplQueueResolutionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ApplQueueResolutionEnums::ValueType * ApplQueueResolutionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ApplQueueResolutionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ApplQueueResolutionEnums::getEnumMapByRaw() const { return ApplQueueResolutionEnums::itemByRaw; }
const FieldEnumBase ** ApplQueueResolutionEnums::getEnums() const { return items; }
const ApplQueueResolutionEnums ApplQueueResolutionEnums::instance;
const FieldEnumBase * ApplQueueResolutionEnums::items[] = {
& ApplQueueResolutionEnums::NO_ACTION_TAKEN,
& ApplQueueResolutionEnums::QUEUE_FLUSHED,
& ApplQueueResolutionEnums::OVERLAY_LAST,
& ApplQueueResolutionEnums::END_SESSION,
nullptr };

const char * ApplQueueActionEnums::getFieldName() const { return FixApplQueueAction; }
const FieldEnumBase * ApplQueueActionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ApplQueueActionEnums::ValueType * ApplQueueActionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ApplQueueActionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ApplQueueActionEnums::getEnumMapByRaw() const { return ApplQueueActionEnums::itemByRaw; }
const FieldEnumBase ** ApplQueueActionEnums::getEnums() const { return items; }
const ApplQueueActionEnums ApplQueueActionEnums::instance;
const FieldEnumBase * ApplQueueActionEnums::items[] = {
& ApplQueueActionEnums::NO_ACTION_TAKEN,
& ApplQueueActionEnums::QUEUE_FLUSHED,
& ApplQueueActionEnums::OVERLAY_LAST,
& ApplQueueActionEnums::END_SESSION,
nullptr };

const char * AvgPxIndicatorEnums::getFieldName() const { return FixAvgPxIndicator; }
const FieldEnumBase * AvgPxIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AvgPxIndicatorEnums::ValueType * AvgPxIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AvgPxIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AvgPxIndicatorEnums::getEnumMapByRaw() const { return AvgPxIndicatorEnums::itemByRaw; }
const FieldEnumBase ** AvgPxIndicatorEnums::getEnums() const { return items; }
const AvgPxIndicatorEnums AvgPxIndicatorEnums::instance;
const FieldEnumBase * AvgPxIndicatorEnums::items[] = {
& AvgPxIndicatorEnums::NO_AVERAGE_PRICING,
& AvgPxIndicatorEnums::TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID,
& AvgPxIndicatorEnums::LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID,
nullptr };

const char * TradeAllocIndicatorEnums::getFieldName() const { return FixTradeAllocIndicator; }
const FieldEnumBase * TradeAllocIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeAllocIndicatorEnums::ValueType * TradeAllocIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeAllocIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeAllocIndicatorEnums::getEnumMapByRaw() const { return TradeAllocIndicatorEnums::itemByRaw; }
const FieldEnumBase ** TradeAllocIndicatorEnums::getEnums() const { return items; }
const TradeAllocIndicatorEnums TradeAllocIndicatorEnums::instance;
const FieldEnumBase * TradeAllocIndicatorEnums::items[] = {
& TradeAllocIndicatorEnums::ALLOCATION_NOT_REQUIRED,
& TradeAllocIndicatorEnums::ALLOCATION_REQUIRED,
& TradeAllocIndicatorEnums::USE_ALLOCATION_PROVIDED_WITH_THE_TRADE,
nullptr };

const char * ExpirationCycleEnums::getFieldName() const { return FixExpirationCycle; }
const FieldEnumBase * ExpirationCycleEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ExpirationCycleEnums::ValueType * ExpirationCycleEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ExpirationCycleEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ExpirationCycleEnums::getEnumMapByRaw() const { return ExpirationCycleEnums::itemByRaw; }
const FieldEnumBase ** ExpirationCycleEnums::getEnums() const { return items; }
const ExpirationCycleEnums ExpirationCycleEnums::instance;
const FieldEnumBase * ExpirationCycleEnums::items[] = {
& ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_CLOSE,
& ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_OPEN,
nullptr };

const char * TrdTypeEnums::getFieldName() const { return FixTrdType; }
const FieldEnumBase * TrdTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TrdTypeEnums::ValueType * TrdTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TrdTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TrdTypeEnums::getEnumMapByRaw() const { return TrdTypeEnums::itemByRaw; }
const FieldEnumBase ** TrdTypeEnums::getEnums() const { return items; }
const TrdTypeEnums TrdTypeEnums::instance;
const FieldEnumBase * TrdTypeEnums::items[] = {
& TrdTypeEnums::REGULAR_TRADE,
& TrdTypeEnums::BLOCK_TRADE,
& TrdTypeEnums::EFP,
& TrdTypeEnums::TRANSFER,
& TrdTypeEnums::LATE_TRADE,
& TrdTypeEnums::T_TRADE,
& TrdTypeEnums::WEIGHTED_AVERAGE_PRICE_TRADE,
& TrdTypeEnums::BUNCHED_TRADE,
& TrdTypeEnums::LATE_BUNCHED_TRADE,
& TrdTypeEnums::PRIOR_REFERENCE_PRICE_TRADE,
& TrdTypeEnums::AFTER_HOURS_TRADE,
nullptr };

const char * PegMoveTypeEnums::getFieldName() const { return FixPegMoveType; }
const FieldEnumBase * PegMoveTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PegMoveTypeEnums::ValueType * PegMoveTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PegMoveTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PegMoveTypeEnums::getEnumMapByRaw() const { return PegMoveTypeEnums::itemByRaw; }
const FieldEnumBase ** PegMoveTypeEnums::getEnums() const { return items; }
const PegMoveTypeEnums PegMoveTypeEnums::instance;
const FieldEnumBase * PegMoveTypeEnums::items[] = {
& PegMoveTypeEnums::FLOATING,
& PegMoveTypeEnums::FIXED,
nullptr };

const char * PegOffsetTypeEnums::getFieldName() const { return FixPegOffsetType; }
const FieldEnumBase * PegOffsetTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PegOffsetTypeEnums::ValueType * PegOffsetTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PegOffsetTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PegOffsetTypeEnums::getEnumMapByRaw() const { return PegOffsetTypeEnums::itemByRaw; }
const FieldEnumBase ** PegOffsetTypeEnums::getEnums() const { return items; }
const PegOffsetTypeEnums PegOffsetTypeEnums::instance;
const FieldEnumBase * PegOffsetTypeEnums::items[] = {
& PegOffsetTypeEnums::PRICE,
& PegOffsetTypeEnums::BASIS_POINTS,
& PegOffsetTypeEnums::TICKS,
& PegOffsetTypeEnums::PRICE_TIER,
nullptr };

const char * PegLimitTypeEnums::getFieldName() const { return FixPegLimitType; }
const FieldEnumBase * PegLimitTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PegLimitTypeEnums::ValueType * PegLimitTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PegLimitTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PegLimitTypeEnums::getEnumMapByRaw() const { return PegLimitTypeEnums::itemByRaw; }
const FieldEnumBase ** PegLimitTypeEnums::getEnums() const { return items; }
const PegLimitTypeEnums PegLimitTypeEnums::instance;
const FieldEnumBase * PegLimitTypeEnums::items[] = {
& PegLimitTypeEnums::OR_BETTER,
& PegLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT,
& PegLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_PEG_LIMIT_IS_A_MINIMUM_AND_FOR_A_SELL_THE_PEG_LIMIT_IS_A_MAXIMUM,
nullptr };

const char * PegRoundDirectionEnums::getFieldName() const { return FixPegRoundDirection; }
const FieldEnumBase * PegRoundDirectionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PegRoundDirectionEnums::ValueType * PegRoundDirectionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PegRoundDirectionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PegRoundDirectionEnums::getEnumMapByRaw() const { return PegRoundDirectionEnums::itemByRaw; }
const FieldEnumBase ** PegRoundDirectionEnums::getEnums() const { return items; }
const PegRoundDirectionEnums PegRoundDirectionEnums::instance;
const FieldEnumBase * PegRoundDirectionEnums::items[] = {
& PegRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK,
& PegRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK,
nullptr };

const char * PegScopeEnums::getFieldName() const { return FixPegScope; }
const FieldEnumBase * PegScopeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PegScopeEnums::ValueType * PegScopeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PegScopeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PegScopeEnums::getEnumMapByRaw() const { return PegScopeEnums::itemByRaw; }
const FieldEnumBase ** PegScopeEnums::getEnums() const { return items; }
const PegScopeEnums PegScopeEnums::instance;
const FieldEnumBase * PegScopeEnums::items[] = {
& PegScopeEnums::LOCAL,
& PegScopeEnums::NATIONAL,
& PegScopeEnums::GLOBAL,
& PegScopeEnums::NATIONAL_EXCLUDING_LOCAL,
nullptr };

const char * DiscretionMoveTypeEnums::getFieldName() const { return FixDiscretionMoveType; }
const FieldEnumBase * DiscretionMoveTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionMoveTypeEnums::ValueType * DiscretionMoveTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionMoveTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionMoveTypeEnums::getEnumMapByRaw() const { return DiscretionMoveTypeEnums::itemByRaw; }
const FieldEnumBase ** DiscretionMoveTypeEnums::getEnums() const { return items; }
const DiscretionMoveTypeEnums DiscretionMoveTypeEnums::instance;
const FieldEnumBase * DiscretionMoveTypeEnums::items[] = {
& DiscretionMoveTypeEnums::FLOATING,
& DiscretionMoveTypeEnums::FIXED,
nullptr };

const char * DiscretionOffsetTypeEnums::getFieldName() const { return FixDiscretionOffsetType; }
const FieldEnumBase * DiscretionOffsetTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionOffsetTypeEnums::ValueType * DiscretionOffsetTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionOffsetTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionOffsetTypeEnums::getEnumMapByRaw() const { return DiscretionOffsetTypeEnums::itemByRaw; }
const FieldEnumBase ** DiscretionOffsetTypeEnums::getEnums() const { return items; }
const DiscretionOffsetTypeEnums DiscretionOffsetTypeEnums::instance;
const FieldEnumBase * DiscretionOffsetTypeEnums::items[] = {
& DiscretionOffsetTypeEnums::PRICE,
& DiscretionOffsetTypeEnums::BASIS_POINTS,
& DiscretionOffsetTypeEnums::TICKS,
& DiscretionOffsetTypeEnums::PRICE_TIER,
nullptr };

const char * DiscretionLimitTypeEnums::getFieldName() const { return FixDiscretionLimitType; }
const FieldEnumBase * DiscretionLimitTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionLimitTypeEnums::ValueType * DiscretionLimitTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionLimitTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionLimitTypeEnums::getEnumMapByRaw() const { return DiscretionLimitTypeEnums::itemByRaw; }
const FieldEnumBase ** DiscretionLimitTypeEnums::getEnums() const { return items; }
const DiscretionLimitTypeEnums DiscretionLimitTypeEnums::instance;
const FieldEnumBase * DiscretionLimitTypeEnums::items[] = {
& DiscretionLimitTypeEnums::OR_BETTER,
& DiscretionLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT,
& DiscretionLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_DISCRETION_PRICE_IS_A_MINIMUM_AND_FOR_A_SELL_THE_DISCRETION_PRICE_IS_A_MAXIMUM,
nullptr };

const char * DiscretionRoundDirectionEnums::getFieldName() const { return FixDiscretionRoundDirection; }
const FieldEnumBase * DiscretionRoundDirectionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionRoundDirectionEnums::ValueType * DiscretionRoundDirectionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionRoundDirectionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionRoundDirectionEnums::getEnumMapByRaw() const { return DiscretionRoundDirectionEnums::itemByRaw; }
const FieldEnumBase ** DiscretionRoundDirectionEnums::getEnums() const { return items; }
const DiscretionRoundDirectionEnums DiscretionRoundDirectionEnums::instance;
const FieldEnumBase * DiscretionRoundDirectionEnums::items[] = {
& DiscretionRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK,
& DiscretionRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK,
nullptr };

const char * DiscretionScopeEnums::getFieldName() const { return FixDiscretionScope; }
const FieldEnumBase * DiscretionScopeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DiscretionScopeEnums::ValueType * DiscretionScopeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DiscretionScopeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DiscretionScopeEnums::getEnumMapByRaw() const { return DiscretionScopeEnums::itemByRaw; }
const FieldEnumBase ** DiscretionScopeEnums::getEnums() const { return items; }
const DiscretionScopeEnums DiscretionScopeEnums::instance;
const FieldEnumBase * DiscretionScopeEnums::items[] = {
& DiscretionScopeEnums::LOCAL,
& DiscretionScopeEnums::NATIONAL,
& DiscretionScopeEnums::GLOBAL,
& DiscretionScopeEnums::NATIONAL_EXCLUDING_LOCAL,
nullptr };

const char * TargetStrategyEnums::getFieldName() const { return FixTargetStrategy; }
const FieldEnumBase * TargetStrategyEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TargetStrategyEnums::ValueType * TargetStrategyEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TargetStrategyEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TargetStrategyEnums::getEnumMapByRaw() const { return TargetStrategyEnums::itemByRaw; }
const FieldEnumBase ** TargetStrategyEnums::getEnums() const { return items; }
const TargetStrategyEnums TargetStrategyEnums::instance;
const FieldEnumBase * TargetStrategyEnums::items[] = {
& TargetStrategyEnums::VWAP,
& TargetStrategyEnums::PARTICIPATE,
& TargetStrategyEnums::MININIZE_MARKET_IMPACT,
nullptr };

const char * LastLiquidityIndEnums::getFieldName() const { return FixLastLiquidityInd; }
const FieldEnumBase * LastLiquidityIndEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LastLiquidityIndEnums::ValueType * LastLiquidityIndEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LastLiquidityIndEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LastLiquidityIndEnums::getEnumMapByRaw() const { return LastLiquidityIndEnums::itemByRaw; }
const FieldEnumBase ** LastLiquidityIndEnums::getEnums() const { return items; }
const LastLiquidityIndEnums LastLiquidityIndEnums::instance;
const FieldEnumBase * LastLiquidityIndEnums::items[] = {
& LastLiquidityIndEnums::ADDED_LIQUIDITY,
& LastLiquidityIndEnums::REMOVED_LIQUIDITY,
& LastLiquidityIndEnums::LIQUIDITY_ROUTED_OUT,
nullptr };

const char * PublishTrdIndicatorEnums::getFieldName() const { return FixPublishTrdIndicator; }
const FieldEnumBase * PublishTrdIndicatorEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const PublishTrdIndicatorEnums::ValueType * PublishTrdIndicatorEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * PublishTrdIndicatorEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & PublishTrdIndicatorEnums::getEnumMapByRaw() const { return PublishTrdIndicatorEnums::itemByRaw; }
const FieldEnumBase ** PublishTrdIndicatorEnums::getEnums() const { return items; }
const PublishTrdIndicatorEnums PublishTrdIndicatorEnums::instance;
const FieldEnumBase * PublishTrdIndicatorEnums::items[] = {
& PublishTrdIndicatorEnums::YES,
& PublishTrdIndicatorEnums::NO,
nullptr };

const char * ShortSaleReasonEnums::getFieldName() const { return FixShortSaleReason; }
const FieldEnumBase * ShortSaleReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const ShortSaleReasonEnums::ValueType * ShortSaleReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * ShortSaleReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & ShortSaleReasonEnums::getEnumMapByRaw() const { return ShortSaleReasonEnums::itemByRaw; }
const FieldEnumBase ** ShortSaleReasonEnums::getEnums() const { return items; }
const ShortSaleReasonEnums ShortSaleReasonEnums::instance;
const FieldEnumBase * ShortSaleReasonEnums::items[] = {
& ShortSaleReasonEnums::DEALER_SOLD_SHORT,
& ShortSaleReasonEnums::DEALER_SOLD_SHORT_EXEMPT,
& ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT,
& ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT_EXEMPT,
& ShortSaleReasonEnums::QUALIFED_SERVICE_REPRESENTATIVE,
& ShortSaleReasonEnums::QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT,
nullptr };

const char * QtyTypeEnums::getFieldName() const { return FixQtyType; }
const FieldEnumBase * QtyTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const QtyTypeEnums::ValueType * QtyTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * QtyTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & QtyTypeEnums::getEnumMapByRaw() const { return QtyTypeEnums::itemByRaw; }
const FieldEnumBase ** QtyTypeEnums::getEnums() const { return items; }
const QtyTypeEnums QtyTypeEnums::instance;
const FieldEnumBase * QtyTypeEnums::items[] = {
& QtyTypeEnums::UNITS,
& QtyTypeEnums::CONTRACTS,
nullptr };

const char * TradeReportTypeEnums::getFieldName() const { return FixTradeReportType; }
const FieldEnumBase * TradeReportTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TradeReportTypeEnums::ValueType * TradeReportTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TradeReportTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TradeReportTypeEnums::getEnumMapByRaw() const { return TradeReportTypeEnums::itemByRaw; }
const FieldEnumBase ** TradeReportTypeEnums::getEnums() const { return items; }
const TradeReportTypeEnums TradeReportTypeEnums::instance;
const FieldEnumBase * TradeReportTypeEnums::items[] = {
& TradeReportTypeEnums::SUBMIT,
& TradeReportTypeEnums::ALLEGED,
& TradeReportTypeEnums::ACCEPT,
& TradeReportTypeEnums::DECLINE,
& TradeReportTypeEnums::ADDENDUM,
& TradeReportTypeEnums::NO_WAS,
& TradeReportTypeEnums::TRADE_REPORT_CANCEL,
& TradeReportTypeEnums::LOCKED_IN_TRADE_BREAK,
nullptr };

const char * AllocNoOrdersTypeEnums::getFieldName() const { return FixAllocNoOrdersType; }
const FieldEnumBase * AllocNoOrdersTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AllocNoOrdersTypeEnums::ValueType * AllocNoOrdersTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AllocNoOrdersTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AllocNoOrdersTypeEnums::getEnumMapByRaw() const { return AllocNoOrdersTypeEnums::itemByRaw; }
const FieldEnumBase ** AllocNoOrdersTypeEnums::getEnums() const { return items; }
const AllocNoOrdersTypeEnums AllocNoOrdersTypeEnums::instance;
const FieldEnumBase * AllocNoOrdersTypeEnums::items[] = {
& AllocNoOrdersTypeEnums::NOT_SPECIFIED,
& AllocNoOrdersTypeEnums::EXPLICIT_LIST_PROVIDED,
nullptr };

const char * EventTypeEnums::getFieldName() const { return FixEventType; }
const FieldEnumBase * EventTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const EventTypeEnums::ValueType * EventTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * EventTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & EventTypeEnums::getEnumMapByRaw() const { return EventTypeEnums::itemByRaw; }
const FieldEnumBase ** EventTypeEnums::getEnums() const { return items; }
const EventTypeEnums EventTypeEnums::instance;
const FieldEnumBase * EventTypeEnums::items[] = {
& EventTypeEnums::PUT,
& EventTypeEnums::CALL,
& EventTypeEnums::TENDER,
& EventTypeEnums::SINKING_FUND_CALL,
& EventTypeEnums::OTHER,
nullptr };

const char * InstrAttribTypeEnums::getFieldName() const { return FixInstrAttribType; }
const FieldEnumBase * InstrAttribTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const InstrAttribTypeEnums::ValueType * InstrAttribTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * InstrAttribTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & InstrAttribTypeEnums::getEnumMapByRaw() const { return InstrAttribTypeEnums::itemByRaw; }
const FieldEnumBase ** InstrAttribTypeEnums::getEnums() const { return items; }
const InstrAttribTypeEnums InstrAttribTypeEnums::instance;
const FieldEnumBase * InstrAttribTypeEnums::items[] = {
& InstrAttribTypeEnums::FLAT,
& InstrAttribTypeEnums::ZERO_COUPON,
& InstrAttribTypeEnums::INTEREST_BEARING,
& InstrAttribTypeEnums::NO_PERIODIC_PAYMENTS,
& InstrAttribTypeEnums::VARIABLE_RATE,
& InstrAttribTypeEnums::LESS_FEE_FOR_PUT,
& InstrAttribTypeEnums::STEPPED_COUPON,
& InstrAttribTypeEnums::COUPON_PERIOD,
& InstrAttribTypeEnums::WHEN_AND_IF_ISSUED,
& InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT,
& InstrAttribTypeEnums::CALLABLE_PUTTABLE,
& InstrAttribTypeEnums::ESCROWED_TO_MATURITY,
& InstrAttribTypeEnums::ESCROWED_TO_REDEMPTION_DATE_CALLABLE_SUPPLY_REDEMPTION_DATE_IN_THE_INSTRATTRIBVALUE,
& InstrAttribTypeEnums::PREREFUNDED,
& InstrAttribTypeEnums::IN_DEFAULT,
& InstrAttribTypeEnums::UNRATED,
& InstrAttribTypeEnums::TAXABLE,
& InstrAttribTypeEnums::INDEXED,
& InstrAttribTypeEnums::SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX,
& InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT_PRICE_SUPPLY_PRICE_IN_THE_INSTRATTRIBVALUE,
& InstrAttribTypeEnums::CALLABLE_BELOW_MATURITY_VALUE,
& InstrAttribTypeEnums::CALLABLE_WITHOUT_NOTICE_BY_MAIL_TO_HOLDER_UNLESS_REGISTERED,
& InstrAttribTypeEnums::TEXT_SUPPLY_THE_TEXT_OF_THE_ATTRIBUTE_OR_DISCLAIMER_IN_THE_INSTRATTRIBVALUE,
nullptr };

const char * CPProgramEnums::getFieldName() const { return FixCPProgram; }
const FieldEnumBase * CPProgramEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CPProgramEnums::ValueType * CPProgramEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CPProgramEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CPProgramEnums::getEnumMapByRaw() const { return CPProgramEnums::itemByRaw; }
const FieldEnumBase ** CPProgramEnums::getEnums() const { return items; }
const CPProgramEnums CPProgramEnums::instance;
const FieldEnumBase * CPProgramEnums::items[] = {
& CPProgramEnums::_3,
& CPProgramEnums::_4,
& CPProgramEnums::OTHER,
nullptr };

const char * MiscFeeBasisEnums::getFieldName() const { return FixMiscFeeBasis; }
const FieldEnumBase * MiscFeeBasisEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const MiscFeeBasisEnums::ValueType * MiscFeeBasisEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * MiscFeeBasisEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & MiscFeeBasisEnums::getEnumMapByRaw() const { return MiscFeeBasisEnums::itemByRaw; }
const FieldEnumBase ** MiscFeeBasisEnums::getEnums() const { return items; }
const MiscFeeBasisEnums MiscFeeBasisEnums::instance;
const FieldEnumBase * MiscFeeBasisEnums::items[] = {
& MiscFeeBasisEnums::ABSOLUTE,
& MiscFeeBasisEnums::PER_UNIT,
& MiscFeeBasisEnums::PERCENTAGE,
nullptr };

const char * LastFragmentEnums::getFieldName() const { return FixLastFragment; }
const FieldEnumBase * LastFragmentEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const LastFragmentEnums::ValueType * LastFragmentEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * LastFragmentEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & LastFragmentEnums::getEnumMapByRaw() const { return LastFragmentEnums::itemByRaw; }
const FieldEnumBase ** LastFragmentEnums::getEnums() const { return items; }
const LastFragmentEnums LastFragmentEnums::instance;
const FieldEnumBase * LastFragmentEnums::items[] = {
& LastFragmentEnums::YES,
& LastFragmentEnums::NO,
nullptr };

const char * CollAsgnReasonEnums::getFieldName() const { return FixCollAsgnReason; }
const FieldEnumBase * CollAsgnReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollAsgnReasonEnums::ValueType * CollAsgnReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollAsgnReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollAsgnReasonEnums::getEnumMapByRaw() const { return CollAsgnReasonEnums::itemByRaw; }
const FieldEnumBase ** CollAsgnReasonEnums::getEnums() const { return items; }
const CollAsgnReasonEnums CollAsgnReasonEnums::instance;
const FieldEnumBase * CollAsgnReasonEnums::items[] = {
& CollAsgnReasonEnums::INITIAL,
& CollAsgnReasonEnums::SCHEDULED,
& CollAsgnReasonEnums::TIME_WARNING,
& CollAsgnReasonEnums::MARGIN_DEFICIENCY,
& CollAsgnReasonEnums::MARGIN_EXCESS,
& CollAsgnReasonEnums::FORWARD_COLLATERAL_DEMAND,
& CollAsgnReasonEnums::EVENT_OF_DEFAULT,
& CollAsgnReasonEnums::ADVERSE_TAX_EVENT,
nullptr };

const char * CollInquiryQualifierEnums::getFieldName() const { return FixCollInquiryQualifier; }
const FieldEnumBase * CollInquiryQualifierEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollInquiryQualifierEnums::ValueType * CollInquiryQualifierEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollInquiryQualifierEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollInquiryQualifierEnums::getEnumMapByRaw() const { return CollInquiryQualifierEnums::itemByRaw; }
const FieldEnumBase ** CollInquiryQualifierEnums::getEnums() const { return items; }
const CollInquiryQualifierEnums CollInquiryQualifierEnums::instance;
const FieldEnumBase * CollInquiryQualifierEnums::items[] = {
& CollInquiryQualifierEnums::TRADEDATE,
& CollInquiryQualifierEnums::GC_INSTRUMENT,
& CollInquiryQualifierEnums::COLLATERALINSTRUMENT,
& CollInquiryQualifierEnums::SUBSTITUTION_ELIGIBLE,
& CollInquiryQualifierEnums::NOT_ASSIGNED,
& CollInquiryQualifierEnums::PARTIALLY_ASSIGNED,
& CollInquiryQualifierEnums::FULLY_ASSIGNED,
& CollInquiryQualifierEnums::OUTSTANDING_TRADES,
nullptr };

const char * CollAsgnTransTypeEnums::getFieldName() const { return FixCollAsgnTransType; }
const FieldEnumBase * CollAsgnTransTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollAsgnTransTypeEnums::ValueType * CollAsgnTransTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollAsgnTransTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollAsgnTransTypeEnums::getEnumMapByRaw() const { return CollAsgnTransTypeEnums::itemByRaw; }
const FieldEnumBase ** CollAsgnTransTypeEnums::getEnums() const { return items; }
const CollAsgnTransTypeEnums CollAsgnTransTypeEnums::instance;
const FieldEnumBase * CollAsgnTransTypeEnums::items[] = {
& CollAsgnTransTypeEnums::NEW,
& CollAsgnTransTypeEnums::REPLACE,
& CollAsgnTransTypeEnums::CANCEL,
& CollAsgnTransTypeEnums::RELEASE,
& CollAsgnTransTypeEnums::REVERSE,
nullptr };

const char * CollAsgnRespTypeEnums::getFieldName() const { return FixCollAsgnRespType; }
const FieldEnumBase * CollAsgnRespTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollAsgnRespTypeEnums::ValueType * CollAsgnRespTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollAsgnRespTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollAsgnRespTypeEnums::getEnumMapByRaw() const { return CollAsgnRespTypeEnums::itemByRaw; }
const FieldEnumBase ** CollAsgnRespTypeEnums::getEnums() const { return items; }
const CollAsgnRespTypeEnums CollAsgnRespTypeEnums::instance;
const FieldEnumBase * CollAsgnRespTypeEnums::items[] = {
& CollAsgnRespTypeEnums::RECEIVED,
& CollAsgnRespTypeEnums::ACCEPTED,
& CollAsgnRespTypeEnums::DECLINED,
& CollAsgnRespTypeEnums::REJECTED,
nullptr };

const char * CollAsgnRejectReasonEnums::getFieldName() const { return FixCollAsgnRejectReason; }
const FieldEnumBase * CollAsgnRejectReasonEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollAsgnRejectReasonEnums::ValueType * CollAsgnRejectReasonEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollAsgnRejectReasonEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollAsgnRejectReasonEnums::getEnumMapByRaw() const { return CollAsgnRejectReasonEnums::itemByRaw; }
const FieldEnumBase ** CollAsgnRejectReasonEnums::getEnums() const { return items; }
const CollAsgnRejectReasonEnums CollAsgnRejectReasonEnums::instance;
const FieldEnumBase * CollAsgnRejectReasonEnums::items[] = {
& CollAsgnRejectReasonEnums::UNKNOWN_DEAL,
& CollAsgnRejectReasonEnums::UNKNOWN_OR_INVALID_INSTRUMENT,
& CollAsgnRejectReasonEnums::UNAUTHORIZED_TRANSACTION,
& CollAsgnRejectReasonEnums::INSUFFICIENT_COLLATERAL,
& CollAsgnRejectReasonEnums::INVALID_TYPE_OF_COLLATERAL,
& CollAsgnRejectReasonEnums::EXCESSIVE_SUBSTITUTION,
& CollAsgnRejectReasonEnums::OTHER,
nullptr };

const char * CollStatusEnums::getFieldName() const { return FixCollStatus; }
const FieldEnumBase * CollStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollStatusEnums::ValueType * CollStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollStatusEnums::getEnumMapByRaw() const { return CollStatusEnums::itemByRaw; }
const FieldEnumBase ** CollStatusEnums::getEnums() const { return items; }
const CollStatusEnums CollStatusEnums::instance;
const FieldEnumBase * CollStatusEnums::items[] = {
& CollStatusEnums::UNASSIGNED,
& CollStatusEnums::PARTIALLY_ASSIGNED,
& CollStatusEnums::ASSIGNMENT_PROPOSED,
& CollStatusEnums::ASSIGNED,
& CollStatusEnums::CHALLENGED,
nullptr };

const char * DeliveryTypeEnums::getFieldName() const { return FixDeliveryType; }
const FieldEnumBase * DeliveryTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const DeliveryTypeEnums::ValueType * DeliveryTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * DeliveryTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & DeliveryTypeEnums::getEnumMapByRaw() const { return DeliveryTypeEnums::itemByRaw; }
const FieldEnumBase ** DeliveryTypeEnums::getEnums() const { return items; }
const DeliveryTypeEnums DeliveryTypeEnums::instance;
const FieldEnumBase * DeliveryTypeEnums::items[] = {
& DeliveryTypeEnums::VERSUS_PAYMENT_DELIVER,
& DeliveryTypeEnums::FREE_DELIVER,
& DeliveryTypeEnums::TRI_PARTY,
& DeliveryTypeEnums::HOLD_IN_CUSTODY,
nullptr };

const char * UserRequestTypeEnums::getFieldName() const { return FixUserRequestType; }
const FieldEnumBase * UserRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const UserRequestTypeEnums::ValueType * UserRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * UserRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & UserRequestTypeEnums::getEnumMapByRaw() const { return UserRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** UserRequestTypeEnums::getEnums() const { return items; }
const UserRequestTypeEnums UserRequestTypeEnums::instance;
const FieldEnumBase * UserRequestTypeEnums::items[] = {
& UserRequestTypeEnums::LOGONUSER,
& UserRequestTypeEnums::LOGOFFUSER,
& UserRequestTypeEnums::CHANGEPASSWORDFORUSER,
& UserRequestTypeEnums::REQUEST_INDIVIDUAL_USER_STATUS,
nullptr };

const char * UserStatusEnums::getFieldName() const { return FixUserStatus; }
const FieldEnumBase * UserStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const UserStatusEnums::ValueType * UserStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * UserStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & UserStatusEnums::getEnumMapByRaw() const { return UserStatusEnums::itemByRaw; }
const FieldEnumBase ** UserStatusEnums::getEnums() const { return items; }
const UserStatusEnums UserStatusEnums::instance;
const FieldEnumBase * UserStatusEnums::items[] = {
& UserStatusEnums::LOGGED_IN,
& UserStatusEnums::NOT_LOGGED_IN,
& UserStatusEnums::USER_NOT_RECOGNISED,
& UserStatusEnums::PASSWORD_INCORRECT,
& UserStatusEnums::PASSWORD_CHANGED,
& UserStatusEnums::OTHER,
nullptr };

const char * StatusValueEnums::getFieldName() const { return FixStatusValue; }
const FieldEnumBase * StatusValueEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const StatusValueEnums::ValueType * StatusValueEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * StatusValueEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & StatusValueEnums::getEnumMapByRaw() const { return StatusValueEnums::itemByRaw; }
const FieldEnumBase ** StatusValueEnums::getEnums() const { return items; }
const StatusValueEnums StatusValueEnums::instance;
const FieldEnumBase * StatusValueEnums::items[] = {
& StatusValueEnums::CONNECTED,
& StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_UP,
& StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_DOWN,
& StatusValueEnums::IN_PROCESS,
nullptr };

const char * NetworkRequestTypeEnums::getFieldName() const { return FixNetworkRequestType; }
const FieldEnumBase * NetworkRequestTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const NetworkRequestTypeEnums::ValueType * NetworkRequestTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * NetworkRequestTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & NetworkRequestTypeEnums::getEnumMapByRaw() const { return NetworkRequestTypeEnums::itemByRaw; }
const FieldEnumBase ** NetworkRequestTypeEnums::getEnums() const { return items; }
const NetworkRequestTypeEnums NetworkRequestTypeEnums::instance;
const FieldEnumBase * NetworkRequestTypeEnums::items[] = {
& NetworkRequestTypeEnums::SNAPSHOT,
& NetworkRequestTypeEnums::SUBSCRIBE,
& NetworkRequestTypeEnums::STOP_SUBSCRIBING,
& NetworkRequestTypeEnums::LEVEL_OF_DETAIL_THEN_NOCOMPIDS_BECOMES_REQUIRED,
nullptr };

const char * NetworkStatusResponseTypeEnums::getFieldName() const { return FixNetworkStatusResponseType; }
const FieldEnumBase * NetworkStatusResponseTypeEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const NetworkStatusResponseTypeEnums::ValueType * NetworkStatusResponseTypeEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * NetworkStatusResponseTypeEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & NetworkStatusResponseTypeEnums::getEnumMapByRaw() const { return NetworkStatusResponseTypeEnums::itemByRaw; }
const FieldEnumBase ** NetworkStatusResponseTypeEnums::getEnums() const { return items; }
const NetworkStatusResponseTypeEnums NetworkStatusResponseTypeEnums::instance;
const FieldEnumBase * NetworkStatusResponseTypeEnums::items[] = {
& NetworkStatusResponseTypeEnums::FULL,
& NetworkStatusResponseTypeEnums::INCREMENTAL_UPDATE,
nullptr };

const char * TrdRptStatusEnums::getFieldName() const { return FixTrdRptStatus; }
const FieldEnumBase * TrdRptStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const TrdRptStatusEnums::ValueType * TrdRptStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * TrdRptStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & TrdRptStatusEnums::getEnumMapByRaw() const { return TrdRptStatusEnums::itemByRaw; }
const FieldEnumBase ** TrdRptStatusEnums::getEnums() const { return items; }
const TrdRptStatusEnums TrdRptStatusEnums::instance;
const FieldEnumBase * TrdRptStatusEnums::items[] = {
& TrdRptStatusEnums::ACCEPTED,
& TrdRptStatusEnums::REJECTED,
nullptr };

const char * AffirmStatusEnums::getFieldName() const { return FixAffirmStatus; }
const FieldEnumBase * AffirmStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const AffirmStatusEnums::ValueType * AffirmStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * AffirmStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & AffirmStatusEnums::getEnumMapByRaw() const { return AffirmStatusEnums::itemByRaw; }
const FieldEnumBase ** AffirmStatusEnums::getEnums() const { return items; }
const AffirmStatusEnums AffirmStatusEnums::instance;
const FieldEnumBase * AffirmStatusEnums::items[] = {
& AffirmStatusEnums::RECEIVED,
& AffirmStatusEnums::CONFIRM_REJECTED_IE_NOT_AFFIRMED,
& AffirmStatusEnums::AFFIRMED,
nullptr };

const char * CollActionEnums::getFieldName() const { return FixCollAction; }
const FieldEnumBase * CollActionEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollActionEnums::ValueType * CollActionEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollActionEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollActionEnums::getEnumMapByRaw() const { return CollActionEnums::itemByRaw; }
const FieldEnumBase ** CollActionEnums::getEnums() const { return items; }
const CollActionEnums CollActionEnums::instance;
const FieldEnumBase * CollActionEnums::items[] = {
& CollActionEnums::RETAIN,
& CollActionEnums::ADD,
& CollActionEnums::REMOVE,
nullptr };

const char * CollInquiryStatusEnums::getFieldName() const { return FixCollInquiryStatus; }
const FieldEnumBase * CollInquiryStatusEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollInquiryStatusEnums::ValueType * CollInquiryStatusEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollInquiryStatusEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollInquiryStatusEnums::getEnumMapByRaw() const { return CollInquiryStatusEnums::itemByRaw; }
const FieldEnumBase ** CollInquiryStatusEnums::getEnums() const { return items; }
const CollInquiryStatusEnums CollInquiryStatusEnums::instance;
const FieldEnumBase * CollInquiryStatusEnums::items[] = {
& CollInquiryStatusEnums::ACCEPTED,
& CollInquiryStatusEnums::ACCEPTED_WITH_WARNINGS,
& CollInquiryStatusEnums::COMPLETED,
& CollInquiryStatusEnums::COMPLETED_WITH_WARNINGS,
& CollInquiryStatusEnums::REJECTED,
nullptr };

const char * CollInquiryResultEnums::getFieldName() const { return FixCollInquiryResult; }
const FieldEnumBase * CollInquiryResultEnums::findEnum( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : it->second; }
const CollInquiryResultEnums::ValueType * CollInquiryResultEnums::findEnumValue( raw_enum_t raw ) { auto it = itemByRaw.find(raw); return it == itemByRaw.end() ? nullptr : & static_cast<const ItemType*>(it->second)->value; }
const FieldEnumBase * CollInquiryResultEnums::getEnumByRaw( raw_enum_t raw ) const { return findEnum( raw ); }
const FieldEnumMap & CollInquiryResultEnums::getEnumMapByRaw() const { return CollInquiryResultEnums::itemByRaw; }
const FieldEnumBase ** CollInquiryResultEnums::getEnums() const { return items; }
const CollInquiryResultEnums CollInquiryResultEnums::instance;
const FieldEnumBase * CollInquiryResultEnums::items[] = {
& CollInquiryResultEnums::SUCCESSFUL,
& CollInquiryResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT,
& CollInquiryResultEnums::INVALID_OR_UNKNOWN_COLLATERAL_TYPE,
& CollInquiryResultEnums::INVALID_PARTIES,
& CollInquiryResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED,
& CollInquiryResultEnums::INVALID_DESTINATION_REQUESTED,
& CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED,
& CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED,
& CollInquiryResultEnums::COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED,
& CollInquiryResultEnums::UNAUTHORIZED_FOR_COLLATERAL_INQUIRY,
& CollInquiryResultEnums::OTHER,
nullptr };

// -------------------------------------- enum maps ----------------------------------------

const FieldEnumMap AdvSideEnums::itemByRaw = {
{ AdvSideEnums::BUY.raw, & AdvSideEnums::BUY },
{ AdvSideEnums::SELL.raw, & AdvSideEnums::SELL },
{ AdvSideEnums::CROSS.raw, & AdvSideEnums::CROSS },
{ AdvSideEnums::TRADE.raw, & AdvSideEnums::TRADE },
};

const FieldEnumMap AdvTransTypeEnums::itemByRaw = {
{ AdvTransTypeEnums::NEW.raw, & AdvTransTypeEnums::NEW },
{ AdvTransTypeEnums::CANCEL.raw, & AdvTransTypeEnums::CANCEL },
{ AdvTransTypeEnums::REPLACE.raw, & AdvTransTypeEnums::REPLACE },
};

const FieldEnumMap CommTypeEnums::itemByRaw = {
{ CommTypeEnums::PER_UNIT.raw, & CommTypeEnums::PER_UNIT },
{ CommTypeEnums::PERCENTAGE.raw, & CommTypeEnums::PERCENTAGE },
{ CommTypeEnums::ABSOLUTE.raw, & CommTypeEnums::ABSOLUTE },
{ CommTypeEnums::_4.raw, & CommTypeEnums::_4 },
{ CommTypeEnums::_5.raw, & CommTypeEnums::_5 },
{ CommTypeEnums::POINTS_PER_BOND_OR_CONTRACT_SUPPLY_CONTRACTMULTIPLIER.raw, & CommTypeEnums::POINTS_PER_BOND_OR_CONTRACT_SUPPLY_CONTRACTMULTIPLIER },
};

const FieldEnumMap ExecInstEnums::itemByRaw = {
{ ExecInstEnums::NOT_HELD.raw, & ExecInstEnums::NOT_HELD },
{ ExecInstEnums::WORK.raw, & ExecInstEnums::WORK },
{ ExecInstEnums::GO_ALONG.raw, & ExecInstEnums::GO_ALONG },
{ ExecInstEnums::OVER_THE_DAY.raw, & ExecInstEnums::OVER_THE_DAY },
{ ExecInstEnums::HELD.raw, & ExecInstEnums::HELD },
{ ExecInstEnums::PARTICIPATE_DONT_INITIATE.raw, & ExecInstEnums::PARTICIPATE_DONT_INITIATE },
{ ExecInstEnums::STRICT_SCALE.raw, & ExecInstEnums::STRICT_SCALE },
{ ExecInstEnums::TRY_TO_SCALE.raw, & ExecInstEnums::TRY_TO_SCALE },
{ ExecInstEnums::STAY_ON_BIDSIDE.raw, & ExecInstEnums::STAY_ON_BIDSIDE },
{ ExecInstEnums::STAY_ON_OFFERSIDE.raw, & ExecInstEnums::STAY_ON_OFFERSIDE },
{ ExecInstEnums::NO_CROSS.raw, & ExecInstEnums::NO_CROSS },
{ ExecInstEnums::OK_TO_CROSS.raw, & ExecInstEnums::OK_TO_CROSS },
{ ExecInstEnums::CALL_FIRST.raw, & ExecInstEnums::CALL_FIRST },
{ ExecInstEnums::PERCENT_OF_VOLUME.raw, & ExecInstEnums::PERCENT_OF_VOLUME },
{ ExecInstEnums::DO_NOT_INCREASE.raw, & ExecInstEnums::DO_NOT_INCREASE },
{ ExecInstEnums::DO_NOT_REDUCE.raw, & ExecInstEnums::DO_NOT_REDUCE },
{ ExecInstEnums::ALL_OR_NONE.raw, & ExecInstEnums::ALL_OR_NONE },
{ ExecInstEnums::REINSTATE_ON_SYSTEM_FAILURE.raw, & ExecInstEnums::REINSTATE_ON_SYSTEM_FAILURE },
{ ExecInstEnums::INSTITUTIONS_ONLY.raw, & ExecInstEnums::INSTITUTIONS_ONLY },
{ ExecInstEnums::REINSTATE_ON_TRADING_HALT.raw, & ExecInstEnums::REINSTATE_ON_TRADING_HALT },
{ ExecInstEnums::CANCEL_ON_TRADING_HALT.raw, & ExecInstEnums::CANCEL_ON_TRADING_HALT },
{ ExecInstEnums::LAST_PEG.raw, & ExecInstEnums::LAST_PEG },
{ ExecInstEnums::MID_PRICE_PEG.raw, & ExecInstEnums::MID_PRICE_PEG },
{ ExecInstEnums::NON_NEGOTIABLE.raw, & ExecInstEnums::NON_NEGOTIABLE },
{ ExecInstEnums::OPENING_PEG.raw, & ExecInstEnums::OPENING_PEG },
{ ExecInstEnums::MARKET_PEG.raw, & ExecInstEnums::MARKET_PEG },
{ ExecInstEnums::CANCEL_ON_SYSTEM_FAILURE.raw, & ExecInstEnums::CANCEL_ON_SYSTEM_FAILURE },
{ ExecInstEnums::PRIMARY_PEG.raw, & ExecInstEnums::PRIMARY_PEG },
{ ExecInstEnums::SUSPEND.raw, & ExecInstEnums::SUSPEND },
{ ExecInstEnums::CUSTOMER_DISPLAY_INSTRUCTION.raw, & ExecInstEnums::CUSTOMER_DISPLAY_INSTRUCTION },
{ ExecInstEnums::NETTING.raw, & ExecInstEnums::NETTING },
{ ExecInstEnums::PEG_TO_VWAP.raw, & ExecInstEnums::PEG_TO_VWAP },
{ ExecInstEnums::TRADE_ALONG.raw, & ExecInstEnums::TRADE_ALONG },
{ ExecInstEnums::TRY_TO_STOP.raw, & ExecInstEnums::TRY_TO_STOP },
{ ExecInstEnums::CANCEL_IF_NOT_BEST.raw, & ExecInstEnums::CANCEL_IF_NOT_BEST },
{ ExecInstEnums::TRAILING_STOP_PEG.raw, & ExecInstEnums::TRAILING_STOP_PEG },
{ ExecInstEnums::STRICT_LIMIT.raw, & ExecInstEnums::STRICT_LIMIT },
{ ExecInstEnums::IGNORE_PRICE_VALIDITY_CHECKS.raw, & ExecInstEnums::IGNORE_PRICE_VALIDITY_CHECKS },
{ ExecInstEnums::PEG_TO_LIMIT_PRICE.raw, & ExecInstEnums::PEG_TO_LIMIT_PRICE },
{ ExecInstEnums::WORK_TO_TARGET_STRATEGY.raw, & ExecInstEnums::WORK_TO_TARGET_STRATEGY },
};

const FieldEnumMap HandlInstEnums::itemByRaw = {
{ HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION.raw, & HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION },
{ HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PUBLIC_BROKER_INTERVENTION_OK.raw, & HandlInstEnums::AUTOMATED_EXECUTION_ORDER_PUBLIC_BROKER_INTERVENTION_OK },
{ HandlInstEnums::MANUAL_ORDER_BEST_EXECUTION.raw, & HandlInstEnums::MANUAL_ORDER_BEST_EXECUTION },
};

const FieldEnumMap SecurityIDSourceEnums::itemByRaw = {
{ SecurityIDSourceEnums::CUSIP.raw, & SecurityIDSourceEnums::CUSIP },
{ SecurityIDSourceEnums::SEDOL.raw, & SecurityIDSourceEnums::SEDOL },
{ SecurityIDSourceEnums::QUIK.raw, & SecurityIDSourceEnums::QUIK },
{ SecurityIDSourceEnums::ISIN_NUMBER.raw, & SecurityIDSourceEnums::ISIN_NUMBER },
{ SecurityIDSourceEnums::RIC_CODE.raw, & SecurityIDSourceEnums::RIC_CODE },
{ SecurityIDSourceEnums::ISO_CURRENCY_CODE.raw, & SecurityIDSourceEnums::ISO_CURRENCY_CODE },
{ SecurityIDSourceEnums::ISO_COUNTRY_CODE.raw, & SecurityIDSourceEnums::ISO_COUNTRY_CODE },
{ SecurityIDSourceEnums::EXCHANGE_SYMBOL.raw, & SecurityIDSourceEnums::EXCHANGE_SYMBOL },
{ SecurityIDSourceEnums::CONSOLIDATED_TAPE_ASSOCIATION.raw, & SecurityIDSourceEnums::CONSOLIDATED_TAPE_ASSOCIATION },
{ SecurityIDSourceEnums::BLOOMBERG_SYMBOL.raw, & SecurityIDSourceEnums::BLOOMBERG_SYMBOL },
{ SecurityIDSourceEnums::WERTPAPIER.raw, & SecurityIDSourceEnums::WERTPAPIER },
{ SecurityIDSourceEnums::DUTCH.raw, & SecurityIDSourceEnums::DUTCH },
{ SecurityIDSourceEnums::VALOREN.raw, & SecurityIDSourceEnums::VALOREN },
{ SecurityIDSourceEnums::SICOVAM.raw, & SecurityIDSourceEnums::SICOVAM },
{ SecurityIDSourceEnums::BELGIAN.raw, & SecurityIDSourceEnums::BELGIAN },
{ SecurityIDSourceEnums::COMMON.raw, & SecurityIDSourceEnums::COMMON },
{ SecurityIDSourceEnums::CLEARING_HOUSE.raw, & SecurityIDSourceEnums::CLEARING_HOUSE },
{ SecurityIDSourceEnums::ISDA_FPML_PRODUCT_SPECIFICATION.raw, & SecurityIDSourceEnums::ISDA_FPML_PRODUCT_SPECIFICATION },
{ SecurityIDSourceEnums::OPTIONS_PRICE_REPORTING_AUTHORITY.raw, & SecurityIDSourceEnums::OPTIONS_PRICE_REPORTING_AUTHORITY },
};

const FieldEnumMap IOIQltyIndEnums::itemByRaw = {
{ IOIQltyIndEnums::LOW.raw, & IOIQltyIndEnums::LOW },
{ IOIQltyIndEnums::MEDIUM.raw, & IOIQltyIndEnums::MEDIUM },
{ IOIQltyIndEnums::HIGH.raw, & IOIQltyIndEnums::HIGH },
};

const FieldEnumMap IOIQtyEnums::itemByRaw = {
{ IOIQtyEnums::SMALL.raw, & IOIQtyEnums::SMALL },
{ IOIQtyEnums::MEDIUM.raw, & IOIQtyEnums::MEDIUM },
{ IOIQtyEnums::LARGE.raw, & IOIQtyEnums::LARGE },
};

const FieldEnumMap IOITransTypeEnums::itemByRaw = {
{ IOITransTypeEnums::NEW.raw, & IOITransTypeEnums::NEW },
{ IOITransTypeEnums::CANCEL.raw, & IOITransTypeEnums::CANCEL },
{ IOITransTypeEnums::REPLACE.raw, & IOITransTypeEnums::REPLACE },
};

const FieldEnumMap LastCapacityEnums::itemByRaw = {
{ LastCapacityEnums::AGENT.raw, & LastCapacityEnums::AGENT },
{ LastCapacityEnums::CROSS_AS_AGENT.raw, & LastCapacityEnums::CROSS_AS_AGENT },
{ LastCapacityEnums::CROSS_AS_PRINCIPAL.raw, & LastCapacityEnums::CROSS_AS_PRINCIPAL },
{ LastCapacityEnums::PRINCIPAL.raw, & LastCapacityEnums::PRINCIPAL },
};

const FieldEnumMap MsgTypeEnums::itemByRaw = {
{ MsgTypeEnums::HEARTBEAT.raw, & MsgTypeEnums::HEARTBEAT },
{ MsgTypeEnums::TEST_REQUEST.raw, & MsgTypeEnums::TEST_REQUEST },
{ MsgTypeEnums::RESEND_REQUEST.raw, & MsgTypeEnums::RESEND_REQUEST },
{ MsgTypeEnums::REJECT.raw, & MsgTypeEnums::REJECT },
{ MsgTypeEnums::SEQUENCE_RESET.raw, & MsgTypeEnums::SEQUENCE_RESET },
{ MsgTypeEnums::LOGOUT.raw, & MsgTypeEnums::LOGOUT },
{ MsgTypeEnums::INDICATION_OF_INTEREST.raw, & MsgTypeEnums::INDICATION_OF_INTEREST },
{ MsgTypeEnums::ADVERTISEMENT.raw, & MsgTypeEnums::ADVERTISEMENT },
{ MsgTypeEnums::EXECUTION_REPORT.raw, & MsgTypeEnums::EXECUTION_REPORT },
{ MsgTypeEnums::ORDER_CANCEL_REJECT.raw, & MsgTypeEnums::ORDER_CANCEL_REJECT },
{ MsgTypeEnums::LOGON.raw, & MsgTypeEnums::LOGON },
{ MsgTypeEnums::NEWS.raw, & MsgTypeEnums::NEWS },
{ MsgTypeEnums::EMAIL.raw, & MsgTypeEnums::EMAIL },
{ MsgTypeEnums::ORDER_SINGLE.raw, & MsgTypeEnums::ORDER_SINGLE },
{ MsgTypeEnums::ORDER_LIST.raw, & MsgTypeEnums::ORDER_LIST },
{ MsgTypeEnums::ORDER_CANCEL_REQUEST.raw, & MsgTypeEnums::ORDER_CANCEL_REQUEST },
{ MsgTypeEnums::ORDER_CANCEL_REPLACE_REQUEST.raw, & MsgTypeEnums::ORDER_CANCEL_REPLACE_REQUEST },
{ MsgTypeEnums::ORDER_STATUS_REQUEST.raw, & MsgTypeEnums::ORDER_STATUS_REQUEST },
{ MsgTypeEnums::ALLOCATION_INSTRUCTION.raw, & MsgTypeEnums::ALLOCATION_INSTRUCTION },
{ MsgTypeEnums::LIST_CANCEL_REQUEST.raw, & MsgTypeEnums::LIST_CANCEL_REQUEST },
{ MsgTypeEnums::LIST_EXECUTE.raw, & MsgTypeEnums::LIST_EXECUTE },
{ MsgTypeEnums::LIST_STATUS_REQUEST.raw, & MsgTypeEnums::LIST_STATUS_REQUEST },
{ MsgTypeEnums::LIST_STATUS.raw, & MsgTypeEnums::LIST_STATUS },
{ MsgTypeEnums::ALLOCATION_INSTRUCTION_ACK.raw, & MsgTypeEnums::ALLOCATION_INSTRUCTION_ACK },
{ MsgTypeEnums::DONT_KNOW_TRADE.raw, & MsgTypeEnums::DONT_KNOW_TRADE },
{ MsgTypeEnums::QUOTE_REQUEST.raw, & MsgTypeEnums::QUOTE_REQUEST },
{ MsgTypeEnums::QUOTE.raw, & MsgTypeEnums::QUOTE },
{ MsgTypeEnums::SETTLEMENT_INSTRUCTIONS.raw, & MsgTypeEnums::SETTLEMENT_INSTRUCTIONS },
{ MsgTypeEnums::MARKET_DATA_REQUEST.raw, & MsgTypeEnums::MARKET_DATA_REQUEST },
{ MsgTypeEnums::MARKET_DATA_SNAPSHOT_FULL_REFRESH.raw, & MsgTypeEnums::MARKET_DATA_SNAPSHOT_FULL_REFRESH },
{ MsgTypeEnums::MARKET_DATA_INCREMENTAL_REFRESH.raw, & MsgTypeEnums::MARKET_DATA_INCREMENTAL_REFRESH },
{ MsgTypeEnums::MARKET_DATA_REQUEST_REJECT.raw, & MsgTypeEnums::MARKET_DATA_REQUEST_REJECT },
{ MsgTypeEnums::QUOTE_CANCEL.raw, & MsgTypeEnums::QUOTE_CANCEL },
{ MsgTypeEnums::QUOTE_STATUS_REQUEST.raw, & MsgTypeEnums::QUOTE_STATUS_REQUEST },
{ MsgTypeEnums::MASS_QUOTE_ACKNOWLEDGEMENT.raw, & MsgTypeEnums::MASS_QUOTE_ACKNOWLEDGEMENT },
{ MsgTypeEnums::SECURITY_DEFINITION_REQUEST.raw, & MsgTypeEnums::SECURITY_DEFINITION_REQUEST },
{ MsgTypeEnums::SECURITY_DEFINITION.raw, & MsgTypeEnums::SECURITY_DEFINITION },
{ MsgTypeEnums::SECURITY_STATUS_REQUEST.raw, & MsgTypeEnums::SECURITY_STATUS_REQUEST },
{ MsgTypeEnums::SECURITY_STATUS.raw, & MsgTypeEnums::SECURITY_STATUS },
{ MsgTypeEnums::TRADING_SESSION_STATUS_REQUEST.raw, & MsgTypeEnums::TRADING_SESSION_STATUS_REQUEST },
{ MsgTypeEnums::TRADING_SESSION_STATUS.raw, & MsgTypeEnums::TRADING_SESSION_STATUS },
{ MsgTypeEnums::MASS_QUOTE.raw, & MsgTypeEnums::MASS_QUOTE },
{ MsgTypeEnums::BUSINESS_MESSAGE_REJECT.raw, & MsgTypeEnums::BUSINESS_MESSAGE_REJECT },
{ MsgTypeEnums::BID_REQUEST.raw, & MsgTypeEnums::BID_REQUEST },
{ MsgTypeEnums::BID_RESPONSE.raw, & MsgTypeEnums::BID_RESPONSE },
{ MsgTypeEnums::LIST_STRIKE_PRICE.raw, & MsgTypeEnums::LIST_STRIKE_PRICE },
{ MsgTypeEnums::XML_MESSAGE.raw, & MsgTypeEnums::XML_MESSAGE },
{ MsgTypeEnums::REGISTRATION_INSTRUCTIONS.raw, & MsgTypeEnums::REGISTRATION_INSTRUCTIONS },
{ MsgTypeEnums::REGISTRATION_INSTRUCTIONS_RESPONSE.raw, & MsgTypeEnums::REGISTRATION_INSTRUCTIONS_RESPONSE },
{ MsgTypeEnums::ORDER_MASS_CANCEL_REQUEST.raw, & MsgTypeEnums::ORDER_MASS_CANCEL_REQUEST },
{ MsgTypeEnums::ORDER_MASS_CANCEL_REPORT.raw, & MsgTypeEnums::ORDER_MASS_CANCEL_REPORT },
{ MsgTypeEnums::NEW_ORDER_s.raw, & MsgTypeEnums::NEW_ORDER_s },
{ MsgTypeEnums::CROSS_ORDER_CANCEL_REPLACE_REQUEST.raw, & MsgTypeEnums::CROSS_ORDER_CANCEL_REPLACE_REQUEST },
{ MsgTypeEnums::CROSS_ORDER_CANCEL_REQUEST.raw, & MsgTypeEnums::CROSS_ORDER_CANCEL_REQUEST },
{ MsgTypeEnums::SECURITY_TYPE_REQUEST.raw, & MsgTypeEnums::SECURITY_TYPE_REQUEST },
{ MsgTypeEnums::SECURITY_TYPES.raw, & MsgTypeEnums::SECURITY_TYPES },
{ MsgTypeEnums::SECURITY_LIST_REQUEST.raw, & MsgTypeEnums::SECURITY_LIST_REQUEST },
{ MsgTypeEnums::SECURITY_LIST.raw, & MsgTypeEnums::SECURITY_LIST },
{ MsgTypeEnums::DERIVATIVE_SECURITY_LIST_REQUEST.raw, & MsgTypeEnums::DERIVATIVE_SECURITY_LIST_REQUEST },
{ MsgTypeEnums::DERIVATIVE_SECURITY_LIST.raw, & MsgTypeEnums::DERIVATIVE_SECURITY_LIST },
{ MsgTypeEnums::NEW_ORDER_AB.raw, & MsgTypeEnums::NEW_ORDER_AB },
{ MsgTypeEnums::MULTILEG_ORDER_CANCEL_REPLACE.raw, & MsgTypeEnums::MULTILEG_ORDER_CANCEL_REPLACE },
{ MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST.raw, & MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST },
{ MsgTypeEnums::TRADE_CAPTURE_REPORT.raw, & MsgTypeEnums::TRADE_CAPTURE_REPORT },
{ MsgTypeEnums::ORDER_MASS_STATUS_REQUEST.raw, & MsgTypeEnums::ORDER_MASS_STATUS_REQUEST },
{ MsgTypeEnums::QUOTE_REQUEST_REJECT.raw, & MsgTypeEnums::QUOTE_REQUEST_REJECT },
{ MsgTypeEnums::RFQ_REQUEST.raw, & MsgTypeEnums::RFQ_REQUEST },
{ MsgTypeEnums::QUOTE_STATUS_REPORT.raw, & MsgTypeEnums::QUOTE_STATUS_REPORT },
{ MsgTypeEnums::QUOTE_RESPONSE.raw, & MsgTypeEnums::QUOTE_RESPONSE },
{ MsgTypeEnums::CONFIRMATION.raw, & MsgTypeEnums::CONFIRMATION },
{ MsgTypeEnums::POSITION_MAINTENANCE_REQUEST.raw, & MsgTypeEnums::POSITION_MAINTENANCE_REQUEST },
{ MsgTypeEnums::POSITION_MAINTENANCE_REPORT.raw, & MsgTypeEnums::POSITION_MAINTENANCE_REPORT },
{ MsgTypeEnums::REQUEST_FOR_POSITIONS.raw, & MsgTypeEnums::REQUEST_FOR_POSITIONS },
{ MsgTypeEnums::REQUEST_FOR_POSITIONS_ACK.raw, & MsgTypeEnums::REQUEST_FOR_POSITIONS_ACK },
{ MsgTypeEnums::POSITION_REPORT.raw, & MsgTypeEnums::POSITION_REPORT },
{ MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST_ACK.raw, & MsgTypeEnums::TRADE_CAPTURE_REPORT_REQUEST_ACK },
{ MsgTypeEnums::TRADE_CAPTURE_REPORT_ACK.raw, & MsgTypeEnums::TRADE_CAPTURE_REPORT_ACK },
{ MsgTypeEnums::ALLOCATION_REPORT.raw, & MsgTypeEnums::ALLOCATION_REPORT },
{ MsgTypeEnums::ALLOCATION_REPORT_ACK.raw, & MsgTypeEnums::ALLOCATION_REPORT_ACK },
{ MsgTypeEnums::CONFIRMATION_ACK.raw, & MsgTypeEnums::CONFIRMATION_ACK },
{ MsgTypeEnums::SETTLEMENT_INSTRUCTION_REQUEST.raw, & MsgTypeEnums::SETTLEMENT_INSTRUCTION_REQUEST },
{ MsgTypeEnums::ASSIGNMENT_REPORT.raw, & MsgTypeEnums::ASSIGNMENT_REPORT },
{ MsgTypeEnums::COLLATERAL_REQUEST.raw, & MsgTypeEnums::COLLATERAL_REQUEST },
{ MsgTypeEnums::COLLATERAL_ASSIGNMENT.raw, & MsgTypeEnums::COLLATERAL_ASSIGNMENT },
{ MsgTypeEnums::COLLATERAL_RESPONSE.raw, & MsgTypeEnums::COLLATERAL_RESPONSE },
{ MsgTypeEnums::COLLATERAL_REPORT.raw, & MsgTypeEnums::COLLATERAL_REPORT },
{ MsgTypeEnums::COLLATERAL_INQUIRY.raw, & MsgTypeEnums::COLLATERAL_INQUIRY },
{ MsgTypeEnums::NETWORK_BC.raw, & MsgTypeEnums::NETWORK_BC },
{ MsgTypeEnums::NETWORK_BD.raw, & MsgTypeEnums::NETWORK_BD },
{ MsgTypeEnums::USER_REQUEST.raw, & MsgTypeEnums::USER_REQUEST },
{ MsgTypeEnums::USER_RESPONSE.raw, & MsgTypeEnums::USER_RESPONSE },
{ MsgTypeEnums::COLLATERAL_INQUIRY_ACK.raw, & MsgTypeEnums::COLLATERAL_INQUIRY_ACK },
{ MsgTypeEnums::CONFIRMATION_REQUEST.raw, & MsgTypeEnums::CONFIRMATION_REQUEST },
};

const FieldEnumMap OrdStatusEnums::itemByRaw = {
{ OrdStatusEnums::NEW.raw, & OrdStatusEnums::NEW },
{ OrdStatusEnums::PARTIALLY_FILLED.raw, & OrdStatusEnums::PARTIALLY_FILLED },
{ OrdStatusEnums::FILLED.raw, & OrdStatusEnums::FILLED },
{ OrdStatusEnums::DONE_FOR_DAY.raw, & OrdStatusEnums::DONE_FOR_DAY },
{ OrdStatusEnums::CANCELED.raw, & OrdStatusEnums::CANCELED },
{ OrdStatusEnums::PENDING_CANCEL.raw, & OrdStatusEnums::PENDING_CANCEL },
{ OrdStatusEnums::STOPPED.raw, & OrdStatusEnums::STOPPED },
{ OrdStatusEnums::REJECTED.raw, & OrdStatusEnums::REJECTED },
{ OrdStatusEnums::SUSPENDED.raw, & OrdStatusEnums::SUSPENDED },
{ OrdStatusEnums::PENDING_NEW.raw, & OrdStatusEnums::PENDING_NEW },
{ OrdStatusEnums::CALCULATED.raw, & OrdStatusEnums::CALCULATED },
{ OrdStatusEnums::EXPIRED.raw, & OrdStatusEnums::EXPIRED },
{ OrdStatusEnums::ACCEPTED_FOR_BIDDING.raw, & OrdStatusEnums::ACCEPTED_FOR_BIDDING },
{ OrdStatusEnums::PENDING_REPLACE.raw, & OrdStatusEnums::PENDING_REPLACE },
};

const FieldEnumMap OrdTypeEnums::itemByRaw = {
{ OrdTypeEnums::MARKET.raw, & OrdTypeEnums::MARKET },
{ OrdTypeEnums::LIMIT.raw, & OrdTypeEnums::LIMIT },
{ OrdTypeEnums::STOP.raw, & OrdTypeEnums::STOP },
{ OrdTypeEnums::STOP_LIMIT.raw, & OrdTypeEnums::STOP_LIMIT },
{ OrdTypeEnums::WITH_OR_WITHOUT.raw, & OrdTypeEnums::WITH_OR_WITHOUT },
{ OrdTypeEnums::LIMIT_OR_BETTER.raw, & OrdTypeEnums::LIMIT_OR_BETTER },
{ OrdTypeEnums::LIMIT_WITH_OR_WITHOUT.raw, & OrdTypeEnums::LIMIT_WITH_OR_WITHOUT },
{ OrdTypeEnums::ON_BASIS.raw, & OrdTypeEnums::ON_BASIS },
{ OrdTypeEnums::PREVIOUSLY_QUOTED.raw, & OrdTypeEnums::PREVIOUSLY_QUOTED },
{ OrdTypeEnums::PREVIOUSLY_INDICATED.raw, & OrdTypeEnums::PREVIOUSLY_INDICATED },
{ OrdTypeEnums::FOREX.raw, & OrdTypeEnums::FOREX },
{ OrdTypeEnums::FUNARI.raw, & OrdTypeEnums::FUNARI },
{ OrdTypeEnums::MARKET_IF_TOUCHED.raw, & OrdTypeEnums::MARKET_IF_TOUCHED },
{ OrdTypeEnums::MARKET_WITH_LEFTOVER_AS_LIMIT.raw, & OrdTypeEnums::MARKET_WITH_LEFTOVER_AS_LIMIT },
{ OrdTypeEnums::PREVIOUS_FUND_VALUATION_POINT.raw, & OrdTypeEnums::PREVIOUS_FUND_VALUATION_POINT },
{ OrdTypeEnums::NEXT_FUND_VALUATION_POINT.raw, & OrdTypeEnums::NEXT_FUND_VALUATION_POINT },
{ OrdTypeEnums::PEGGED.raw, & OrdTypeEnums::PEGGED },
};

const FieldEnumMap PossDupFlagEnums::itemByRaw = {
{ PossDupFlagEnums::YES.raw, & PossDupFlagEnums::YES },
{ PossDupFlagEnums::NO.raw, & PossDupFlagEnums::NO },
};

const FieldEnumMap SideEnums::itemByRaw = {
{ SideEnums::BUY.raw, & SideEnums::BUY },
{ SideEnums::SELL.raw, & SideEnums::SELL },
{ SideEnums::BUY_MINUS.raw, & SideEnums::BUY_MINUS },
{ SideEnums::SELL_PLUS.raw, & SideEnums::SELL_PLUS },
{ SideEnums::SELL_SHORT.raw, & SideEnums::SELL_SHORT },
{ SideEnums::SELL_SHORT_EXEMPT.raw, & SideEnums::SELL_SHORT_EXEMPT },
{ SideEnums::UNDISCLOSED.raw, & SideEnums::UNDISCLOSED },
{ SideEnums::CROSS.raw, & SideEnums::CROSS },
{ SideEnums::CROSS_SHORT.raw, & SideEnums::CROSS_SHORT },
{ SideEnums::CROSS_SHORT_EXEMPT.raw, & SideEnums::CROSS_SHORT_EXEMPT },
{ SideEnums::AS_DEFINED.raw, & SideEnums::AS_DEFINED },
{ SideEnums::OPPOSITE.raw, & SideEnums::OPPOSITE },
{ SideEnums::SUBSCRIBE.raw, & SideEnums::SUBSCRIBE },
{ SideEnums::REDEEM.raw, & SideEnums::REDEEM },
{ SideEnums::LEND.raw, & SideEnums::LEND },
{ SideEnums::BORROW.raw, & SideEnums::BORROW },
};

const FieldEnumMap TimeInForceEnums::itemByRaw = {
{ TimeInForceEnums::DAY.raw, & TimeInForceEnums::DAY },
{ TimeInForceEnums::GOOD_TILL_CANCEL.raw, & TimeInForceEnums::GOOD_TILL_CANCEL },
{ TimeInForceEnums::AT_THE_OPENING.raw, & TimeInForceEnums::AT_THE_OPENING },
{ TimeInForceEnums::IMMEDIATE_OR_CANCEL.raw, & TimeInForceEnums::IMMEDIATE_OR_CANCEL },
{ TimeInForceEnums::FILL_OR_KILL.raw, & TimeInForceEnums::FILL_OR_KILL },
{ TimeInForceEnums::GOOD_TILL_CROSSING.raw, & TimeInForceEnums::GOOD_TILL_CROSSING },
{ TimeInForceEnums::GOOD_TILL_DATE.raw, & TimeInForceEnums::GOOD_TILL_DATE },
{ TimeInForceEnums::AT_THE_CLOSE.raw, & TimeInForceEnums::AT_THE_CLOSE },
};

const FieldEnumMap UrgencyEnums::itemByRaw = {
{ UrgencyEnums::NORMAL.raw, & UrgencyEnums::NORMAL },
{ UrgencyEnums::FLASH.raw, & UrgencyEnums::FLASH },
{ UrgencyEnums::BACKGROUND.raw, & UrgencyEnums::BACKGROUND },
};

const FieldEnumMap SettlTypeEnums::itemByRaw = {
{ SettlTypeEnums::REGULAR.raw, & SettlTypeEnums::REGULAR },
{ SettlTypeEnums::CASH.raw, & SettlTypeEnums::CASH },
{ SettlTypeEnums::NEXT_DAY.raw, & SettlTypeEnums::NEXT_DAY },
{ SettlTypeEnums::T_PLUS_2.raw, & SettlTypeEnums::T_PLUS_2 },
{ SettlTypeEnums::T_PLUS_3.raw, & SettlTypeEnums::T_PLUS_3 },
{ SettlTypeEnums::T_PLUS_4.raw, & SettlTypeEnums::T_PLUS_4 },
{ SettlTypeEnums::FUTURE.raw, & SettlTypeEnums::FUTURE },
{ SettlTypeEnums::WHEN_AND_IF_ISSUED.raw, & SettlTypeEnums::WHEN_AND_IF_ISSUED },
{ SettlTypeEnums::SELLERS_OPTION.raw, & SettlTypeEnums::SELLERS_OPTION },
{ SettlTypeEnums::T_PLUS_5.raw, & SettlTypeEnums::T_PLUS_5 },
};

const FieldEnumMap AllocTransTypeEnums::itemByRaw = {
{ AllocTransTypeEnums::NEW.raw, & AllocTransTypeEnums::NEW },
{ AllocTransTypeEnums::REPLACE.raw, & AllocTransTypeEnums::REPLACE },
{ AllocTransTypeEnums::CANCEL.raw, & AllocTransTypeEnums::CANCEL },
};

const FieldEnumMap PositionEffectEnums::itemByRaw = {
{ PositionEffectEnums::OPEN.raw, & PositionEffectEnums::OPEN },
{ PositionEffectEnums::CLOSE.raw, & PositionEffectEnums::CLOSE },
{ PositionEffectEnums::ROLLED.raw, & PositionEffectEnums::ROLLED },
{ PositionEffectEnums::FIFO.raw, & PositionEffectEnums::FIFO },
};

const FieldEnumMap ProcessCodeEnums::itemByRaw = {
{ ProcessCodeEnums::REGULAR.raw, & ProcessCodeEnums::REGULAR },
{ ProcessCodeEnums::SOFT_DOLLAR.raw, & ProcessCodeEnums::SOFT_DOLLAR },
{ ProcessCodeEnums::STEP_IN.raw, & ProcessCodeEnums::STEP_IN },
{ ProcessCodeEnums::STEP_OUT.raw, & ProcessCodeEnums::STEP_OUT },
{ ProcessCodeEnums::SOFT_DOLLAR_STEP_IN.raw, & ProcessCodeEnums::SOFT_DOLLAR_STEP_IN },
{ ProcessCodeEnums::SOFT_DOLLAR_STEP_OUT.raw, & ProcessCodeEnums::SOFT_DOLLAR_STEP_OUT },
{ ProcessCodeEnums::PLAN_SPONSOR.raw, & ProcessCodeEnums::PLAN_SPONSOR },
};

const FieldEnumMap AllocStatusEnums::itemByRaw = {
{ AllocStatusEnums::ACCEPTED.raw, & AllocStatusEnums::ACCEPTED },
{ AllocStatusEnums::BLOCK_LEVEL_REJECT.raw, & AllocStatusEnums::BLOCK_LEVEL_REJECT },
{ AllocStatusEnums::ACCOUNT_LEVEL_REJECT.raw, & AllocStatusEnums::ACCOUNT_LEVEL_REJECT },
{ AllocStatusEnums::RECEIVED.raw, & AllocStatusEnums::RECEIVED },
{ AllocStatusEnums::INCOMPLETE.raw, & AllocStatusEnums::INCOMPLETE },
{ AllocStatusEnums::REJECTED_BY_INTERMEDIARY.raw, & AllocStatusEnums::REJECTED_BY_INTERMEDIARY },
};

const FieldEnumMap AllocRejCodeEnums::itemByRaw = {
{ AllocRejCodeEnums::UNKNOWN_ACCOUNT.raw, & AllocRejCodeEnums::UNKNOWN_ACCOUNT },
{ AllocRejCodeEnums::INCORRECT_QUANTITY.raw, & AllocRejCodeEnums::INCORRECT_QUANTITY },
{ AllocRejCodeEnums::INCORRECT_AVERAGE_PRICE.raw, & AllocRejCodeEnums::INCORRECT_AVERAGE_PRICE },
{ AllocRejCodeEnums::UNKNOWN_EXECUTING_BROKER_MNEMONIC.raw, & AllocRejCodeEnums::UNKNOWN_EXECUTING_BROKER_MNEMONIC },
{ AllocRejCodeEnums::COMMISSION_DIFFERENCE.raw, & AllocRejCodeEnums::COMMISSION_DIFFERENCE },
{ AllocRejCodeEnums::UNKNOWN_ORDERID.raw, & AllocRejCodeEnums::UNKNOWN_ORDERID },
{ AllocRejCodeEnums::UNKNOWN_LISTID.raw, & AllocRejCodeEnums::UNKNOWN_LISTID },
{ AllocRejCodeEnums::OTHER.raw, & AllocRejCodeEnums::OTHER },
{ AllocRejCodeEnums::INCORRECT_ALLOCATED_QUANTITY.raw, & AllocRejCodeEnums::INCORRECT_ALLOCATED_QUANTITY },
{ AllocRejCodeEnums::CALCULATION_DIFFERENCE.raw, & AllocRejCodeEnums::CALCULATION_DIFFERENCE },
{ AllocRejCodeEnums::UNKNOWN_OR_STALE_EXECID.raw, & AllocRejCodeEnums::UNKNOWN_OR_STALE_EXECID },
{ AllocRejCodeEnums::MISMATCHED_DATA_VALUE.raw, & AllocRejCodeEnums::MISMATCHED_DATA_VALUE },
{ AllocRejCodeEnums::UNKNOWN_CLORDID.raw, & AllocRejCodeEnums::UNKNOWN_CLORDID },
{ AllocRejCodeEnums::WAREHOUSE_REQUEST_REJECTED.raw, & AllocRejCodeEnums::WAREHOUSE_REQUEST_REJECTED },
};

const FieldEnumMap EmailTypeEnums::itemByRaw = {
{ EmailTypeEnums::NEW.raw, & EmailTypeEnums::NEW },
{ EmailTypeEnums::REPLY.raw, & EmailTypeEnums::REPLY },
{ EmailTypeEnums::ADMIN_REPLY.raw, & EmailTypeEnums::ADMIN_REPLY },
};

const FieldEnumMap PossResendEnums::itemByRaw = {
{ PossResendEnums::YES.raw, & PossResendEnums::YES },
{ PossResendEnums::NO.raw, & PossResendEnums::NO },
};

const FieldEnumMap EncryptMethodEnums::itemByRaw = {
{ EncryptMethodEnums::NONE.raw, & EncryptMethodEnums::NONE },
{ EncryptMethodEnums::PKCS.raw, & EncryptMethodEnums::PKCS },
{ EncryptMethodEnums::DES.raw, & EncryptMethodEnums::DES },
{ EncryptMethodEnums::PKCS_DES.raw, & EncryptMethodEnums::PKCS_DES },
{ EncryptMethodEnums::PGP_DES.raw, & EncryptMethodEnums::PGP_DES },
{ EncryptMethodEnums::PGP_DES_MD5.raw, & EncryptMethodEnums::PGP_DES_MD5 },
{ EncryptMethodEnums::PEM_DES_MD5.raw, & EncryptMethodEnums::PEM_DES_MD5 },
};

const FieldEnumMap CxlRejReasonEnums::itemByRaw = {
{ CxlRejReasonEnums::TOO_LATE_TO_CANCEL.raw, & CxlRejReasonEnums::TOO_LATE_TO_CANCEL },
{ CxlRejReasonEnums::UNKNOWN_ORDER.raw, & CxlRejReasonEnums::UNKNOWN_ORDER },
{ CxlRejReasonEnums::BROKER.raw, & CxlRejReasonEnums::BROKER },
{ CxlRejReasonEnums::ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS.raw, & CxlRejReasonEnums::ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS },
{ CxlRejReasonEnums::UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST.raw, & CxlRejReasonEnums::UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST },
{ CxlRejReasonEnums::ORIGORDMODTIME.raw, & CxlRejReasonEnums::ORIGORDMODTIME },
{ CxlRejReasonEnums::DUPLICATE_CLORDID.raw, & CxlRejReasonEnums::DUPLICATE_CLORDID },
{ CxlRejReasonEnums::OTHER.raw, & CxlRejReasonEnums::OTHER },
};

const FieldEnumMap OrdRejReasonEnums::itemByRaw = {
{ OrdRejReasonEnums::BROKER.raw, & OrdRejReasonEnums::BROKER },
{ OrdRejReasonEnums::UNKNOWN_SYMBOL.raw, & OrdRejReasonEnums::UNKNOWN_SYMBOL },
{ OrdRejReasonEnums::EXCHANGE_CLOSED.raw, & OrdRejReasonEnums::EXCHANGE_CLOSED },
{ OrdRejReasonEnums::ORDER_EXCEEDS_LIMIT.raw, & OrdRejReasonEnums::ORDER_EXCEEDS_LIMIT },
{ OrdRejReasonEnums::TOO_LATE_TO_ENTER.raw, & OrdRejReasonEnums::TOO_LATE_TO_ENTER },
{ OrdRejReasonEnums::UNKNOWN_ORDER.raw, & OrdRejReasonEnums::UNKNOWN_ORDER },
{ OrdRejReasonEnums::DUPLICATE_ORDER.raw, & OrdRejReasonEnums::DUPLICATE_ORDER },
{ OrdRejReasonEnums::DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER.raw, & OrdRejReasonEnums::DUPLICATE_OF_A_VERBALLY_COMMUNICATED_ORDER },
{ OrdRejReasonEnums::STALE_ORDER.raw, & OrdRejReasonEnums::STALE_ORDER },
{ OrdRejReasonEnums::TRADE_ALONG_REQUIRED.raw, & OrdRejReasonEnums::TRADE_ALONG_REQUIRED },
{ OrdRejReasonEnums::INVALID_INVESTOR_ID.raw, & OrdRejReasonEnums::INVALID_INVESTOR_ID },
{ OrdRejReasonEnums::UNSUPPORTED_ORDER_CHARACTERISTIC12_SURVEILLENCE_OPTION.raw, & OrdRejReasonEnums::UNSUPPORTED_ORDER_CHARACTERISTIC12_SURVEILLENCE_OPTION },
{ OrdRejReasonEnums::INCORRECT_QUANTITY.raw, & OrdRejReasonEnums::INCORRECT_QUANTITY },
{ OrdRejReasonEnums::INCORRECT_ALLOCATED_QUANTITY.raw, & OrdRejReasonEnums::INCORRECT_ALLOCATED_QUANTITY },
{ OrdRejReasonEnums::UNKNOWN_ACCOUNT.raw, & OrdRejReasonEnums::UNKNOWN_ACCOUNT },
{ OrdRejReasonEnums::OTHER.raw, & OrdRejReasonEnums::OTHER },
};

const FieldEnumMap IOIQualifierEnums::itemByRaw = {
{ IOIQualifierEnums::ALL_OR_NONE.raw, & IOIQualifierEnums::ALL_OR_NONE },
{ IOIQualifierEnums::MARKET_ON_CLOSE.raw, & IOIQualifierEnums::MARKET_ON_CLOSE },
{ IOIQualifierEnums::AT_THE_CLOSE.raw, & IOIQualifierEnums::AT_THE_CLOSE },
{ IOIQualifierEnums::VWAP.raw, & IOIQualifierEnums::VWAP },
{ IOIQualifierEnums::IN_TOUCH_WITH.raw, & IOIQualifierEnums::IN_TOUCH_WITH },
{ IOIQualifierEnums::LIMIT.raw, & IOIQualifierEnums::LIMIT },
{ IOIQualifierEnums::MORE_BEHIND.raw, & IOIQualifierEnums::MORE_BEHIND },
{ IOIQualifierEnums::AT_THE_OPEN.raw, & IOIQualifierEnums::AT_THE_OPEN },
{ IOIQualifierEnums::TAKING_A_POSITION.raw, & IOIQualifierEnums::TAKING_A_POSITION },
{ IOIQualifierEnums::AT_THE_MARKET.raw, & IOIQualifierEnums::AT_THE_MARKET },
{ IOIQualifierEnums::READY_TO_TRADE.raw, & IOIQualifierEnums::READY_TO_TRADE },
{ IOIQualifierEnums::PORTFOLIO_SHOWN.raw, & IOIQualifierEnums::PORTFOLIO_SHOWN },
{ IOIQualifierEnums::THROUGH_THE_DAY.raw, & IOIQualifierEnums::THROUGH_THE_DAY },
{ IOIQualifierEnums::VERSUS.raw, & IOIQualifierEnums::VERSUS },
{ IOIQualifierEnums::INDICATION.raw, & IOIQualifierEnums::INDICATION },
{ IOIQualifierEnums::CROSSING_OPPORTUNITY.raw, & IOIQualifierEnums::CROSSING_OPPORTUNITY },
{ IOIQualifierEnums::AT_THE_MIDPOINT.raw, & IOIQualifierEnums::AT_THE_MIDPOINT },
{ IOIQualifierEnums::PRE_OPEN.raw, & IOIQualifierEnums::PRE_OPEN },
};

const FieldEnumMap ReportToExchEnums::itemByRaw = {
{ ReportToExchEnums::YES.raw, & ReportToExchEnums::YES },
{ ReportToExchEnums::NO.raw, & ReportToExchEnums::NO },
};

const FieldEnumMap LocateReqdEnums::itemByRaw = {
{ LocateReqdEnums::YES.raw, & LocateReqdEnums::YES },
{ LocateReqdEnums::NO.raw, & LocateReqdEnums::NO },
};

const FieldEnumMap ForexReqEnums::itemByRaw = {
{ ForexReqEnums::YES.raw, & ForexReqEnums::YES },
{ ForexReqEnums::NO.raw, & ForexReqEnums::NO },
};

const FieldEnumMap GapFillFlagEnums::itemByRaw = {
{ GapFillFlagEnums::YES.raw, & GapFillFlagEnums::YES },
{ GapFillFlagEnums::NO.raw, & GapFillFlagEnums::NO },
};

const FieldEnumMap DKReasonEnums::itemByRaw = {
{ DKReasonEnums::UNKNOWN_SYMBOL.raw, & DKReasonEnums::UNKNOWN_SYMBOL },
{ DKReasonEnums::WRONG_SIDE.raw, & DKReasonEnums::WRONG_SIDE },
{ DKReasonEnums::QUANTITY_EXCEEDS_ORDER.raw, & DKReasonEnums::QUANTITY_EXCEEDS_ORDER },
{ DKReasonEnums::NO_MATCHING_ORDER.raw, & DKReasonEnums::NO_MATCHING_ORDER },
{ DKReasonEnums::PRICE_EXCEEDS_LIMIT.raw, & DKReasonEnums::PRICE_EXCEEDS_LIMIT },
{ DKReasonEnums::CALCULATION_DIFFERENCE.raw, & DKReasonEnums::CALCULATION_DIFFERENCE },
{ DKReasonEnums::OTHER.raw, & DKReasonEnums::OTHER },
};

const FieldEnumMap IOINaturalFlagEnums::itemByRaw = {
{ IOINaturalFlagEnums::YES.raw, & IOINaturalFlagEnums::YES },
{ IOINaturalFlagEnums::NO.raw, & IOINaturalFlagEnums::NO },
};

const FieldEnumMap MiscFeeTypeEnums::itemByRaw = {
{ MiscFeeTypeEnums::REGULATORY.raw, & MiscFeeTypeEnums::REGULATORY },
{ MiscFeeTypeEnums::TAX.raw, & MiscFeeTypeEnums::TAX },
{ MiscFeeTypeEnums::LOCAL_COMMISSION.raw, & MiscFeeTypeEnums::LOCAL_COMMISSION },
{ MiscFeeTypeEnums::EXCHANGE_FEES.raw, & MiscFeeTypeEnums::EXCHANGE_FEES },
{ MiscFeeTypeEnums::STAMP.raw, & MiscFeeTypeEnums::STAMP },
{ MiscFeeTypeEnums::LEVY.raw, & MiscFeeTypeEnums::LEVY },
{ MiscFeeTypeEnums::OTHER.raw, & MiscFeeTypeEnums::OTHER },
{ MiscFeeTypeEnums::MARKUP.raw, & MiscFeeTypeEnums::MARKUP },
{ MiscFeeTypeEnums::CONSUMPTION_TAX.raw, & MiscFeeTypeEnums::CONSUMPTION_TAX },
{ MiscFeeTypeEnums::PER_TRANSACTION.raw, & MiscFeeTypeEnums::PER_TRANSACTION },
{ MiscFeeTypeEnums::CONVERSION.raw, & MiscFeeTypeEnums::CONVERSION },
{ MiscFeeTypeEnums::AGENT.raw, & MiscFeeTypeEnums::AGENT },
};

const FieldEnumMap ResetSeqNumFlagEnums::itemByRaw = {
{ ResetSeqNumFlagEnums::YES.raw, & ResetSeqNumFlagEnums::YES },
{ ResetSeqNumFlagEnums::NO.raw, & ResetSeqNumFlagEnums::NO },
};

const FieldEnumMap ExecTypeEnums::itemByRaw = {
{ ExecTypeEnums::NEW.raw, & ExecTypeEnums::NEW },
{ ExecTypeEnums::DONE_FOR_DAY.raw, & ExecTypeEnums::DONE_FOR_DAY },
{ ExecTypeEnums::CANCELED.raw, & ExecTypeEnums::CANCELED },
{ ExecTypeEnums::REPLACE.raw, & ExecTypeEnums::REPLACE },
{ ExecTypeEnums::PENDING_CANCEL.raw, & ExecTypeEnums::PENDING_CANCEL },
{ ExecTypeEnums::STOPPED.raw, & ExecTypeEnums::STOPPED },
{ ExecTypeEnums::REJECTED.raw, & ExecTypeEnums::REJECTED },
{ ExecTypeEnums::SUSPENDED.raw, & ExecTypeEnums::SUSPENDED },
{ ExecTypeEnums::PENDING_NEW.raw, & ExecTypeEnums::PENDING_NEW },
{ ExecTypeEnums::CALCULATED.raw, & ExecTypeEnums::CALCULATED },
{ ExecTypeEnums::EXPIRED.raw, & ExecTypeEnums::EXPIRED },
{ ExecTypeEnums::RESTATED.raw, & ExecTypeEnums::RESTATED },
{ ExecTypeEnums::PENDING_REPLACE.raw, & ExecTypeEnums::PENDING_REPLACE },
{ ExecTypeEnums::TRADE.raw, & ExecTypeEnums::TRADE },
{ ExecTypeEnums::TRADE_CORRECT.raw, & ExecTypeEnums::TRADE_CORRECT },
{ ExecTypeEnums::TRADE_CANCEL.raw, & ExecTypeEnums::TRADE_CANCEL },
{ ExecTypeEnums::ORDER_STATUS.raw, & ExecTypeEnums::ORDER_STATUS },
};

const FieldEnumMap SettlCurrFxRateCalcEnums::itemByRaw = {
{ SettlCurrFxRateCalcEnums::MULTIPLY.raw, & SettlCurrFxRateCalcEnums::MULTIPLY },
{ SettlCurrFxRateCalcEnums::DIVIDE.raw, & SettlCurrFxRateCalcEnums::DIVIDE },
};

const FieldEnumMap SettlInstModeEnums::itemByRaw = {
{ SettlInstModeEnums::STANDING_INSTRUCTIONS_PROVIDED.raw, & SettlInstModeEnums::STANDING_INSTRUCTIONS_PROVIDED },
{ SettlInstModeEnums::SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT.raw, & SettlInstModeEnums::SPECIFIC_ORDER_FOR_A_SINGLE_ACCOUNT },
{ SettlInstModeEnums::REQUEST_REJECT.raw, & SettlInstModeEnums::REQUEST_REJECT },
};

const FieldEnumMap SettlInstTransTypeEnums::itemByRaw = {
{ SettlInstTransTypeEnums::NEW.raw, & SettlInstTransTypeEnums::NEW },
{ SettlInstTransTypeEnums::CANCEL.raw, & SettlInstTransTypeEnums::CANCEL },
{ SettlInstTransTypeEnums::REPLACE.raw, & SettlInstTransTypeEnums::REPLACE },
{ SettlInstTransTypeEnums::RESTATE.raw, & SettlInstTransTypeEnums::RESTATE },
};

const FieldEnumMap SettlInstSourceEnums::itemByRaw = {
{ SettlInstSourceEnums::BROKERS_INSTRUCTIONS.raw, & SettlInstSourceEnums::BROKERS_INSTRUCTIONS },
{ SettlInstSourceEnums::INSTITUTIONS_INSTRUCTIONS.raw, & SettlInstSourceEnums::INSTITUTIONS_INSTRUCTIONS },
{ SettlInstSourceEnums::INVESTOR.raw, & SettlInstSourceEnums::INVESTOR },
};

const FieldEnumMap SecurityTypeEnums::itemByRaw = {
{ SecurityTypeEnums::FUTURE.raw, & SecurityTypeEnums::FUTURE },
{ SecurityTypeEnums::OPTION.raw, & SecurityTypeEnums::OPTION },
{ SecurityTypeEnums::EURO_SUPRANATIONAL_COUPONS.raw, & SecurityTypeEnums::EURO_SUPRANATIONAL_COUPONS },
{ SecurityTypeEnums::FEDERAL_AGENCY_COUPON.raw, & SecurityTypeEnums::FEDERAL_AGENCY_COUPON },
{ SecurityTypeEnums::FEDERAL_AGENCY_DISCOUNT_NOTE.raw, & SecurityTypeEnums::FEDERAL_AGENCY_DISCOUNT_NOTE },
{ SecurityTypeEnums::PRIVATE_EXPORT_FUNDING.raw, & SecurityTypeEnums::PRIVATE_EXPORT_FUNDING },
{ SecurityTypeEnums::USD_SUPRANATIONAL_COUPONS.raw, & SecurityTypeEnums::USD_SUPRANATIONAL_COUPONS },
{ SecurityTypeEnums::CORPORATE_BOND.raw, & SecurityTypeEnums::CORPORATE_BOND },
{ SecurityTypeEnums::CORPORATE_PRIVATE_PLACEMENT.raw, & SecurityTypeEnums::CORPORATE_PRIVATE_PLACEMENT },
{ SecurityTypeEnums::CONVERTIBLE_BOND.raw, & SecurityTypeEnums::CONVERTIBLE_BOND },
{ SecurityTypeEnums::DUAL_CURRENCY.raw, & SecurityTypeEnums::DUAL_CURRENCY },
{ SecurityTypeEnums::EURO_CORPORATE_BOND.raw, & SecurityTypeEnums::EURO_CORPORATE_BOND },
{ SecurityTypeEnums::INDEXED_LINKED.raw, & SecurityTypeEnums::INDEXED_LINKED },
{ SecurityTypeEnums::STRUCTURED_NOTES.raw, & SecurityTypeEnums::STRUCTURED_NOTES },
{ SecurityTypeEnums::YANKEE_CORPORATE_BOND.raw, & SecurityTypeEnums::YANKEE_CORPORATE_BOND },
{ SecurityTypeEnums::FOREIGN_EXCHANGE_CONTRACT.raw, & SecurityTypeEnums::FOREIGN_EXCHANGE_CONTRACT },
{ SecurityTypeEnums::COMMON_STOCK.raw, & SecurityTypeEnums::COMMON_STOCK },
{ SecurityTypeEnums::PREFERRED_STOCK.raw, & SecurityTypeEnums::PREFERRED_STOCK },
{ SecurityTypeEnums::BRADY_BOND.raw, & SecurityTypeEnums::BRADY_BOND },
{ SecurityTypeEnums::EURO_SOVEREIGNS.raw, & SecurityTypeEnums::EURO_SOVEREIGNS },
{ SecurityTypeEnums::US_TREASURY_BOND.raw, & SecurityTypeEnums::US_TREASURY_BOND },
{ SecurityTypeEnums::INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE.raw, & SecurityTypeEnums::INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE },
{ SecurityTypeEnums::TREASURY_INFLATION_PROTECTED_SECURITIES.raw, & SecurityTypeEnums::TREASURY_INFLATION_PROTECTED_SECURITIES },
{ SecurityTypeEnums::PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE.raw, & SecurityTypeEnums::PRINCIPAL_STRIP_OF_A_CALLABLE_BOND_OR_NOTE },
{ SecurityTypeEnums::PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE.raw, & SecurityTypeEnums::PRINCIPAL_STRIP_FROM_A_NON_CALLABLE_BOND_OR_NOTE },
{ SecurityTypeEnums::US_TREASURY_NOTE_UST.raw, & SecurityTypeEnums::US_TREASURY_NOTE_UST },
{ SecurityTypeEnums::US_TREASURY_BILL_USTB.raw, & SecurityTypeEnums::US_TREASURY_BILL_USTB },
{ SecurityTypeEnums::US_TREASURY_NOTE_TNOTE.raw, & SecurityTypeEnums::US_TREASURY_NOTE_TNOTE },
{ SecurityTypeEnums::US_TREASURY_BILL_TBILL.raw, & SecurityTypeEnums::US_TREASURY_BILL_TBILL },
{ SecurityTypeEnums::REPURCHASE.raw, & SecurityTypeEnums::REPURCHASE },
{ SecurityTypeEnums::FORWARD.raw, & SecurityTypeEnums::FORWARD },
{ SecurityTypeEnums::BUY_SELLBACK.raw, & SecurityTypeEnums::BUY_SELLBACK },
{ SecurityTypeEnums::SECURITIES_LOAN.raw, & SecurityTypeEnums::SECURITIES_LOAN },
{ SecurityTypeEnums::SECURITIES_PLEDGE.raw, & SecurityTypeEnums::SECURITIES_PLEDGE },
{ SecurityTypeEnums::TERM_LOAN.raw, & SecurityTypeEnums::TERM_LOAN },
{ SecurityTypeEnums::REVOLVER_LOAN.raw, & SecurityTypeEnums::REVOLVER_LOAN },
{ SecurityTypeEnums::REVOLVER_TERM_LOAN.raw, & SecurityTypeEnums::REVOLVER_TERM_LOAN },
{ SecurityTypeEnums::BRIDGE_LOAN.raw, & SecurityTypeEnums::BRIDGE_LOAN },
{ SecurityTypeEnums::LETTER_OF_CREDIT.raw, & SecurityTypeEnums::LETTER_OF_CREDIT },
{ SecurityTypeEnums::SWING_LINE_FACILITY.raw, & SecurityTypeEnums::SWING_LINE_FACILITY },
{ SecurityTypeEnums::DEBTOR_IN_POSSESSION.raw, & SecurityTypeEnums::DEBTOR_IN_POSSESSION },
{ SecurityTypeEnums::DEFAULTED.raw, & SecurityTypeEnums::DEFAULTED },
{ SecurityTypeEnums::WITHDRAWN.raw, & SecurityTypeEnums::WITHDRAWN },
{ SecurityTypeEnums::REPLACED.raw, & SecurityTypeEnums::REPLACED },
{ SecurityTypeEnums::MATURED.raw, & SecurityTypeEnums::MATURED },
{ SecurityTypeEnums::AMENDED_RESTATED.raw, & SecurityTypeEnums::AMENDED_RESTATED },
{ SecurityTypeEnums::RETIRED.raw, & SecurityTypeEnums::RETIRED },
{ SecurityTypeEnums::BANKERS_ACCEPTANCE.raw, & SecurityTypeEnums::BANKERS_ACCEPTANCE },
{ SecurityTypeEnums::BANK_NOTES.raw, & SecurityTypeEnums::BANK_NOTES },
{ SecurityTypeEnums::BILL_OF_EXCHANGES.raw, & SecurityTypeEnums::BILL_OF_EXCHANGES },
{ SecurityTypeEnums::CERTIFICATE_OF_DEPOSIT.raw, & SecurityTypeEnums::CERTIFICATE_OF_DEPOSIT },
{ SecurityTypeEnums::CALL_LOANS.raw, & SecurityTypeEnums::CALL_LOANS },
{ SecurityTypeEnums::COMMERCIAL_PAPER.raw, & SecurityTypeEnums::COMMERCIAL_PAPER },
{ SecurityTypeEnums::DEPOSIT_NOTES.raw, & SecurityTypeEnums::DEPOSIT_NOTES },
{ SecurityTypeEnums::EURO_CERTIFICATE_OF_DEPOSIT.raw, & SecurityTypeEnums::EURO_CERTIFICATE_OF_DEPOSIT },
{ SecurityTypeEnums::EURO_COMMERCIAL_PAPER.raw, & SecurityTypeEnums::EURO_COMMERCIAL_PAPER },
{ SecurityTypeEnums::LIQUIDITY_NOTE.raw, & SecurityTypeEnums::LIQUIDITY_NOTE },
{ SecurityTypeEnums::MEDIUM_TERM_NOTES.raw, & SecurityTypeEnums::MEDIUM_TERM_NOTES },
{ SecurityTypeEnums::OVERNIGHT.raw, & SecurityTypeEnums::OVERNIGHT },
{ SecurityTypeEnums::PROMISSORY_NOTE.raw, & SecurityTypeEnums::PROMISSORY_NOTE },
{ SecurityTypeEnums::PLAZOS_FIJOS.raw, & SecurityTypeEnums::PLAZOS_FIJOS },
{ SecurityTypeEnums::SHORT_TERM_LOAN_NOTE.raw, & SecurityTypeEnums::SHORT_TERM_LOAN_NOTE },
{ SecurityTypeEnums::TIME_DEPOSIT.raw, & SecurityTypeEnums::TIME_DEPOSIT },
{ SecurityTypeEnums::EXTENDED_COMM_NOTE.raw, & SecurityTypeEnums::EXTENDED_COMM_NOTE },
{ SecurityTypeEnums::YANKEE_CERTIFICATE_OF_DEPOSIT.raw, & SecurityTypeEnums::YANKEE_CERTIFICATE_OF_DEPOSIT },
{ SecurityTypeEnums::ASSET_BACKED_SECURITIES.raw, & SecurityTypeEnums::ASSET_BACKED_SECURITIES },
{ SecurityTypeEnums::CORP_MORTGAGE_BACKED_SECURITIES.raw, & SecurityTypeEnums::CORP_MORTGAGE_BACKED_SECURITIES },
{ SecurityTypeEnums::COLLATERALIZED_MORTGAGE_OBLIGATION.raw, & SecurityTypeEnums::COLLATERALIZED_MORTGAGE_OBLIGATION },
{ SecurityTypeEnums::IOETTE_MORTGAGE.raw, & SecurityTypeEnums::IOETTE_MORTGAGE },
{ SecurityTypeEnums::MORTGAGE_BACKED_SECURITIES.raw, & SecurityTypeEnums::MORTGAGE_BACKED_SECURITIES },
{ SecurityTypeEnums::MORTGAGE_INTEREST_ONLY.raw, & SecurityTypeEnums::MORTGAGE_INTEREST_ONLY },
{ SecurityTypeEnums::MORTGAGE_PRINCIPAL_ONLY.raw, & SecurityTypeEnums::MORTGAGE_PRINCIPAL_ONLY },
{ SecurityTypeEnums::MORTGAGE_PRIVATE_PLACEMENT.raw, & SecurityTypeEnums::MORTGAGE_PRIVATE_PLACEMENT },
{ SecurityTypeEnums::MISCELLANEOUS_PASS_THROUGH.raw, & SecurityTypeEnums::MISCELLANEOUS_PASS_THROUGH },
{ SecurityTypeEnums::PFANDBRIEFE.raw, & SecurityTypeEnums::PFANDBRIEFE },
{ SecurityTypeEnums::TO_BE_ANNOUNCED.raw, & SecurityTypeEnums::TO_BE_ANNOUNCED },
{ SecurityTypeEnums::OTHER_ANTICIPATION_NOTES_BAN_GAN_ETC.raw, & SecurityTypeEnums::OTHER_ANTICIPATION_NOTES_BAN_GAN_ETC },
{ SecurityTypeEnums::CERTIFICATE_OF_OBLIGATION.raw, & SecurityTypeEnums::CERTIFICATE_OF_OBLIGATION },
{ SecurityTypeEnums::CERTIFICATE_OF_PARTICIPATION.raw, & SecurityTypeEnums::CERTIFICATE_OF_PARTICIPATION },
{ SecurityTypeEnums::GENERAL_OBLIGATION_BONDS.raw, & SecurityTypeEnums::GENERAL_OBLIGATION_BONDS },
{ SecurityTypeEnums::MANDATORY_TENDER.raw, & SecurityTypeEnums::MANDATORY_TENDER },
{ SecurityTypeEnums::REVENUE_ANTICIPATION_NOTE.raw, & SecurityTypeEnums::REVENUE_ANTICIPATION_NOTE },
{ SecurityTypeEnums::REVENUE_BONDS.raw, & SecurityTypeEnums::REVENUE_BONDS },
{ SecurityTypeEnums::SPECIAL_ASSESSMENT.raw, & SecurityTypeEnums::SPECIAL_ASSESSMENT },
{ SecurityTypeEnums::SPECIAL_OBLIGATION.raw, & SecurityTypeEnums::SPECIAL_OBLIGATION },
{ SecurityTypeEnums::SPECIAL_TAX.raw, & SecurityTypeEnums::SPECIAL_TAX },
{ SecurityTypeEnums::TAX_ANTICIPATION_NOTE.raw, & SecurityTypeEnums::TAX_ANTICIPATION_NOTE },
{ SecurityTypeEnums::TAX_ALLOCATION.raw, & SecurityTypeEnums::TAX_ALLOCATION },
{ SecurityTypeEnums::TAX_EXEMPT_COMMERCIAL_PAPER.raw, & SecurityTypeEnums::TAX_EXEMPT_COMMERCIAL_PAPER },
{ SecurityTypeEnums::TAX_REVENUE_ANTICIPATION_NOTE.raw, & SecurityTypeEnums::TAX_REVENUE_ANTICIPATION_NOTE },
{ SecurityTypeEnums::VARIABLE_RATE_DEMAND_NOTE.raw, & SecurityTypeEnums::VARIABLE_RATE_DEMAND_NOTE },
{ SecurityTypeEnums::WARRANT.raw, & SecurityTypeEnums::WARRANT },
{ SecurityTypeEnums::MUTUAL_FUND.raw, & SecurityTypeEnums::MUTUAL_FUND },
{ SecurityTypeEnums::MULTI_LEG_INSTRUMENT.raw, & SecurityTypeEnums::MULTI_LEG_INSTRUMENT },
{ SecurityTypeEnums::NO_SECURITY_TYPE.raw, & SecurityTypeEnums::NO_SECURITY_TYPE },
};

const FieldEnumMap StandInstDbTypeEnums::itemByRaw = {
{ StandInstDbTypeEnums::OTHER.raw, & StandInstDbTypeEnums::OTHER },
{ StandInstDbTypeEnums::DTC_SID.raw, & StandInstDbTypeEnums::DTC_SID },
{ StandInstDbTypeEnums::THOMSON_ALERT.raw, & StandInstDbTypeEnums::THOMSON_ALERT },
{ StandInstDbTypeEnums::A_GLOBAL_CUSTODIAN.raw, & StandInstDbTypeEnums::A_GLOBAL_CUSTODIAN },
{ StandInstDbTypeEnums::ACCOUNTNET.raw, & StandInstDbTypeEnums::ACCOUNTNET },
};

const FieldEnumMap SettlDeliveryTypeEnums::itemByRaw = {
{ SettlDeliveryTypeEnums::VERSUS_PAYMENT_DELIVER.raw, & SettlDeliveryTypeEnums::VERSUS_PAYMENT_DELIVER },
{ SettlDeliveryTypeEnums::FREE_DELIVER.raw, & SettlDeliveryTypeEnums::FREE_DELIVER },
{ SettlDeliveryTypeEnums::TRI_PARTY.raw, & SettlDeliveryTypeEnums::TRI_PARTY },
{ SettlDeliveryTypeEnums::HOLD_IN_CUSTODY.raw, & SettlDeliveryTypeEnums::HOLD_IN_CUSTODY },
};

const FieldEnumMap AllocLinkTypeEnums::itemByRaw = {
{ AllocLinkTypeEnums::F_X_NETTING.raw, & AllocLinkTypeEnums::F_X_NETTING },
{ AllocLinkTypeEnums::F_X_SWAP.raw, & AllocLinkTypeEnums::F_X_SWAP },
};

const FieldEnumMap PutOrCallEnums::itemByRaw = {
{ PutOrCallEnums::PUT.raw, & PutOrCallEnums::PUT },
{ PutOrCallEnums::CALL.raw, & PutOrCallEnums::CALL },
};

const FieldEnumMap CoveredOrUncoveredEnums::itemByRaw = {
{ CoveredOrUncoveredEnums::COVERED.raw, & CoveredOrUncoveredEnums::COVERED },
{ CoveredOrUncoveredEnums::UNCOVERED.raw, & CoveredOrUncoveredEnums::UNCOVERED },
};

const FieldEnumMap NotifyBrokerOfCreditEnums::itemByRaw = {
{ NotifyBrokerOfCreditEnums::YES.raw, & NotifyBrokerOfCreditEnums::YES },
{ NotifyBrokerOfCreditEnums::NO.raw, & NotifyBrokerOfCreditEnums::NO },
};

const FieldEnumMap AllocHandlInstEnums::itemByRaw = {
{ AllocHandlInstEnums::MATCH.raw, & AllocHandlInstEnums::MATCH },
{ AllocHandlInstEnums::FORWARD.raw, & AllocHandlInstEnums::FORWARD },
{ AllocHandlInstEnums::FORWARD_AND_MATCH.raw, & AllocHandlInstEnums::FORWARD_AND_MATCH },
};

const FieldEnumMap RoutingTypeEnums::itemByRaw = {
{ RoutingTypeEnums::TARGET_FIRM.raw, & RoutingTypeEnums::TARGET_FIRM },
{ RoutingTypeEnums::TARGET_LIST.raw, & RoutingTypeEnums::TARGET_LIST },
{ RoutingTypeEnums::BLOCK_FIRM.raw, & RoutingTypeEnums::BLOCK_FIRM },
{ RoutingTypeEnums::BLOCK_LIST.raw, & RoutingTypeEnums::BLOCK_LIST },
};

const FieldEnumMap StipulationTypeEnums::itemByRaw = {
{ StipulationTypeEnums::AMT.raw, & StipulationTypeEnums::AMT },
{ StipulationTypeEnums::AUTO_REINVESTMENT_AT_RATE_OR_BETTER.raw, & StipulationTypeEnums::AUTO_REINVESTMENT_AT_RATE_OR_BETTER },
{ StipulationTypeEnums::BANK_QUALIFIED.raw, & StipulationTypeEnums::BANK_QUALIFIED },
{ StipulationTypeEnums::BARGAIN_CONDITIONS_SEE.raw, & StipulationTypeEnums::BARGAIN_CONDITIONS_SEE },
{ StipulationTypeEnums::COUPON_RANGE.raw, & StipulationTypeEnums::COUPON_RANGE },
{ StipulationTypeEnums::ISO_CURRENCY_CODE.raw, & StipulationTypeEnums::ISO_CURRENCY_CODE },
{ StipulationTypeEnums::CUSTOM_START_END_DATE.raw, & StipulationTypeEnums::CUSTOM_START_END_DATE },
{ StipulationTypeEnums::GEOGRAPHICS_AND_RANGE.raw, & StipulationTypeEnums::GEOGRAPHICS_AND_RANGE },
{ StipulationTypeEnums::VALUATION_DISCOUNT.raw, & StipulationTypeEnums::VALUATION_DISCOUNT },
{ StipulationTypeEnums::INSURED.raw, & StipulationTypeEnums::INSURED },
{ StipulationTypeEnums::YEAR_OR_YEAR_MONTH_OF_ISSUE.raw, & StipulationTypeEnums::YEAR_OR_YEAR_MONTH_OF_ISSUE },
{ StipulationTypeEnums::ISSUERS_TICKER.raw, & StipulationTypeEnums::ISSUERS_TICKER },
{ StipulationTypeEnums::ISSUE_SIZE_RANGE.raw, & StipulationTypeEnums::ISSUE_SIZE_RANGE },
{ StipulationTypeEnums::LOOKBACK_DAYS.raw, & StipulationTypeEnums::LOOKBACK_DAYS },
{ StipulationTypeEnums::EXPLICIT_LOT_IDENTIFIER.raw, & StipulationTypeEnums::EXPLICIT_LOT_IDENTIFIER },
{ StipulationTypeEnums::LOT_VARIANCE.raw, & StipulationTypeEnums::LOT_VARIANCE },
{ StipulationTypeEnums::MATURITY_YEAR_AND_MONTH.raw, & StipulationTypeEnums::MATURITY_YEAR_AND_MONTH },
{ StipulationTypeEnums::MATURITY_RANGE.raw, & StipulationTypeEnums::MATURITY_RANGE },
{ StipulationTypeEnums::MAXIMUM_SUBSTITUTIONS.raw, & StipulationTypeEnums::MAXIMUM_SUBSTITUTIONS },
{ StipulationTypeEnums::MINIMUM_QUANTITY.raw, & StipulationTypeEnums::MINIMUM_QUANTITY },
{ StipulationTypeEnums::MINIMUM_INCREMENT.raw, & StipulationTypeEnums::MINIMUM_INCREMENT },
{ StipulationTypeEnums::MINIMUM_DENOMINATION.raw, & StipulationTypeEnums::MINIMUM_DENOMINATION },
{ StipulationTypeEnums::PAYMENT_FREQUENCY_CALENDAR.raw, & StipulationTypeEnums::PAYMENT_FREQUENCY_CALENDAR },
{ StipulationTypeEnums::NUMBER_OF_PIECES.raw, & StipulationTypeEnums::NUMBER_OF_PIECES },
{ StipulationTypeEnums::POOLS_MAXIMUM.raw, & StipulationTypeEnums::POOLS_MAXIMUM },
{ StipulationTypeEnums::POOLS_PER_MILLION.raw, & StipulationTypeEnums::POOLS_PER_MILLION },
{ StipulationTypeEnums::POOLS_PER_LOT.raw, & StipulationTypeEnums::POOLS_PER_LOT },
{ StipulationTypeEnums::POOLS_PER_TRADE.raw, & StipulationTypeEnums::POOLS_PER_TRADE },
{ StipulationTypeEnums::PRICE_RANGE.raw, & StipulationTypeEnums::PRICE_RANGE },
{ StipulationTypeEnums::PRICING_FREQUENCY.raw, & StipulationTypeEnums::PRICING_FREQUENCY },
{ StipulationTypeEnums::PRODUCTION_YEAR.raw, & StipulationTypeEnums::PRODUCTION_YEAR },
{ StipulationTypeEnums::CALL_PROTECTION.raw, & StipulationTypeEnums::CALL_PROTECTION },
{ StipulationTypeEnums::PURPOSE.raw, & StipulationTypeEnums::PURPOSE },
{ StipulationTypeEnums::BENCHMARK_PRICE_SOURCE.raw, & StipulationTypeEnums::BENCHMARK_PRICE_SOURCE },
{ StipulationTypeEnums::RATING_SOURCE_AND_RANGE.raw, & StipulationTypeEnums::RATING_SOURCE_AND_RANGE },
{ StipulationTypeEnums::TYPE_OF_REDEMPTION_VALUES_ARE_NONCALLABLE_CALLABLE_PREFUNDED_ESCROWEDTOMATURITY_PUTABLE_CONVERTIBLE.raw, & StipulationTypeEnums::TYPE_OF_REDEMPTION_VALUES_ARE_NONCALLABLE_CALLABLE_PREFUNDED_ESCROWEDTOMATURITY_PUTABLE_CONVERTIBLE },
{ StipulationTypeEnums::RESTRICTED.raw, & StipulationTypeEnums::RESTRICTED },
{ StipulationTypeEnums::MARKET_SECTOR.raw, & StipulationTypeEnums::MARKET_SECTOR },
{ StipulationTypeEnums::SECURITYTYPE_INCLUDED_OR_EXCLUDED.raw, & StipulationTypeEnums::SECURITYTYPE_INCLUDED_OR_EXCLUDED },
{ StipulationTypeEnums::STRUCTURE.raw, & StipulationTypeEnums::STRUCTURE },
{ StipulationTypeEnums::SUBSTITUTIONS_FREQUENCY.raw, & StipulationTypeEnums::SUBSTITUTIONS_FREQUENCY },
{ StipulationTypeEnums::SUBSTITUTIONS_LEFT.raw, & StipulationTypeEnums::SUBSTITUTIONS_LEFT },
{ StipulationTypeEnums::FREEFORM_TEXT.raw, & StipulationTypeEnums::FREEFORM_TEXT },
{ StipulationTypeEnums::TRADE_VARIANCE.raw, & StipulationTypeEnums::TRADE_VARIANCE },
{ StipulationTypeEnums::WEIGHTED_AVERAGE_COUPONVALUE_IN_PERCENT.raw, & StipulationTypeEnums::WEIGHTED_AVERAGE_COUPONVALUE_IN_PERCENT },
{ StipulationTypeEnums::WEIGHTED_AVERAGE_LIFE_COUPON_VALUE_IN_PERCENT.raw, & StipulationTypeEnums::WEIGHTED_AVERAGE_LIFE_COUPON_VALUE_IN_PERCENT },
{ StipulationTypeEnums::WEIGHTED_AVERAGE_LOAN_AGE_VALUE_IN_MONTHS.raw, & StipulationTypeEnums::WEIGHTED_AVERAGE_LOAN_AGE_VALUE_IN_MONTHS },
{ StipulationTypeEnums::WEIGHTED_AVERAGE_MATURITY_VALUE_IN_MONTHS.raw, & StipulationTypeEnums::WEIGHTED_AVERAGE_MATURITY_VALUE_IN_MONTHS },
{ StipulationTypeEnums::WHOLE_POOL.raw, & StipulationTypeEnums::WHOLE_POOL },
{ StipulationTypeEnums::YIELD_RANGE.raw, & StipulationTypeEnums::YIELD_RANGE },
};

const FieldEnumMap YieldTypeEnums::itemByRaw = {
{ YieldTypeEnums::AFTER_TAX_YIELD.raw, & YieldTypeEnums::AFTER_TAX_YIELD },
{ YieldTypeEnums::ANNUAL_YIELD.raw, & YieldTypeEnums::ANNUAL_YIELD },
{ YieldTypeEnums::YIELD_AT_ISSUE.raw, & YieldTypeEnums::YIELD_AT_ISSUE },
{ YieldTypeEnums::YIELD_TO_AVERAGE_MATURITY.raw, & YieldTypeEnums::YIELD_TO_AVERAGE_MATURITY },
{ YieldTypeEnums::BOOK_YIELD.raw, & YieldTypeEnums::BOOK_YIELD },
{ YieldTypeEnums::YIELD_TO_NEXT_CALL.raw, & YieldTypeEnums::YIELD_TO_NEXT_CALL },
{ YieldTypeEnums::YIELD_CHANGE_SINCE_CLOSE.raw, & YieldTypeEnums::YIELD_CHANGE_SINCE_CLOSE },
{ YieldTypeEnums::CLOSING_YIELD.raw, & YieldTypeEnums::CLOSING_YIELD },
{ YieldTypeEnums::COMPOUND_YIELD.raw, & YieldTypeEnums::COMPOUND_YIELD },
{ YieldTypeEnums::CURRENT_YIELD.raw, & YieldTypeEnums::CURRENT_YIELD },
{ YieldTypeEnums::TRUE_GROSS_YIELD.raw, & YieldTypeEnums::TRUE_GROSS_YIELD },
{ YieldTypeEnums::GOVERNMENT_EQUIVALENT_YIELD.raw, & YieldTypeEnums::GOVERNMENT_EQUIVALENT_YIELD },
{ YieldTypeEnums::YIELD_WITH_INFLATION_ASSUMPTION.raw, & YieldTypeEnums::YIELD_WITH_INFLATION_ASSUMPTION },
{ YieldTypeEnums::INVERSE_FLOATER_BOND_YIELD.raw, & YieldTypeEnums::INVERSE_FLOATER_BOND_YIELD },
{ YieldTypeEnums::MOST_RECENT_CLOSING_YIELD.raw, & YieldTypeEnums::MOST_RECENT_CLOSING_YIELD },
{ YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_MONTH.raw, & YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_MONTH },
{ YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_QUARTER.raw, & YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_QUARTER },
{ YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_YEAR.raw, & YieldTypeEnums::CLOSING_YIELD_MOST_RECENT_YEAR },
{ YieldTypeEnums::YIELD_TO_LONGEST_AVERAGE_LIFE.raw, & YieldTypeEnums::YIELD_TO_LONGEST_AVERAGE_LIFE },
{ YieldTypeEnums::MARK_TO_MARKET_YIELD.raw, & YieldTypeEnums::MARK_TO_MARKET_YIELD },
{ YieldTypeEnums::YIELD_TO_MATURITY.raw, & YieldTypeEnums::YIELD_TO_MATURITY },
{ YieldTypeEnums::YIELD_TO_NEXT_REFUND.raw, & YieldTypeEnums::YIELD_TO_NEXT_REFUND },
{ YieldTypeEnums::OPEN_AVERAGE_YIELD.raw, & YieldTypeEnums::OPEN_AVERAGE_YIELD },
{ YieldTypeEnums::YIELD_TO_NEXT_PUT.raw, & YieldTypeEnums::YIELD_TO_NEXT_PUT },
{ YieldTypeEnums::PREVIOUS_CLOSE_YIELD.raw, & YieldTypeEnums::PREVIOUS_CLOSE_YIELD },
{ YieldTypeEnums::PROCEEDS_YIELD.raw, & YieldTypeEnums::PROCEEDS_YIELD },
{ YieldTypeEnums::SEMI_ANNUAL_YIELD.raw, & YieldTypeEnums::SEMI_ANNUAL_YIELD },
{ YieldTypeEnums::YIELD_TO_SHORTEST_AVERAGE_LIFE.raw, & YieldTypeEnums::YIELD_TO_SHORTEST_AVERAGE_LIFE },
{ YieldTypeEnums::SIMPLE_YIELD.raw, & YieldTypeEnums::SIMPLE_YIELD },
{ YieldTypeEnums::TAX_EQUIVALENT_YIELD.raw, & YieldTypeEnums::TAX_EQUIVALENT_YIELD },
{ YieldTypeEnums::YIELD_TO_TENDER_DATE.raw, & YieldTypeEnums::YIELD_TO_TENDER_DATE },
{ YieldTypeEnums::TRUE_YIELD.raw, & YieldTypeEnums::TRUE_YIELD },
{ YieldTypeEnums::YIELD_VALUE_OF_1_32.raw, & YieldTypeEnums::YIELD_VALUE_OF_1_32 },
{ YieldTypeEnums::YIELD_TO_WORST.raw, & YieldTypeEnums::YIELD_TO_WORST },
};

const FieldEnumMap TradedFlatSwitchEnums::itemByRaw = {
{ TradedFlatSwitchEnums::YES.raw, & TradedFlatSwitchEnums::YES },
{ TradedFlatSwitchEnums::NO.raw, & TradedFlatSwitchEnums::NO },
};

const FieldEnumMap SubscriptionRequestTypeEnums::itemByRaw = {
{ SubscriptionRequestTypeEnums::SNAPSHOT.raw, & SubscriptionRequestTypeEnums::SNAPSHOT },
{ SubscriptionRequestTypeEnums::SNAPSHOT_PLUS_UPDATES.raw, & SubscriptionRequestTypeEnums::SNAPSHOT_PLUS_UPDATES },
{ SubscriptionRequestTypeEnums::DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST.raw, & SubscriptionRequestTypeEnums::DISABLE_PREVIOUS_SNAPSHOT_PLUS_UPDATE_REQUEST },
};

const FieldEnumMap MDUpdateTypeEnums::itemByRaw = {
{ MDUpdateTypeEnums::FULL_REFRESH.raw, & MDUpdateTypeEnums::FULL_REFRESH },
{ MDUpdateTypeEnums::INCREMENTAL_REFRESH.raw, & MDUpdateTypeEnums::INCREMENTAL_REFRESH },
};

const FieldEnumMap AggregatedBookEnums::itemByRaw = {
{ AggregatedBookEnums::YES.raw, & AggregatedBookEnums::YES },
{ AggregatedBookEnums::NO.raw, & AggregatedBookEnums::NO },
};

const FieldEnumMap MDEntryTypeEnums::itemByRaw = {
{ MDEntryTypeEnums::BID.raw, & MDEntryTypeEnums::BID },
{ MDEntryTypeEnums::OFFER.raw, & MDEntryTypeEnums::OFFER },
{ MDEntryTypeEnums::TRADE.raw, & MDEntryTypeEnums::TRADE },
{ MDEntryTypeEnums::INDEX_VALUE.raw, & MDEntryTypeEnums::INDEX_VALUE },
{ MDEntryTypeEnums::OPENING_PRICE.raw, & MDEntryTypeEnums::OPENING_PRICE },
{ MDEntryTypeEnums::CLOSING_PRICE.raw, & MDEntryTypeEnums::CLOSING_PRICE },
{ MDEntryTypeEnums::SETTLEMENT_PRICE.raw, & MDEntryTypeEnums::SETTLEMENT_PRICE },
{ MDEntryTypeEnums::TRADING_SESSION_HIGH_PRICE.raw, & MDEntryTypeEnums::TRADING_SESSION_HIGH_PRICE },
{ MDEntryTypeEnums::TRADING_SESSION_LOW_PRICE.raw, & MDEntryTypeEnums::TRADING_SESSION_LOW_PRICE },
{ MDEntryTypeEnums::TRADING_SESSION_VWAP_PRICE.raw, & MDEntryTypeEnums::TRADING_SESSION_VWAP_PRICE },
{ MDEntryTypeEnums::IMBALANCE.raw, & MDEntryTypeEnums::IMBALANCE },
{ MDEntryTypeEnums::TRADE_VOLUME.raw, & MDEntryTypeEnums::TRADE_VOLUME },
{ MDEntryTypeEnums::OPEN_INTEREST.raw, & MDEntryTypeEnums::OPEN_INTEREST },
};

const FieldEnumMap TickDirectionEnums::itemByRaw = {
{ TickDirectionEnums::PLUS_TICK.raw, & TickDirectionEnums::PLUS_TICK },
{ TickDirectionEnums::ZERO_PLUS_TICK.raw, & TickDirectionEnums::ZERO_PLUS_TICK },
{ TickDirectionEnums::MINUS_TICK.raw, & TickDirectionEnums::MINUS_TICK },
{ TickDirectionEnums::ZERO_MINUS_TICK.raw, & TickDirectionEnums::ZERO_MINUS_TICK },
};

const FieldEnumMap QuoteConditionEnums::itemByRaw = {
{ QuoteConditionEnums::OPEN.raw, & QuoteConditionEnums::OPEN },
{ QuoteConditionEnums::CLOSED.raw, & QuoteConditionEnums::CLOSED },
{ QuoteConditionEnums::EXCHANGE_BEST.raw, & QuoteConditionEnums::EXCHANGE_BEST },
{ QuoteConditionEnums::CONSOLIDATED_BEST.raw, & QuoteConditionEnums::CONSOLIDATED_BEST },
{ QuoteConditionEnums::LOCKED.raw, & QuoteConditionEnums::LOCKED },
{ QuoteConditionEnums::CROSSED.raw, & QuoteConditionEnums::CROSSED },
{ QuoteConditionEnums::DEPTH.raw, & QuoteConditionEnums::DEPTH },
{ QuoteConditionEnums::FAST_TRADING.raw, & QuoteConditionEnums::FAST_TRADING },
{ QuoteConditionEnums::NON_FIRM.raw, & QuoteConditionEnums::NON_FIRM },
};

const FieldEnumMap TradeConditionEnums::itemByRaw = {
{ TradeConditionEnums::CASH.raw, & TradeConditionEnums::CASH },
{ TradeConditionEnums::AVERAGE_PRICE_TRADE.raw, & TradeConditionEnums::AVERAGE_PRICE_TRADE },
{ TradeConditionEnums::CASH_TRADE.raw, & TradeConditionEnums::CASH_TRADE },
{ TradeConditionEnums::NEXT_DAY.raw, & TradeConditionEnums::NEXT_DAY },
{ TradeConditionEnums::OPENING.raw, & TradeConditionEnums::OPENING },
{ TradeConditionEnums::INTRADAY_TRADE_DETAIL.raw, & TradeConditionEnums::INTRADAY_TRADE_DETAIL },
{ TradeConditionEnums::RULE_127_TRADE.raw, & TradeConditionEnums::RULE_127_TRADE },
{ TradeConditionEnums::RULE_155_TRADE.raw, & TradeConditionEnums::RULE_155_TRADE },
{ TradeConditionEnums::SOLD_LAST.raw, & TradeConditionEnums::SOLD_LAST },
{ TradeConditionEnums::NEXT_DAY_TRADE.raw, & TradeConditionEnums::NEXT_DAY_TRADE },
{ TradeConditionEnums::OPENED.raw, & TradeConditionEnums::OPENED },
{ TradeConditionEnums::SELLER.raw, & TradeConditionEnums::SELLER },
{ TradeConditionEnums::SOLD.raw, & TradeConditionEnums::SOLD },
{ TradeConditionEnums::STOPPED_STOCK.raw, & TradeConditionEnums::STOPPED_STOCK },
{ TradeConditionEnums::IMBALANCE_MORE_BUYERS.raw, & TradeConditionEnums::IMBALANCE_MORE_BUYERS },
{ TradeConditionEnums::IMBALANCE_MORE_SELLERS.raw, & TradeConditionEnums::IMBALANCE_MORE_SELLERS },
{ TradeConditionEnums::OPENING_PRICE.raw, & TradeConditionEnums::OPENING_PRICE },
};

const FieldEnumMap MDUpdateActionEnums::itemByRaw = {
{ MDUpdateActionEnums::NEW.raw, & MDUpdateActionEnums::NEW },
{ MDUpdateActionEnums::CHANGE.raw, & MDUpdateActionEnums::CHANGE },
{ MDUpdateActionEnums::DELETE.raw, & MDUpdateActionEnums::DELETE },
};

const FieldEnumMap MDReqRejReasonEnums::itemByRaw = {
{ MDReqRejReasonEnums::UNKNOWN_SYMBOL.raw, & MDReqRejReasonEnums::UNKNOWN_SYMBOL },
{ MDReqRejReasonEnums::DUPLICATE_MDREQID.raw, & MDReqRejReasonEnums::DUPLICATE_MDREQID },
{ MDReqRejReasonEnums::INSUFFICIENT_BANDWIDTH.raw, & MDReqRejReasonEnums::INSUFFICIENT_BANDWIDTH },
{ MDReqRejReasonEnums::INSUFFICIENT_PERMISSIONS.raw, & MDReqRejReasonEnums::INSUFFICIENT_PERMISSIONS },
{ MDReqRejReasonEnums::UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE.raw, & MDReqRejReasonEnums::UNSUPPORTED_SUBSCRIPTIONREQUESTTYPE },
{ MDReqRejReasonEnums::UNSUPPORTED_MARKETDEPTH.raw, & MDReqRejReasonEnums::UNSUPPORTED_MARKETDEPTH },
{ MDReqRejReasonEnums::UNSUPPORTED_MDUPDATETYPE.raw, & MDReqRejReasonEnums::UNSUPPORTED_MDUPDATETYPE },
{ MDReqRejReasonEnums::UNSUPPORTED_AGGREGATEDBOOK.raw, & MDReqRejReasonEnums::UNSUPPORTED_AGGREGATEDBOOK },
{ MDReqRejReasonEnums::UNSUPPORTED_MDENTRYTYPE.raw, & MDReqRejReasonEnums::UNSUPPORTED_MDENTRYTYPE },
{ MDReqRejReasonEnums::UNSUPPORTED_TRADINGSESSIONID.raw, & MDReqRejReasonEnums::UNSUPPORTED_TRADINGSESSIONID },
{ MDReqRejReasonEnums::UNSUPPORTED_SCOPE.raw, & MDReqRejReasonEnums::UNSUPPORTED_SCOPE },
{ MDReqRejReasonEnums::UNSUPPORTED_OPENCLOSESETTLEFLAG.raw, & MDReqRejReasonEnums::UNSUPPORTED_OPENCLOSESETTLEFLAG },
{ MDReqRejReasonEnums::UNSUPPORTED_MDIMPLICITDELETE.raw, & MDReqRejReasonEnums::UNSUPPORTED_MDIMPLICITDELETE },
};

const FieldEnumMap DeleteReasonEnums::itemByRaw = {
{ DeleteReasonEnums::CANCELATION.raw, & DeleteReasonEnums::CANCELATION },
{ DeleteReasonEnums::ERROR.raw, & DeleteReasonEnums::ERROR },
};

const FieldEnumMap OpenCloseSettlFlagEnums::itemByRaw = {
{ OpenCloseSettlFlagEnums::DAILY_OPEN.raw, & OpenCloseSettlFlagEnums::DAILY_OPEN },
{ OpenCloseSettlFlagEnums::SESSION_OPEN.raw, & OpenCloseSettlFlagEnums::SESSION_OPEN },
{ OpenCloseSettlFlagEnums::DELIVERY_SETTLEMENT_ENTRY.raw, & OpenCloseSettlFlagEnums::DELIVERY_SETTLEMENT_ENTRY },
{ OpenCloseSettlFlagEnums::EXPECTED_ENTRY.raw, & OpenCloseSettlFlagEnums::EXPECTED_ENTRY },
{ OpenCloseSettlFlagEnums::ENTRY_FROM_PREVIOUS_BUSINESS_DAY.raw, & OpenCloseSettlFlagEnums::ENTRY_FROM_PREVIOUS_BUSINESS_DAY },
{ OpenCloseSettlFlagEnums::THEORETICAL_PRICE_VALUE.raw, & OpenCloseSettlFlagEnums::THEORETICAL_PRICE_VALUE },
};

const FieldEnumMap FinancialStatusEnums::itemByRaw = {
{ FinancialStatusEnums::BANKRUPT.raw, & FinancialStatusEnums::BANKRUPT },
{ FinancialStatusEnums::PENDING_DELISTING.raw, & FinancialStatusEnums::PENDING_DELISTING },
};

const FieldEnumMap CorporateActionEnums::itemByRaw = {
{ CorporateActionEnums::EX_DIVIDEND.raw, & CorporateActionEnums::EX_DIVIDEND },
{ CorporateActionEnums::EX_DISTRIBUTION.raw, & CorporateActionEnums::EX_DISTRIBUTION },
{ CorporateActionEnums::EX_RIGHTS.raw, & CorporateActionEnums::EX_RIGHTS },
{ CorporateActionEnums::NEW.raw, & CorporateActionEnums::NEW },
{ CorporateActionEnums::EX_INTEREST.raw, & CorporateActionEnums::EX_INTEREST },
};

const FieldEnumMap QuoteStatusEnums::itemByRaw = {
{ QuoteStatusEnums::ACCEPTED.raw, & QuoteStatusEnums::ACCEPTED },
{ QuoteStatusEnums::CANCELED_FOR_SYMBOL.raw, & QuoteStatusEnums::CANCELED_FOR_SYMBOL },
{ QuoteStatusEnums::CANCELED_FOR_SECURITY_TYPE.raw, & QuoteStatusEnums::CANCELED_FOR_SECURITY_TYPE },
{ QuoteStatusEnums::CANCELED_FOR_UNDERLYING.raw, & QuoteStatusEnums::CANCELED_FOR_UNDERLYING },
{ QuoteStatusEnums::CANCELED_ALL.raw, & QuoteStatusEnums::CANCELED_ALL },
{ QuoteStatusEnums::REJECTED.raw, & QuoteStatusEnums::REJECTED },
{ QuoteStatusEnums::REMOVED_FROM_MARKET.raw, & QuoteStatusEnums::REMOVED_FROM_MARKET },
{ QuoteStatusEnums::EXPIRED.raw, & QuoteStatusEnums::EXPIRED },
{ QuoteStatusEnums::QUERY.raw, & QuoteStatusEnums::QUERY },
{ QuoteStatusEnums::QUOTE_NOT_FOUND.raw, & QuoteStatusEnums::QUOTE_NOT_FOUND },
{ QuoteStatusEnums::PENDING.raw, & QuoteStatusEnums::PENDING },
{ QuoteStatusEnums::PASS.raw, & QuoteStatusEnums::PASS },
{ QuoteStatusEnums::LOCKED_MARKET_WARNING.raw, & QuoteStatusEnums::LOCKED_MARKET_WARNING },
{ QuoteStatusEnums::CROSS_MARKET_WARNING.raw, & QuoteStatusEnums::CROSS_MARKET_WARNING },
{ QuoteStatusEnums::CANCELED_DUE_TO_LOCK_MARKET.raw, & QuoteStatusEnums::CANCELED_DUE_TO_LOCK_MARKET },
{ QuoteStatusEnums::CANCELED_DUE_TO_CROSS_MARKET.raw, & QuoteStatusEnums::CANCELED_DUE_TO_CROSS_MARKET },
};

const FieldEnumMap QuoteCancelTypeEnums::itemByRaw = {
{ QuoteCancelTypeEnums::CANCEL_FOR_SYMBOL.raw, & QuoteCancelTypeEnums::CANCEL_FOR_SYMBOL },
{ QuoteCancelTypeEnums::CANCEL_FOR_SECURITY_TYPE.raw, & QuoteCancelTypeEnums::CANCEL_FOR_SECURITY_TYPE },
{ QuoteCancelTypeEnums::CANCEL_FOR_UNDERLYING_SYMBOL.raw, & QuoteCancelTypeEnums::CANCEL_FOR_UNDERLYING_SYMBOL },
{ QuoteCancelTypeEnums::CANCEL_ALL_QUOTES.raw, & QuoteCancelTypeEnums::CANCEL_ALL_QUOTES },
};

const FieldEnumMap QuoteRejectReasonEnums::itemByRaw = {
{ QuoteRejectReasonEnums::UNKNOWN_SYMBOL.raw, & QuoteRejectReasonEnums::UNKNOWN_SYMBOL },
{ QuoteRejectReasonEnums::EXCHANGE.raw, & QuoteRejectReasonEnums::EXCHANGE },
{ QuoteRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT.raw, & QuoteRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT },
{ QuoteRejectReasonEnums::TOO_LATE_TO_ENTER.raw, & QuoteRejectReasonEnums::TOO_LATE_TO_ENTER },
{ QuoteRejectReasonEnums::UNKNOWN_QUOTE.raw, & QuoteRejectReasonEnums::UNKNOWN_QUOTE },
{ QuoteRejectReasonEnums::DUPLICATE_QUOTE.raw, & QuoteRejectReasonEnums::DUPLICATE_QUOTE },
{ QuoteRejectReasonEnums::INVALID_BID_ASK_SPREAD.raw, & QuoteRejectReasonEnums::INVALID_BID_ASK_SPREAD },
{ QuoteRejectReasonEnums::INVALID_PRICE.raw, & QuoteRejectReasonEnums::INVALID_PRICE },
{ QuoteRejectReasonEnums::NOT_AUTHORIZED_TO_QUOTE_SECURITY.raw, & QuoteRejectReasonEnums::NOT_AUTHORIZED_TO_QUOTE_SECURITY },
{ QuoteRejectReasonEnums::OTHER.raw, & QuoteRejectReasonEnums::OTHER },
};

const FieldEnumMap QuoteResponseLevelEnums::itemByRaw = {
{ QuoteResponseLevelEnums::NO_ACKNOWLEDGEMENT.raw, & QuoteResponseLevelEnums::NO_ACKNOWLEDGEMENT },
{ QuoteResponseLevelEnums::ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES.raw, & QuoteResponseLevelEnums::ACKNOWLEDGE_ONLY_NEGATIVE_OR_ERRONEOUS_QUOTES },
{ QuoteResponseLevelEnums::ACKNOWLEDGE_EACH_QUOTE_MESSAGES.raw, & QuoteResponseLevelEnums::ACKNOWLEDGE_EACH_QUOTE_MESSAGES },
};

const FieldEnumMap QuoteRequestTypeEnums::itemByRaw = {
{ QuoteRequestTypeEnums::MANUAL.raw, & QuoteRequestTypeEnums::MANUAL },
{ QuoteRequestTypeEnums::AUTOMATIC.raw, & QuoteRequestTypeEnums::AUTOMATIC },
};

const FieldEnumMap SecurityRequestTypeEnums::itemByRaw = {
{ SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS.raw, & SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS },
{ SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED.raw, & SecurityRequestTypeEnums::REQUEST_SECURITY_IDENTITY_FOR_THE_SPECIFICATIONS_PROVIDED },
{ SecurityRequestTypeEnums::REQUEST_LIST_SECURITY_TYPES.raw, & SecurityRequestTypeEnums::REQUEST_LIST_SECURITY_TYPES },
{ SecurityRequestTypeEnums::REQUEST_LIST_SECURITIES.raw, & SecurityRequestTypeEnums::REQUEST_LIST_SECURITIES },
};

const FieldEnumMap SecurityResponseTypeEnums::itemByRaw = {
{ SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_AS_IS.raw, & SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_AS_IS },
{ SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE.raw, & SecurityResponseTypeEnums::ACCEPT_SECURITY_PROPOSAL_WITH_REVISIONS_AS_INDICATED_IN_THE_MESSAGE },
{ SecurityResponseTypeEnums::REJECT_SECURITY_PROPOSAL.raw, & SecurityResponseTypeEnums::REJECT_SECURITY_PROPOSAL },
{ SecurityResponseTypeEnums::CAN_NOT_MATCH_SELECTION_CRITERIA.raw, & SecurityResponseTypeEnums::CAN_NOT_MATCH_SELECTION_CRITERIA },
};

const FieldEnumMap UnsolicitedIndicatorEnums::itemByRaw = {
{ UnsolicitedIndicatorEnums::YES.raw, & UnsolicitedIndicatorEnums::YES },
{ UnsolicitedIndicatorEnums::NO.raw, & UnsolicitedIndicatorEnums::NO },
};

const FieldEnumMap SecurityTradingStatusEnums::itemByRaw = {
{ SecurityTradingStatusEnums::OPENING_DELAY.raw, & SecurityTradingStatusEnums::OPENING_DELAY },
{ SecurityTradingStatusEnums::TRADING_HALT.raw, & SecurityTradingStatusEnums::TRADING_HALT },
{ SecurityTradingStatusEnums::RESUME.raw, & SecurityTradingStatusEnums::RESUME },
{ SecurityTradingStatusEnums::NO_OPEN_NO_RESUME.raw, & SecurityTradingStatusEnums::NO_OPEN_NO_RESUME },
{ SecurityTradingStatusEnums::PRICE_INDICATION.raw, & SecurityTradingStatusEnums::PRICE_INDICATION },
{ SecurityTradingStatusEnums::TRADING_RANGE_INDICATION.raw, & SecurityTradingStatusEnums::TRADING_RANGE_INDICATION },
{ SecurityTradingStatusEnums::MARKET_IMBALANCE_BUY.raw, & SecurityTradingStatusEnums::MARKET_IMBALANCE_BUY },
{ SecurityTradingStatusEnums::MARKET_IMBALANCE_SELL.raw, & SecurityTradingStatusEnums::MARKET_IMBALANCE_SELL },
{ SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_BUY.raw, & SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_BUY },
{ SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_SELL.raw, & SecurityTradingStatusEnums::MARKET_ON_CLOSE_IMBALANCE_SELL },
{ SecurityTradingStatusEnums::NO_MARKET_IMBALANCE.raw, & SecurityTradingStatusEnums::NO_MARKET_IMBALANCE },
{ SecurityTradingStatusEnums::NO_MARKET_ON_CLOSE_IMBALANCE.raw, & SecurityTradingStatusEnums::NO_MARKET_ON_CLOSE_IMBALANCE },
{ SecurityTradingStatusEnums::ITS_PRE_OPENING.raw, & SecurityTradingStatusEnums::ITS_PRE_OPENING },
{ SecurityTradingStatusEnums::NEW_PRICE_INDICATION.raw, & SecurityTradingStatusEnums::NEW_PRICE_INDICATION },
{ SecurityTradingStatusEnums::TRADE_DISSEMINATION_TIME.raw, & SecurityTradingStatusEnums::TRADE_DISSEMINATION_TIME },
{ SecurityTradingStatusEnums::READY_TO_TRADE.raw, & SecurityTradingStatusEnums::READY_TO_TRADE },
{ SecurityTradingStatusEnums::NOT_AVAILABLE_FOR_TRADING.raw, & SecurityTradingStatusEnums::NOT_AVAILABLE_FOR_TRADING },
{ SecurityTradingStatusEnums::NOT_TRADED_ON_THIS_MARKET.raw, & SecurityTradingStatusEnums::NOT_TRADED_ON_THIS_MARKET },
{ SecurityTradingStatusEnums::UNKNOWN_OR_INVALID.raw, & SecurityTradingStatusEnums::UNKNOWN_OR_INVALID },
{ SecurityTradingStatusEnums::PRE_OPEN.raw, & SecurityTradingStatusEnums::PRE_OPEN },
{ SecurityTradingStatusEnums::OPENING_ROTATION.raw, & SecurityTradingStatusEnums::OPENING_ROTATION },
{ SecurityTradingStatusEnums::FAST_MARKET.raw, & SecurityTradingStatusEnums::FAST_MARKET },
};

const FieldEnumMap HaltReasonCharEnums::itemByRaw = {
{ HaltReasonCharEnums::ORDER_IMBALANCE.raw, & HaltReasonCharEnums::ORDER_IMBALANCE },
{ HaltReasonCharEnums::EQUIPMENT_CHANGEOVER.raw, & HaltReasonCharEnums::EQUIPMENT_CHANGEOVER },
{ HaltReasonCharEnums::NEWS_PENDING.raw, & HaltReasonCharEnums::NEWS_PENDING },
{ HaltReasonCharEnums::NEWS_DISSEMINATION.raw, & HaltReasonCharEnums::NEWS_DISSEMINATION },
{ HaltReasonCharEnums::ORDER_INFLUX.raw, & HaltReasonCharEnums::ORDER_INFLUX },
{ HaltReasonCharEnums::ADDITIONAL_INFORMATION.raw, & HaltReasonCharEnums::ADDITIONAL_INFORMATION },
};

const FieldEnumMap InViewOfCommonEnums::itemByRaw = {
{ InViewOfCommonEnums::YES.raw, & InViewOfCommonEnums::YES },
{ InViewOfCommonEnums::NO.raw, & InViewOfCommonEnums::NO },
};

const FieldEnumMap DueToRelatedEnums::itemByRaw = {
{ DueToRelatedEnums::YES.raw, & DueToRelatedEnums::YES },
{ DueToRelatedEnums::NO.raw, & DueToRelatedEnums::NO },
};

const FieldEnumMap AdjustmentEnums::itemByRaw = {
{ AdjustmentEnums::CANCEL.raw, & AdjustmentEnums::CANCEL },
{ AdjustmentEnums::ERROR.raw, & AdjustmentEnums::ERROR },
{ AdjustmentEnums::CORRECTION.raw, & AdjustmentEnums::CORRECTION },
};

const FieldEnumMap TradSesMethodEnums::itemByRaw = {
{ TradSesMethodEnums::ELECTRONIC.raw, & TradSesMethodEnums::ELECTRONIC },
{ TradSesMethodEnums::OPEN_OUTCRY.raw, & TradSesMethodEnums::OPEN_OUTCRY },
{ TradSesMethodEnums::TWO_PARTY.raw, & TradSesMethodEnums::TWO_PARTY },
};

const FieldEnumMap TradSesModeEnums::itemByRaw = {
{ TradSesModeEnums::TESTING.raw, & TradSesModeEnums::TESTING },
{ TradSesModeEnums::SIMULATED.raw, & TradSesModeEnums::SIMULATED },
{ TradSesModeEnums::PRODUCTION.raw, & TradSesModeEnums::PRODUCTION },
};

const FieldEnumMap TradSesStatusEnums::itemByRaw = {
{ TradSesStatusEnums::UNKNOWN.raw, & TradSesStatusEnums::UNKNOWN },
{ TradSesStatusEnums::HALTED.raw, & TradSesStatusEnums::HALTED },
{ TradSesStatusEnums::OPEN.raw, & TradSesStatusEnums::OPEN },
{ TradSesStatusEnums::CLOSED.raw, & TradSesStatusEnums::CLOSED },
{ TradSesStatusEnums::PRE_OPEN.raw, & TradSesStatusEnums::PRE_OPEN },
{ TradSesStatusEnums::PRE_CLOSE.raw, & TradSesStatusEnums::PRE_CLOSE },
{ TradSesStatusEnums::REQUEST_REJECTED.raw, & TradSesStatusEnums::REQUEST_REJECTED },
};

const FieldEnumMap MessageEncodingEnums::itemByRaw = {
{ MessageEncodingEnums::JIS.raw, & MessageEncodingEnums::JIS },
{ MessageEncodingEnums::EUC.raw, & MessageEncodingEnums::EUC },
{ MessageEncodingEnums::FOR_USING_SJIS.raw, & MessageEncodingEnums::FOR_USING_SJIS },
{ MessageEncodingEnums::UNICODE.raw, & MessageEncodingEnums::UNICODE },
};

const FieldEnumMap SessionRejectReasonEnums::itemByRaw = {
{ SessionRejectReasonEnums::INVALID_TAG_NUMBER.raw, & SessionRejectReasonEnums::INVALID_TAG_NUMBER },
{ SessionRejectReasonEnums::REQUIRED_TAG_MISSING.raw, & SessionRejectReasonEnums::REQUIRED_TAG_MISSING },
{ SessionRejectReasonEnums::TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE.raw, & SessionRejectReasonEnums::TAG_NOT_DEFINED_FOR_THIS_MESSAGE_TYPE },
{ SessionRejectReasonEnums::UNDEFINED_TAG.raw, & SessionRejectReasonEnums::UNDEFINED_TAG },
{ SessionRejectReasonEnums::TAG_SPECIFIED_WITHOUT_A_VALUE.raw, & SessionRejectReasonEnums::TAG_SPECIFIED_WITHOUT_A_VALUE },
{ SessionRejectReasonEnums::VALUE_IS_INCORRECT.raw, & SessionRejectReasonEnums::VALUE_IS_INCORRECT },
{ SessionRejectReasonEnums::INCORRECT_DATA_FORMAT_FOR_VALUE.raw, & SessionRejectReasonEnums::INCORRECT_DATA_FORMAT_FOR_VALUE },
{ SessionRejectReasonEnums::DECRYPTION_PROBLEM.raw, & SessionRejectReasonEnums::DECRYPTION_PROBLEM },
{ SessionRejectReasonEnums::SIGNATURE_PROBLEM.raw, & SessionRejectReasonEnums::SIGNATURE_PROBLEM },
{ SessionRejectReasonEnums::COMPID_PROBLEM.raw, & SessionRejectReasonEnums::COMPID_PROBLEM },
{ SessionRejectReasonEnums::SENDINGTIME_ACCURACY_PROBLEM.raw, & SessionRejectReasonEnums::SENDINGTIME_ACCURACY_PROBLEM },
{ SessionRejectReasonEnums::INVALID_MSGTYPE.raw, & SessionRejectReasonEnums::INVALID_MSGTYPE },
{ SessionRejectReasonEnums::XML_VALIDATION_ERROR.raw, & SessionRejectReasonEnums::XML_VALIDATION_ERROR },
{ SessionRejectReasonEnums::TAG_APPEARS_MORE_THAN_ONCE.raw, & SessionRejectReasonEnums::TAG_APPEARS_MORE_THAN_ONCE },
{ SessionRejectReasonEnums::TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER.raw, & SessionRejectReasonEnums::TAG_SPECIFIED_OUT_OF_REQUIRED_ORDER },
{ SessionRejectReasonEnums::REPEATING_GROUP_FIELDS_OUT_OF_ORDER.raw, & SessionRejectReasonEnums::REPEATING_GROUP_FIELDS_OUT_OF_ORDER },
{ SessionRejectReasonEnums::INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP.raw, & SessionRejectReasonEnums::INCORRECT_NUMINGROUP_COUNT_FOR_REPEATING_GROUP },
{ SessionRejectReasonEnums::NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER.raw, & SessionRejectReasonEnums::NON_DATA_VALUE_INCLUDES_FIELD_DELIMITER },
{ SessionRejectReasonEnums::OTHER.raw, & SessionRejectReasonEnums::OTHER },
};

const FieldEnumMap BidRequestTransTypeEnums::itemByRaw = {
{ BidRequestTransTypeEnums::NEW.raw, & BidRequestTransTypeEnums::NEW },
{ BidRequestTransTypeEnums::CANCEL.raw, & BidRequestTransTypeEnums::CANCEL },
};

const FieldEnumMap SolicitedFlagEnums::itemByRaw = {
{ SolicitedFlagEnums::YES.raw, & SolicitedFlagEnums::YES },
{ SolicitedFlagEnums::NO.raw, & SolicitedFlagEnums::NO },
};

const FieldEnumMap ExecRestatementReasonEnums::itemByRaw = {
{ ExecRestatementReasonEnums::GT_CORPORATE_ACTION.raw, & ExecRestatementReasonEnums::GT_CORPORATE_ACTION },
{ ExecRestatementReasonEnums::GT_RENEWAL.raw, & ExecRestatementReasonEnums::GT_RENEWAL },
{ ExecRestatementReasonEnums::VERBAL_CHANGE.raw, & ExecRestatementReasonEnums::VERBAL_CHANGE },
{ ExecRestatementReasonEnums::REPRICING_OF_ORDER.raw, & ExecRestatementReasonEnums::REPRICING_OF_ORDER },
{ ExecRestatementReasonEnums::BROKER_OPTION.raw, & ExecRestatementReasonEnums::BROKER_OPTION },
{ ExecRestatementReasonEnums::PARTIAL_DECLINE_OF_ORDERQTY.raw, & ExecRestatementReasonEnums::PARTIAL_DECLINE_OF_ORDERQTY },
{ ExecRestatementReasonEnums::CANCEL_ON_TRADING_HALT.raw, & ExecRestatementReasonEnums::CANCEL_ON_TRADING_HALT },
{ ExecRestatementReasonEnums::CANCEL_ON_SYSTEM_FAILURE.raw, & ExecRestatementReasonEnums::CANCEL_ON_SYSTEM_FAILURE },
{ ExecRestatementReasonEnums::MARKET.raw, & ExecRestatementReasonEnums::MARKET },
{ ExecRestatementReasonEnums::CANCELED_NOT_BEST.raw, & ExecRestatementReasonEnums::CANCELED_NOT_BEST },
{ ExecRestatementReasonEnums::WAREHOUSE_RECAP.raw, & ExecRestatementReasonEnums::WAREHOUSE_RECAP },
{ ExecRestatementReasonEnums::OTHER.raw, & ExecRestatementReasonEnums::OTHER },
};

const FieldEnumMap BusinessRejectReasonEnums::itemByRaw = {
{ BusinessRejectReasonEnums::OTHER.raw, & BusinessRejectReasonEnums::OTHER },
{ BusinessRejectReasonEnums::UNKOWN_ID.raw, & BusinessRejectReasonEnums::UNKOWN_ID },
{ BusinessRejectReasonEnums::UNKNOWN_SECURITY.raw, & BusinessRejectReasonEnums::UNKNOWN_SECURITY },
{ BusinessRejectReasonEnums::UNSUPPORTED_MESSAGE_TYPE.raw, & BusinessRejectReasonEnums::UNSUPPORTED_MESSAGE_TYPE },
{ BusinessRejectReasonEnums::APPLICATION_NOT_AVAILABLE.raw, & BusinessRejectReasonEnums::APPLICATION_NOT_AVAILABLE },
{ BusinessRejectReasonEnums::CONDITIONALLY_REQUIRED_FIELD_MISSING.raw, & BusinessRejectReasonEnums::CONDITIONALLY_REQUIRED_FIELD_MISSING },
{ BusinessRejectReasonEnums::NOT_AUTHORIZED.raw, & BusinessRejectReasonEnums::NOT_AUTHORIZED },
{ BusinessRejectReasonEnums::DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME.raw, & BusinessRejectReasonEnums::DELIVERTO_FIRM_NOT_AVAILABLE_AT_THIS_TIME },
};

const FieldEnumMap MsgDirectionEnums::itemByRaw = {
{ MsgDirectionEnums::SEND.raw, & MsgDirectionEnums::SEND },
{ MsgDirectionEnums::RECEIVE.raw, & MsgDirectionEnums::RECEIVE },
};

const FieldEnumMap DiscretionInstEnums::itemByRaw = {
{ DiscretionInstEnums::RELATED_TO_DISPLAYED_PRICE.raw, & DiscretionInstEnums::RELATED_TO_DISPLAYED_PRICE },
{ DiscretionInstEnums::RELATED_TO_MARKET_PRICE.raw, & DiscretionInstEnums::RELATED_TO_MARKET_PRICE },
{ DiscretionInstEnums::RELATED_TO_PRIMARY_PRICE.raw, & DiscretionInstEnums::RELATED_TO_PRIMARY_PRICE },
{ DiscretionInstEnums::RELATED_TO_LOCAL_PRIMARY_PRICE.raw, & DiscretionInstEnums::RELATED_TO_LOCAL_PRIMARY_PRICE },
{ DiscretionInstEnums::RELATED_TO_MIDPOINT_PRICE.raw, & DiscretionInstEnums::RELATED_TO_MIDPOINT_PRICE },
{ DiscretionInstEnums::RELATED_TO_LAST_TRADE_PRICE.raw, & DiscretionInstEnums::RELATED_TO_LAST_TRADE_PRICE },
{ DiscretionInstEnums::RELATED_TO_VWAP.raw, & DiscretionInstEnums::RELATED_TO_VWAP },
};

const FieldEnumMap BidTypeEnums::itemByRaw = {
{ BidTypeEnums::NON_DISCLOSED_STYLE.raw, & BidTypeEnums::NON_DISCLOSED_STYLE },
{ BidTypeEnums::DISCLOSED_STYLE.raw, & BidTypeEnums::DISCLOSED_STYLE },
{ BidTypeEnums::NO_BIDDING_PROCESS.raw, & BidTypeEnums::NO_BIDDING_PROCESS },
};

const FieldEnumMap BidDescriptorTypeEnums::itemByRaw = {
{ BidDescriptorTypeEnums::SECTOR.raw, & BidDescriptorTypeEnums::SECTOR },
{ BidDescriptorTypeEnums::COUNTRY.raw, & BidDescriptorTypeEnums::COUNTRY },
{ BidDescriptorTypeEnums::INDEX.raw, & BidDescriptorTypeEnums::INDEX },
};

const FieldEnumMap SideValueIndEnums::itemByRaw = {
{ SideValueIndEnums::SIDEVALUE1.raw, & SideValueIndEnums::SIDEVALUE1 },
{ SideValueIndEnums::SIDEVALUE_2.raw, & SideValueIndEnums::SIDEVALUE_2 },
};

const FieldEnumMap LiquidityIndTypeEnums::itemByRaw = {
{ LiquidityIndTypeEnums::_5DAY_MOVING_AVERAGE.raw, & LiquidityIndTypeEnums::_5DAY_MOVING_AVERAGE },
{ LiquidityIndTypeEnums::_20_DAY_MOVING_AVERAGE.raw, & LiquidityIndTypeEnums::_20_DAY_MOVING_AVERAGE },
{ LiquidityIndTypeEnums::NORMAL_MARKET_SIZE.raw, & LiquidityIndTypeEnums::NORMAL_MARKET_SIZE },
{ LiquidityIndTypeEnums::OTHER.raw, & LiquidityIndTypeEnums::OTHER },
};

const FieldEnumMap ExchangeForPhysicalEnums::itemByRaw = {
{ ExchangeForPhysicalEnums::YES.raw, & ExchangeForPhysicalEnums::YES },
{ ExchangeForPhysicalEnums::NO.raw, & ExchangeForPhysicalEnums::NO },
};

const FieldEnumMap ProgRptReqsEnums::itemByRaw = {
{ ProgRptReqsEnums::BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST.raw, & ProgRptReqsEnums::BUYSIDE_EXPLICITLY_REQUESTS_STATUS_USING_STATUSREQUEST },
{ ProgRptReqsEnums::SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_PERIOD_OPTIONALLY_SPECIFIED_IN_PROGRESSPERIOD.raw, & ProgRptReqsEnums::SELLSIDE_PERIODICALLY_SENDS_STATUS_USING_LISTSTATUS_PERIOD_OPTIONALLY_SPECIFIED_IN_PROGRESSPERIOD },
{ ProgRptReqsEnums::REAL_TIME_EXECUTION_REPORTS.raw, & ProgRptReqsEnums::REAL_TIME_EXECUTION_REPORTS },
};

const FieldEnumMap IncTaxIndEnums::itemByRaw = {
{ IncTaxIndEnums::NET.raw, & IncTaxIndEnums::NET },
{ IncTaxIndEnums::GROSS.raw, & IncTaxIndEnums::GROSS },
};

const FieldEnumMap BidTradeTypeEnums::itemByRaw = {
{ BidTradeTypeEnums::RISK_TRADE.raw, & BidTradeTypeEnums::RISK_TRADE },
{ BidTradeTypeEnums::VWAP_GUARANTEE.raw, & BidTradeTypeEnums::VWAP_GUARANTEE },
{ BidTradeTypeEnums::AGENCY.raw, & BidTradeTypeEnums::AGENCY },
{ BidTradeTypeEnums::GUARANTEED_CLOSE.raw, & BidTradeTypeEnums::GUARANTEED_CLOSE },
};

const FieldEnumMap BasisPxTypeEnums::itemByRaw = {
{ BasisPxTypeEnums::CLOSING_PRICE_AT_MORNING_SESSION.raw, & BasisPxTypeEnums::CLOSING_PRICE_AT_MORNING_SESSION },
{ BasisPxTypeEnums::CLOSING_PRICE.raw, & BasisPxTypeEnums::CLOSING_PRICE },
{ BasisPxTypeEnums::CURRENT_PRICE.raw, & BasisPxTypeEnums::CURRENT_PRICE },
{ BasisPxTypeEnums::SQ.raw, & BasisPxTypeEnums::SQ },
{ BasisPxTypeEnums::VWAP_THROUGH_A_DAY.raw, & BasisPxTypeEnums::VWAP_THROUGH_A_DAY },
{ BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION.raw, & BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION },
{ BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION.raw, & BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION },
{ BasisPxTypeEnums::VWAP_THROUGH_A_DAY_EXCEPT_YORI.raw, & BasisPxTypeEnums::VWAP_THROUGH_A_DAY_EXCEPT_YORI },
{ BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI.raw, & BasisPxTypeEnums::VWAP_THROUGH_A_MORNING_SESSION_EXCEPT_YORI },
{ BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI.raw, & BasisPxTypeEnums::VWAP_THROUGH_AN_AFTERNOON_SESSION_EXCEPT_YORI },
{ BasisPxTypeEnums::STRIKE.raw, & BasisPxTypeEnums::STRIKE },
{ BasisPxTypeEnums::OPEN.raw, & BasisPxTypeEnums::OPEN },
{ BasisPxTypeEnums::OTHERS.raw, & BasisPxTypeEnums::OTHERS },
};

const FieldEnumMap PriceTypeEnums::itemByRaw = {
{ PriceTypeEnums::PERCENTAGE.raw, & PriceTypeEnums::PERCENTAGE },
{ PriceTypeEnums::PER_UNIT.raw, & PriceTypeEnums::PER_UNIT },
{ PriceTypeEnums::FIXED_AMOUNT.raw, & PriceTypeEnums::FIXED_AMOUNT },
{ PriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR.raw, & PriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR },
{ PriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR.raw, & PriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR },
{ PriceTypeEnums::SPREAD.raw, & PriceTypeEnums::SPREAD },
{ PriceTypeEnums::TED_PRICE.raw, & PriceTypeEnums::TED_PRICE },
{ PriceTypeEnums::TED_YIELD.raw, & PriceTypeEnums::TED_YIELD },
{ PriceTypeEnums::YIELD.raw, & PriceTypeEnums::YIELD },
{ PriceTypeEnums::FIXED_CABINET_TRADE_PRICE.raw, & PriceTypeEnums::FIXED_CABINET_TRADE_PRICE },
{ PriceTypeEnums::VARIABLE_CABINET_TRADE_PRICE.raw, & PriceTypeEnums::VARIABLE_CABINET_TRADE_PRICE },
};

const FieldEnumMap GTBookingInstEnums::itemByRaw = {
{ GTBookingInstEnums::BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION.raw, & GTBookingInstEnums::BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION },
{ GTBookingInstEnums::ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES.raw, & GTBookingInstEnums::ACCUMULATE_EXECUTIONS_UNTIL_ORDER_IS_FILLED_OR_EXPIRES },
{ GTBookingInstEnums::ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE.raw, & GTBookingInstEnums::ACCUMULATE_UNTIL_VERBALLY_NOTIFIED_OTHERWISE },
};

const FieldEnumMap ListStatusTypeEnums::itemByRaw = {
{ ListStatusTypeEnums::ACK.raw, & ListStatusTypeEnums::ACK },
{ ListStatusTypeEnums::RESPONSE.raw, & ListStatusTypeEnums::RESPONSE },
{ ListStatusTypeEnums::TIMED.raw, & ListStatusTypeEnums::TIMED },
{ ListStatusTypeEnums::EXECSTARTED.raw, & ListStatusTypeEnums::EXECSTARTED },
{ ListStatusTypeEnums::ALLDONE.raw, & ListStatusTypeEnums::ALLDONE },
{ ListStatusTypeEnums::ALERT.raw, & ListStatusTypeEnums::ALERT },
};

const FieldEnumMap NetGrossIndEnums::itemByRaw = {
{ NetGrossIndEnums::NET.raw, & NetGrossIndEnums::NET },
{ NetGrossIndEnums::GROSS.raw, & NetGrossIndEnums::GROSS },
};

const FieldEnumMap ListOrderStatusEnums::itemByRaw = {
{ ListOrderStatusEnums::INBIDDINGPROCESS.raw, & ListOrderStatusEnums::INBIDDINGPROCESS },
{ ListOrderStatusEnums::RECEIVEDFOREXECUTION.raw, & ListOrderStatusEnums::RECEIVEDFOREXECUTION },
{ ListOrderStatusEnums::EXECUTING.raw, & ListOrderStatusEnums::EXECUTING },
{ ListOrderStatusEnums::CANCELING.raw, & ListOrderStatusEnums::CANCELING },
{ ListOrderStatusEnums::ALERT.raw, & ListOrderStatusEnums::ALERT },
{ ListOrderStatusEnums::ALL_DONE.raw, & ListOrderStatusEnums::ALL_DONE },
{ ListOrderStatusEnums::REJECT.raw, & ListOrderStatusEnums::REJECT },
};

const FieldEnumMap ListExecInstTypeEnums::itemByRaw = {
{ ListExecInstTypeEnums::IMMEDIATE.raw, & ListExecInstTypeEnums::IMMEDIATE },
{ ListExecInstTypeEnums::WAIT_FOR_EXECUTE_INSTRUCTION.raw, & ListExecInstTypeEnums::WAIT_FOR_EXECUTE_INSTRUCTION },
{ ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN.raw, & ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_SELL_DRIVEN },
{ ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP.raw, & ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_TOP_UP },
{ ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW.raw, & ListExecInstTypeEnums::EXCHANGE_SWITCH_CIV_ORDER_BUY_DRIVEN_CASH_WITHDRAW },
};

const FieldEnumMap CxlRejResponseToEnums::itemByRaw = {
{ CxlRejResponseToEnums::ORDER_CANCEL_REQUEST.raw, & CxlRejResponseToEnums::ORDER_CANCEL_REQUEST },
{ CxlRejResponseToEnums::ORDER_CANCEL_REPLACE_REQUEST.raw, & CxlRejResponseToEnums::ORDER_CANCEL_REPLACE_REQUEST },
};

const FieldEnumMap MultiLegReportingTypeEnums::itemByRaw = {
{ MultiLegReportingTypeEnums::SINGLE_SECURITY.raw, & MultiLegReportingTypeEnums::SINGLE_SECURITY },
{ MultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY.raw, & MultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY },
{ MultiLegReportingTypeEnums::MULTI_LEG_SECURITY.raw, & MultiLegReportingTypeEnums::MULTI_LEG_SECURITY },
};

const FieldEnumMap PartyIDSourceEnums::itemByRaw = {
{ PartyIDSourceEnums::BIC.raw, & PartyIDSourceEnums::BIC },
{ PartyIDSourceEnums::GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER.raw, & PartyIDSourceEnums::GENERALLY_ACCEPTED_MARKET_PARTICIPANT_IDENTIFIER },
{ PartyIDSourceEnums::PROPRIETARY_CUSTOM_CODE.raw, & PartyIDSourceEnums::PROPRIETARY_CUSTOM_CODE },
{ PartyIDSourceEnums::ISO_COUNTRY_CODE.raw, & PartyIDSourceEnums::ISO_COUNTRY_CODE },
{ PartyIDSourceEnums::SETTLEMENT_ENTITY_LOCATION.raw, & PartyIDSourceEnums::SETTLEMENT_ENTITY_LOCATION },
{ PartyIDSourceEnums::MIC.raw, & PartyIDSourceEnums::MIC },
{ PartyIDSourceEnums::CSD_PARTICIPANT_MEMBER_CODE.raw, & PartyIDSourceEnums::CSD_PARTICIPANT_MEMBER_CODE },
{ PartyIDSourceEnums::KOREAN_INVESTOR_ID.raw, & PartyIDSourceEnums::KOREAN_INVESTOR_ID },
{ PartyIDSourceEnums::TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII.raw, & PartyIDSourceEnums::TAIWANESE_QUALIFIED_FOREIGN_INVESTOR_ID_QFII },
{ PartyIDSourceEnums::TAIWANESE_TRADING_ACCOUNT.raw, & PartyIDSourceEnums::TAIWANESE_TRADING_ACCOUNT },
{ PartyIDSourceEnums::MALAYSIAN_CENTRAL_DEPOSITORY.raw, & PartyIDSourceEnums::MALAYSIAN_CENTRAL_DEPOSITORY },
{ PartyIDSourceEnums::CHINESE_B_SHARE.raw, & PartyIDSourceEnums::CHINESE_B_SHARE },
{ PartyIDSourceEnums::UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER.raw, & PartyIDSourceEnums::UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER },
{ PartyIDSourceEnums::US_SOCIAL_SECURITY_NUMBER.raw, & PartyIDSourceEnums::US_SOCIAL_SECURITY_NUMBER },
{ PartyIDSourceEnums::US_EMPLOYER_IDENTIFICATION_NUMBER.raw, & PartyIDSourceEnums::US_EMPLOYER_IDENTIFICATION_NUMBER },
{ PartyIDSourceEnums::AUSTRALIAN_BUSINESS_NUMBER.raw, & PartyIDSourceEnums::AUSTRALIAN_BUSINESS_NUMBER },
{ PartyIDSourceEnums::AUSTRALIAN_TAX_FILE_NUMBER.raw, & PartyIDSourceEnums::AUSTRALIAN_TAX_FILE_NUMBER },
{ PartyIDSourceEnums::DIRECTED_BROKER_THREE_CHARACTER_ACRONYM_AS_DEFINED_IN_ISITC_ETC_BEST_PRACTICE_GUIDELINES_DOCUMENT.raw, & PartyIDSourceEnums::DIRECTED_BROKER_THREE_CHARACTER_ACRONYM_AS_DEFINED_IN_ISITC_ETC_BEST_PRACTICE_GUIDELINES_DOCUMENT },
};

const FieldEnumMap PartyRoleEnums::itemByRaw = {
{ PartyRoleEnums::EXECUTING_FIRM.raw, & PartyRoleEnums::EXECUTING_FIRM },
{ PartyRoleEnums::BROKER_OF_CREDIT.raw, & PartyRoleEnums::BROKER_OF_CREDIT },
{ PartyRoleEnums::CLIENT_ID.raw, & PartyRoleEnums::CLIENT_ID },
{ PartyRoleEnums::CLEARING_FIRM.raw, & PartyRoleEnums::CLEARING_FIRM },
{ PartyRoleEnums::INVESTOR_ID.raw, & PartyRoleEnums::INVESTOR_ID },
{ PartyRoleEnums::INTRODUCING_FIRM.raw, & PartyRoleEnums::INTRODUCING_FIRM },
{ PartyRoleEnums::ENTERING_FIRM.raw, & PartyRoleEnums::ENTERING_FIRM },
{ PartyRoleEnums::LOCATE_LENDING_FIRM.raw, & PartyRoleEnums::LOCATE_LENDING_FIRM },
{ PartyRoleEnums::FUND_MANAGER_CLIENT_ID.raw, & PartyRoleEnums::FUND_MANAGER_CLIENT_ID },
{ PartyRoleEnums::SETTLEMENT_LOCATION.raw, & PartyRoleEnums::SETTLEMENT_LOCATION },
{ PartyRoleEnums::ORDER_ORIGINATION_TRADER.raw, & PartyRoleEnums::ORDER_ORIGINATION_TRADER },
{ PartyRoleEnums::EXECUTING_TRADER.raw, & PartyRoleEnums::EXECUTING_TRADER },
{ PartyRoleEnums::ORDER_ORIGINATION_FIRM.raw, & PartyRoleEnums::ORDER_ORIGINATION_FIRM },
{ PartyRoleEnums::GIVEUP_CLEARING_FIRM.raw, & PartyRoleEnums::GIVEUP_CLEARING_FIRM },
{ PartyRoleEnums::CORRESPONDANT_CLEARING_FIRM.raw, & PartyRoleEnums::CORRESPONDANT_CLEARING_FIRM },
{ PartyRoleEnums::EXECUTING_SYSTEM.raw, & PartyRoleEnums::EXECUTING_SYSTEM },
{ PartyRoleEnums::CONTRA_FIRM.raw, & PartyRoleEnums::CONTRA_FIRM },
{ PartyRoleEnums::CONTRA_CLEARING_FIRM.raw, & PartyRoleEnums::CONTRA_CLEARING_FIRM },
{ PartyRoleEnums::SPONSORING_FIRM.raw, & PartyRoleEnums::SPONSORING_FIRM },
{ PartyRoleEnums::UNDERLYING_CONTRA_FIRM.raw, & PartyRoleEnums::UNDERLYING_CONTRA_FIRM },
{ PartyRoleEnums::CLEARING_ORGANIZATION.raw, & PartyRoleEnums::CLEARING_ORGANIZATION },
{ PartyRoleEnums::EXCHANGE.raw, & PartyRoleEnums::EXCHANGE },
{ PartyRoleEnums::CUSTOMER_ACCOUNT.raw, & PartyRoleEnums::CUSTOMER_ACCOUNT },
{ PartyRoleEnums::CORRESPONDENT_CLEARING_ORGANIZATION.raw, & PartyRoleEnums::CORRESPONDENT_CLEARING_ORGANIZATION },
{ PartyRoleEnums::CORRESPONDENT_BROKER.raw, & PartyRoleEnums::CORRESPONDENT_BROKER },
{ PartyRoleEnums::BUYER_SELLER.raw, & PartyRoleEnums::BUYER_SELLER },
{ PartyRoleEnums::CUSTODIAN.raw, & PartyRoleEnums::CUSTODIAN },
{ PartyRoleEnums::INTERMEDIARY.raw, & PartyRoleEnums::INTERMEDIARY },
{ PartyRoleEnums::AGENT.raw, & PartyRoleEnums::AGENT },
{ PartyRoleEnums::SUB_CUSTODIAN.raw, & PartyRoleEnums::SUB_CUSTODIAN },
{ PartyRoleEnums::BENEFICIARY.raw, & PartyRoleEnums::BENEFICIARY },
{ PartyRoleEnums::INTERESTED_PARTY.raw, & PartyRoleEnums::INTERESTED_PARTY },
{ PartyRoleEnums::REGULATORY_BODY.raw, & PartyRoleEnums::REGULATORY_BODY },
{ PartyRoleEnums::LIQUIDITY_PROVIDER.raw, & PartyRoleEnums::LIQUIDITY_PROVIDER },
{ PartyRoleEnums::ENTERING_TRADER.raw, & PartyRoleEnums::ENTERING_TRADER },
{ PartyRoleEnums::CONTRA_TRADER.raw, & PartyRoleEnums::CONTRA_TRADER },
{ PartyRoleEnums::POSITION_ACCOUNT.raw, & PartyRoleEnums::POSITION_ACCOUNT },
};

const FieldEnumMap ProductEnums::itemByRaw = {
{ ProductEnums::AGENCY.raw, & ProductEnums::AGENCY },
{ ProductEnums::COMMODITY.raw, & ProductEnums::COMMODITY },
{ ProductEnums::CORPORATE.raw, & ProductEnums::CORPORATE },
{ ProductEnums::CURRENCY.raw, & ProductEnums::CURRENCY },
{ ProductEnums::EQUITY.raw, & ProductEnums::EQUITY },
{ ProductEnums::GOVERNMENT.raw, & ProductEnums::GOVERNMENT },
{ ProductEnums::INDEX.raw, & ProductEnums::INDEX },
{ ProductEnums::LOAN.raw, & ProductEnums::LOAN },
{ ProductEnums::MONEYMARKET.raw, & ProductEnums::MONEYMARKET },
{ ProductEnums::MORTGAGE.raw, & ProductEnums::MORTGAGE },
{ ProductEnums::MUNICIPAL.raw, & ProductEnums::MUNICIPAL },
{ ProductEnums::OTHER.raw, & ProductEnums::OTHER },
{ ProductEnums::FINANCING.raw, & ProductEnums::FINANCING },
};

const FieldEnumMap TestMessageIndicatorEnums::itemByRaw = {
{ TestMessageIndicatorEnums::YES.raw, & TestMessageIndicatorEnums::YES },
{ TestMessageIndicatorEnums::NO.raw, & TestMessageIndicatorEnums::NO },
};

const FieldEnumMap RoundingDirectionEnums::itemByRaw = {
{ RoundingDirectionEnums::ROUND_TO_NEAREST.raw, & RoundingDirectionEnums::ROUND_TO_NEAREST },
{ RoundingDirectionEnums::ROUND_DOWN.raw, & RoundingDirectionEnums::ROUND_DOWN },
{ RoundingDirectionEnums::ROUND_UP.raw, & RoundingDirectionEnums::ROUND_UP },
};

const FieldEnumMap DistribPaymentMethodEnums::itemByRaw = {
{ DistribPaymentMethodEnums::CREST.raw, & DistribPaymentMethodEnums::CREST },
{ DistribPaymentMethodEnums::NSCC.raw, & DistribPaymentMethodEnums::NSCC },
{ DistribPaymentMethodEnums::EUROCLEAR.raw, & DistribPaymentMethodEnums::EUROCLEAR },
{ DistribPaymentMethodEnums::CLEARSTREAM.raw, & DistribPaymentMethodEnums::CLEARSTREAM },
{ DistribPaymentMethodEnums::CHEQUE.raw, & DistribPaymentMethodEnums::CHEQUE },
{ DistribPaymentMethodEnums::TELEGRAPHIC_TRANSFER.raw, & DistribPaymentMethodEnums::TELEGRAPHIC_TRANSFER },
{ DistribPaymentMethodEnums::FEDWIRE.raw, & DistribPaymentMethodEnums::FEDWIRE },
{ DistribPaymentMethodEnums::DIRECT_CREDIT.raw, & DistribPaymentMethodEnums::DIRECT_CREDIT },
{ DistribPaymentMethodEnums::ACH_CREDIT.raw, & DistribPaymentMethodEnums::ACH_CREDIT },
{ DistribPaymentMethodEnums::BPAY.raw, & DistribPaymentMethodEnums::BPAY },
{ DistribPaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM.raw, & DistribPaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM },
{ DistribPaymentMethodEnums::REINVEST_IN_FUND.raw, & DistribPaymentMethodEnums::REINVEST_IN_FUND },
};

const FieldEnumMap CancellationRightsEnums::itemByRaw = {
{ CancellationRightsEnums::YES.raw, & CancellationRightsEnums::YES },
{ CancellationRightsEnums::NO_EXECUTION_ONLY.raw, & CancellationRightsEnums::NO_EXECUTION_ONLY },
{ CancellationRightsEnums::NO_WAIVER_AGREEMENT.raw, & CancellationRightsEnums::NO_WAIVER_AGREEMENT },
{ CancellationRightsEnums::NO_INSTITUTIONAL.raw, & CancellationRightsEnums::NO_INSTITUTIONAL },
};

const FieldEnumMap MoneyLaunderingStatusEnums::itemByRaw = {
{ MoneyLaunderingStatusEnums::PASSED.raw, & MoneyLaunderingStatusEnums::PASSED },
{ MoneyLaunderingStatusEnums::NOT_CHECKED.raw, & MoneyLaunderingStatusEnums::NOT_CHECKED },
{ MoneyLaunderingStatusEnums::EXEMPT_BELOW_THE_LIMIT.raw, & MoneyLaunderingStatusEnums::EXEMPT_BELOW_THE_LIMIT },
{ MoneyLaunderingStatusEnums::EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION.raw, & MoneyLaunderingStatusEnums::EXEMPT_CLIENT_MONEY_TYPE_EXEMPTION },
{ MoneyLaunderingStatusEnums::EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION.raw, & MoneyLaunderingStatusEnums::EXEMPT_AUTHORISED_CREDIT_OR_FINANCIAL_INSTITUTION },
};

const FieldEnumMap ExecPriceTypeEnums::itemByRaw = {
{ ExecPriceTypeEnums::BID_PRICE.raw, & ExecPriceTypeEnums::BID_PRICE },
{ ExecPriceTypeEnums::CREATION_PRICE.raw, & ExecPriceTypeEnums::CREATION_PRICE },
{ ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT.raw, & ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT },
{ ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT.raw, & ExecPriceTypeEnums::CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT },
{ ExecPriceTypeEnums::OFFER_PRICE.raw, & ExecPriceTypeEnums::OFFER_PRICE },
{ ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT.raw, & ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT },
{ ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT.raw, & ExecPriceTypeEnums::OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT },
{ ExecPriceTypeEnums::SINGLE_PRICE.raw, & ExecPriceTypeEnums::SINGLE_PRICE },
};

const FieldEnumMap PaymentMethodEnums::itemByRaw = {
{ PaymentMethodEnums::CREST.raw, & PaymentMethodEnums::CREST },
{ PaymentMethodEnums::NSCC.raw, & PaymentMethodEnums::NSCC },
{ PaymentMethodEnums::EUROCLEAR.raw, & PaymentMethodEnums::EUROCLEAR },
{ PaymentMethodEnums::CLEARSTREAM.raw, & PaymentMethodEnums::CLEARSTREAM },
{ PaymentMethodEnums::CHEQUE.raw, & PaymentMethodEnums::CHEQUE },
{ PaymentMethodEnums::TELEGRAPHIC_TRANSFER.raw, & PaymentMethodEnums::TELEGRAPHIC_TRANSFER },
{ PaymentMethodEnums::FEDWIRE.raw, & PaymentMethodEnums::FEDWIRE },
{ PaymentMethodEnums::DEBIT_CARD.raw, & PaymentMethodEnums::DEBIT_CARD },
{ PaymentMethodEnums::DIRECT_DEBIT.raw, & PaymentMethodEnums::DIRECT_DEBIT },
{ PaymentMethodEnums::DIRECT_CREDIT.raw, & PaymentMethodEnums::DIRECT_CREDIT },
{ PaymentMethodEnums::CREDIT_CARD.raw, & PaymentMethodEnums::CREDIT_CARD },
{ PaymentMethodEnums::ACH_DEBIT.raw, & PaymentMethodEnums::ACH_DEBIT },
{ PaymentMethodEnums::ACH_CREDIT.raw, & PaymentMethodEnums::ACH_CREDIT },
{ PaymentMethodEnums::BPAY.raw, & PaymentMethodEnums::BPAY },
{ PaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM.raw, & PaymentMethodEnums::HIGH_VALUE_CLEARING_SYSTEM },
};

const FieldEnumMap TaxAdvantageTypeEnums::itemByRaw = {
{ TaxAdvantageTypeEnums::NONE_NOT_APPLICABLE.raw, & TaxAdvantageTypeEnums::NONE_NOT_APPLICABLE },
{ TaxAdvantageTypeEnums::MAXI_ISA.raw, & TaxAdvantageTypeEnums::MAXI_ISA },
{ TaxAdvantageTypeEnums::TESSA.raw, & TaxAdvantageTypeEnums::TESSA },
{ TaxAdvantageTypeEnums::MINI_CASH_ISA.raw, & TaxAdvantageTypeEnums::MINI_CASH_ISA },
{ TaxAdvantageTypeEnums::MINI_STOCKS_AND_SHARES_ISA.raw, & TaxAdvantageTypeEnums::MINI_STOCKS_AND_SHARES_ISA },
{ TaxAdvantageTypeEnums::MINI_INSURANCE_ISA.raw, & TaxAdvantageTypeEnums::MINI_INSURANCE_ISA },
{ TaxAdvantageTypeEnums::CURRENT_YEAR_PAYMENT.raw, & TaxAdvantageTypeEnums::CURRENT_YEAR_PAYMENT },
{ TaxAdvantageTypeEnums::PRIOR_YEAR_PAYMENT.raw, & TaxAdvantageTypeEnums::PRIOR_YEAR_PAYMENT },
{ TaxAdvantageTypeEnums::ASSET_TRANSFER.raw, & TaxAdvantageTypeEnums::ASSET_TRANSFER },
{ TaxAdvantageTypeEnums::EMPLOYEE.raw, & TaxAdvantageTypeEnums::EMPLOYEE },
{ TaxAdvantageTypeEnums::EMPLOYEE_CURRENT_YEAR.raw, & TaxAdvantageTypeEnums::EMPLOYEE_CURRENT_YEAR },
{ TaxAdvantageTypeEnums::EMPLOYER.raw, & TaxAdvantageTypeEnums::EMPLOYER },
{ TaxAdvantageTypeEnums::EMPLOYER_CURRENT_YEAR.raw, & TaxAdvantageTypeEnums::EMPLOYER_CURRENT_YEAR },
{ TaxAdvantageTypeEnums::NON_FUND_PROTOTYPE_IRA.raw, & TaxAdvantageTypeEnums::NON_FUND_PROTOTYPE_IRA },
{ TaxAdvantageTypeEnums::NON_FUND_QUALIFIED_PLAN.raw, & TaxAdvantageTypeEnums::NON_FUND_QUALIFIED_PLAN },
{ TaxAdvantageTypeEnums::DEFINED_CONTRIBUTION_PLAN.raw, & TaxAdvantageTypeEnums::DEFINED_CONTRIBUTION_PLAN },
{ TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT.raw, & TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT },
{ TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT_ROLLOVER.raw, & TaxAdvantageTypeEnums::INDIVIDUAL_RETIREMENT_ACCOUNT_ROLLOVER },
{ TaxAdvantageTypeEnums::KEOGH.raw, & TaxAdvantageTypeEnums::KEOGH },
{ TaxAdvantageTypeEnums::PROFIT_SHARING_PLAN.raw, & TaxAdvantageTypeEnums::PROFIT_SHARING_PLAN },
{ TaxAdvantageTypeEnums::_401K.raw, & TaxAdvantageTypeEnums::_401K },
{ TaxAdvantageTypeEnums::SELF_DIRECTED_IRA.raw, & TaxAdvantageTypeEnums::SELF_DIRECTED_IRA },
{ TaxAdvantageTypeEnums::_403.raw, & TaxAdvantageTypeEnums::_403 },
{ TaxAdvantageTypeEnums::_457.raw, & TaxAdvantageTypeEnums::_457 },
{ TaxAdvantageTypeEnums::ROTH_IRA_24.raw, & TaxAdvantageTypeEnums::ROTH_IRA_24 },
{ TaxAdvantageTypeEnums::ROTH_IRA_25.raw, & TaxAdvantageTypeEnums::ROTH_IRA_25 },
{ TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_26.raw, & TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_26 },
{ TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_27.raw, & TaxAdvantageTypeEnums::ROTH_CONVERSION_IRA_27 },
{ TaxAdvantageTypeEnums::EDUCATION_IRA_28.raw, & TaxAdvantageTypeEnums::EDUCATION_IRA_28 },
{ TaxAdvantageTypeEnums::EDUCATION_IRA_29.raw, & TaxAdvantageTypeEnums::EDUCATION_IRA_29 },
};

const FieldEnumMap FundRenewWaivEnums::itemByRaw = {
{ FundRenewWaivEnums::YES.raw, & FundRenewWaivEnums::YES },
{ FundRenewWaivEnums::NO.raw, & FundRenewWaivEnums::NO },
};

const FieldEnumMap RegistStatusEnums::itemByRaw = {
{ RegistStatusEnums::ACCEPTED.raw, & RegistStatusEnums::ACCEPTED },
{ RegistStatusEnums::REJECTED.raw, & RegistStatusEnums::REJECTED },
{ RegistStatusEnums::HELD.raw, & RegistStatusEnums::HELD },
{ RegistStatusEnums::REMINDER_IE_REGISTRATION_INSTRUCTIONS_ARE_STILL_OUTSTANDING.raw, & RegistStatusEnums::REMINDER_IE_REGISTRATION_INSTRUCTIONS_ARE_STILL_OUTSTANDING },
};

const FieldEnumMap RegistRejReasonCodeEnums::itemByRaw = {
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_ACCOUNT_TYPE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_ACCOUNT_TYPE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_TAX_EXEMPT_TYPE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_OWNERSHIP_TYPE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_OWNERSHIP_TYPE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NO_REG_DETLS.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NO_REG_DETLS },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_SEQ_NO.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_SEQ_NO },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_DTLS.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_REG_DTLS },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_DTLS.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_DTLS },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_INST.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_MAILING_INST },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_ID_SOURCE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DATE_OF_BIRTH.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DATE_OF_BIRTH },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_INVESTOR_COUNTRY_OF_RESIDENCE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NODISTRIBINSTNS.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_NODISTRIBINSTNS },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PERCENTAGE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_DISTRIB_PAYMENT_METHOD },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NAME },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_CODE },
{ RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM.raw, & RegistRejReasonCodeEnums::INVALID_UNACCEPTABLE_CASH_DISTRIB_AGENT_ACCT_NUM },
{ RegistRejReasonCodeEnums::OTHER.raw, & RegistRejReasonCodeEnums::OTHER },
};

const FieldEnumMap RegistTransTypeEnums::itemByRaw = {
{ RegistTransTypeEnums::NEW.raw, & RegistTransTypeEnums::NEW },
{ RegistTransTypeEnums::REPLACE.raw, & RegistTransTypeEnums::REPLACE },
{ RegistTransTypeEnums::CANCEL.raw, & RegistTransTypeEnums::CANCEL },
};

const FieldEnumMap OwnershipTypeEnums::itemByRaw = {
{ OwnershipTypeEnums::JOINT_INVESTORS.raw, & OwnershipTypeEnums::JOINT_INVESTORS },
{ OwnershipTypeEnums::TENANTS_IN_COMMON.raw, & OwnershipTypeEnums::TENANTS_IN_COMMON },
{ OwnershipTypeEnums::JOINT_TRUSTEES.raw, & OwnershipTypeEnums::JOINT_TRUSTEES },
};

const FieldEnumMap ContAmtTypeEnums::itemByRaw = {
{ ContAmtTypeEnums::COMMISSION_AMOUNT.raw, & ContAmtTypeEnums::COMMISSION_AMOUNT },
{ ContAmtTypeEnums::COMMISSION.raw, & ContAmtTypeEnums::COMMISSION },
{ ContAmtTypeEnums::INITIAL_CHARGE_AMOUNT.raw, & ContAmtTypeEnums::INITIAL_CHARGE_AMOUNT },
{ ContAmtTypeEnums::INITIAL_CHARGE.raw, & ContAmtTypeEnums::INITIAL_CHARGE },
{ ContAmtTypeEnums::DISCOUNT_AMOUNT.raw, & ContAmtTypeEnums::DISCOUNT_AMOUNT },
{ ContAmtTypeEnums::DISCOUNT.raw, & ContAmtTypeEnums::DISCOUNT },
{ ContAmtTypeEnums::DILUTION_LEVY_AMOUNT.raw, & ContAmtTypeEnums::DILUTION_LEVY_AMOUNT },
{ ContAmtTypeEnums::DILUTION_LEVY.raw, & ContAmtTypeEnums::DILUTION_LEVY },
{ ContAmtTypeEnums::EXIT_CHARGE_AMOUNT.raw, & ContAmtTypeEnums::EXIT_CHARGE_AMOUNT },
{ ContAmtTypeEnums::EXIT_CHARGE.raw, & ContAmtTypeEnums::EXIT_CHARGE },
{ ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION.raw, & ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION },
{ ContAmtTypeEnums::PROJECTED_FUND_VALUE.raw, & ContAmtTypeEnums::PROJECTED_FUND_VALUE },
{ ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_13.raw, & ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_13 },
{ ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_14.raw, & ContAmtTypeEnums::FUND_BASED_RENEWAL_COMMISSION_AMOUNT_14 },
{ ContAmtTypeEnums::NET_SETTLEMENT_AMOUNT.raw, & ContAmtTypeEnums::NET_SETTLEMENT_AMOUNT },
};

const FieldEnumMap OwnerTypeEnums::itemByRaw = {
{ OwnerTypeEnums::INDIVIDUAL_INVESTOR.raw, & OwnerTypeEnums::INDIVIDUAL_INVESTOR },
{ OwnerTypeEnums::PUBLIC_COMPANY.raw, & OwnerTypeEnums::PUBLIC_COMPANY },
{ OwnerTypeEnums::PRIVATE_COMPANY.raw, & OwnerTypeEnums::PRIVATE_COMPANY },
{ OwnerTypeEnums::INDIVIDUAL_TRUSTEE.raw, & OwnerTypeEnums::INDIVIDUAL_TRUSTEE },
{ OwnerTypeEnums::COMPANY_TRUSTEE.raw, & OwnerTypeEnums::COMPANY_TRUSTEE },
{ OwnerTypeEnums::PENSION_PLAN.raw, & OwnerTypeEnums::PENSION_PLAN },
{ OwnerTypeEnums::CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT.raw, & OwnerTypeEnums::CUSTODIAN_UNDER_GIFTS_TO_MINORS_ACT },
{ OwnerTypeEnums::TRUSTS.raw, & OwnerTypeEnums::TRUSTS },
{ OwnerTypeEnums::FIDUCIARIES.raw, & OwnerTypeEnums::FIDUCIARIES },
{ OwnerTypeEnums::NETWORKING_SUB_ACCOUNT.raw, & OwnerTypeEnums::NETWORKING_SUB_ACCOUNT },
{ OwnerTypeEnums::NON_PROFIT_ORGANIZATION.raw, & OwnerTypeEnums::NON_PROFIT_ORGANIZATION },
{ OwnerTypeEnums::CORPORATE_BODY.raw, & OwnerTypeEnums::CORPORATE_BODY },
{ OwnerTypeEnums::NOMINEE.raw, & OwnerTypeEnums::NOMINEE },
};

const FieldEnumMap OrderCapacityEnums::itemByRaw = {
{ OrderCapacityEnums::AGENCY.raw, & OrderCapacityEnums::AGENCY },
{ OrderCapacityEnums::PROPRIETARY.raw, & OrderCapacityEnums::PROPRIETARY },
{ OrderCapacityEnums::INDIVIDUAL.raw, & OrderCapacityEnums::INDIVIDUAL },
{ OrderCapacityEnums::PRINCIPAL.raw, & OrderCapacityEnums::PRINCIPAL },
{ OrderCapacityEnums::RISKLESS_PRINCIPAL.raw, & OrderCapacityEnums::RISKLESS_PRINCIPAL },
{ OrderCapacityEnums::AGENT_FOR_OTHER_MEMBER.raw, & OrderCapacityEnums::AGENT_FOR_OTHER_MEMBER },
};

const FieldEnumMap OrderRestrictionsEnums::itemByRaw = {
{ OrderRestrictionsEnums::PROGRAM_TRADE.raw, & OrderRestrictionsEnums::PROGRAM_TRADE },
{ OrderRestrictionsEnums::INDEX_ARBITRAGE.raw, & OrderRestrictionsEnums::INDEX_ARBITRAGE },
{ OrderRestrictionsEnums::NON_INDEX_ARBITRAGE.raw, & OrderRestrictionsEnums::NON_INDEX_ARBITRAGE },
{ OrderRestrictionsEnums::COMPETING_MARKET_MAKER.raw, & OrderRestrictionsEnums::COMPETING_MARKET_MAKER },
{ OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY.raw, & OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_SECURITY },
{ OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY.raw, & OrderRestrictionsEnums::ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_THE_UNDERLYING_SECURITY_OF_A_DERIVATIVE_SECURITY },
{ OrderRestrictionsEnums::FOREIGN_ENTITY.raw, & OrderRestrictionsEnums::FOREIGN_ENTITY },
{ OrderRestrictionsEnums::EXTERNAL_MARKET_PARTICIPANT.raw, & OrderRestrictionsEnums::EXTERNAL_MARKET_PARTICIPANT },
{ OrderRestrictionsEnums::EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE.raw, & OrderRestrictionsEnums::EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE },
{ OrderRestrictionsEnums::RISKLESS_ARBITRAGE.raw, & OrderRestrictionsEnums::RISKLESS_ARBITRAGE },
};

const FieldEnumMap MassCancelRequestTypeEnums::itemByRaw = {
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITY.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITY },
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY },
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_PRODUCT.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_PRODUCT },
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_CFICODE.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_CFICODE },
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE },
{ MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION.raw, & MassCancelRequestTypeEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION },
{ MassCancelRequestTypeEnums::CANCEL_ALL_ORDERS.raw, & MassCancelRequestTypeEnums::CANCEL_ALL_ORDERS },
};

const FieldEnumMap MassCancelResponseEnums::itemByRaw = {
{ MassCancelResponseEnums::CANCEL_REQUEST_REJECTED.raw, & MassCancelResponseEnums::CANCEL_REQUEST_REJECTED },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITY.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITY },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_AN_UNDERLYING_SECURITY },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_PRODUCT.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_PRODUCT },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_CFICODE.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_CFICODE },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_SECURITYTYPE },
{ MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION.raw, & MassCancelResponseEnums::CANCEL_ORDERS_FOR_A_TRADING_SESSION },
{ MassCancelResponseEnums::CANCEL_ALL_ORDERS.raw, & MassCancelResponseEnums::CANCEL_ALL_ORDERS },
};

const FieldEnumMap MassCancelRejectReasonEnums::itemByRaw = {
{ MassCancelRejectReasonEnums::MASS_CANCEL_NOT_SUPPORTED.raw, & MassCancelRejectReasonEnums::MASS_CANCEL_NOT_SUPPORTED },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_UNDERLYING.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_UNDERLYING },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_PRODUCT.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_PRODUCT },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_CFICODE.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_CFICODE },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY_TYPE.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_SECURITY_TYPE },
{ MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_TRADING_SESSION.raw, & MassCancelRejectReasonEnums::INVALID_OR_UNKNOWN_TRADING_SESSION },
{ MassCancelRejectReasonEnums::OTHER.raw, & MassCancelRejectReasonEnums::OTHER },
};

const FieldEnumMap QuoteTypeEnums::itemByRaw = {
{ QuoteTypeEnums::INDICATIVE.raw, & QuoteTypeEnums::INDICATIVE },
{ QuoteTypeEnums::TRADEABLE.raw, & QuoteTypeEnums::TRADEABLE },
{ QuoteTypeEnums::RESTRICTED_TRADEABLE.raw, & QuoteTypeEnums::RESTRICTED_TRADEABLE },
{ QuoteTypeEnums::COUNTER.raw, & QuoteTypeEnums::COUNTER },
};

const FieldEnumMap CashMarginEnums::itemByRaw = {
{ CashMarginEnums::CASH.raw, & CashMarginEnums::CASH },
{ CashMarginEnums::MARGIN_OPEN.raw, & CashMarginEnums::MARGIN_OPEN },
{ CashMarginEnums::MARGIN_CLOSE.raw, & CashMarginEnums::MARGIN_CLOSE },
};

const FieldEnumMap ScopeEnums::itemByRaw = {
{ ScopeEnums::LOCAL.raw, & ScopeEnums::LOCAL },
{ ScopeEnums::NATIONAL.raw, & ScopeEnums::NATIONAL },
{ ScopeEnums::GLOBAL.raw, & ScopeEnums::GLOBAL },
};

const FieldEnumMap MDImplicitDeleteEnums::itemByRaw = {
{ MDImplicitDeleteEnums::YES.raw, & MDImplicitDeleteEnums::YES },
{ MDImplicitDeleteEnums::NO.raw, & MDImplicitDeleteEnums::NO },
};

const FieldEnumMap CrossTypeEnums::itemByRaw = {
{ CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_BOTH_SIDES_ARE_TREATED_IN_THE_SAME_MANNER_THIS_IS_EQUIVALENT_TO_AN_ALL_OR_NONE.raw, & CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_COMPLETELY_OR_NOT_BOTH_SIDES_ARE_TREATED_IN_THE_SAME_MANNER_THIS_IS_EQUIVALENT_TO_AN_ALL_OR_NONE },
{ CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_ONE_SIDE_IS_FULLY_EXECUTED_THE_OTHER_SIDE_IS_PARTIALLY_EXECUTED_WITH_THE_REMAINDER_BEING_CANCELLED_THIS_IS_EQUIVALENT_TO_AN_IMMEDIATE_OR_CANCEL_ON_THE_OTHER_SIDE_NOTE_THE_CROSSPRIORITZATION.raw, & CrossTypeEnums::CROSS_TRADE_WHICH_IS_EXECUTED_PARTIALLY_AND_THE_REST_IS_CANCELLED_ONE_SIDE_IS_FULLY_EXECUTED_THE_OTHER_SIDE_IS_PARTIALLY_EXECUTED_WITH_THE_REMAINDER_BEING_CANCELLED_THIS_IS_EQUIVALENT_TO_AN_IMMEDIATE_OR_CANCEL_ON_THE_OTHER_SIDE_NOTE_THE_CROSSPRIORITZATION },
{ CrossTypeEnums::CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_ONE_SIDE_OF_THE_CROSS_IS_FULLY_EXECUTED.raw, & CrossTypeEnums::CROSS_TRADE_WHICH_IS_PARTIALLY_EXECUTED_WITH_THE_UNFILLED_PORTIONS_REMAINING_ACTIVE_ONE_SIDE_OF_THE_CROSS_IS_FULLY_EXECUTED },
{ CrossTypeEnums::CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_IN_THE_CASE_OTHER_ORDERS_EXIST_WITH_THE_SAME_PRICE_THE_QUANTITY_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_EXISTING_ORDERS_AND_QUOTES_THE_REMAINDER_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_OTHER_SIDE_OF_THE_CROSS_THE_TWO_SIDES_POTENTIALLY_HAVE_DIFFERENT_QUANTITIES.raw, & CrossTypeEnums::CROSS_TRADE_IS_EXECUTED_WITH_EXISTING_ORDERS_WITH_THE_SAME_PRICE_IN_THE_CASE_OTHER_ORDERS_EXIST_WITH_THE_SAME_PRICE_THE_QUANTITY_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_EXISTING_ORDERS_AND_QUOTES_THE_REMAINDER_OF_THE_CROSS_IS_EXECUTED_AGAINST_THE_OTHER_SIDE_OF_THE_CROSS_THE_TWO_SIDES_POTENTIALLY_HAVE_DIFFERENT_QUANTITIES },
};

const FieldEnumMap CrossPrioritizationEnums::itemByRaw = {
{ CrossPrioritizationEnums::NONE.raw, & CrossPrioritizationEnums::NONE },
{ CrossPrioritizationEnums::BUY_SIDE_IS_PRIORITIZED.raw, & CrossPrioritizationEnums::BUY_SIDE_IS_PRIORITIZED },
{ CrossPrioritizationEnums::SELL_SIDE_IS_PRIORITIZED.raw, & CrossPrioritizationEnums::SELL_SIDE_IS_PRIORITIZED },
};

const FieldEnumMap NoSidesEnums::itemByRaw = {
{ NoSidesEnums::ONE_SIDE.raw, & NoSidesEnums::ONE_SIDE },
{ NoSidesEnums::BOTH_SIDES.raw, & NoSidesEnums::BOTH_SIDES },
};

const FieldEnumMap SecurityListRequestTypeEnums::itemByRaw = {
{ SecurityListRequestTypeEnums::SYMBOL.raw, & SecurityListRequestTypeEnums::SYMBOL },
{ SecurityListRequestTypeEnums::SECURITYTYPE_AND_OR_CFICODE.raw, & SecurityListRequestTypeEnums::SECURITYTYPE_AND_OR_CFICODE },
{ SecurityListRequestTypeEnums::PRODUCT.raw, & SecurityListRequestTypeEnums::PRODUCT },
{ SecurityListRequestTypeEnums::TRADINGSESSIONID.raw, & SecurityListRequestTypeEnums::TRADINGSESSIONID },
{ SecurityListRequestTypeEnums::ALL_SECURITIES.raw, & SecurityListRequestTypeEnums::ALL_SECURITIES },
};

const FieldEnumMap SecurityRequestResultEnums::itemByRaw = {
{ SecurityRequestResultEnums::VALID_REQUEST.raw, & SecurityRequestResultEnums::VALID_REQUEST },
{ SecurityRequestResultEnums::INVALID_OR_UNSUPPORTED_REQUEST.raw, & SecurityRequestResultEnums::INVALID_OR_UNSUPPORTED_REQUEST },
{ SecurityRequestResultEnums::NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA.raw, & SecurityRequestResultEnums::NO_INSTRUMENTS_FOUND_THAT_MATCH_SELECTION_CRITERIA },
{ SecurityRequestResultEnums::NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA.raw, & SecurityRequestResultEnums::NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA },
{ SecurityRequestResultEnums::INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE.raw, & SecurityRequestResultEnums::INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE },
{ SecurityRequestResultEnums::REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED.raw, & SecurityRequestResultEnums::REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED },
};

const FieldEnumMap MultiLegRptTypeReqEnums::itemByRaw = {
{ MultiLegRptTypeReqEnums::REPORT_BY_MULITLEG_SECURITY_ONLY.raw, & MultiLegRptTypeReqEnums::REPORT_BY_MULITLEG_SECURITY_ONLY },
{ MultiLegRptTypeReqEnums::REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY.raw, & MultiLegRptTypeReqEnums::REPORT_BY_MULTILEG_SECURITY_AND_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY },
{ MultiLegRptTypeReqEnums::REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY.raw, & MultiLegRptTypeReqEnums::REPORT_BY_INSTRUMENT_LEGS_BELONGING_TO_THE_MULTILEG_SECURITY_ONLY },
};

const FieldEnumMap TradSesStatusRejReasonEnums::itemByRaw = {
{ TradSesStatusRejReasonEnums::UNKNOWN_OR_INVALID_TRADINGSESSIONID.raw, & TradSesStatusRejReasonEnums::UNKNOWN_OR_INVALID_TRADINGSESSIONID },
{ TradSesStatusRejReasonEnums::OTHER.raw, & TradSesStatusRejReasonEnums::OTHER },
};

const FieldEnumMap TradeRequestTypeEnums::itemByRaw = {
{ TradeRequestTypeEnums::ALL_TRADES.raw, & TradeRequestTypeEnums::ALL_TRADES },
{ TradeRequestTypeEnums::MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST.raw, & TradeRequestTypeEnums::MATCHED_TRADES_MATCHING_CRITERIA_PROVIDED_ON_REQUEST },
{ TradeRequestTypeEnums::UNMATCHED_TRADES_THAT_MATCH_CRITERIA.raw, & TradeRequestTypeEnums::UNMATCHED_TRADES_THAT_MATCH_CRITERIA },
{ TradeRequestTypeEnums::UNREPORTED_TRADES_THAT_MATCH_CRITERIA.raw, & TradeRequestTypeEnums::UNREPORTED_TRADES_THAT_MATCH_CRITERIA },
{ TradeRequestTypeEnums::ADVISORIES_THAT_MATCH_CRITERIA.raw, & TradeRequestTypeEnums::ADVISORIES_THAT_MATCH_CRITERIA },
};

const FieldEnumMap PreviouslyReportedEnums::itemByRaw = {
{ PreviouslyReportedEnums::YES.raw, & PreviouslyReportedEnums::YES },
{ PreviouslyReportedEnums::NO.raw, & PreviouslyReportedEnums::NO },
};

const FieldEnumMap MatchStatusEnums::itemByRaw = {
{ MatchStatusEnums::COMPARED_MATCHED_OR_AFFIRMED.raw, & MatchStatusEnums::COMPARED_MATCHED_OR_AFFIRMED },
{ MatchStatusEnums::UNCOMPARED_UNMATCHED_OR_UNAFFIRMED.raw, & MatchStatusEnums::UNCOMPARED_UNMATCHED_OR_UNAFFIRMED },
{ MatchStatusEnums::ADVISORY_OR_ALERT.raw, & MatchStatusEnums::ADVISORY_OR_ALERT },
};

const FieldEnumMap MatchTypeEnums::itemByRaw = {
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES_AND_EXECUTION_TIME.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES_AND_EXECUTION_TIME },
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_FOUR_BADGES },
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES_AND_EXECUTION_TIME.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES_AND_EXECUTION_TIME },
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_TWO_BADGES },
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_EXECUTION_TIME.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_PLUS_EXECUTION_TIME },
{ MatchTypeEnums::COMPARED_RECORDS_RESULTING_FROM_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_PAIR_OFFS.raw, & MatchTypeEnums::COMPARED_RECORDS_RESULTING_FROM_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS_PAIR_OFFS },
{ MatchTypeEnums::SUMMARIZED_MATCH_USING_A1_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED.raw, & MatchTypeEnums::SUMMARIZED_MATCH_USING_A1_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED },
{ MatchTypeEnums::SUMMARIZED_MATCH_USING_A2_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED.raw, & MatchTypeEnums::SUMMARIZED_MATCH_USING_A2_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED },
{ MatchTypeEnums::SUMMARIZED_MATCH_USING_A3_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED.raw, & MatchTypeEnums::SUMMARIZED_MATCH_USING_A3_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED },
{ MatchTypeEnums::SUMMARIZED_MATCH_USING_A4_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED.raw, & MatchTypeEnums::SUMMARIZED_MATCH_USING_A4_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED },
{ MatchTypeEnums::SUMMARIZED_MATCH_USING_A5_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED.raw, & MatchTypeEnums::SUMMARIZED_MATCH_USING_A5_EXACT_MATCH_CRITERIA_EXCEPT_QUANTITY_IS_SUMMARIZED },
{ MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_MINUS_BADGES_AND_TIMES_ACT_M1_MATCH.raw, & MatchTypeEnums::EXACT_MATCH_ON_TRADE_DATE_STOCK_SYMBOL_QUANTITY_PRICE_TRADE_TYPE_AND_SPECIAL_TRADE_INDICATOR_MINUS_BADGES_AND_TIMES_ACT_M1_MATCH },
{ MatchTypeEnums::SUMMARIZED_MATCH_MINUS_BADGES_AND_TIMES_ACT_M2_MATCH.raw, & MatchTypeEnums::SUMMARIZED_MATCH_MINUS_BADGES_AND_TIMES_ACT_M2_MATCH },
{ MatchTypeEnums::OCS_LOCKED_IN_NON_ACT.raw, & MatchTypeEnums::OCS_LOCKED_IN_NON_ACT },
{ MatchTypeEnums::ACT_ACCEPTED_TRADE.raw, & MatchTypeEnums::ACT_ACCEPTED_TRADE },
{ MatchTypeEnums::ACT_DEFAULT_TRADE.raw, & MatchTypeEnums::ACT_DEFAULT_TRADE },
{ MatchTypeEnums::ACT_DEFAULT_AFTER_M2.raw, & MatchTypeEnums::ACT_DEFAULT_AFTER_M2 },
{ MatchTypeEnums::ACT_M6_MATCH.raw, & MatchTypeEnums::ACT_M6_MATCH },
};

const FieldEnumMap OddLotEnums::itemByRaw = {
{ OddLotEnums::YES.raw, & OddLotEnums::YES },
{ OddLotEnums::NO.raw, & OddLotEnums::NO },
};

const FieldEnumMap ClearingInstructionEnums::itemByRaw = {
{ ClearingInstructionEnums::PROCESS_NORMALLY.raw, & ClearingInstructionEnums::PROCESS_NORMALLY },
{ ClearingInstructionEnums::EXCLUDE_FROM_ALL_NETTING.raw, & ClearingInstructionEnums::EXCLUDE_FROM_ALL_NETTING },
{ ClearingInstructionEnums::BILATERAL_NETTING_ONLY.raw, & ClearingInstructionEnums::BILATERAL_NETTING_ONLY },
{ ClearingInstructionEnums::EX_CLEARING.raw, & ClearingInstructionEnums::EX_CLEARING },
{ ClearingInstructionEnums::SPECIAL_TRADE.raw, & ClearingInstructionEnums::SPECIAL_TRADE },
{ ClearingInstructionEnums::MULTILATERAL_NETTING.raw, & ClearingInstructionEnums::MULTILATERAL_NETTING },
{ ClearingInstructionEnums::CLEAR_AGAINST_CENTRAL_COUNTERPARTY.raw, & ClearingInstructionEnums::CLEAR_AGAINST_CENTRAL_COUNTERPARTY },
{ ClearingInstructionEnums::EXCLUDE_FROM_CENTRAL_COUNTERPARTY.raw, & ClearingInstructionEnums::EXCLUDE_FROM_CENTRAL_COUNTERPARTY },
{ ClearingInstructionEnums::MANUAL_MODE.raw, & ClearingInstructionEnums::MANUAL_MODE },
{ ClearingInstructionEnums::AUTOMATIC_POSTING_MODE.raw, & ClearingInstructionEnums::AUTOMATIC_POSTING_MODE },
{ ClearingInstructionEnums::AUTOMATIC_GIVE_UP_MODE.raw, & ClearingInstructionEnums::AUTOMATIC_GIVE_UP_MODE },
{ ClearingInstructionEnums::QUALIFIED_SERVICE_REPRESENTATIVE.raw, & ClearingInstructionEnums::QUALIFIED_SERVICE_REPRESENTATIVE },
{ ClearingInstructionEnums::CUSTOMER_TRADE.raw, & ClearingInstructionEnums::CUSTOMER_TRADE },
{ ClearingInstructionEnums::SELF_CLEARING.raw, & ClearingInstructionEnums::SELF_CLEARING },
};

const FieldEnumMap AccountTypeEnums::itemByRaw = {
{ AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS.raw, & AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS },
{ AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS.raw, & AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS },
{ AccountTypeEnums::HOUSE_TRADER.raw, & AccountTypeEnums::HOUSE_TRADER },
{ AccountTypeEnums::FLOOR_TRADER.raw, & AccountTypeEnums::FLOOR_TRADER },
{ AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED.raw, & AccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED },
{ AccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED.raw, & AccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED },
{ AccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT.raw, & AccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT },
};

const FieldEnumMap CustOrderCapacityEnums::itemByRaw = {
{ CustOrderCapacityEnums::MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT.raw, & CustOrderCapacityEnums::MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT },
{ CustOrderCapacityEnums::CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT.raw, & CustOrderCapacityEnums::CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT },
{ CustOrderCapacityEnums::MEMBER_TRADING_FOR_ANOTHER_MEMBER.raw, & CustOrderCapacityEnums::MEMBER_TRADING_FOR_ANOTHER_MEMBER },
{ CustOrderCapacityEnums::ALL_OTHER.raw, & CustOrderCapacityEnums::ALL_OTHER },
};

const FieldEnumMap MassStatusReqTypeEnums::itemByRaw = {
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITY.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITY },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_AN_UNDERLYING_SECURITY },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PRODUCT.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PRODUCT },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_CFICODE.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_CFICODE },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_SECURITYTYPE },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_TRADING_SESSION },
{ MassStatusReqTypeEnums::STATUS_FOR_ALL_ORDERS.raw, & MassStatusReqTypeEnums::STATUS_FOR_ALL_ORDERS },
{ MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PARTYID.raw, & MassStatusReqTypeEnums::STATUS_FOR_ORDERS_FOR_A_PARTYID },
};

const FieldEnumMap DayBookingInstEnums::itemByRaw = {
{ DayBookingInstEnums::CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR.raw, & DayBookingInstEnums::CAN_TRIGGER_BOOKING_WITHOUT_REFERENCE_TO_THE_ORDER_INITIATOR },
{ DayBookingInstEnums::SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING.raw, & DayBookingInstEnums::SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING },
{ DayBookingInstEnums::ACCUMULATE.raw, & DayBookingInstEnums::ACCUMULATE },
};

const FieldEnumMap BookingUnitEnums::itemByRaw = {
{ BookingUnitEnums::EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT.raw, & BookingUnitEnums::EACH_PARTIAL_EXECUTION_IS_A_BOOKABLE_UNIT },
{ BookingUnitEnums::AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER.raw, & BookingUnitEnums::AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER_AND_BOOK_ONE_TRADE_PER_ORDER },
{ BookingUnitEnums::AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE.raw, & BookingUnitEnums::AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL_SIDE_AND_SETTLEMENT_DATE },
};

const FieldEnumMap PreallocMethodEnums::itemByRaw = {
{ PreallocMethodEnums::PRO_RATA.raw, & PreallocMethodEnums::PRO_RATA },
{ PreallocMethodEnums::DO_NOT_PRO_RATA_DISCUSS_FIRST.raw, & PreallocMethodEnums::DO_NOT_PRO_RATA_DISCUSS_FIRST },
};

const FieldEnumMap AllocTypeEnums::itemByRaw = {
{ AllocTypeEnums::CALCULATED.raw, & AllocTypeEnums::CALCULATED },
{ AllocTypeEnums::PRELIMINARY.raw, & AllocTypeEnums::PRELIMINARY },
{ AllocTypeEnums::READY_TO_BOOK.raw, & AllocTypeEnums::READY_TO_BOOK },
{ AllocTypeEnums::WAREHOUSE_INSTRUCTION.raw, & AllocTypeEnums::WAREHOUSE_INSTRUCTION },
{ AllocTypeEnums::REQUEST_TO_INTERMEDIARY.raw, & AllocTypeEnums::REQUEST_TO_INTERMEDIARY },
};

const FieldEnumMap ClearingFeeIndicatorEnums::itemByRaw = {
{ ClearingFeeIndicatorEnums::CBOE_MEMBER.raw, & ClearingFeeIndicatorEnums::CBOE_MEMBER },
{ ClearingFeeIndicatorEnums::NON_MEMBER_AND_CUSTOMER.raw, & ClearingFeeIndicatorEnums::NON_MEMBER_AND_CUSTOMER },
{ ClearingFeeIndicatorEnums::EQUITY_MEMBER_AND_CLEARING_MEMBER.raw, & ClearingFeeIndicatorEnums::EQUITY_MEMBER_AND_CLEARING_MEMBER },
{ ClearingFeeIndicatorEnums::FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS.raw, & ClearingFeeIndicatorEnums::FULL_AND_ASSOCIATE_MEMBER_TRADING_FOR_OWN_ACCOUNT_AND_AS_FLOOR_BROKERS },
{ ClearingFeeIndicatorEnums::_106H_AND_106J_FIRMS.raw, & ClearingFeeIndicatorEnums::_106H_AND_106J_FIRMS },
{ ClearingFeeIndicatorEnums::GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS.raw, & ClearingFeeIndicatorEnums::GIM_IDEM_AND_COM_MEMBERSHIP_INTEREST_HOLDERS },
{ ClearingFeeIndicatorEnums::LESSEE_AND_106F_EMPLOYEES.raw, & ClearingFeeIndicatorEnums::LESSEE_AND_106F_EMPLOYEES },
{ ClearingFeeIndicatorEnums::ALL_OTHER_OWNERSHIP_TYPES.raw, & ClearingFeeIndicatorEnums::ALL_OTHER_OWNERSHIP_TYPES },
{ ClearingFeeIndicatorEnums::_1ST_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_1ST_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
{ ClearingFeeIndicatorEnums::_2ND_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_2ND_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
{ ClearingFeeIndicatorEnums::_3RD_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_3RD_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
{ ClearingFeeIndicatorEnums::_4TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_4TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
{ ClearingFeeIndicatorEnums::_5TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_5TH_YEAR_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
{ ClearingFeeIndicatorEnums::_6TH_YEAR_AND_BEYOND_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT.raw, & ClearingFeeIndicatorEnums::_6TH_YEAR_AND_BEYOND_DELEGATE_TRADING_FOR_HIS_OWN_ACCOUNT },
};

const FieldEnumMap WorkingIndicatorEnums::itemByRaw = {
{ WorkingIndicatorEnums::YES.raw, & WorkingIndicatorEnums::YES },
{ WorkingIndicatorEnums::NO.raw, & WorkingIndicatorEnums::NO },
};

const FieldEnumMap PriorityIndicatorEnums::itemByRaw = {
{ PriorityIndicatorEnums::PRIORITY_UNCHANGED.raw, & PriorityIndicatorEnums::PRIORITY_UNCHANGED },
{ PriorityIndicatorEnums::LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE.raw, & PriorityIndicatorEnums::LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE },
};

const FieldEnumMap LegalConfirmEnums::itemByRaw = {
{ LegalConfirmEnums::YES.raw, & LegalConfirmEnums::YES },
{ LegalConfirmEnums::NO.raw, & LegalConfirmEnums::NO },
};

const FieldEnumMap QuoteRequestRejectReasonEnums::itemByRaw = {
{ QuoteRequestRejectReasonEnums::UNKNOWN_SYMBOL.raw, & QuoteRequestRejectReasonEnums::UNKNOWN_SYMBOL },
{ QuoteRequestRejectReasonEnums::EXCHANGE.raw, & QuoteRequestRejectReasonEnums::EXCHANGE },
{ QuoteRequestRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT.raw, & QuoteRequestRejectReasonEnums::QUOTE_REQUEST_EXCEEDS_LIMIT },
{ QuoteRequestRejectReasonEnums::TOO_LATE_TO_ENTER.raw, & QuoteRequestRejectReasonEnums::TOO_LATE_TO_ENTER },
{ QuoteRequestRejectReasonEnums::INVALID_PRICE.raw, & QuoteRequestRejectReasonEnums::INVALID_PRICE },
{ QuoteRequestRejectReasonEnums::NOT_AUTHORIZED_TO_REQUEST_QUOTE.raw, & QuoteRequestRejectReasonEnums::NOT_AUTHORIZED_TO_REQUEST_QUOTE },
{ QuoteRequestRejectReasonEnums::NO_MATCH_FOR_INQUIRY.raw, & QuoteRequestRejectReasonEnums::NO_MATCH_FOR_INQUIRY },
{ QuoteRequestRejectReasonEnums::NO_MARKET_FOR_INSTRUMENT.raw, & QuoteRequestRejectReasonEnums::NO_MARKET_FOR_INSTRUMENT },
{ QuoteRequestRejectReasonEnums::NO_INVENTORY.raw, & QuoteRequestRejectReasonEnums::NO_INVENTORY },
{ QuoteRequestRejectReasonEnums::PASS.raw, & QuoteRequestRejectReasonEnums::PASS },
{ QuoteRequestRejectReasonEnums::OTHER.raw, & QuoteRequestRejectReasonEnums::OTHER },
};

const FieldEnumMap AcctIDSourceEnums::itemByRaw = {
{ AcctIDSourceEnums::BIC.raw, & AcctIDSourceEnums::BIC },
{ AcctIDSourceEnums::SID_CODE.raw, & AcctIDSourceEnums::SID_CODE },
{ AcctIDSourceEnums::TFM.raw, & AcctIDSourceEnums::TFM },
{ AcctIDSourceEnums::OMGEO.raw, & AcctIDSourceEnums::OMGEO },
{ AcctIDSourceEnums::DTCC_CODE.raw, & AcctIDSourceEnums::DTCC_CODE },
{ AcctIDSourceEnums::OTHER.raw, & AcctIDSourceEnums::OTHER },
};

const FieldEnumMap ConfirmStatusEnums::itemByRaw = {
{ ConfirmStatusEnums::RECEIVED.raw, & ConfirmStatusEnums::RECEIVED },
{ ConfirmStatusEnums::MISMATCHED_ACCOUNT.raw, & ConfirmStatusEnums::MISMATCHED_ACCOUNT },
{ ConfirmStatusEnums::MISSING_SETTLEMENT_INSTRUCTIONS.raw, & ConfirmStatusEnums::MISSING_SETTLEMENT_INSTRUCTIONS },
{ ConfirmStatusEnums::CONFIRMED.raw, & ConfirmStatusEnums::CONFIRMED },
{ ConfirmStatusEnums::REQUEST_REJECTED.raw, & ConfirmStatusEnums::REQUEST_REJECTED },
};

const FieldEnumMap ConfirmTransTypeEnums::itemByRaw = {
{ ConfirmTransTypeEnums::NEW.raw, & ConfirmTransTypeEnums::NEW },
{ ConfirmTransTypeEnums::REPLACE.raw, & ConfirmTransTypeEnums::REPLACE },
{ ConfirmTransTypeEnums::CANCEL.raw, & ConfirmTransTypeEnums::CANCEL },
};

const FieldEnumMap DeliveryFormEnums::itemByRaw = {
{ DeliveryFormEnums::BOOKENTRY.raw, & DeliveryFormEnums::BOOKENTRY },
{ DeliveryFormEnums::BEARER.raw, & DeliveryFormEnums::BEARER },
};

const FieldEnumMap LegSwapTypeEnums::itemByRaw = {
{ LegSwapTypeEnums::PAR_FOR_PAR.raw, & LegSwapTypeEnums::PAR_FOR_PAR },
{ LegSwapTypeEnums::MODIFIED_DURATION.raw, & LegSwapTypeEnums::MODIFIED_DURATION },
{ LegSwapTypeEnums::RISK.raw, & LegSwapTypeEnums::RISK },
{ LegSwapTypeEnums::PROCEEDS.raw, & LegSwapTypeEnums::PROCEEDS },
};

const FieldEnumMap QuotePriceTypeEnums::itemByRaw = {
{ QuotePriceTypeEnums::PERCENT.raw, & QuotePriceTypeEnums::PERCENT },
{ QuotePriceTypeEnums::PER_SHARE.raw, & QuotePriceTypeEnums::PER_SHARE },
{ QuotePriceTypeEnums::FIXED_AMOUNT.raw, & QuotePriceTypeEnums::FIXED_AMOUNT },
{ QuotePriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR.raw, & QuotePriceTypeEnums::DISCOUNT_PERCENTAGE_POINTS_BELOW_PAR },
{ QuotePriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR.raw, & QuotePriceTypeEnums::PREMIUM_PERCENTAGE_POINTS_OVER_PAR },
{ QuotePriceTypeEnums::BASIS_POINTS_RELATIVE_TO_BENCHMARK.raw, & QuotePriceTypeEnums::BASIS_POINTS_RELATIVE_TO_BENCHMARK },
{ QuotePriceTypeEnums::TED_PRICE.raw, & QuotePriceTypeEnums::TED_PRICE },
{ QuotePriceTypeEnums::TED_YIELD.raw, & QuotePriceTypeEnums::TED_YIELD },
{ QuotePriceTypeEnums::YIELD_SPREAD.raw, & QuotePriceTypeEnums::YIELD_SPREAD },
{ QuotePriceTypeEnums::YIELD.raw, & QuotePriceTypeEnums::YIELD },
};

const FieldEnumMap QuoteRespTypeEnums::itemByRaw = {
{ QuoteRespTypeEnums::HIT_LIFT.raw, & QuoteRespTypeEnums::HIT_LIFT },
{ QuoteRespTypeEnums::COUNTER.raw, & QuoteRespTypeEnums::COUNTER },
{ QuoteRespTypeEnums::EXPIRED.raw, & QuoteRespTypeEnums::EXPIRED },
{ QuoteRespTypeEnums::COVER.raw, & QuoteRespTypeEnums::COVER },
{ QuoteRespTypeEnums::DONE_AWAY.raw, & QuoteRespTypeEnums::DONE_AWAY },
{ QuoteRespTypeEnums::PASS.raw, & QuoteRespTypeEnums::PASS },
};

const FieldEnumMap PosTypeEnums::itemByRaw = {
{ PosTypeEnums::TRANSACTION_QUANTITY.raw, & PosTypeEnums::TRANSACTION_QUANTITY },
{ PosTypeEnums::INTRA_SPREAD_QTY.raw, & PosTypeEnums::INTRA_SPREAD_QTY },
{ PosTypeEnums::INTER_SPREAD_QTY.raw, & PosTypeEnums::INTER_SPREAD_QTY },
{ PosTypeEnums::END_OF_DAY_QTY.raw, & PosTypeEnums::END_OF_DAY_QTY },
{ PosTypeEnums::START_OF_DAY_QTY.raw, & PosTypeEnums::START_OF_DAY_QTY },
{ PosTypeEnums::OPTION_EXERCISE_QTY.raw, & PosTypeEnums::OPTION_EXERCISE_QTY },
{ PosTypeEnums::OPTION_ASSIGNMENT.raw, & PosTypeEnums::OPTION_ASSIGNMENT },
{ PosTypeEnums::TRANSACTION_FROM_EXERCISE.raw, & PosTypeEnums::TRANSACTION_FROM_EXERCISE },
{ PosTypeEnums::TRANSACTION_FROM_ASSIGNMENT.raw, & PosTypeEnums::TRANSACTION_FROM_ASSIGNMENT },
{ PosTypeEnums::PIT_TRADE_QTY.raw, & PosTypeEnums::PIT_TRADE_QTY },
{ PosTypeEnums::TRANSFER_TRADE_QTY.raw, & PosTypeEnums::TRANSFER_TRADE_QTY },
{ PosTypeEnums::ELECTRONIC_TRADE_QTY.raw, & PosTypeEnums::ELECTRONIC_TRADE_QTY },
{ PosTypeEnums::ALLOCATION_TRADE_QTY.raw, & PosTypeEnums::ALLOCATION_TRADE_QTY },
{ PosTypeEnums::ADJUSTMENT_QTY.raw, & PosTypeEnums::ADJUSTMENT_QTY },
{ PosTypeEnums::AS_OF_TRADE_QTY.raw, & PosTypeEnums::AS_OF_TRADE_QTY },
{ PosTypeEnums::DELIVERY_QTY.raw, & PosTypeEnums::DELIVERY_QTY },
{ PosTypeEnums::TOTAL_TRANSACTION_QTY.raw, & PosTypeEnums::TOTAL_TRANSACTION_QTY },
{ PosTypeEnums::CROSS_MARGIN_QTY.raw, & PosTypeEnums::CROSS_MARGIN_QTY },
{ PosTypeEnums::INTEGRAL_SPLIT.raw, & PosTypeEnums::INTEGRAL_SPLIT },
};

const FieldEnumMap PosQtyStatusEnums::itemByRaw = {
{ PosQtyStatusEnums::SUBMITTED.raw, & PosQtyStatusEnums::SUBMITTED },
{ PosQtyStatusEnums::ACCEPTED.raw, & PosQtyStatusEnums::ACCEPTED },
{ PosQtyStatusEnums::REJECTED.raw, & PosQtyStatusEnums::REJECTED },
};

const FieldEnumMap PosAmtTypeEnums::itemByRaw = {
{ PosAmtTypeEnums::FINAL_MARK_TO_MARKET_AMOUNT.raw, & PosAmtTypeEnums::FINAL_MARK_TO_MARKET_AMOUNT },
{ PosAmtTypeEnums::INCREMENTAL_MARK_TO_MARKET_AMOUNT.raw, & PosAmtTypeEnums::INCREMENTAL_MARK_TO_MARKET_AMOUNT },
{ PosAmtTypeEnums::TRADE_VARIATION_AMOUNT.raw, & PosAmtTypeEnums::TRADE_VARIATION_AMOUNT },
{ PosAmtTypeEnums::START_OF_DAY_MARK_TO_MARKET_AMOUNT.raw, & PosAmtTypeEnums::START_OF_DAY_MARK_TO_MARKET_AMOUNT },
{ PosAmtTypeEnums::PREMIUM_AMOUNT.raw, & PosAmtTypeEnums::PREMIUM_AMOUNT },
{ PosAmtTypeEnums::CASH_RESIDUAL_AMOUNT.raw, & PosAmtTypeEnums::CASH_RESIDUAL_AMOUNT },
{ PosAmtTypeEnums::CASH_AMOUNT.raw, & PosAmtTypeEnums::CASH_AMOUNT },
{ PosAmtTypeEnums::VALUE_ADJUSTED_AMOUNT.raw, & PosAmtTypeEnums::VALUE_ADJUSTED_AMOUNT },
};

const FieldEnumMap PosTransTypeEnums::itemByRaw = {
{ PosTransTypeEnums::EXERCISE.raw, & PosTransTypeEnums::EXERCISE },
{ PosTransTypeEnums::DO_NOT_EXERCISE.raw, & PosTransTypeEnums::DO_NOT_EXERCISE },
{ PosTransTypeEnums::POSITION_ADJUSTMENT.raw, & PosTransTypeEnums::POSITION_ADJUSTMENT },
{ PosTransTypeEnums::POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION.raw, & PosTransTypeEnums::POSITION_CHANGE_SUBMISSION_MARGIN_DISPOSITION },
{ PosTransTypeEnums::PLEDGE.raw, & PosTransTypeEnums::PLEDGE },
};

const FieldEnumMap PosMaintActionEnums::itemByRaw = {
{ PosMaintActionEnums::NEW_USED_TO_INCREMENT_THE_OVERALL_TRANSACTION_QUANTITY.raw, & PosMaintActionEnums::NEW_USED_TO_INCREMENT_THE_OVERALL_TRANSACTION_QUANTITY },
{ PosMaintActionEnums::REPLACE_USED_TO_OVERRIDE_THE_OVERALL_TRANSACTION_QUANTITY_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_THE_REFERENCE_ID.raw, & PosMaintActionEnums::REPLACE_USED_TO_OVERRIDE_THE_OVERALL_TRANSACTION_QUANTITY_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_THE_REFERENCE_ID },
{ PosMaintActionEnums::CANCEL_USED_TO_REMOVE_THE_OVERALL_TRANSACTION_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_REFERENCE_ID.raw, & PosMaintActionEnums::CANCEL_USED_TO_REMOVE_THE_OVERALL_TRANSACTION_OR_SPECIFIC_ADD_MESSAGES_BASED_ON_REFERENCE_ID },
};

const FieldEnumMap SettlSessIDEnums::itemByRaw = {
{ SettlSessIDEnums::INTRADAY.raw, & SettlSessIDEnums::INTRADAY },
{ SettlSessIDEnums::REGULAR_TRADING_HOURS.raw, & SettlSessIDEnums::REGULAR_TRADING_HOURS },
{ SettlSessIDEnums::ELECTRONIC_TRADING_HOURS.raw, & SettlSessIDEnums::ELECTRONIC_TRADING_HOURS },
};

const FieldEnumMap AdjustmentTypeEnums::itemByRaw = {
{ AdjustmentTypeEnums::PROCESS_REQUEST_AS_MARGIN_DISPOSITION.raw, & AdjustmentTypeEnums::PROCESS_REQUEST_AS_MARGIN_DISPOSITION },
{ AdjustmentTypeEnums::DELTA_PLUS.raw, & AdjustmentTypeEnums::DELTA_PLUS },
{ AdjustmentTypeEnums::DELTA_MINUS.raw, & AdjustmentTypeEnums::DELTA_MINUS },
{ AdjustmentTypeEnums::FINAL.raw, & AdjustmentTypeEnums::FINAL },
};

const FieldEnumMap PosMaintStatusEnums::itemByRaw = {
{ PosMaintStatusEnums::ACCEPTED.raw, & PosMaintStatusEnums::ACCEPTED },
{ PosMaintStatusEnums::ACCEPTED_WITH_WARNINGS.raw, & PosMaintStatusEnums::ACCEPTED_WITH_WARNINGS },
{ PosMaintStatusEnums::REJECTED.raw, & PosMaintStatusEnums::REJECTED },
{ PosMaintStatusEnums::COMPLETED.raw, & PosMaintStatusEnums::COMPLETED },
{ PosMaintStatusEnums::COMPLETED_WITH_WARNINGS.raw, & PosMaintStatusEnums::COMPLETED_WITH_WARNINGS },
};

const FieldEnumMap PosMaintResultEnums::itemByRaw = {
{ PosMaintResultEnums::SUCCESSFUL_COMPLETION.raw, & PosMaintResultEnums::SUCCESSFUL_COMPLETION },
{ PosMaintResultEnums::REJECTED.raw, & PosMaintResultEnums::REJECTED },
{ PosMaintResultEnums::OTHER.raw, & PosMaintResultEnums::OTHER },
};

const FieldEnumMap PosReqTypeEnums::itemByRaw = {
{ PosReqTypeEnums::POSITIONS.raw, & PosReqTypeEnums::POSITIONS },
{ PosReqTypeEnums::TRADES.raw, & PosReqTypeEnums::TRADES },
{ PosReqTypeEnums::EXERCISES.raw, & PosReqTypeEnums::EXERCISES },
{ PosReqTypeEnums::ASSIGNMENTS.raw, & PosReqTypeEnums::ASSIGNMENTS },
};

const FieldEnumMap ResponseTransportTypeEnums::itemByRaw = {
{ ResponseTransportTypeEnums::INBAND_TRANSPORT_THE_REQUEST_WAS_SENT_OVER.raw, & ResponseTransportTypeEnums::INBAND_TRANSPORT_THE_REQUEST_WAS_SENT_OVER },
{ ResponseTransportTypeEnums::OUT_OF_BAND_PRE_ARRANGED_OUT_OF_BAND_DELIVERY_MECHANISM.raw, & ResponseTransportTypeEnums::OUT_OF_BAND_PRE_ARRANGED_OUT_OF_BAND_DELIVERY_MECHANISM },
};

const FieldEnumMap PosReqResultEnums::itemByRaw = {
{ PosReqResultEnums::VALID_REQUEST.raw, & PosReqResultEnums::VALID_REQUEST },
{ PosReqResultEnums::INVALID_OR_UNSUPPORTED_REQUEST.raw, & PosReqResultEnums::INVALID_OR_UNSUPPORTED_REQUEST },
{ PosReqResultEnums::NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA.raw, & PosReqResultEnums::NO_POSITIONS_FOUND_THAT_MATCH_CRITERIA },
{ PosReqResultEnums::NOT_AUTHORIZED_TO_REQUEST_POSITIONS.raw, & PosReqResultEnums::NOT_AUTHORIZED_TO_REQUEST_POSITIONS },
{ PosReqResultEnums::REQUEST_FOR_POSITION_NOT_SUPPORTED.raw, & PosReqResultEnums::REQUEST_FOR_POSITION_NOT_SUPPORTED },
{ PosReqResultEnums::OTHER.raw, & PosReqResultEnums::OTHER },
};

const FieldEnumMap PosReqStatusEnums::itemByRaw = {
{ PosReqStatusEnums::COMPLETED.raw, & PosReqStatusEnums::COMPLETED },
{ PosReqStatusEnums::COMPLETED_WITH_WARNINGS.raw, & PosReqStatusEnums::COMPLETED_WITH_WARNINGS },
{ PosReqStatusEnums::REJECTED.raw, & PosReqStatusEnums::REJECTED },
};

const FieldEnumMap SettlPriceTypeEnums::itemByRaw = {
{ SettlPriceTypeEnums::FINAL.raw, & SettlPriceTypeEnums::FINAL },
{ SettlPriceTypeEnums::THEORETICAL.raw, & SettlPriceTypeEnums::THEORETICAL },
};

const FieldEnumMap AssignmentMethodEnums::itemByRaw = {
{ AssignmentMethodEnums::RANDOM.raw, & AssignmentMethodEnums::RANDOM },
{ AssignmentMethodEnums::PRORATA.raw, & AssignmentMethodEnums::PRORATA },
};

const FieldEnumMap ExerciseMethodEnums::itemByRaw = {
{ ExerciseMethodEnums::AUTOMATIC.raw, & ExerciseMethodEnums::AUTOMATIC },
{ ExerciseMethodEnums::MANUAL.raw, & ExerciseMethodEnums::MANUAL },
};

const FieldEnumMap TradeRequestResultEnums::itemByRaw = {
{ TradeRequestResultEnums::SUCCESSFUL.raw, & TradeRequestResultEnums::SUCCESSFUL },
{ TradeRequestResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT.raw, & TradeRequestResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT },
{ TradeRequestResultEnums::INVALID_TYPE_OF_TRADE_REQUESTED.raw, & TradeRequestResultEnums::INVALID_TYPE_OF_TRADE_REQUESTED },
{ TradeRequestResultEnums::INVALID_PARTIES.raw, & TradeRequestResultEnums::INVALID_PARTIES },
{ TradeRequestResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED.raw, & TradeRequestResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED },
{ TradeRequestResultEnums::INVALID_DESTINATION_REQUESTED.raw, & TradeRequestResultEnums::INVALID_DESTINATION_REQUESTED },
{ TradeRequestResultEnums::TRADEREQUESTTYPE_NOT_SUPPORTED.raw, & TradeRequestResultEnums::TRADEREQUESTTYPE_NOT_SUPPORTED },
{ TradeRequestResultEnums::UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST.raw, & TradeRequestResultEnums::UNAUTHORIZED_FOR_TRADE_CAPTURE_REPORT_REQUEST },
{ TradeRequestResultEnums::OTHER.raw, & TradeRequestResultEnums::OTHER },
};

const FieldEnumMap TradeRequestStatusEnums::itemByRaw = {
{ TradeRequestStatusEnums::ACCEPTED.raw, & TradeRequestStatusEnums::ACCEPTED },
{ TradeRequestStatusEnums::COMPLETED.raw, & TradeRequestStatusEnums::COMPLETED },
{ TradeRequestStatusEnums::REJECTED.raw, & TradeRequestStatusEnums::REJECTED },
};

const FieldEnumMap TradeReportRejectReasonEnums::itemByRaw = {
{ TradeReportRejectReasonEnums::SUCCESSFUL.raw, & TradeReportRejectReasonEnums::SUCCESSFUL },
{ TradeReportRejectReasonEnums::INVALID_PARTY_INFORMATION.raw, & TradeReportRejectReasonEnums::INVALID_PARTY_INFORMATION },
{ TradeReportRejectReasonEnums::UNKNOWN_INSTRUMENT.raw, & TradeReportRejectReasonEnums::UNKNOWN_INSTRUMENT },
{ TradeReportRejectReasonEnums::UNAUTHORIZED_TO_REPORT_TRADES.raw, & TradeReportRejectReasonEnums::UNAUTHORIZED_TO_REPORT_TRADES },
{ TradeReportRejectReasonEnums::INVALID_TRADE_TYPE.raw, & TradeReportRejectReasonEnums::INVALID_TRADE_TYPE },
{ TradeReportRejectReasonEnums::OTHER.raw, & TradeReportRejectReasonEnums::OTHER },
};

const FieldEnumMap SideMultiLegReportingTypeEnums::itemByRaw = {
{ SideMultiLegReportingTypeEnums::SINGLE_SECURITY.raw, & SideMultiLegReportingTypeEnums::SINGLE_SECURITY },
{ SideMultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY.raw, & SideMultiLegReportingTypeEnums::INDIVIDUAL_LEG_OF_A_MULTI_LEG_SECURITY },
{ SideMultiLegReportingTypeEnums::MULTI_LEG_SECURITY.raw, & SideMultiLegReportingTypeEnums::MULTI_LEG_SECURITY },
};

const FieldEnumMap TrdRegTimestampTypeEnums::itemByRaw = {
{ TrdRegTimestampTypeEnums::EXECUTION_TIME.raw, & TrdRegTimestampTypeEnums::EXECUTION_TIME },
{ TrdRegTimestampTypeEnums::TIME_IN.raw, & TrdRegTimestampTypeEnums::TIME_IN },
{ TrdRegTimestampTypeEnums::TIME_OUT.raw, & TrdRegTimestampTypeEnums::TIME_OUT },
{ TrdRegTimestampTypeEnums::BROKER_RECEIPT.raw, & TrdRegTimestampTypeEnums::BROKER_RECEIPT },
{ TrdRegTimestampTypeEnums::BROKER_EXECUTION.raw, & TrdRegTimestampTypeEnums::BROKER_EXECUTION },
};

const FieldEnumMap ConfirmTypeEnums::itemByRaw = {
{ ConfirmTypeEnums::STATUS.raw, & ConfirmTypeEnums::STATUS },
{ ConfirmTypeEnums::CONFIRMATION.raw, & ConfirmTypeEnums::CONFIRMATION },
{ ConfirmTypeEnums::CONFIRMATION_REQUEST_REJECTED.raw, & ConfirmTypeEnums::CONFIRMATION_REQUEST_REJECTED },
};

const FieldEnumMap ConfirmRejReasonEnums::itemByRaw = {
{ ConfirmRejReasonEnums::MISMATCHED_ACCOUNT.raw, & ConfirmRejReasonEnums::MISMATCHED_ACCOUNT },
{ ConfirmRejReasonEnums::MISSING_SETTLEMENT_INSTRUCTIONS.raw, & ConfirmRejReasonEnums::MISSING_SETTLEMENT_INSTRUCTIONS },
{ ConfirmRejReasonEnums::OTHER.raw, & ConfirmRejReasonEnums::OTHER },
};

const FieldEnumMap BookingTypeEnums::itemByRaw = {
{ BookingTypeEnums::REGULAR_BOOKING.raw, & BookingTypeEnums::REGULAR_BOOKING },
{ BookingTypeEnums::CFD.raw, & BookingTypeEnums::CFD },
{ BookingTypeEnums::TOTAL_RETURN_SWAP.raw, & BookingTypeEnums::TOTAL_RETURN_SWAP },
};

const FieldEnumMap AllocSettlInstTypeEnums::itemByRaw = {
{ AllocSettlInstTypeEnums::USE_DEFAULT_INSTRUCTIONS.raw, & AllocSettlInstTypeEnums::USE_DEFAULT_INSTRUCTIONS },
{ AllocSettlInstTypeEnums::DERIVE_FROM_PARAMETERS_PROVIDED.raw, & AllocSettlInstTypeEnums::DERIVE_FROM_PARAMETERS_PROVIDED },
{ AllocSettlInstTypeEnums::FULL_DETAILS_PROVIDED.raw, & AllocSettlInstTypeEnums::FULL_DETAILS_PROVIDED },
{ AllocSettlInstTypeEnums::SSI_DB_IDS_PROVIDED.raw, & AllocSettlInstTypeEnums::SSI_DB_IDS_PROVIDED },
{ AllocSettlInstTypeEnums::PHONE_FOR_INSTRUCTIONS.raw, & AllocSettlInstTypeEnums::PHONE_FOR_INSTRUCTIONS },
};

const FieldEnumMap DlvyInstTypeEnums::itemByRaw = {
{ DlvyInstTypeEnums::SECURITIES.raw, & DlvyInstTypeEnums::SECURITIES },
{ DlvyInstTypeEnums::CASH.raw, & DlvyInstTypeEnums::CASH },
};

const FieldEnumMap TerminationTypeEnums::itemByRaw = {
{ TerminationTypeEnums::OVERNIGHT.raw, & TerminationTypeEnums::OVERNIGHT },
{ TerminationTypeEnums::TERM.raw, & TerminationTypeEnums::TERM },
{ TerminationTypeEnums::FLEXIBLE.raw, & TerminationTypeEnums::FLEXIBLE },
{ TerminationTypeEnums::OPEN.raw, & TerminationTypeEnums::OPEN },
};

const FieldEnumMap SettlInstReqRejCodeEnums::itemByRaw = {
{ SettlInstReqRejCodeEnums::UNABLE_TO_PROCESS_REQUEST.raw, & SettlInstReqRejCodeEnums::UNABLE_TO_PROCESS_REQUEST },
{ SettlInstReqRejCodeEnums::UNKNOWN_ACCOUNT.raw, & SettlInstReqRejCodeEnums::UNKNOWN_ACCOUNT },
{ SettlInstReqRejCodeEnums::NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND.raw, & SettlInstReqRejCodeEnums::NO_MATCHING_SETTLEMENT_INSTRUCTIONS_FOUND },
{ SettlInstReqRejCodeEnums::OTHER.raw, & SettlInstReqRejCodeEnums::OTHER },
};

const FieldEnumMap AllocReportTypeEnums::itemByRaw = {
{ AllocReportTypeEnums::SELLSIDE_CALCULATED_USING_PRELIMINARY.raw, & AllocReportTypeEnums::SELLSIDE_CALCULATED_USING_PRELIMINARY },
{ AllocReportTypeEnums::SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY.raw, & AllocReportTypeEnums::SELLSIDE_CALCULATED_WITHOUT_PRELIMINARY },
{ AllocReportTypeEnums::WAREHOUSE_RECAP.raw, & AllocReportTypeEnums::WAREHOUSE_RECAP },
{ AllocReportTypeEnums::REQUEST_TO_INTERMEDIARY.raw, & AllocReportTypeEnums::REQUEST_TO_INTERMEDIARY },
};

const FieldEnumMap AllocCancReplaceReasonEnums::itemByRaw = {
{ AllocCancReplaceReasonEnums::ORIGINAL_DETAILS_INCOMPLETE_INCORRECT.raw, & AllocCancReplaceReasonEnums::ORIGINAL_DETAILS_INCOMPLETE_INCORRECT },
{ AllocCancReplaceReasonEnums::CHANGE_IN_UNDERLYING_ORDER_DETAILS.raw, & AllocCancReplaceReasonEnums::CHANGE_IN_UNDERLYING_ORDER_DETAILS },
{ AllocCancReplaceReasonEnums::OTHER.raw, & AllocCancReplaceReasonEnums::OTHER },
};

const FieldEnumMap AllocAccountTypeEnums::itemByRaw = {
{ AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS.raw, & AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_CUSTOMER_SIDE_OF_BOOKS },
{ AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS.raw, & AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS },
{ AllocAccountTypeEnums::HOUSE_TRADER.raw, & AllocAccountTypeEnums::HOUSE_TRADER },
{ AllocAccountTypeEnums::FLOOR_TRADER.raw, & AllocAccountTypeEnums::FLOOR_TRADER },
{ AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED.raw, & AllocAccountTypeEnums::ACCOUNT_IS_CARRIED_ON_NON_CUSTOMER_SIDE_OF_BOOKS_AND_IS_CROSS_MARGINED },
{ AllocAccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED.raw, & AllocAccountTypeEnums::ACCOUNT_IS_HOUSE_TRADER_AND_IS_CROSS_MARGINED },
{ AllocAccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT.raw, & AllocAccountTypeEnums::JOINT_BACKOFFICE_ACCOUNT },
};

const FieldEnumMap PartySubIDTypeEnums::itemByRaw = {
{ PartySubIDTypeEnums::FIRM.raw, & PartySubIDTypeEnums::FIRM },
{ PartySubIDTypeEnums::PERSON.raw, & PartySubIDTypeEnums::PERSON },
{ PartySubIDTypeEnums::SYSTEM.raw, & PartySubIDTypeEnums::SYSTEM },
{ PartySubIDTypeEnums::APPLICATION.raw, & PartySubIDTypeEnums::APPLICATION },
{ PartySubIDTypeEnums::FULL_LEGAL_NAME_OF_FIRM.raw, & PartySubIDTypeEnums::FULL_LEGAL_NAME_OF_FIRM },
{ PartySubIDTypeEnums::POSTAL_ADDRESS.raw, & PartySubIDTypeEnums::POSTAL_ADDRESS },
{ PartySubIDTypeEnums::PHONE_NUMBER.raw, & PartySubIDTypeEnums::PHONE_NUMBER },
{ PartySubIDTypeEnums::EMAIL_ADDRESS.raw, & PartySubIDTypeEnums::EMAIL_ADDRESS },
{ PartySubIDTypeEnums::CONTACT_NAME.raw, & PartySubIDTypeEnums::CONTACT_NAME },
{ PartySubIDTypeEnums::SECURITIES_ACCOUNT_NUMBER.raw, & PartySubIDTypeEnums::SECURITIES_ACCOUNT_NUMBER },
{ PartySubIDTypeEnums::REGISTRATION_NUMBER.raw, & PartySubIDTypeEnums::REGISTRATION_NUMBER },
{ PartySubIDTypeEnums::REGISTERED_ADDRESS_12.raw, & PartySubIDTypeEnums::REGISTERED_ADDRESS_12 },
{ PartySubIDTypeEnums::REGULATORY_STATUS.raw, & PartySubIDTypeEnums::REGULATORY_STATUS },
{ PartySubIDTypeEnums::REGISTRATION_NAME.raw, & PartySubIDTypeEnums::REGISTRATION_NAME },
{ PartySubIDTypeEnums::CASH_ACCOUNT_NUMBER.raw, & PartySubIDTypeEnums::CASH_ACCOUNT_NUMBER },
{ PartySubIDTypeEnums::BIC.raw, & PartySubIDTypeEnums::BIC },
{ PartySubIDTypeEnums::CSD_PARTICIPANT_MEMBER_CODE.raw, & PartySubIDTypeEnums::CSD_PARTICIPANT_MEMBER_CODE },
{ PartySubIDTypeEnums::REGISTERED_ADDRESS_18.raw, & PartySubIDTypeEnums::REGISTERED_ADDRESS_18 },
{ PartySubIDTypeEnums::FUND_ACCOUNT_NAME.raw, & PartySubIDTypeEnums::FUND_ACCOUNT_NAME },
{ PartySubIDTypeEnums::TELEX_NUMBER.raw, & PartySubIDTypeEnums::TELEX_NUMBER },
{ PartySubIDTypeEnums::FAX_NUMBER.raw, & PartySubIDTypeEnums::FAX_NUMBER },
{ PartySubIDTypeEnums::SECURITIES_ACCOUNT_NAME.raw, & PartySubIDTypeEnums::SECURITIES_ACCOUNT_NAME },
{ PartySubIDTypeEnums::CASH_ACCOUNT_NAME.raw, & PartySubIDTypeEnums::CASH_ACCOUNT_NAME },
{ PartySubIDTypeEnums::DEPARTMENT.raw, & PartySubIDTypeEnums::DEPARTMENT },
{ PartySubIDTypeEnums::LOCATION.raw, & PartySubIDTypeEnums::LOCATION },
{ PartySubIDTypeEnums::POSITION_ACCOUNT_TYPE.raw, & PartySubIDTypeEnums::POSITION_ACCOUNT_TYPE },
};

const FieldEnumMap AllocIntermedReqTypeEnums::itemByRaw = {
{ AllocIntermedReqTypeEnums::PENDING_ACCEPT.raw, & AllocIntermedReqTypeEnums::PENDING_ACCEPT },
{ AllocIntermedReqTypeEnums::PENDING_RELEASE.raw, & AllocIntermedReqTypeEnums::PENDING_RELEASE },
{ AllocIntermedReqTypeEnums::PENDING_REVERSAL.raw, & AllocIntermedReqTypeEnums::PENDING_REVERSAL },
{ AllocIntermedReqTypeEnums::ACCEPT.raw, & AllocIntermedReqTypeEnums::ACCEPT },
{ AllocIntermedReqTypeEnums::BLOCK_LEVEL_REJECT.raw, & AllocIntermedReqTypeEnums::BLOCK_LEVEL_REJECT },
{ AllocIntermedReqTypeEnums::ACCOUNT_LEVEL_REJECT.raw, & AllocIntermedReqTypeEnums::ACCOUNT_LEVEL_REJECT },
};

const FieldEnumMap ApplQueueResolutionEnums::itemByRaw = {
{ ApplQueueResolutionEnums::NO_ACTION_TAKEN.raw, & ApplQueueResolutionEnums::NO_ACTION_TAKEN },
{ ApplQueueResolutionEnums::QUEUE_FLUSHED.raw, & ApplQueueResolutionEnums::QUEUE_FLUSHED },
{ ApplQueueResolutionEnums::OVERLAY_LAST.raw, & ApplQueueResolutionEnums::OVERLAY_LAST },
{ ApplQueueResolutionEnums::END_SESSION.raw, & ApplQueueResolutionEnums::END_SESSION },
};

const FieldEnumMap ApplQueueActionEnums::itemByRaw = {
{ ApplQueueActionEnums::NO_ACTION_TAKEN.raw, & ApplQueueActionEnums::NO_ACTION_TAKEN },
{ ApplQueueActionEnums::QUEUE_FLUSHED.raw, & ApplQueueActionEnums::QUEUE_FLUSHED },
{ ApplQueueActionEnums::OVERLAY_LAST.raw, & ApplQueueActionEnums::OVERLAY_LAST },
{ ApplQueueActionEnums::END_SESSION.raw, & ApplQueueActionEnums::END_SESSION },
};

const FieldEnumMap AvgPxIndicatorEnums::itemByRaw = {
{ AvgPxIndicatorEnums::NO_AVERAGE_PRICING.raw, & AvgPxIndicatorEnums::NO_AVERAGE_PRICING },
{ AvgPxIndicatorEnums::TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID.raw, & AvgPxIndicatorEnums::TRADE_IS_PART_OF_AN_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID },
{ AvgPxIndicatorEnums::LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID.raw, & AvgPxIndicatorEnums::LAST_TRADE_IN_THE_AVERAGE_PRICE_GROUP_IDENTIFIED_BY_THE_TRADELINKID },
};

const FieldEnumMap TradeAllocIndicatorEnums::itemByRaw = {
{ TradeAllocIndicatorEnums::ALLOCATION_NOT_REQUIRED.raw, & TradeAllocIndicatorEnums::ALLOCATION_NOT_REQUIRED },
{ TradeAllocIndicatorEnums::ALLOCATION_REQUIRED.raw, & TradeAllocIndicatorEnums::ALLOCATION_REQUIRED },
{ TradeAllocIndicatorEnums::USE_ALLOCATION_PROVIDED_WITH_THE_TRADE.raw, & TradeAllocIndicatorEnums::USE_ALLOCATION_PROVIDED_WITH_THE_TRADE },
};

const FieldEnumMap ExpirationCycleEnums::itemByRaw = {
{ ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_CLOSE.raw, & ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_CLOSE },
{ ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_OPEN.raw, & ExpirationCycleEnums::EXPIRE_ON_TRADING_SESSION_OPEN },
};

const FieldEnumMap TrdTypeEnums::itemByRaw = {
{ TrdTypeEnums::REGULAR_TRADE.raw, & TrdTypeEnums::REGULAR_TRADE },
{ TrdTypeEnums::BLOCK_TRADE.raw, & TrdTypeEnums::BLOCK_TRADE },
{ TrdTypeEnums::EFP.raw, & TrdTypeEnums::EFP },
{ TrdTypeEnums::TRANSFER.raw, & TrdTypeEnums::TRANSFER },
{ TrdTypeEnums::LATE_TRADE.raw, & TrdTypeEnums::LATE_TRADE },
{ TrdTypeEnums::T_TRADE.raw, & TrdTypeEnums::T_TRADE },
{ TrdTypeEnums::WEIGHTED_AVERAGE_PRICE_TRADE.raw, & TrdTypeEnums::WEIGHTED_AVERAGE_PRICE_TRADE },
{ TrdTypeEnums::BUNCHED_TRADE.raw, & TrdTypeEnums::BUNCHED_TRADE },
{ TrdTypeEnums::LATE_BUNCHED_TRADE.raw, & TrdTypeEnums::LATE_BUNCHED_TRADE },
{ TrdTypeEnums::PRIOR_REFERENCE_PRICE_TRADE.raw, & TrdTypeEnums::PRIOR_REFERENCE_PRICE_TRADE },
{ TrdTypeEnums::AFTER_HOURS_TRADE.raw, & TrdTypeEnums::AFTER_HOURS_TRADE },
};

const FieldEnumMap PegMoveTypeEnums::itemByRaw = {
{ PegMoveTypeEnums::FLOATING.raw, & PegMoveTypeEnums::FLOATING },
{ PegMoveTypeEnums::FIXED.raw, & PegMoveTypeEnums::FIXED },
};

const FieldEnumMap PegOffsetTypeEnums::itemByRaw = {
{ PegOffsetTypeEnums::PRICE.raw, & PegOffsetTypeEnums::PRICE },
{ PegOffsetTypeEnums::BASIS_POINTS.raw, & PegOffsetTypeEnums::BASIS_POINTS },
{ PegOffsetTypeEnums::TICKS.raw, & PegOffsetTypeEnums::TICKS },
{ PegOffsetTypeEnums::PRICE_TIER.raw, & PegOffsetTypeEnums::PRICE_TIER },
};

const FieldEnumMap PegLimitTypeEnums::itemByRaw = {
{ PegLimitTypeEnums::OR_BETTER.raw, & PegLimitTypeEnums::OR_BETTER },
{ PegLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT.raw, & PegLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT },
{ PegLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_PEG_LIMIT_IS_A_MINIMUM_AND_FOR_A_SELL_THE_PEG_LIMIT_IS_A_MAXIMUM.raw, & PegLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_PEG_LIMIT_IS_A_MINIMUM_AND_FOR_A_SELL_THE_PEG_LIMIT_IS_A_MAXIMUM },
};

const FieldEnumMap PegRoundDirectionEnums::itemByRaw = {
{ PegRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK.raw, & PegRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK },
{ PegRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK.raw, & PegRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK },
};

const FieldEnumMap PegScopeEnums::itemByRaw = {
{ PegScopeEnums::LOCAL.raw, & PegScopeEnums::LOCAL },
{ PegScopeEnums::NATIONAL.raw, & PegScopeEnums::NATIONAL },
{ PegScopeEnums::GLOBAL.raw, & PegScopeEnums::GLOBAL },
{ PegScopeEnums::NATIONAL_EXCLUDING_LOCAL.raw, & PegScopeEnums::NATIONAL_EXCLUDING_LOCAL },
};

const FieldEnumMap DiscretionMoveTypeEnums::itemByRaw = {
{ DiscretionMoveTypeEnums::FLOATING.raw, & DiscretionMoveTypeEnums::FLOATING },
{ DiscretionMoveTypeEnums::FIXED.raw, & DiscretionMoveTypeEnums::FIXED },
};

const FieldEnumMap DiscretionOffsetTypeEnums::itemByRaw = {
{ DiscretionOffsetTypeEnums::PRICE.raw, & DiscretionOffsetTypeEnums::PRICE },
{ DiscretionOffsetTypeEnums::BASIS_POINTS.raw, & DiscretionOffsetTypeEnums::BASIS_POINTS },
{ DiscretionOffsetTypeEnums::TICKS.raw, & DiscretionOffsetTypeEnums::TICKS },
{ DiscretionOffsetTypeEnums::PRICE_TIER.raw, & DiscretionOffsetTypeEnums::PRICE_TIER },
};

const FieldEnumMap DiscretionLimitTypeEnums::itemByRaw = {
{ DiscretionLimitTypeEnums::OR_BETTER.raw, & DiscretionLimitTypeEnums::OR_BETTER },
{ DiscretionLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT.raw, & DiscretionLimitTypeEnums::STRICT_LIMIT_IS_A_STRICT_LIMIT },
{ DiscretionLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_DISCRETION_PRICE_IS_A_MINIMUM_AND_FOR_A_SELL_THE_DISCRETION_PRICE_IS_A_MAXIMUM.raw, & DiscretionLimitTypeEnums::OR_WORSE_FOR_A_BUY_THE_DISCRETION_PRICE_IS_A_MINIMUM_AND_FOR_A_SELL_THE_DISCRETION_PRICE_IS_A_MAXIMUM },
};

const FieldEnumMap DiscretionRoundDirectionEnums::itemByRaw = {
{ DiscretionRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK.raw, & DiscretionRoundDirectionEnums::MORE_AGGRESSIVE_ON_A_BUY_ORDER_ROUND_THE_PRICE_UP_ROUND_UP_TO_THE_NEAREST_TICK_ON_A_SELL_ROUND_DOWN_TO_THE_NEAREST_TICK },
{ DiscretionRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK.raw, & DiscretionRoundDirectionEnums::MORE_PASSIVE_ON_A_BUY_ORDER_ROUND_DOWN_TO_NEAREST_TICK_ON_A_SELL_ORDER_ROUND_UP_TO_NEAREST_TICK },
};

const FieldEnumMap DiscretionScopeEnums::itemByRaw = {
{ DiscretionScopeEnums::LOCAL.raw, & DiscretionScopeEnums::LOCAL },
{ DiscretionScopeEnums::NATIONAL.raw, & DiscretionScopeEnums::NATIONAL },
{ DiscretionScopeEnums::GLOBAL.raw, & DiscretionScopeEnums::GLOBAL },
{ DiscretionScopeEnums::NATIONAL_EXCLUDING_LOCAL.raw, & DiscretionScopeEnums::NATIONAL_EXCLUDING_LOCAL },
};

const FieldEnumMap TargetStrategyEnums::itemByRaw = {
{ TargetStrategyEnums::VWAP.raw, & TargetStrategyEnums::VWAP },
{ TargetStrategyEnums::PARTICIPATE.raw, & TargetStrategyEnums::PARTICIPATE },
{ TargetStrategyEnums::MININIZE_MARKET_IMPACT.raw, & TargetStrategyEnums::MININIZE_MARKET_IMPACT },
};

const FieldEnumMap LastLiquidityIndEnums::itemByRaw = {
{ LastLiquidityIndEnums::ADDED_LIQUIDITY.raw, & LastLiquidityIndEnums::ADDED_LIQUIDITY },
{ LastLiquidityIndEnums::REMOVED_LIQUIDITY.raw, & LastLiquidityIndEnums::REMOVED_LIQUIDITY },
{ LastLiquidityIndEnums::LIQUIDITY_ROUTED_OUT.raw, & LastLiquidityIndEnums::LIQUIDITY_ROUTED_OUT },
};

const FieldEnumMap PublishTrdIndicatorEnums::itemByRaw = {
{ PublishTrdIndicatorEnums::YES.raw, & PublishTrdIndicatorEnums::YES },
{ PublishTrdIndicatorEnums::NO.raw, & PublishTrdIndicatorEnums::NO },
};

const FieldEnumMap ShortSaleReasonEnums::itemByRaw = {
{ ShortSaleReasonEnums::DEALER_SOLD_SHORT.raw, & ShortSaleReasonEnums::DEALER_SOLD_SHORT },
{ ShortSaleReasonEnums::DEALER_SOLD_SHORT_EXEMPT.raw, & ShortSaleReasonEnums::DEALER_SOLD_SHORT_EXEMPT },
{ ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT.raw, & ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT },
{ ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT_EXEMPT.raw, & ShortSaleReasonEnums::SELLING_CUSTOMER_SOLD_SHORT_EXEMPT },
{ ShortSaleReasonEnums::QUALIFED_SERVICE_REPRESENTATIVE.raw, & ShortSaleReasonEnums::QUALIFED_SERVICE_REPRESENTATIVE },
{ ShortSaleReasonEnums::QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT.raw, & ShortSaleReasonEnums::QSR_OR_AGU_CONTRA_SIDE_SOLD_SHORT_EXEMPT },
};

const FieldEnumMap QtyTypeEnums::itemByRaw = {
{ QtyTypeEnums::UNITS.raw, & QtyTypeEnums::UNITS },
{ QtyTypeEnums::CONTRACTS.raw, & QtyTypeEnums::CONTRACTS },
};

const FieldEnumMap TradeReportTypeEnums::itemByRaw = {
{ TradeReportTypeEnums::SUBMIT.raw, & TradeReportTypeEnums::SUBMIT },
{ TradeReportTypeEnums::ALLEGED.raw, & TradeReportTypeEnums::ALLEGED },
{ TradeReportTypeEnums::ACCEPT.raw, & TradeReportTypeEnums::ACCEPT },
{ TradeReportTypeEnums::DECLINE.raw, & TradeReportTypeEnums::DECLINE },
{ TradeReportTypeEnums::ADDENDUM.raw, & TradeReportTypeEnums::ADDENDUM },
{ TradeReportTypeEnums::NO_WAS.raw, & TradeReportTypeEnums::NO_WAS },
{ TradeReportTypeEnums::TRADE_REPORT_CANCEL.raw, & TradeReportTypeEnums::TRADE_REPORT_CANCEL },
{ TradeReportTypeEnums::LOCKED_IN_TRADE_BREAK.raw, & TradeReportTypeEnums::LOCKED_IN_TRADE_BREAK },
};

const FieldEnumMap AllocNoOrdersTypeEnums::itemByRaw = {
{ AllocNoOrdersTypeEnums::NOT_SPECIFIED.raw, & AllocNoOrdersTypeEnums::NOT_SPECIFIED },
{ AllocNoOrdersTypeEnums::EXPLICIT_LIST_PROVIDED.raw, & AllocNoOrdersTypeEnums::EXPLICIT_LIST_PROVIDED },
};

const FieldEnumMap EventTypeEnums::itemByRaw = {
{ EventTypeEnums::PUT.raw, & EventTypeEnums::PUT },
{ EventTypeEnums::CALL.raw, & EventTypeEnums::CALL },
{ EventTypeEnums::TENDER.raw, & EventTypeEnums::TENDER },
{ EventTypeEnums::SINKING_FUND_CALL.raw, & EventTypeEnums::SINKING_FUND_CALL },
{ EventTypeEnums::OTHER.raw, & EventTypeEnums::OTHER },
};

const FieldEnumMap InstrAttribTypeEnums::itemByRaw = {
{ InstrAttribTypeEnums::FLAT.raw, & InstrAttribTypeEnums::FLAT },
{ InstrAttribTypeEnums::ZERO_COUPON.raw, & InstrAttribTypeEnums::ZERO_COUPON },
{ InstrAttribTypeEnums::INTEREST_BEARING.raw, & InstrAttribTypeEnums::INTEREST_BEARING },
{ InstrAttribTypeEnums::NO_PERIODIC_PAYMENTS.raw, & InstrAttribTypeEnums::NO_PERIODIC_PAYMENTS },
{ InstrAttribTypeEnums::VARIABLE_RATE.raw, & InstrAttribTypeEnums::VARIABLE_RATE },
{ InstrAttribTypeEnums::LESS_FEE_FOR_PUT.raw, & InstrAttribTypeEnums::LESS_FEE_FOR_PUT },
{ InstrAttribTypeEnums::STEPPED_COUPON.raw, & InstrAttribTypeEnums::STEPPED_COUPON },
{ InstrAttribTypeEnums::COUPON_PERIOD.raw, & InstrAttribTypeEnums::COUPON_PERIOD },
{ InstrAttribTypeEnums::WHEN_AND_IF_ISSUED.raw, & InstrAttribTypeEnums::WHEN_AND_IF_ISSUED },
{ InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT.raw, & InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT },
{ InstrAttribTypeEnums::CALLABLE_PUTTABLE.raw, & InstrAttribTypeEnums::CALLABLE_PUTTABLE },
{ InstrAttribTypeEnums::ESCROWED_TO_MATURITY.raw, & InstrAttribTypeEnums::ESCROWED_TO_MATURITY },
{ InstrAttribTypeEnums::ESCROWED_TO_REDEMPTION_DATE_CALLABLE_SUPPLY_REDEMPTION_DATE_IN_THE_INSTRATTRIBVALUE.raw, & InstrAttribTypeEnums::ESCROWED_TO_REDEMPTION_DATE_CALLABLE_SUPPLY_REDEMPTION_DATE_IN_THE_INSTRATTRIBVALUE },
{ InstrAttribTypeEnums::PREREFUNDED.raw, & InstrAttribTypeEnums::PREREFUNDED },
{ InstrAttribTypeEnums::IN_DEFAULT.raw, & InstrAttribTypeEnums::IN_DEFAULT },
{ InstrAttribTypeEnums::UNRATED.raw, & InstrAttribTypeEnums::UNRATED },
{ InstrAttribTypeEnums::TAXABLE.raw, & InstrAttribTypeEnums::TAXABLE },
{ InstrAttribTypeEnums::INDEXED.raw, & InstrAttribTypeEnums::INDEXED },
{ InstrAttribTypeEnums::SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX.raw, & InstrAttribTypeEnums::SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX },
{ InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT_PRICE_SUPPLY_PRICE_IN_THE_INSTRATTRIBVALUE.raw, & InstrAttribTypeEnums::ORIGINAL_ISSUE_DISCOUNT_PRICE_SUPPLY_PRICE_IN_THE_INSTRATTRIBVALUE },
{ InstrAttribTypeEnums::CALLABLE_BELOW_MATURITY_VALUE.raw, & InstrAttribTypeEnums::CALLABLE_BELOW_MATURITY_VALUE },
{ InstrAttribTypeEnums::CALLABLE_WITHOUT_NOTICE_BY_MAIL_TO_HOLDER_UNLESS_REGISTERED.raw, & InstrAttribTypeEnums::CALLABLE_WITHOUT_NOTICE_BY_MAIL_TO_HOLDER_UNLESS_REGISTERED },
{ InstrAttribTypeEnums::TEXT_SUPPLY_THE_TEXT_OF_THE_ATTRIBUTE_OR_DISCLAIMER_IN_THE_INSTRATTRIBVALUE.raw, & InstrAttribTypeEnums::TEXT_SUPPLY_THE_TEXT_OF_THE_ATTRIBUTE_OR_DISCLAIMER_IN_THE_INSTRATTRIBVALUE },
};

const FieldEnumMap CPProgramEnums::itemByRaw = {
{ CPProgramEnums::_3.raw, & CPProgramEnums::_3 },
{ CPProgramEnums::_4.raw, & CPProgramEnums::_4 },
{ CPProgramEnums::OTHER.raw, & CPProgramEnums::OTHER },
};

const FieldEnumMap MiscFeeBasisEnums::itemByRaw = {
{ MiscFeeBasisEnums::ABSOLUTE.raw, & MiscFeeBasisEnums::ABSOLUTE },
{ MiscFeeBasisEnums::PER_UNIT.raw, & MiscFeeBasisEnums::PER_UNIT },
{ MiscFeeBasisEnums::PERCENTAGE.raw, & MiscFeeBasisEnums::PERCENTAGE },
};

const FieldEnumMap LastFragmentEnums::itemByRaw = {
{ LastFragmentEnums::YES.raw, & LastFragmentEnums::YES },
{ LastFragmentEnums::NO.raw, & LastFragmentEnums::NO },
};

const FieldEnumMap CollAsgnReasonEnums::itemByRaw = {
{ CollAsgnReasonEnums::INITIAL.raw, & CollAsgnReasonEnums::INITIAL },
{ CollAsgnReasonEnums::SCHEDULED.raw, & CollAsgnReasonEnums::SCHEDULED },
{ CollAsgnReasonEnums::TIME_WARNING.raw, & CollAsgnReasonEnums::TIME_WARNING },
{ CollAsgnReasonEnums::MARGIN_DEFICIENCY.raw, & CollAsgnReasonEnums::MARGIN_DEFICIENCY },
{ CollAsgnReasonEnums::MARGIN_EXCESS.raw, & CollAsgnReasonEnums::MARGIN_EXCESS },
{ CollAsgnReasonEnums::FORWARD_COLLATERAL_DEMAND.raw, & CollAsgnReasonEnums::FORWARD_COLLATERAL_DEMAND },
{ CollAsgnReasonEnums::EVENT_OF_DEFAULT.raw, & CollAsgnReasonEnums::EVENT_OF_DEFAULT },
{ CollAsgnReasonEnums::ADVERSE_TAX_EVENT.raw, & CollAsgnReasonEnums::ADVERSE_TAX_EVENT },
};

const FieldEnumMap CollInquiryQualifierEnums::itemByRaw = {
{ CollInquiryQualifierEnums::TRADEDATE.raw, & CollInquiryQualifierEnums::TRADEDATE },
{ CollInquiryQualifierEnums::GC_INSTRUMENT.raw, & CollInquiryQualifierEnums::GC_INSTRUMENT },
{ CollInquiryQualifierEnums::COLLATERALINSTRUMENT.raw, & CollInquiryQualifierEnums::COLLATERALINSTRUMENT },
{ CollInquiryQualifierEnums::SUBSTITUTION_ELIGIBLE.raw, & CollInquiryQualifierEnums::SUBSTITUTION_ELIGIBLE },
{ CollInquiryQualifierEnums::NOT_ASSIGNED.raw, & CollInquiryQualifierEnums::NOT_ASSIGNED },
{ CollInquiryQualifierEnums::PARTIALLY_ASSIGNED.raw, & CollInquiryQualifierEnums::PARTIALLY_ASSIGNED },
{ CollInquiryQualifierEnums::FULLY_ASSIGNED.raw, & CollInquiryQualifierEnums::FULLY_ASSIGNED },
{ CollInquiryQualifierEnums::OUTSTANDING_TRADES.raw, & CollInquiryQualifierEnums::OUTSTANDING_TRADES },
};

const FieldEnumMap CollAsgnTransTypeEnums::itemByRaw = {
{ CollAsgnTransTypeEnums::NEW.raw, & CollAsgnTransTypeEnums::NEW },
{ CollAsgnTransTypeEnums::REPLACE.raw, & CollAsgnTransTypeEnums::REPLACE },
{ CollAsgnTransTypeEnums::CANCEL.raw, & CollAsgnTransTypeEnums::CANCEL },
{ CollAsgnTransTypeEnums::RELEASE.raw, & CollAsgnTransTypeEnums::RELEASE },
{ CollAsgnTransTypeEnums::REVERSE.raw, & CollAsgnTransTypeEnums::REVERSE },
};

const FieldEnumMap CollAsgnRespTypeEnums::itemByRaw = {
{ CollAsgnRespTypeEnums::RECEIVED.raw, & CollAsgnRespTypeEnums::RECEIVED },
{ CollAsgnRespTypeEnums::ACCEPTED.raw, & CollAsgnRespTypeEnums::ACCEPTED },
{ CollAsgnRespTypeEnums::DECLINED.raw, & CollAsgnRespTypeEnums::DECLINED },
{ CollAsgnRespTypeEnums::REJECTED.raw, & CollAsgnRespTypeEnums::REJECTED },
};

const FieldEnumMap CollAsgnRejectReasonEnums::itemByRaw = {
{ CollAsgnRejectReasonEnums::UNKNOWN_DEAL.raw, & CollAsgnRejectReasonEnums::UNKNOWN_DEAL },
{ CollAsgnRejectReasonEnums::UNKNOWN_OR_INVALID_INSTRUMENT.raw, & CollAsgnRejectReasonEnums::UNKNOWN_OR_INVALID_INSTRUMENT },
{ CollAsgnRejectReasonEnums::UNAUTHORIZED_TRANSACTION.raw, & CollAsgnRejectReasonEnums::UNAUTHORIZED_TRANSACTION },
{ CollAsgnRejectReasonEnums::INSUFFICIENT_COLLATERAL.raw, & CollAsgnRejectReasonEnums::INSUFFICIENT_COLLATERAL },
{ CollAsgnRejectReasonEnums::INVALID_TYPE_OF_COLLATERAL.raw, & CollAsgnRejectReasonEnums::INVALID_TYPE_OF_COLLATERAL },
{ CollAsgnRejectReasonEnums::EXCESSIVE_SUBSTITUTION.raw, & CollAsgnRejectReasonEnums::EXCESSIVE_SUBSTITUTION },
{ CollAsgnRejectReasonEnums::OTHER.raw, & CollAsgnRejectReasonEnums::OTHER },
};

const FieldEnumMap CollStatusEnums::itemByRaw = {
{ CollStatusEnums::UNASSIGNED.raw, & CollStatusEnums::UNASSIGNED },
{ CollStatusEnums::PARTIALLY_ASSIGNED.raw, & CollStatusEnums::PARTIALLY_ASSIGNED },
{ CollStatusEnums::ASSIGNMENT_PROPOSED.raw, & CollStatusEnums::ASSIGNMENT_PROPOSED },
{ CollStatusEnums::ASSIGNED.raw, & CollStatusEnums::ASSIGNED },
{ CollStatusEnums::CHALLENGED.raw, & CollStatusEnums::CHALLENGED },
};

const FieldEnumMap DeliveryTypeEnums::itemByRaw = {
{ DeliveryTypeEnums::VERSUS_PAYMENT_DELIVER.raw, & DeliveryTypeEnums::VERSUS_PAYMENT_DELIVER },
{ DeliveryTypeEnums::FREE_DELIVER.raw, & DeliveryTypeEnums::FREE_DELIVER },
{ DeliveryTypeEnums::TRI_PARTY.raw, & DeliveryTypeEnums::TRI_PARTY },
{ DeliveryTypeEnums::HOLD_IN_CUSTODY.raw, & DeliveryTypeEnums::HOLD_IN_CUSTODY },
};

const FieldEnumMap UserRequestTypeEnums::itemByRaw = {
{ UserRequestTypeEnums::LOGONUSER.raw, & UserRequestTypeEnums::LOGONUSER },
{ UserRequestTypeEnums::LOGOFFUSER.raw, & UserRequestTypeEnums::LOGOFFUSER },
{ UserRequestTypeEnums::CHANGEPASSWORDFORUSER.raw, & UserRequestTypeEnums::CHANGEPASSWORDFORUSER },
{ UserRequestTypeEnums::REQUEST_INDIVIDUAL_USER_STATUS.raw, & UserRequestTypeEnums::REQUEST_INDIVIDUAL_USER_STATUS },
};

const FieldEnumMap UserStatusEnums::itemByRaw = {
{ UserStatusEnums::LOGGED_IN.raw, & UserStatusEnums::LOGGED_IN },
{ UserStatusEnums::NOT_LOGGED_IN.raw, & UserStatusEnums::NOT_LOGGED_IN },
{ UserStatusEnums::USER_NOT_RECOGNISED.raw, & UserStatusEnums::USER_NOT_RECOGNISED },
{ UserStatusEnums::PASSWORD_INCORRECT.raw, & UserStatusEnums::PASSWORD_INCORRECT },
{ UserStatusEnums::PASSWORD_CHANGED.raw, & UserStatusEnums::PASSWORD_CHANGED },
{ UserStatusEnums::OTHER.raw, & UserStatusEnums::OTHER },
};

const FieldEnumMap StatusValueEnums::itemByRaw = {
{ StatusValueEnums::CONNECTED.raw, & StatusValueEnums::CONNECTED },
{ StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_UP.raw, & StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_UP },
{ StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_DOWN.raw, & StatusValueEnums::NOT_CONNECTED_DOWN_EXPECTED_DOWN },
{ StatusValueEnums::IN_PROCESS.raw, & StatusValueEnums::IN_PROCESS },
};

const FieldEnumMap NetworkRequestTypeEnums::itemByRaw = {
{ NetworkRequestTypeEnums::SNAPSHOT.raw, & NetworkRequestTypeEnums::SNAPSHOT },
{ NetworkRequestTypeEnums::SUBSCRIBE.raw, & NetworkRequestTypeEnums::SUBSCRIBE },
{ NetworkRequestTypeEnums::STOP_SUBSCRIBING.raw, & NetworkRequestTypeEnums::STOP_SUBSCRIBING },
{ NetworkRequestTypeEnums::LEVEL_OF_DETAIL_THEN_NOCOMPIDS_BECOMES_REQUIRED.raw, & NetworkRequestTypeEnums::LEVEL_OF_DETAIL_THEN_NOCOMPIDS_BECOMES_REQUIRED },
};

const FieldEnumMap NetworkStatusResponseTypeEnums::itemByRaw = {
{ NetworkStatusResponseTypeEnums::FULL.raw, & NetworkStatusResponseTypeEnums::FULL },
{ NetworkStatusResponseTypeEnums::INCREMENTAL_UPDATE.raw, & NetworkStatusResponseTypeEnums::INCREMENTAL_UPDATE },
};

const FieldEnumMap TrdRptStatusEnums::itemByRaw = {
{ TrdRptStatusEnums::ACCEPTED.raw, & TrdRptStatusEnums::ACCEPTED },
{ TrdRptStatusEnums::REJECTED.raw, & TrdRptStatusEnums::REJECTED },
};

const FieldEnumMap AffirmStatusEnums::itemByRaw = {
{ AffirmStatusEnums::RECEIVED.raw, & AffirmStatusEnums::RECEIVED },
{ AffirmStatusEnums::CONFIRM_REJECTED_IE_NOT_AFFIRMED.raw, & AffirmStatusEnums::CONFIRM_REJECTED_IE_NOT_AFFIRMED },
{ AffirmStatusEnums::AFFIRMED.raw, & AffirmStatusEnums::AFFIRMED },
};

const FieldEnumMap CollActionEnums::itemByRaw = {
{ CollActionEnums::RETAIN.raw, & CollActionEnums::RETAIN },
{ CollActionEnums::ADD.raw, & CollActionEnums::ADD },
{ CollActionEnums::REMOVE.raw, & CollActionEnums::REMOVE },
};

const FieldEnumMap CollInquiryStatusEnums::itemByRaw = {
{ CollInquiryStatusEnums::ACCEPTED.raw, & CollInquiryStatusEnums::ACCEPTED },
{ CollInquiryStatusEnums::ACCEPTED_WITH_WARNINGS.raw, & CollInquiryStatusEnums::ACCEPTED_WITH_WARNINGS },
{ CollInquiryStatusEnums::COMPLETED.raw, & CollInquiryStatusEnums::COMPLETED },
{ CollInquiryStatusEnums::COMPLETED_WITH_WARNINGS.raw, & CollInquiryStatusEnums::COMPLETED_WITH_WARNINGS },
{ CollInquiryStatusEnums::REJECTED.raw, & CollInquiryStatusEnums::REJECTED },
};

const FieldEnumMap CollInquiryResultEnums::itemByRaw = {
{ CollInquiryResultEnums::SUCCESSFUL.raw, & CollInquiryResultEnums::SUCCESSFUL },
{ CollInquiryResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT.raw, & CollInquiryResultEnums::INVALID_OR_UNKNOWN_INSTRUMENT },
{ CollInquiryResultEnums::INVALID_OR_UNKNOWN_COLLATERAL_TYPE.raw, & CollInquiryResultEnums::INVALID_OR_UNKNOWN_COLLATERAL_TYPE },
{ CollInquiryResultEnums::INVALID_PARTIES.raw, & CollInquiryResultEnums::INVALID_PARTIES },
{ CollInquiryResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED.raw, & CollInquiryResultEnums::INVALID_TRANSPORT_TYPE_REQUESTED },
{ CollInquiryResultEnums::INVALID_DESTINATION_REQUESTED.raw, & CollInquiryResultEnums::INVALID_DESTINATION_REQUESTED },
{ CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED.raw, & CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_TRADE_SPECIFIED },
{ CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED.raw, & CollInquiryResultEnums::NO_COLLATERAL_FOUND_FOR_THE_ORDER_SPECIFIED },
{ CollInquiryResultEnums::COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED.raw, & CollInquiryResultEnums::COLLATERAL_INQUIRY_TYPE_NOT_SUPPORTED },
{ CollInquiryResultEnums::UNAUTHORIZED_FOR_COLLATERAL_INQUIRY.raw, & CollInquiryResultEnums::UNAUTHORIZED_FOR_COLLATERAL_INQUIRY },
{ CollInquiryResultEnums::OTHER.raw, & CollInquiryResultEnums::OTHER },
};

// -------------------------------------- init ----------------------------------------
#pragma GCC push_options
#pragma GCC optimize("O0")

int initStatics()
{

  tagNameByRaw.emplace( tag_as_raw<1>(), FixAccount );
  tagNameByValue.emplace( 1, FixAccount );
  tagByName.emplace( FixAccount, 1 );
  fieldTypeByValue.emplace( 1, FieldType::STRING );
  fieldTypeNameByValue.emplace( 1, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<2>(), FixAdvId );
  tagNameByValue.emplace( 2, FixAdvId );
  tagByName.emplace( FixAdvId, 2 );
  fieldTypeByValue.emplace( 2, FieldType::STRING );
  fieldTypeNameByValue.emplace( 2, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<3>(), FixAdvRefID );
  tagNameByValue.emplace( 3, FixAdvRefID );
  tagByName.emplace( FixAdvRefID, 3 );
  fieldTypeByValue.emplace( 3, FieldType::STRING );
  fieldTypeNameByValue.emplace( 3, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<4>(), FixAdvSide );
  tagNameByValue.emplace( 4, FixAdvSide );
  tagByName.emplace( FixAdvSide, 4 );
  fieldTypeByValue.emplace( 4, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 4, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<5>(), FixAdvTransType );
  tagNameByValue.emplace( 5, FixAdvTransType );
  tagByName.emplace( FixAdvTransType, 5 );
  fieldTypeByValue.emplace( 5, FieldType::STRING );
  fieldTypeNameByValue.emplace( 5, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<6>(), FixAvgPx );
  tagNameByValue.emplace( 6, FixAvgPx );
  tagByName.emplace( FixAvgPx, 6 );
  fieldTypeByValue.emplace( 6, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 6, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<7>(), FixBeginSeqNo );
  tagNameByValue.emplace( 7, FixBeginSeqNo );
  tagByName.emplace( FixBeginSeqNo, 7 );
  fieldTypeByValue.emplace( 7, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 7, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<8>(), FixBeginString );
  tagNameByValue.emplace( 8, FixBeginString );
  tagByName.emplace( FixBeginString, 8 );
  fieldTypeByValue.emplace( 8, FieldType::STRING );
  fieldTypeNameByValue.emplace( 8, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<9>(), FixBodyLength );
  tagNameByValue.emplace( 9, FixBodyLength );
  tagByName.emplace( FixBodyLength, 9 );
  fieldTypeByValue.emplace( 9, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 9, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<10>(), FixCheckSum );
  tagNameByValue.emplace( 10, FixCheckSum );
  tagByName.emplace( FixCheckSum, 10 );
  fieldTypeByValue.emplace( 10, FieldType::STRING );
  fieldTypeNameByValue.emplace( 10, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<11>(), FixClOrdID );
  tagNameByValue.emplace( 11, FixClOrdID );
  tagByName.emplace( FixClOrdID, 11 );
  fieldTypeByValue.emplace( 11, FieldType::STRING );
  fieldTypeNameByValue.emplace( 11, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<12>(), FixCommission );
  tagNameByValue.emplace( 12, FixCommission );
  tagByName.emplace( FixCommission, 12 );
  fieldTypeByValue.emplace( 12, FieldType::AMT );
  fieldTypeNameByValue.emplace( 12, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<13>(), FixCommType );
  tagNameByValue.emplace( 13, FixCommType );
  tagByName.emplace( FixCommType, 13 );
  fieldTypeByValue.emplace( 13, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 13, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<14>(), FixCumQty );
  tagNameByValue.emplace( 14, FixCumQty );
  tagByName.emplace( FixCumQty, 14 );
  fieldTypeByValue.emplace( 14, FieldType::QTY );
  fieldTypeNameByValue.emplace( 14, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<15>(), FixCurrency );
  tagNameByValue.emplace( 15, FixCurrency );
  tagByName.emplace( FixCurrency, 15 );
  fieldTypeByValue.emplace( 15, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 15, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<16>(), FixEndSeqNo );
  tagNameByValue.emplace( 16, FixEndSeqNo );
  tagByName.emplace( FixEndSeqNo, 16 );
  fieldTypeByValue.emplace( 16, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 16, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<17>(), FixExecID );
  tagNameByValue.emplace( 17, FixExecID );
  tagByName.emplace( FixExecID, 17 );
  fieldTypeByValue.emplace( 17, FieldType::STRING );
  fieldTypeNameByValue.emplace( 17, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<18>(), FixExecInst );
  tagNameByValue.emplace( 18, FixExecInst );
  tagByName.emplace( FixExecInst, 18 );
  fieldTypeByValue.emplace( 18, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 18, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<19>(), FixExecRefID );
  tagNameByValue.emplace( 19, FixExecRefID );
  tagByName.emplace( FixExecRefID, 19 );
  fieldTypeByValue.emplace( 19, FieldType::STRING );
  fieldTypeNameByValue.emplace( 19, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<21>(), FixHandlInst );
  tagNameByValue.emplace( 21, FixHandlInst );
  tagByName.emplace( FixHandlInst, 21 );
  fieldTypeByValue.emplace( 21, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 21, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<22>(), FixSecurityIDSource );
  tagNameByValue.emplace( 22, FixSecurityIDSource );
  tagByName.emplace( FixSecurityIDSource, 22 );
  fieldTypeByValue.emplace( 22, FieldType::STRING );
  fieldTypeNameByValue.emplace( 22, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<23>(), FixIOIID );
  tagNameByValue.emplace( 23, FixIOIID );
  tagByName.emplace( FixIOIID, 23 );
  fieldTypeByValue.emplace( 23, FieldType::STRING );
  fieldTypeNameByValue.emplace( 23, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<25>(), FixIOIQltyInd );
  tagNameByValue.emplace( 25, FixIOIQltyInd );
  tagByName.emplace( FixIOIQltyInd, 25 );
  fieldTypeByValue.emplace( 25, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 25, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<26>(), FixIOIRefID );
  tagNameByValue.emplace( 26, FixIOIRefID );
  tagByName.emplace( FixIOIRefID, 26 );
  fieldTypeByValue.emplace( 26, FieldType::STRING );
  fieldTypeNameByValue.emplace( 26, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<27>(), FixIOIQty );
  tagNameByValue.emplace( 27, FixIOIQty );
  tagByName.emplace( FixIOIQty, 27 );
  fieldTypeByValue.emplace( 27, FieldType::STRING );
  fieldTypeNameByValue.emplace( 27, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<28>(), FixIOITransType );
  tagNameByValue.emplace( 28, FixIOITransType );
  tagByName.emplace( FixIOITransType, 28 );
  fieldTypeByValue.emplace( 28, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 28, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<29>(), FixLastCapacity );
  tagNameByValue.emplace( 29, FixLastCapacity );
  tagByName.emplace( FixLastCapacity, 29 );
  fieldTypeByValue.emplace( 29, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 29, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<30>(), FixLastMkt );
  tagNameByValue.emplace( 30, FixLastMkt );
  tagByName.emplace( FixLastMkt, 30 );
  fieldTypeByValue.emplace( 30, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 30, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<31>(), FixLastPx );
  tagNameByValue.emplace( 31, FixLastPx );
  tagByName.emplace( FixLastPx, 31 );
  fieldTypeByValue.emplace( 31, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 31, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<32>(), FixLastQty );
  tagNameByValue.emplace( 32, FixLastQty );
  tagByName.emplace( FixLastQty, 32 );
  fieldTypeByValue.emplace( 32, FieldType::QTY );
  fieldTypeNameByValue.emplace( 32, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<33>(), FixNoLinesOfText );
  tagNameByValue.emplace( 33, FixNoLinesOfText );
  tagByName.emplace( FixNoLinesOfText, 33 );
  fieldTypeByValue.emplace( 33, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 33, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<34>(), FixMsgSeqNum );
  tagNameByValue.emplace( 34, FixMsgSeqNum );
  tagByName.emplace( FixMsgSeqNum, 34 );
  fieldTypeByValue.emplace( 34, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 34, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<35>(), FixMsgType );
  tagNameByValue.emplace( 35, FixMsgType );
  tagByName.emplace( FixMsgType, 35 );
  fieldTypeByValue.emplace( 35, FieldType::STRING );
  fieldTypeNameByValue.emplace( 35, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<36>(), FixNewSeqNo );
  tagNameByValue.emplace( 36, FixNewSeqNo );
  tagByName.emplace( FixNewSeqNo, 36 );
  fieldTypeByValue.emplace( 36, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 36, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<37>(), FixOrderID );
  tagNameByValue.emplace( 37, FixOrderID );
  tagByName.emplace( FixOrderID, 37 );
  fieldTypeByValue.emplace( 37, FieldType::STRING );
  fieldTypeNameByValue.emplace( 37, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<38>(), FixOrderQty );
  tagNameByValue.emplace( 38, FixOrderQty );
  tagByName.emplace( FixOrderQty, 38 );
  fieldTypeByValue.emplace( 38, FieldType::QTY );
  fieldTypeNameByValue.emplace( 38, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<39>(), FixOrdStatus );
  tagNameByValue.emplace( 39, FixOrdStatus );
  tagByName.emplace( FixOrdStatus, 39 );
  fieldTypeByValue.emplace( 39, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 39, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<40>(), FixOrdType );
  tagNameByValue.emplace( 40, FixOrdType );
  tagByName.emplace( FixOrdType, 40 );
  fieldTypeByValue.emplace( 40, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 40, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<41>(), FixOrigClOrdID );
  tagNameByValue.emplace( 41, FixOrigClOrdID );
  tagByName.emplace( FixOrigClOrdID, 41 );
  fieldTypeByValue.emplace( 41, FieldType::STRING );
  fieldTypeNameByValue.emplace( 41, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<42>(), FixOrigTime );
  tagNameByValue.emplace( 42, FixOrigTime );
  tagByName.emplace( FixOrigTime, 42 );
  fieldTypeByValue.emplace( 42, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 42, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<43>(), FixPossDupFlag );
  tagNameByValue.emplace( 43, FixPossDupFlag );
  tagByName.emplace( FixPossDupFlag, 43 );
  fieldTypeByValue.emplace( 43, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 43, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<44>(), FixPrice );
  tagNameByValue.emplace( 44, FixPrice );
  tagByName.emplace( FixPrice, 44 );
  fieldTypeByValue.emplace( 44, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 44, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<45>(), FixRefSeqNum );
  tagNameByValue.emplace( 45, FixRefSeqNum );
  tagByName.emplace( FixRefSeqNum, 45 );
  fieldTypeByValue.emplace( 45, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 45, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<48>(), FixSecurityID );
  tagNameByValue.emplace( 48, FixSecurityID );
  tagByName.emplace( FixSecurityID, 48 );
  fieldTypeByValue.emplace( 48, FieldType::STRING );
  fieldTypeNameByValue.emplace( 48, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<49>(), FixSenderCompID );
  tagNameByValue.emplace( 49, FixSenderCompID );
  tagByName.emplace( FixSenderCompID, 49 );
  fieldTypeByValue.emplace( 49, FieldType::STRING );
  fieldTypeNameByValue.emplace( 49, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<50>(), FixSenderSubID );
  tagNameByValue.emplace( 50, FixSenderSubID );
  tagByName.emplace( FixSenderSubID, 50 );
  fieldTypeByValue.emplace( 50, FieldType::STRING );
  fieldTypeNameByValue.emplace( 50, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<52>(), FixSendingTime );
  tagNameByValue.emplace( 52, FixSendingTime );
  tagByName.emplace( FixSendingTime, 52 );
  fieldTypeByValue.emplace( 52, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 52, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<53>(), FixQuantity );
  tagNameByValue.emplace( 53, FixQuantity );
  tagByName.emplace( FixQuantity, 53 );
  fieldTypeByValue.emplace( 53, FieldType::QTY );
  fieldTypeNameByValue.emplace( 53, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<54>(), FixSide );
  tagNameByValue.emplace( 54, FixSide );
  tagByName.emplace( FixSide, 54 );
  fieldTypeByValue.emplace( 54, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 54, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<55>(), FixSymbol );
  tagNameByValue.emplace( 55, FixSymbol );
  tagByName.emplace( FixSymbol, 55 );
  fieldTypeByValue.emplace( 55, FieldType::STRING );
  fieldTypeNameByValue.emplace( 55, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<56>(), FixTargetCompID );
  tagNameByValue.emplace( 56, FixTargetCompID );
  tagByName.emplace( FixTargetCompID, 56 );
  fieldTypeByValue.emplace( 56, FieldType::STRING );
  fieldTypeNameByValue.emplace( 56, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<57>(), FixTargetSubID );
  tagNameByValue.emplace( 57, FixTargetSubID );
  tagByName.emplace( FixTargetSubID, 57 );
  fieldTypeByValue.emplace( 57, FieldType::STRING );
  fieldTypeNameByValue.emplace( 57, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<58>(), FixText );
  tagNameByValue.emplace( 58, FixText );
  tagByName.emplace( FixText, 58 );
  fieldTypeByValue.emplace( 58, FieldType::STRING );
  fieldTypeNameByValue.emplace( 58, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<59>(), FixTimeInForce );
  tagNameByValue.emplace( 59, FixTimeInForce );
  tagByName.emplace( FixTimeInForce, 59 );
  fieldTypeByValue.emplace( 59, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 59, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<60>(), FixTransactTime );
  tagNameByValue.emplace( 60, FixTransactTime );
  tagByName.emplace( FixTransactTime, 60 );
  fieldTypeByValue.emplace( 60, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 60, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<61>(), FixUrgency );
  tagNameByValue.emplace( 61, FixUrgency );
  tagByName.emplace( FixUrgency, 61 );
  fieldTypeByValue.emplace( 61, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 61, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<62>(), FixValidUntilTime );
  tagNameByValue.emplace( 62, FixValidUntilTime );
  tagByName.emplace( FixValidUntilTime, 62 );
  fieldTypeByValue.emplace( 62, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 62, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<63>(), FixSettlType );
  tagNameByValue.emplace( 63, FixSettlType );
  tagByName.emplace( FixSettlType, 63 );
  fieldTypeByValue.emplace( 63, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 63, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<64>(), FixSettlDate );
  tagNameByValue.emplace( 64, FixSettlDate );
  tagByName.emplace( FixSettlDate, 64 );
  fieldTypeByValue.emplace( 64, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 64, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<65>(), FixSymbolSfx );
  tagNameByValue.emplace( 65, FixSymbolSfx );
  tagByName.emplace( FixSymbolSfx, 65 );
  fieldTypeByValue.emplace( 65, FieldType::STRING );
  fieldTypeNameByValue.emplace( 65, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<66>(), FixListID );
  tagNameByValue.emplace( 66, FixListID );
  tagByName.emplace( FixListID, 66 );
  fieldTypeByValue.emplace( 66, FieldType::STRING );
  fieldTypeNameByValue.emplace( 66, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<67>(), FixListSeqNo );
  tagNameByValue.emplace( 67, FixListSeqNo );
  tagByName.emplace( FixListSeqNo, 67 );
  fieldTypeByValue.emplace( 67, FieldType::INT );
  fieldTypeNameByValue.emplace( 67, "INT" );

  tagNameByRaw.emplace( tag_as_raw<68>(), FixTotNoOrders );
  tagNameByValue.emplace( 68, FixTotNoOrders );
  tagByName.emplace( FixTotNoOrders, 68 );
  fieldTypeByValue.emplace( 68, FieldType::INT );
  fieldTypeNameByValue.emplace( 68, "INT" );

  tagNameByRaw.emplace( tag_as_raw<69>(), FixListExecInst );
  tagNameByValue.emplace( 69, FixListExecInst );
  tagByName.emplace( FixListExecInst, 69 );
  fieldTypeByValue.emplace( 69, FieldType::STRING );
  fieldTypeNameByValue.emplace( 69, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<70>(), FixAllocID );
  tagNameByValue.emplace( 70, FixAllocID );
  tagByName.emplace( FixAllocID, 70 );
  fieldTypeByValue.emplace( 70, FieldType::STRING );
  fieldTypeNameByValue.emplace( 70, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<71>(), FixAllocTransType );
  tagNameByValue.emplace( 71, FixAllocTransType );
  tagByName.emplace( FixAllocTransType, 71 );
  fieldTypeByValue.emplace( 71, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 71, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<72>(), FixRefAllocID );
  tagNameByValue.emplace( 72, FixRefAllocID );
  tagByName.emplace( FixRefAllocID, 72 );
  fieldTypeByValue.emplace( 72, FieldType::STRING );
  fieldTypeNameByValue.emplace( 72, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<73>(), FixNoOrders );
  tagNameByValue.emplace( 73, FixNoOrders );
  tagByName.emplace( FixNoOrders, 73 );
  fieldTypeByValue.emplace( 73, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 73, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<74>(), FixAvgPxPrecision );
  tagNameByValue.emplace( 74, FixAvgPxPrecision );
  tagByName.emplace( FixAvgPxPrecision, 74 );
  fieldTypeByValue.emplace( 74, FieldType::INT );
  fieldTypeNameByValue.emplace( 74, "INT" );

  tagNameByRaw.emplace( tag_as_raw<75>(), FixTradeDate );
  tagNameByValue.emplace( 75, FixTradeDate );
  tagByName.emplace( FixTradeDate, 75 );
  fieldTypeByValue.emplace( 75, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 75, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<77>(), FixPositionEffect );
  tagNameByValue.emplace( 77, FixPositionEffect );
  tagByName.emplace( FixPositionEffect, 77 );
  fieldTypeByValue.emplace( 77, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 77, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<78>(), FixNoAllocs );
  tagNameByValue.emplace( 78, FixNoAllocs );
  tagByName.emplace( FixNoAllocs, 78 );
  fieldTypeByValue.emplace( 78, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 78, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<79>(), FixAllocAccount );
  tagNameByValue.emplace( 79, FixAllocAccount );
  tagByName.emplace( FixAllocAccount, 79 );
  fieldTypeByValue.emplace( 79, FieldType::STRING );
  fieldTypeNameByValue.emplace( 79, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<80>(), FixAllocQty );
  tagNameByValue.emplace( 80, FixAllocQty );
  tagByName.emplace( FixAllocQty, 80 );
  fieldTypeByValue.emplace( 80, FieldType::QTY );
  fieldTypeNameByValue.emplace( 80, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<81>(), FixProcessCode );
  tagNameByValue.emplace( 81, FixProcessCode );
  tagByName.emplace( FixProcessCode, 81 );
  fieldTypeByValue.emplace( 81, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 81, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<82>(), FixNoRpts );
  tagNameByValue.emplace( 82, FixNoRpts );
  tagByName.emplace( FixNoRpts, 82 );
  fieldTypeByValue.emplace( 82, FieldType::INT );
  fieldTypeNameByValue.emplace( 82, "INT" );

  tagNameByRaw.emplace( tag_as_raw<83>(), FixRptSeq );
  tagNameByValue.emplace( 83, FixRptSeq );
  tagByName.emplace( FixRptSeq, 83 );
  fieldTypeByValue.emplace( 83, FieldType::INT );
  fieldTypeNameByValue.emplace( 83, "INT" );

  tagNameByRaw.emplace( tag_as_raw<84>(), FixCxlQty );
  tagNameByValue.emplace( 84, FixCxlQty );
  tagByName.emplace( FixCxlQty, 84 );
  fieldTypeByValue.emplace( 84, FieldType::QTY );
  fieldTypeNameByValue.emplace( 84, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<85>(), FixNoDlvyInst );
  tagNameByValue.emplace( 85, FixNoDlvyInst );
  tagByName.emplace( FixNoDlvyInst, 85 );
  fieldTypeByValue.emplace( 85, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 85, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<87>(), FixAllocStatus );
  tagNameByValue.emplace( 87, FixAllocStatus );
  tagByName.emplace( FixAllocStatus, 87 );
  fieldTypeByValue.emplace( 87, FieldType::INT );
  fieldTypeNameByValue.emplace( 87, "INT" );

  tagNameByRaw.emplace( tag_as_raw<88>(), FixAllocRejCode );
  tagNameByValue.emplace( 88, FixAllocRejCode );
  tagByName.emplace( FixAllocRejCode, 88 );
  fieldTypeByValue.emplace( 88, FieldType::INT );
  fieldTypeNameByValue.emplace( 88, "INT" );

  tagNameByRaw.emplace( tag_as_raw<89>(), FixSignature );
  tagNameByValue.emplace( 89, FixSignature );
  tagByName.emplace( FixSignature, 89 );
  fieldTypeByValue.emplace( 89, FieldType::DATA );
  fieldTypeNameByValue.emplace( 89, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<90>(), FixSecureDataLen );
  tagNameByValue.emplace( 90, FixSecureDataLen );
  tagByName.emplace( FixSecureDataLen, 90 );
  fieldTypeByValue.emplace( 90, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 90, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<91>(), FixSecureData );
  tagNameByValue.emplace( 91, FixSecureData );
  tagByName.emplace( FixSecureData, 91 );
  fieldTypeByValue.emplace( 91, FieldType::DATA );
  fieldTypeNameByValue.emplace( 91, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<93>(), FixSignatureLength );
  tagNameByValue.emplace( 93, FixSignatureLength );
  tagByName.emplace( FixSignatureLength, 93 );
  fieldTypeByValue.emplace( 93, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 93, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<94>(), FixEmailType );
  tagNameByValue.emplace( 94, FixEmailType );
  tagByName.emplace( FixEmailType, 94 );
  fieldTypeByValue.emplace( 94, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 94, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<95>(), FixRawDataLength );
  tagNameByValue.emplace( 95, FixRawDataLength );
  tagByName.emplace( FixRawDataLength, 95 );
  fieldTypeByValue.emplace( 95, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 95, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<96>(), FixRawData );
  tagNameByValue.emplace( 96, FixRawData );
  tagByName.emplace( FixRawData, 96 );
  fieldTypeByValue.emplace( 96, FieldType::DATA );
  fieldTypeNameByValue.emplace( 96, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<97>(), FixPossResend );
  tagNameByValue.emplace( 97, FixPossResend );
  tagByName.emplace( FixPossResend, 97 );
  fieldTypeByValue.emplace( 97, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 97, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<98>(), FixEncryptMethod );
  tagNameByValue.emplace( 98, FixEncryptMethod );
  tagByName.emplace( FixEncryptMethod, 98 );
  fieldTypeByValue.emplace( 98, FieldType::INT );
  fieldTypeNameByValue.emplace( 98, "INT" );

  tagNameByRaw.emplace( tag_as_raw<99>(), FixStopPx );
  tagNameByValue.emplace( 99, FixStopPx );
  tagByName.emplace( FixStopPx, 99 );
  fieldTypeByValue.emplace( 99, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 99, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<100>(), FixExDestination );
  tagNameByValue.emplace( 100, FixExDestination );
  tagByName.emplace( FixExDestination, 100 );
  fieldTypeByValue.emplace( 100, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 100, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<102>(), FixCxlRejReason );
  tagNameByValue.emplace( 102, FixCxlRejReason );
  tagByName.emplace( FixCxlRejReason, 102 );
  fieldTypeByValue.emplace( 102, FieldType::INT );
  fieldTypeNameByValue.emplace( 102, "INT" );

  tagNameByRaw.emplace( tag_as_raw<103>(), FixOrdRejReason );
  tagNameByValue.emplace( 103, FixOrdRejReason );
  tagByName.emplace( FixOrdRejReason, 103 );
  fieldTypeByValue.emplace( 103, FieldType::INT );
  fieldTypeNameByValue.emplace( 103, "INT" );

  tagNameByRaw.emplace( tag_as_raw<104>(), FixIOIQualifier );
  tagNameByValue.emplace( 104, FixIOIQualifier );
  tagByName.emplace( FixIOIQualifier, 104 );
  fieldTypeByValue.emplace( 104, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 104, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<106>(), FixIssuer );
  tagNameByValue.emplace( 106, FixIssuer );
  tagByName.emplace( FixIssuer, 106 );
  fieldTypeByValue.emplace( 106, FieldType::STRING );
  fieldTypeNameByValue.emplace( 106, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<107>(), FixSecurityDesc );
  tagNameByValue.emplace( 107, FixSecurityDesc );
  tagByName.emplace( FixSecurityDesc, 107 );
  fieldTypeByValue.emplace( 107, FieldType::STRING );
  fieldTypeNameByValue.emplace( 107, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<108>(), FixHeartBtInt );
  tagNameByValue.emplace( 108, FixHeartBtInt );
  tagByName.emplace( FixHeartBtInt, 108 );
  fieldTypeByValue.emplace( 108, FieldType::INT );
  fieldTypeNameByValue.emplace( 108, "INT" );

  tagNameByRaw.emplace( tag_as_raw<110>(), FixMinQty );
  tagNameByValue.emplace( 110, FixMinQty );
  tagByName.emplace( FixMinQty, 110 );
  fieldTypeByValue.emplace( 110, FieldType::QTY );
  fieldTypeNameByValue.emplace( 110, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<111>(), FixMaxFloor );
  tagNameByValue.emplace( 111, FixMaxFloor );
  tagByName.emplace( FixMaxFloor, 111 );
  fieldTypeByValue.emplace( 111, FieldType::QTY );
  fieldTypeNameByValue.emplace( 111, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<112>(), FixTestReqID );
  tagNameByValue.emplace( 112, FixTestReqID );
  tagByName.emplace( FixTestReqID, 112 );
  fieldTypeByValue.emplace( 112, FieldType::STRING );
  fieldTypeNameByValue.emplace( 112, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<113>(), FixReportToExch );
  tagNameByValue.emplace( 113, FixReportToExch );
  tagByName.emplace( FixReportToExch, 113 );
  fieldTypeByValue.emplace( 113, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 113, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<114>(), FixLocateReqd );
  tagNameByValue.emplace( 114, FixLocateReqd );
  tagByName.emplace( FixLocateReqd, 114 );
  fieldTypeByValue.emplace( 114, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 114, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<115>(), FixOnBehalfOfCompID );
  tagNameByValue.emplace( 115, FixOnBehalfOfCompID );
  tagByName.emplace( FixOnBehalfOfCompID, 115 );
  fieldTypeByValue.emplace( 115, FieldType::STRING );
  fieldTypeNameByValue.emplace( 115, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<116>(), FixOnBehalfOfSubID );
  tagNameByValue.emplace( 116, FixOnBehalfOfSubID );
  tagByName.emplace( FixOnBehalfOfSubID, 116 );
  fieldTypeByValue.emplace( 116, FieldType::STRING );
  fieldTypeNameByValue.emplace( 116, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<117>(), FixQuoteID );
  tagNameByValue.emplace( 117, FixQuoteID );
  tagByName.emplace( FixQuoteID, 117 );
  fieldTypeByValue.emplace( 117, FieldType::STRING );
  fieldTypeNameByValue.emplace( 117, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<118>(), FixNetMoney );
  tagNameByValue.emplace( 118, FixNetMoney );
  tagByName.emplace( FixNetMoney, 118 );
  fieldTypeByValue.emplace( 118, FieldType::AMT );
  fieldTypeNameByValue.emplace( 118, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<119>(), FixSettlCurrAmt );
  tagNameByValue.emplace( 119, FixSettlCurrAmt );
  tagByName.emplace( FixSettlCurrAmt, 119 );
  fieldTypeByValue.emplace( 119, FieldType::AMT );
  fieldTypeNameByValue.emplace( 119, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<120>(), FixSettlCurrency );
  tagNameByValue.emplace( 120, FixSettlCurrency );
  tagByName.emplace( FixSettlCurrency, 120 );
  fieldTypeByValue.emplace( 120, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 120, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<121>(), FixForexReq );
  tagNameByValue.emplace( 121, FixForexReq );
  tagByName.emplace( FixForexReq, 121 );
  fieldTypeByValue.emplace( 121, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 121, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<122>(), FixOrigSendingTime );
  tagNameByValue.emplace( 122, FixOrigSendingTime );
  tagByName.emplace( FixOrigSendingTime, 122 );
  fieldTypeByValue.emplace( 122, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 122, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<123>(), FixGapFillFlag );
  tagNameByValue.emplace( 123, FixGapFillFlag );
  tagByName.emplace( FixGapFillFlag, 123 );
  fieldTypeByValue.emplace( 123, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 123, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<124>(), FixNoExecs );
  tagNameByValue.emplace( 124, FixNoExecs );
  tagByName.emplace( FixNoExecs, 124 );
  fieldTypeByValue.emplace( 124, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 124, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<126>(), FixExpireTime );
  tagNameByValue.emplace( 126, FixExpireTime );
  tagByName.emplace( FixExpireTime, 126 );
  fieldTypeByValue.emplace( 126, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 126, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<127>(), FixDKReason );
  tagNameByValue.emplace( 127, FixDKReason );
  tagByName.emplace( FixDKReason, 127 );
  fieldTypeByValue.emplace( 127, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 127, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<128>(), FixDeliverToCompID );
  tagNameByValue.emplace( 128, FixDeliverToCompID );
  tagByName.emplace( FixDeliverToCompID, 128 );
  fieldTypeByValue.emplace( 128, FieldType::STRING );
  fieldTypeNameByValue.emplace( 128, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<129>(), FixDeliverToSubID );
  tagNameByValue.emplace( 129, FixDeliverToSubID );
  tagByName.emplace( FixDeliverToSubID, 129 );
  fieldTypeByValue.emplace( 129, FieldType::STRING );
  fieldTypeNameByValue.emplace( 129, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<130>(), FixIOINaturalFlag );
  tagNameByValue.emplace( 130, FixIOINaturalFlag );
  tagByName.emplace( FixIOINaturalFlag, 130 );
  fieldTypeByValue.emplace( 130, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 130, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<131>(), FixQuoteReqID );
  tagNameByValue.emplace( 131, FixQuoteReqID );
  tagByName.emplace( FixQuoteReqID, 131 );
  fieldTypeByValue.emplace( 131, FieldType::STRING );
  fieldTypeNameByValue.emplace( 131, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<132>(), FixBidPx );
  tagNameByValue.emplace( 132, FixBidPx );
  tagByName.emplace( FixBidPx, 132 );
  fieldTypeByValue.emplace( 132, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 132, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<133>(), FixOfferPx );
  tagNameByValue.emplace( 133, FixOfferPx );
  tagByName.emplace( FixOfferPx, 133 );
  fieldTypeByValue.emplace( 133, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 133, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<134>(), FixBidSize );
  tagNameByValue.emplace( 134, FixBidSize );
  tagByName.emplace( FixBidSize, 134 );
  fieldTypeByValue.emplace( 134, FieldType::QTY );
  fieldTypeNameByValue.emplace( 134, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<135>(), FixOfferSize );
  tagNameByValue.emplace( 135, FixOfferSize );
  tagByName.emplace( FixOfferSize, 135 );
  fieldTypeByValue.emplace( 135, FieldType::QTY );
  fieldTypeNameByValue.emplace( 135, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<136>(), FixNoMiscFees );
  tagNameByValue.emplace( 136, FixNoMiscFees );
  tagByName.emplace( FixNoMiscFees, 136 );
  fieldTypeByValue.emplace( 136, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 136, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<137>(), FixMiscFeeAmt );
  tagNameByValue.emplace( 137, FixMiscFeeAmt );
  tagByName.emplace( FixMiscFeeAmt, 137 );
  fieldTypeByValue.emplace( 137, FieldType::AMT );
  fieldTypeNameByValue.emplace( 137, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<138>(), FixMiscFeeCurr );
  tagNameByValue.emplace( 138, FixMiscFeeCurr );
  tagByName.emplace( FixMiscFeeCurr, 138 );
  fieldTypeByValue.emplace( 138, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 138, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<139>(), FixMiscFeeType );
  tagNameByValue.emplace( 139, FixMiscFeeType );
  tagByName.emplace( FixMiscFeeType, 139 );
  fieldTypeByValue.emplace( 139, FieldType::STRING );
  fieldTypeNameByValue.emplace( 139, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<140>(), FixPrevClosePx );
  tagNameByValue.emplace( 140, FixPrevClosePx );
  tagByName.emplace( FixPrevClosePx, 140 );
  fieldTypeByValue.emplace( 140, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 140, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<141>(), FixResetSeqNumFlag );
  tagNameByValue.emplace( 141, FixResetSeqNumFlag );
  tagByName.emplace( FixResetSeqNumFlag, 141 );
  fieldTypeByValue.emplace( 141, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 141, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<142>(), FixSenderLocationID );
  tagNameByValue.emplace( 142, FixSenderLocationID );
  tagByName.emplace( FixSenderLocationID, 142 );
  fieldTypeByValue.emplace( 142, FieldType::STRING );
  fieldTypeNameByValue.emplace( 142, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<143>(), FixTargetLocationID );
  tagNameByValue.emplace( 143, FixTargetLocationID );
  tagByName.emplace( FixTargetLocationID, 143 );
  fieldTypeByValue.emplace( 143, FieldType::STRING );
  fieldTypeNameByValue.emplace( 143, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<144>(), FixOnBehalfOfLocationID );
  tagNameByValue.emplace( 144, FixOnBehalfOfLocationID );
  tagByName.emplace( FixOnBehalfOfLocationID, 144 );
  fieldTypeByValue.emplace( 144, FieldType::STRING );
  fieldTypeNameByValue.emplace( 144, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<145>(), FixDeliverToLocationID );
  tagNameByValue.emplace( 145, FixDeliverToLocationID );
  tagByName.emplace( FixDeliverToLocationID, 145 );
  fieldTypeByValue.emplace( 145, FieldType::STRING );
  fieldTypeNameByValue.emplace( 145, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<146>(), FixNoRelatedSym );
  tagNameByValue.emplace( 146, FixNoRelatedSym );
  tagByName.emplace( FixNoRelatedSym, 146 );
  fieldTypeByValue.emplace( 146, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 146, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<147>(), FixSubject );
  tagNameByValue.emplace( 147, FixSubject );
  tagByName.emplace( FixSubject, 147 );
  fieldTypeByValue.emplace( 147, FieldType::STRING );
  fieldTypeNameByValue.emplace( 147, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<148>(), FixHeadline );
  tagNameByValue.emplace( 148, FixHeadline );
  tagByName.emplace( FixHeadline, 148 );
  fieldTypeByValue.emplace( 148, FieldType::STRING );
  fieldTypeNameByValue.emplace( 148, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<149>(), FixURLLink );
  tagNameByValue.emplace( 149, FixURLLink );
  tagByName.emplace( FixURLLink, 149 );
  fieldTypeByValue.emplace( 149, FieldType::STRING );
  fieldTypeNameByValue.emplace( 149, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<150>(), FixExecType );
  tagNameByValue.emplace( 150, FixExecType );
  tagByName.emplace( FixExecType, 150 );
  fieldTypeByValue.emplace( 150, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 150, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<151>(), FixLeavesQty );
  tagNameByValue.emplace( 151, FixLeavesQty );
  tagByName.emplace( FixLeavesQty, 151 );
  fieldTypeByValue.emplace( 151, FieldType::QTY );
  fieldTypeNameByValue.emplace( 151, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<152>(), FixCashOrderQty );
  tagNameByValue.emplace( 152, FixCashOrderQty );
  tagByName.emplace( FixCashOrderQty, 152 );
  fieldTypeByValue.emplace( 152, FieldType::QTY );
  fieldTypeNameByValue.emplace( 152, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<153>(), FixAllocAvgPx );
  tagNameByValue.emplace( 153, FixAllocAvgPx );
  tagByName.emplace( FixAllocAvgPx, 153 );
  fieldTypeByValue.emplace( 153, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 153, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<154>(), FixAllocNetMoney );
  tagNameByValue.emplace( 154, FixAllocNetMoney );
  tagByName.emplace( FixAllocNetMoney, 154 );
  fieldTypeByValue.emplace( 154, FieldType::AMT );
  fieldTypeNameByValue.emplace( 154, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<155>(), FixSettlCurrFxRate );
  tagNameByValue.emplace( 155, FixSettlCurrFxRate );
  tagByName.emplace( FixSettlCurrFxRate, 155 );
  fieldTypeByValue.emplace( 155, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 155, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<156>(), FixSettlCurrFxRateCalc );
  tagNameByValue.emplace( 156, FixSettlCurrFxRateCalc );
  tagByName.emplace( FixSettlCurrFxRateCalc, 156 );
  fieldTypeByValue.emplace( 156, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 156, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<157>(), FixNumDaysInterest );
  tagNameByValue.emplace( 157, FixNumDaysInterest );
  tagByName.emplace( FixNumDaysInterest, 157 );
  fieldTypeByValue.emplace( 157, FieldType::INT );
  fieldTypeNameByValue.emplace( 157, "INT" );

  tagNameByRaw.emplace( tag_as_raw<158>(), FixAccruedInterestRate );
  tagNameByValue.emplace( 158, FixAccruedInterestRate );
  tagByName.emplace( FixAccruedInterestRate, 158 );
  fieldTypeByValue.emplace( 158, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 158, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<159>(), FixAccruedInterestAmt );
  tagNameByValue.emplace( 159, FixAccruedInterestAmt );
  tagByName.emplace( FixAccruedInterestAmt, 159 );
  fieldTypeByValue.emplace( 159, FieldType::AMT );
  fieldTypeNameByValue.emplace( 159, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<160>(), FixSettlInstMode );
  tagNameByValue.emplace( 160, FixSettlInstMode );
  tagByName.emplace( FixSettlInstMode, 160 );
  fieldTypeByValue.emplace( 160, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 160, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<161>(), FixAllocText );
  tagNameByValue.emplace( 161, FixAllocText );
  tagByName.emplace( FixAllocText, 161 );
  fieldTypeByValue.emplace( 161, FieldType::STRING );
  fieldTypeNameByValue.emplace( 161, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<162>(), FixSettlInstID );
  tagNameByValue.emplace( 162, FixSettlInstID );
  tagByName.emplace( FixSettlInstID, 162 );
  fieldTypeByValue.emplace( 162, FieldType::STRING );
  fieldTypeNameByValue.emplace( 162, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<163>(), FixSettlInstTransType );
  tagNameByValue.emplace( 163, FixSettlInstTransType );
  tagByName.emplace( FixSettlInstTransType, 163 );
  fieldTypeByValue.emplace( 163, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 163, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<164>(), FixEmailThreadID );
  tagNameByValue.emplace( 164, FixEmailThreadID );
  tagByName.emplace( FixEmailThreadID, 164 );
  fieldTypeByValue.emplace( 164, FieldType::STRING );
  fieldTypeNameByValue.emplace( 164, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<165>(), FixSettlInstSource );
  tagNameByValue.emplace( 165, FixSettlInstSource );
  tagByName.emplace( FixSettlInstSource, 165 );
  fieldTypeByValue.emplace( 165, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 165, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<167>(), FixSecurityType );
  tagNameByValue.emplace( 167, FixSecurityType );
  tagByName.emplace( FixSecurityType, 167 );
  fieldTypeByValue.emplace( 167, FieldType::STRING );
  fieldTypeNameByValue.emplace( 167, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<168>(), FixEffectiveTime );
  tagNameByValue.emplace( 168, FixEffectiveTime );
  tagByName.emplace( FixEffectiveTime, 168 );
  fieldTypeByValue.emplace( 168, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 168, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<169>(), FixStandInstDbType );
  tagNameByValue.emplace( 169, FixStandInstDbType );
  tagByName.emplace( FixStandInstDbType, 169 );
  fieldTypeByValue.emplace( 169, FieldType::INT );
  fieldTypeNameByValue.emplace( 169, "INT" );

  tagNameByRaw.emplace( tag_as_raw<170>(), FixStandInstDbName );
  tagNameByValue.emplace( 170, FixStandInstDbName );
  tagByName.emplace( FixStandInstDbName, 170 );
  fieldTypeByValue.emplace( 170, FieldType::STRING );
  fieldTypeNameByValue.emplace( 170, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<171>(), FixStandInstDbID );
  tagNameByValue.emplace( 171, FixStandInstDbID );
  tagByName.emplace( FixStandInstDbID, 171 );
  fieldTypeByValue.emplace( 171, FieldType::STRING );
  fieldTypeNameByValue.emplace( 171, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<172>(), FixSettlDeliveryType );
  tagNameByValue.emplace( 172, FixSettlDeliveryType );
  tagByName.emplace( FixSettlDeliveryType, 172 );
  fieldTypeByValue.emplace( 172, FieldType::INT );
  fieldTypeNameByValue.emplace( 172, "INT" );

  tagNameByRaw.emplace( tag_as_raw<188>(), FixBidSpotRate );
  tagNameByValue.emplace( 188, FixBidSpotRate );
  tagByName.emplace( FixBidSpotRate, 188 );
  fieldTypeByValue.emplace( 188, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 188, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<189>(), FixBidForwardPoints );
  tagNameByValue.emplace( 189, FixBidForwardPoints );
  tagByName.emplace( FixBidForwardPoints, 189 );
  fieldTypeByValue.emplace( 189, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 189, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<190>(), FixOfferSpotRate );
  tagNameByValue.emplace( 190, FixOfferSpotRate );
  tagByName.emplace( FixOfferSpotRate, 190 );
  fieldTypeByValue.emplace( 190, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 190, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<191>(), FixOfferForwardPoints );
  tagNameByValue.emplace( 191, FixOfferForwardPoints );
  tagByName.emplace( FixOfferForwardPoints, 191 );
  fieldTypeByValue.emplace( 191, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 191, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<192>(), FixOrderQty2 );
  tagNameByValue.emplace( 192, FixOrderQty2 );
  tagByName.emplace( FixOrderQty2, 192 );
  fieldTypeByValue.emplace( 192, FieldType::QTY );
  fieldTypeNameByValue.emplace( 192, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<193>(), FixSettlDate2 );
  tagNameByValue.emplace( 193, FixSettlDate2 );
  tagByName.emplace( FixSettlDate2, 193 );
  fieldTypeByValue.emplace( 193, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 193, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<194>(), FixLastSpotRate );
  tagNameByValue.emplace( 194, FixLastSpotRate );
  tagByName.emplace( FixLastSpotRate, 194 );
  fieldTypeByValue.emplace( 194, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 194, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<195>(), FixLastForwardPoints );
  tagNameByValue.emplace( 195, FixLastForwardPoints );
  tagByName.emplace( FixLastForwardPoints, 195 );
  fieldTypeByValue.emplace( 195, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 195, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<196>(), FixAllocLinkID );
  tagNameByValue.emplace( 196, FixAllocLinkID );
  tagByName.emplace( FixAllocLinkID, 196 );
  fieldTypeByValue.emplace( 196, FieldType::STRING );
  fieldTypeNameByValue.emplace( 196, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<197>(), FixAllocLinkType );
  tagNameByValue.emplace( 197, FixAllocLinkType );
  tagByName.emplace( FixAllocLinkType, 197 );
  fieldTypeByValue.emplace( 197, FieldType::INT );
  fieldTypeNameByValue.emplace( 197, "INT" );

  tagNameByRaw.emplace( tag_as_raw<198>(), FixSecondaryOrderID );
  tagNameByValue.emplace( 198, FixSecondaryOrderID );
  tagByName.emplace( FixSecondaryOrderID, 198 );
  fieldTypeByValue.emplace( 198, FieldType::STRING );
  fieldTypeNameByValue.emplace( 198, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<199>(), FixNoIOIQualifiers );
  tagNameByValue.emplace( 199, FixNoIOIQualifiers );
  tagByName.emplace( FixNoIOIQualifiers, 199 );
  fieldTypeByValue.emplace( 199, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 199, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<200>(), FixMaturityMonthYear );
  tagNameByValue.emplace( 200, FixMaturityMonthYear );
  tagByName.emplace( FixMaturityMonthYear, 200 );
  fieldTypeByValue.emplace( 200, FieldType::MONTHYEAR );
  fieldTypeNameByValue.emplace( 200, "MONTHYEAR" );

  tagNameByRaw.emplace( tag_as_raw<201>(), FixPutOrCall );
  tagNameByValue.emplace( 201, FixPutOrCall );
  tagByName.emplace( FixPutOrCall, 201 );
  fieldTypeByValue.emplace( 201, FieldType::INT );
  fieldTypeNameByValue.emplace( 201, "INT" );

  tagNameByRaw.emplace( tag_as_raw<202>(), FixStrikePrice );
  tagNameByValue.emplace( 202, FixStrikePrice );
  tagByName.emplace( FixStrikePrice, 202 );
  fieldTypeByValue.emplace( 202, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 202, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<203>(), FixCoveredOrUncovered );
  tagNameByValue.emplace( 203, FixCoveredOrUncovered );
  tagByName.emplace( FixCoveredOrUncovered, 203 );
  fieldTypeByValue.emplace( 203, FieldType::INT );
  fieldTypeNameByValue.emplace( 203, "INT" );

  tagNameByRaw.emplace( tag_as_raw<206>(), FixOptAttribute );
  tagNameByValue.emplace( 206, FixOptAttribute );
  tagByName.emplace( FixOptAttribute, 206 );
  fieldTypeByValue.emplace( 206, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 206, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<207>(), FixSecurityExchange );
  tagNameByValue.emplace( 207, FixSecurityExchange );
  tagByName.emplace( FixSecurityExchange, 207 );
  fieldTypeByValue.emplace( 207, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 207, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<208>(), FixNotifyBrokerOfCredit );
  tagNameByValue.emplace( 208, FixNotifyBrokerOfCredit );
  tagByName.emplace( FixNotifyBrokerOfCredit, 208 );
  fieldTypeByValue.emplace( 208, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 208, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<209>(), FixAllocHandlInst );
  tagNameByValue.emplace( 209, FixAllocHandlInst );
  tagByName.emplace( FixAllocHandlInst, 209 );
  fieldTypeByValue.emplace( 209, FieldType::INT );
  fieldTypeNameByValue.emplace( 209, "INT" );

  tagNameByRaw.emplace( tag_as_raw<210>(), FixMaxShow );
  tagNameByValue.emplace( 210, FixMaxShow );
  tagByName.emplace( FixMaxShow, 210 );
  fieldTypeByValue.emplace( 210, FieldType::QTY );
  fieldTypeNameByValue.emplace( 210, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<211>(), FixPegOffsetValue );
  tagNameByValue.emplace( 211, FixPegOffsetValue );
  tagByName.emplace( FixPegOffsetValue, 211 );
  fieldTypeByValue.emplace( 211, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 211, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<212>(), FixXmlDataLen );
  tagNameByValue.emplace( 212, FixXmlDataLen );
  tagByName.emplace( FixXmlDataLen, 212 );
  fieldTypeByValue.emplace( 212, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 212, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<213>(), FixXmlData );
  tagNameByValue.emplace( 213, FixXmlData );
  tagByName.emplace( FixXmlData, 213 );
  fieldTypeByValue.emplace( 213, FieldType::DATA );
  fieldTypeNameByValue.emplace( 213, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<214>(), FixSettlInstRefID );
  tagNameByValue.emplace( 214, FixSettlInstRefID );
  tagByName.emplace( FixSettlInstRefID, 214 );
  fieldTypeByValue.emplace( 214, FieldType::STRING );
  fieldTypeNameByValue.emplace( 214, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<215>(), FixNoRoutingIDs );
  tagNameByValue.emplace( 215, FixNoRoutingIDs );
  tagByName.emplace( FixNoRoutingIDs, 215 );
  fieldTypeByValue.emplace( 215, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 215, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<216>(), FixRoutingType );
  tagNameByValue.emplace( 216, FixRoutingType );
  tagByName.emplace( FixRoutingType, 216 );
  fieldTypeByValue.emplace( 216, FieldType::INT );
  fieldTypeNameByValue.emplace( 216, "INT" );

  tagNameByRaw.emplace( tag_as_raw<217>(), FixRoutingID );
  tagNameByValue.emplace( 217, FixRoutingID );
  tagByName.emplace( FixRoutingID, 217 );
  fieldTypeByValue.emplace( 217, FieldType::STRING );
  fieldTypeNameByValue.emplace( 217, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<218>(), FixSpread );
  tagNameByValue.emplace( 218, FixSpread );
  tagByName.emplace( FixSpread, 218 );
  fieldTypeByValue.emplace( 218, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 218, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<220>(), FixBenchmarkCurveCurrency );
  tagNameByValue.emplace( 220, FixBenchmarkCurveCurrency );
  tagByName.emplace( FixBenchmarkCurveCurrency, 220 );
  fieldTypeByValue.emplace( 220, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 220, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<221>(), FixBenchmarkCurveName );
  tagNameByValue.emplace( 221, FixBenchmarkCurveName );
  tagByName.emplace( FixBenchmarkCurveName, 221 );
  fieldTypeByValue.emplace( 221, FieldType::STRING );
  fieldTypeNameByValue.emplace( 221, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<222>(), FixBenchmarkCurvePoint );
  tagNameByValue.emplace( 222, FixBenchmarkCurvePoint );
  tagByName.emplace( FixBenchmarkCurvePoint, 222 );
  fieldTypeByValue.emplace( 222, FieldType::STRING );
  fieldTypeNameByValue.emplace( 222, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<223>(), FixCouponRate );
  tagNameByValue.emplace( 223, FixCouponRate );
  tagByName.emplace( FixCouponRate, 223 );
  fieldTypeByValue.emplace( 223, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 223, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<224>(), FixCouponPaymentDate );
  tagNameByValue.emplace( 224, FixCouponPaymentDate );
  tagByName.emplace( FixCouponPaymentDate, 224 );
  fieldTypeByValue.emplace( 224, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 224, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<225>(), FixIssueDate );
  tagNameByValue.emplace( 225, FixIssueDate );
  tagByName.emplace( FixIssueDate, 225 );
  fieldTypeByValue.emplace( 225, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 225, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<226>(), FixRepurchaseTerm );
  tagNameByValue.emplace( 226, FixRepurchaseTerm );
  tagByName.emplace( FixRepurchaseTerm, 226 );
  fieldTypeByValue.emplace( 226, FieldType::INT );
  fieldTypeNameByValue.emplace( 226, "INT" );

  tagNameByRaw.emplace( tag_as_raw<227>(), FixRepurchaseRate );
  tagNameByValue.emplace( 227, FixRepurchaseRate );
  tagByName.emplace( FixRepurchaseRate, 227 );
  fieldTypeByValue.emplace( 227, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 227, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<228>(), FixFactor );
  tagNameByValue.emplace( 228, FixFactor );
  tagByName.emplace( FixFactor, 228 );
  fieldTypeByValue.emplace( 228, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 228, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<229>(), FixTradeOriginationDate );
  tagNameByValue.emplace( 229, FixTradeOriginationDate );
  tagByName.emplace( FixTradeOriginationDate, 229 );
  fieldTypeByValue.emplace( 229, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 229, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<230>(), FixExDate );
  tagNameByValue.emplace( 230, FixExDate );
  tagByName.emplace( FixExDate, 230 );
  fieldTypeByValue.emplace( 230, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 230, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<231>(), FixContractMultiplier );
  tagNameByValue.emplace( 231, FixContractMultiplier );
  tagByName.emplace( FixContractMultiplier, 231 );
  fieldTypeByValue.emplace( 231, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 231, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<232>(), FixNoStipulations );
  tagNameByValue.emplace( 232, FixNoStipulations );
  tagByName.emplace( FixNoStipulations, 232 );
  fieldTypeByValue.emplace( 232, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 232, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<233>(), FixStipulationType );
  tagNameByValue.emplace( 233, FixStipulationType );
  tagByName.emplace( FixStipulationType, 233 );
  fieldTypeByValue.emplace( 233, FieldType::STRING );
  fieldTypeNameByValue.emplace( 233, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<234>(), FixStipulationValue );
  tagNameByValue.emplace( 234, FixStipulationValue );
  tagByName.emplace( FixStipulationValue, 234 );
  fieldTypeByValue.emplace( 234, FieldType::STRING );
  fieldTypeNameByValue.emplace( 234, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<235>(), FixYieldType );
  tagNameByValue.emplace( 235, FixYieldType );
  tagByName.emplace( FixYieldType, 235 );
  fieldTypeByValue.emplace( 235, FieldType::STRING );
  fieldTypeNameByValue.emplace( 235, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<236>(), FixYield );
  tagNameByValue.emplace( 236, FixYield );
  tagByName.emplace( FixYield, 236 );
  fieldTypeByValue.emplace( 236, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 236, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<237>(), FixTotalTakedown );
  tagNameByValue.emplace( 237, FixTotalTakedown );
  tagByName.emplace( FixTotalTakedown, 237 );
  fieldTypeByValue.emplace( 237, FieldType::AMT );
  fieldTypeNameByValue.emplace( 237, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<238>(), FixConcession );
  tagNameByValue.emplace( 238, FixConcession );
  tagByName.emplace( FixConcession, 238 );
  fieldTypeByValue.emplace( 238, FieldType::AMT );
  fieldTypeNameByValue.emplace( 238, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<239>(), FixRepoCollateralSecurityType );
  tagNameByValue.emplace( 239, FixRepoCollateralSecurityType );
  tagByName.emplace( FixRepoCollateralSecurityType, 239 );
  fieldTypeByValue.emplace( 239, FieldType::STRING );
  fieldTypeNameByValue.emplace( 239, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<240>(), FixRedemptionDate );
  tagNameByValue.emplace( 240, FixRedemptionDate );
  tagByName.emplace( FixRedemptionDate, 240 );
  fieldTypeByValue.emplace( 240, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 240, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<241>(), FixUnderlyingCouponPaymentDate );
  tagNameByValue.emplace( 241, FixUnderlyingCouponPaymentDate );
  tagByName.emplace( FixUnderlyingCouponPaymentDate, 241 );
  fieldTypeByValue.emplace( 241, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 241, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<242>(), FixUnderlyingIssueDate );
  tagNameByValue.emplace( 242, FixUnderlyingIssueDate );
  tagByName.emplace( FixUnderlyingIssueDate, 242 );
  fieldTypeByValue.emplace( 242, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 242, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<243>(), FixUnderlyingRepoCollateralSecurityType );
  tagNameByValue.emplace( 243, FixUnderlyingRepoCollateralSecurityType );
  tagByName.emplace( FixUnderlyingRepoCollateralSecurityType, 243 );
  fieldTypeByValue.emplace( 243, FieldType::STRING );
  fieldTypeNameByValue.emplace( 243, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<244>(), FixUnderlyingRepurchaseTerm );
  tagNameByValue.emplace( 244, FixUnderlyingRepurchaseTerm );
  tagByName.emplace( FixUnderlyingRepurchaseTerm, 244 );
  fieldTypeByValue.emplace( 244, FieldType::INT );
  fieldTypeNameByValue.emplace( 244, "INT" );

  tagNameByRaw.emplace( tag_as_raw<245>(), FixUnderlyingRepurchaseRate );
  tagNameByValue.emplace( 245, FixUnderlyingRepurchaseRate );
  tagByName.emplace( FixUnderlyingRepurchaseRate, 245 );
  fieldTypeByValue.emplace( 245, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 245, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<246>(), FixUnderlyingFactor );
  tagNameByValue.emplace( 246, FixUnderlyingFactor );
  tagByName.emplace( FixUnderlyingFactor, 246 );
  fieldTypeByValue.emplace( 246, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 246, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<247>(), FixUnderlyingRedemptionDate );
  tagNameByValue.emplace( 247, FixUnderlyingRedemptionDate );
  tagByName.emplace( FixUnderlyingRedemptionDate, 247 );
  fieldTypeByValue.emplace( 247, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 247, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<248>(), FixLegCouponPaymentDate );
  tagNameByValue.emplace( 248, FixLegCouponPaymentDate );
  tagByName.emplace( FixLegCouponPaymentDate, 248 );
  fieldTypeByValue.emplace( 248, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 248, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<249>(), FixLegIssueDate );
  tagNameByValue.emplace( 249, FixLegIssueDate );
  tagByName.emplace( FixLegIssueDate, 249 );
  fieldTypeByValue.emplace( 249, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 249, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<250>(), FixLegRepoCollateralSecurityType );
  tagNameByValue.emplace( 250, FixLegRepoCollateralSecurityType );
  tagByName.emplace( FixLegRepoCollateralSecurityType, 250 );
  fieldTypeByValue.emplace( 250, FieldType::STRING );
  fieldTypeNameByValue.emplace( 250, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<251>(), FixLegRepurchaseTerm );
  tagNameByValue.emplace( 251, FixLegRepurchaseTerm );
  tagByName.emplace( FixLegRepurchaseTerm, 251 );
  fieldTypeByValue.emplace( 251, FieldType::INT );
  fieldTypeNameByValue.emplace( 251, "INT" );

  tagNameByRaw.emplace( tag_as_raw<252>(), FixLegRepurchaseRate );
  tagNameByValue.emplace( 252, FixLegRepurchaseRate );
  tagByName.emplace( FixLegRepurchaseRate, 252 );
  fieldTypeByValue.emplace( 252, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 252, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<253>(), FixLegFactor );
  tagNameByValue.emplace( 253, FixLegFactor );
  tagByName.emplace( FixLegFactor, 253 );
  fieldTypeByValue.emplace( 253, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 253, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<254>(), FixLegRedemptionDate );
  tagNameByValue.emplace( 254, FixLegRedemptionDate );
  tagByName.emplace( FixLegRedemptionDate, 254 );
  fieldTypeByValue.emplace( 254, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 254, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<255>(), FixCreditRating );
  tagNameByValue.emplace( 255, FixCreditRating );
  tagByName.emplace( FixCreditRating, 255 );
  fieldTypeByValue.emplace( 255, FieldType::STRING );
  fieldTypeNameByValue.emplace( 255, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<256>(), FixUnderlyingCreditRating );
  tagNameByValue.emplace( 256, FixUnderlyingCreditRating );
  tagByName.emplace( FixUnderlyingCreditRating, 256 );
  fieldTypeByValue.emplace( 256, FieldType::STRING );
  fieldTypeNameByValue.emplace( 256, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<257>(), FixLegCreditRating );
  tagNameByValue.emplace( 257, FixLegCreditRating );
  tagByName.emplace( FixLegCreditRating, 257 );
  fieldTypeByValue.emplace( 257, FieldType::STRING );
  fieldTypeNameByValue.emplace( 257, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<258>(), FixTradedFlatSwitch );
  tagNameByValue.emplace( 258, FixTradedFlatSwitch );
  tagByName.emplace( FixTradedFlatSwitch, 258 );
  fieldTypeByValue.emplace( 258, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 258, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<259>(), FixBasisFeatureDate );
  tagNameByValue.emplace( 259, FixBasisFeatureDate );
  tagByName.emplace( FixBasisFeatureDate, 259 );
  fieldTypeByValue.emplace( 259, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 259, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<260>(), FixBasisFeaturePrice );
  tagNameByValue.emplace( 260, FixBasisFeaturePrice );
  tagByName.emplace( FixBasisFeaturePrice, 260 );
  fieldTypeByValue.emplace( 260, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 260, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<262>(), FixMDReqID );
  tagNameByValue.emplace( 262, FixMDReqID );
  tagByName.emplace( FixMDReqID, 262 );
  fieldTypeByValue.emplace( 262, FieldType::STRING );
  fieldTypeNameByValue.emplace( 262, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<263>(), FixSubscriptionRequestType );
  tagNameByValue.emplace( 263, FixSubscriptionRequestType );
  tagByName.emplace( FixSubscriptionRequestType, 263 );
  fieldTypeByValue.emplace( 263, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 263, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<264>(), FixMarketDepth );
  tagNameByValue.emplace( 264, FixMarketDepth );
  tagByName.emplace( FixMarketDepth, 264 );
  fieldTypeByValue.emplace( 264, FieldType::INT );
  fieldTypeNameByValue.emplace( 264, "INT" );

  tagNameByRaw.emplace( tag_as_raw<265>(), FixMDUpdateType );
  tagNameByValue.emplace( 265, FixMDUpdateType );
  tagByName.emplace( FixMDUpdateType, 265 );
  fieldTypeByValue.emplace( 265, FieldType::INT );
  fieldTypeNameByValue.emplace( 265, "INT" );

  tagNameByRaw.emplace( tag_as_raw<266>(), FixAggregatedBook );
  tagNameByValue.emplace( 266, FixAggregatedBook );
  tagByName.emplace( FixAggregatedBook, 266 );
  fieldTypeByValue.emplace( 266, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 266, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<267>(), FixNoMDEntryTypes );
  tagNameByValue.emplace( 267, FixNoMDEntryTypes );
  tagByName.emplace( FixNoMDEntryTypes, 267 );
  fieldTypeByValue.emplace( 267, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 267, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<268>(), FixNoMDEntries );
  tagNameByValue.emplace( 268, FixNoMDEntries );
  tagByName.emplace( FixNoMDEntries, 268 );
  fieldTypeByValue.emplace( 268, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 268, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<269>(), FixMDEntryType );
  tagNameByValue.emplace( 269, FixMDEntryType );
  tagByName.emplace( FixMDEntryType, 269 );
  fieldTypeByValue.emplace( 269, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 269, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<270>(), FixMDEntryPx );
  tagNameByValue.emplace( 270, FixMDEntryPx );
  tagByName.emplace( FixMDEntryPx, 270 );
  fieldTypeByValue.emplace( 270, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 270, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<271>(), FixMDEntrySize );
  tagNameByValue.emplace( 271, FixMDEntrySize );
  tagByName.emplace( FixMDEntrySize, 271 );
  fieldTypeByValue.emplace( 271, FieldType::QTY );
  fieldTypeNameByValue.emplace( 271, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<272>(), FixMDEntryDate );
  tagNameByValue.emplace( 272, FixMDEntryDate );
  tagByName.emplace( FixMDEntryDate, 272 );
  fieldTypeByValue.emplace( 272, FieldType::UTCDATEONLY );
  fieldTypeNameByValue.emplace( 272, "UTCDATEONLY" );

  tagNameByRaw.emplace( tag_as_raw<273>(), FixMDEntryTime );
  tagNameByValue.emplace( 273, FixMDEntryTime );
  tagByName.emplace( FixMDEntryTime, 273 );
  fieldTypeByValue.emplace( 273, FieldType::UTCTIMEONLY );
  fieldTypeNameByValue.emplace( 273, "UTCTIMEONLY" );

  tagNameByRaw.emplace( tag_as_raw<274>(), FixTickDirection );
  tagNameByValue.emplace( 274, FixTickDirection );
  tagByName.emplace( FixTickDirection, 274 );
  fieldTypeByValue.emplace( 274, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 274, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<275>(), FixMDMkt );
  tagNameByValue.emplace( 275, FixMDMkt );
  tagByName.emplace( FixMDMkt, 275 );
  fieldTypeByValue.emplace( 275, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 275, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<276>(), FixQuoteCondition );
  tagNameByValue.emplace( 276, FixQuoteCondition );
  tagByName.emplace( FixQuoteCondition, 276 );
  fieldTypeByValue.emplace( 276, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 276, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<277>(), FixTradeCondition );
  tagNameByValue.emplace( 277, FixTradeCondition );
  tagByName.emplace( FixTradeCondition, 277 );
  fieldTypeByValue.emplace( 277, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 277, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<278>(), FixMDEntryID );
  tagNameByValue.emplace( 278, FixMDEntryID );
  tagByName.emplace( FixMDEntryID, 278 );
  fieldTypeByValue.emplace( 278, FieldType::STRING );
  fieldTypeNameByValue.emplace( 278, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<279>(), FixMDUpdateAction );
  tagNameByValue.emplace( 279, FixMDUpdateAction );
  tagByName.emplace( FixMDUpdateAction, 279 );
  fieldTypeByValue.emplace( 279, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 279, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<280>(), FixMDEntryRefID );
  tagNameByValue.emplace( 280, FixMDEntryRefID );
  tagByName.emplace( FixMDEntryRefID, 280 );
  fieldTypeByValue.emplace( 280, FieldType::STRING );
  fieldTypeNameByValue.emplace( 280, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<281>(), FixMDReqRejReason );
  tagNameByValue.emplace( 281, FixMDReqRejReason );
  tagByName.emplace( FixMDReqRejReason, 281 );
  fieldTypeByValue.emplace( 281, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 281, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<282>(), FixMDEntryOriginator );
  tagNameByValue.emplace( 282, FixMDEntryOriginator );
  tagByName.emplace( FixMDEntryOriginator, 282 );
  fieldTypeByValue.emplace( 282, FieldType::STRING );
  fieldTypeNameByValue.emplace( 282, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<283>(), FixLocationID );
  tagNameByValue.emplace( 283, FixLocationID );
  tagByName.emplace( FixLocationID, 283 );
  fieldTypeByValue.emplace( 283, FieldType::STRING );
  fieldTypeNameByValue.emplace( 283, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<284>(), FixDeskID );
  tagNameByValue.emplace( 284, FixDeskID );
  tagByName.emplace( FixDeskID, 284 );
  fieldTypeByValue.emplace( 284, FieldType::STRING );
  fieldTypeNameByValue.emplace( 284, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<285>(), FixDeleteReason );
  tagNameByValue.emplace( 285, FixDeleteReason );
  tagByName.emplace( FixDeleteReason, 285 );
  fieldTypeByValue.emplace( 285, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 285, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<286>(), FixOpenCloseSettlFlag );
  tagNameByValue.emplace( 286, FixOpenCloseSettlFlag );
  tagByName.emplace( FixOpenCloseSettlFlag, 286 );
  fieldTypeByValue.emplace( 286, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 286, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<287>(), FixSellerDays );
  tagNameByValue.emplace( 287, FixSellerDays );
  tagByName.emplace( FixSellerDays, 287 );
  fieldTypeByValue.emplace( 287, FieldType::INT );
  fieldTypeNameByValue.emplace( 287, "INT" );

  tagNameByRaw.emplace( tag_as_raw<288>(), FixMDEntryBuyer );
  tagNameByValue.emplace( 288, FixMDEntryBuyer );
  tagByName.emplace( FixMDEntryBuyer, 288 );
  fieldTypeByValue.emplace( 288, FieldType::STRING );
  fieldTypeNameByValue.emplace( 288, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<289>(), FixMDEntrySeller );
  tagNameByValue.emplace( 289, FixMDEntrySeller );
  tagByName.emplace( FixMDEntrySeller, 289 );
  fieldTypeByValue.emplace( 289, FieldType::STRING );
  fieldTypeNameByValue.emplace( 289, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<290>(), FixMDEntryPositionNo );
  tagNameByValue.emplace( 290, FixMDEntryPositionNo );
  tagByName.emplace( FixMDEntryPositionNo, 290 );
  fieldTypeByValue.emplace( 290, FieldType::INT );
  fieldTypeNameByValue.emplace( 290, "INT" );

  tagNameByRaw.emplace( tag_as_raw<291>(), FixFinancialStatus );
  tagNameByValue.emplace( 291, FixFinancialStatus );
  tagByName.emplace( FixFinancialStatus, 291 );
  fieldTypeByValue.emplace( 291, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 291, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<292>(), FixCorporateAction );
  tagNameByValue.emplace( 292, FixCorporateAction );
  tagByName.emplace( FixCorporateAction, 292 );
  fieldTypeByValue.emplace( 292, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 292, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<293>(), FixDefBidSize );
  tagNameByValue.emplace( 293, FixDefBidSize );
  tagByName.emplace( FixDefBidSize, 293 );
  fieldTypeByValue.emplace( 293, FieldType::QTY );
  fieldTypeNameByValue.emplace( 293, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<294>(), FixDefOfferSize );
  tagNameByValue.emplace( 294, FixDefOfferSize );
  tagByName.emplace( FixDefOfferSize, 294 );
  fieldTypeByValue.emplace( 294, FieldType::QTY );
  fieldTypeNameByValue.emplace( 294, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<295>(), FixNoQuoteEntries );
  tagNameByValue.emplace( 295, FixNoQuoteEntries );
  tagByName.emplace( FixNoQuoteEntries, 295 );
  fieldTypeByValue.emplace( 295, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 295, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<296>(), FixNoQuoteSets );
  tagNameByValue.emplace( 296, FixNoQuoteSets );
  tagByName.emplace( FixNoQuoteSets, 296 );
  fieldTypeByValue.emplace( 296, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 296, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<297>(), FixQuoteStatus );
  tagNameByValue.emplace( 297, FixQuoteStatus );
  tagByName.emplace( FixQuoteStatus, 297 );
  fieldTypeByValue.emplace( 297, FieldType::INT );
  fieldTypeNameByValue.emplace( 297, "INT" );

  tagNameByRaw.emplace( tag_as_raw<298>(), FixQuoteCancelType );
  tagNameByValue.emplace( 298, FixQuoteCancelType );
  tagByName.emplace( FixQuoteCancelType, 298 );
  fieldTypeByValue.emplace( 298, FieldType::INT );
  fieldTypeNameByValue.emplace( 298, "INT" );

  tagNameByRaw.emplace( tag_as_raw<299>(), FixQuoteEntryID );
  tagNameByValue.emplace( 299, FixQuoteEntryID );
  tagByName.emplace( FixQuoteEntryID, 299 );
  fieldTypeByValue.emplace( 299, FieldType::STRING );
  fieldTypeNameByValue.emplace( 299, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<300>(), FixQuoteRejectReason );
  tagNameByValue.emplace( 300, FixQuoteRejectReason );
  tagByName.emplace( FixQuoteRejectReason, 300 );
  fieldTypeByValue.emplace( 300, FieldType::INT );
  fieldTypeNameByValue.emplace( 300, "INT" );

  tagNameByRaw.emplace( tag_as_raw<301>(), FixQuoteResponseLevel );
  tagNameByValue.emplace( 301, FixQuoteResponseLevel );
  tagByName.emplace( FixQuoteResponseLevel, 301 );
  fieldTypeByValue.emplace( 301, FieldType::INT );
  fieldTypeNameByValue.emplace( 301, "INT" );

  tagNameByRaw.emplace( tag_as_raw<302>(), FixQuoteSetID );
  tagNameByValue.emplace( 302, FixQuoteSetID );
  tagByName.emplace( FixQuoteSetID, 302 );
  fieldTypeByValue.emplace( 302, FieldType::STRING );
  fieldTypeNameByValue.emplace( 302, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<303>(), FixQuoteRequestType );
  tagNameByValue.emplace( 303, FixQuoteRequestType );
  tagByName.emplace( FixQuoteRequestType, 303 );
  fieldTypeByValue.emplace( 303, FieldType::INT );
  fieldTypeNameByValue.emplace( 303, "INT" );

  tagNameByRaw.emplace( tag_as_raw<304>(), FixTotNoQuoteEntries );
  tagNameByValue.emplace( 304, FixTotNoQuoteEntries );
  tagByName.emplace( FixTotNoQuoteEntries, 304 );
  fieldTypeByValue.emplace( 304, FieldType::INT );
  fieldTypeNameByValue.emplace( 304, "INT" );

  tagNameByRaw.emplace( tag_as_raw<305>(), FixUnderlyingSecurityIDSource );
  tagNameByValue.emplace( 305, FixUnderlyingSecurityIDSource );
  tagByName.emplace( FixUnderlyingSecurityIDSource, 305 );
  fieldTypeByValue.emplace( 305, FieldType::STRING );
  fieldTypeNameByValue.emplace( 305, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<306>(), FixUnderlyingIssuer );
  tagNameByValue.emplace( 306, FixUnderlyingIssuer );
  tagByName.emplace( FixUnderlyingIssuer, 306 );
  fieldTypeByValue.emplace( 306, FieldType::STRING );
  fieldTypeNameByValue.emplace( 306, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<307>(), FixUnderlyingSecurityDesc );
  tagNameByValue.emplace( 307, FixUnderlyingSecurityDesc );
  tagByName.emplace( FixUnderlyingSecurityDesc, 307 );
  fieldTypeByValue.emplace( 307, FieldType::STRING );
  fieldTypeNameByValue.emplace( 307, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<308>(), FixUnderlyingSecurityExchange );
  tagNameByValue.emplace( 308, FixUnderlyingSecurityExchange );
  tagByName.emplace( FixUnderlyingSecurityExchange, 308 );
  fieldTypeByValue.emplace( 308, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 308, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<309>(), FixUnderlyingSecurityID );
  tagNameByValue.emplace( 309, FixUnderlyingSecurityID );
  tagByName.emplace( FixUnderlyingSecurityID, 309 );
  fieldTypeByValue.emplace( 309, FieldType::STRING );
  fieldTypeNameByValue.emplace( 309, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<310>(), FixUnderlyingSecurityType );
  tagNameByValue.emplace( 310, FixUnderlyingSecurityType );
  tagByName.emplace( FixUnderlyingSecurityType, 310 );
  fieldTypeByValue.emplace( 310, FieldType::STRING );
  fieldTypeNameByValue.emplace( 310, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<311>(), FixUnderlyingSymbol );
  tagNameByValue.emplace( 311, FixUnderlyingSymbol );
  tagByName.emplace( FixUnderlyingSymbol, 311 );
  fieldTypeByValue.emplace( 311, FieldType::STRING );
  fieldTypeNameByValue.emplace( 311, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<312>(), FixUnderlyingSymbolSfx );
  tagNameByValue.emplace( 312, FixUnderlyingSymbolSfx );
  tagByName.emplace( FixUnderlyingSymbolSfx, 312 );
  fieldTypeByValue.emplace( 312, FieldType::STRING );
  fieldTypeNameByValue.emplace( 312, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<313>(), FixUnderlyingMaturityMonthYear );
  tagNameByValue.emplace( 313, FixUnderlyingMaturityMonthYear );
  tagByName.emplace( FixUnderlyingMaturityMonthYear, 313 );
  fieldTypeByValue.emplace( 313, FieldType::MONTHYEAR );
  fieldTypeNameByValue.emplace( 313, "MONTHYEAR" );

  tagNameByRaw.emplace( tag_as_raw<315>(), FixUnderlyingPutOrCall );
  tagNameByValue.emplace( 315, FixUnderlyingPutOrCall );
  tagByName.emplace( FixUnderlyingPutOrCall, 315 );
  fieldTypeByValue.emplace( 315, FieldType::INT );
  fieldTypeNameByValue.emplace( 315, "INT" );

  tagNameByRaw.emplace( tag_as_raw<316>(), FixUnderlyingStrikePrice );
  tagNameByValue.emplace( 316, FixUnderlyingStrikePrice );
  tagByName.emplace( FixUnderlyingStrikePrice, 316 );
  fieldTypeByValue.emplace( 316, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 316, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<317>(), FixUnderlyingOptAttribute );
  tagNameByValue.emplace( 317, FixUnderlyingOptAttribute );
  tagByName.emplace( FixUnderlyingOptAttribute, 317 );
  fieldTypeByValue.emplace( 317, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 317, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<318>(), FixUnderlyingCurrency );
  tagNameByValue.emplace( 318, FixUnderlyingCurrency );
  tagByName.emplace( FixUnderlyingCurrency, 318 );
  fieldTypeByValue.emplace( 318, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 318, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<320>(), FixSecurityReqID );
  tagNameByValue.emplace( 320, FixSecurityReqID );
  tagByName.emplace( FixSecurityReqID, 320 );
  fieldTypeByValue.emplace( 320, FieldType::STRING );
  fieldTypeNameByValue.emplace( 320, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<321>(), FixSecurityRequestType );
  tagNameByValue.emplace( 321, FixSecurityRequestType );
  tagByName.emplace( FixSecurityRequestType, 321 );
  fieldTypeByValue.emplace( 321, FieldType::INT );
  fieldTypeNameByValue.emplace( 321, "INT" );

  tagNameByRaw.emplace( tag_as_raw<322>(), FixSecurityResponseID );
  tagNameByValue.emplace( 322, FixSecurityResponseID );
  tagByName.emplace( FixSecurityResponseID, 322 );
  fieldTypeByValue.emplace( 322, FieldType::STRING );
  fieldTypeNameByValue.emplace( 322, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<323>(), FixSecurityResponseType );
  tagNameByValue.emplace( 323, FixSecurityResponseType );
  tagByName.emplace( FixSecurityResponseType, 323 );
  fieldTypeByValue.emplace( 323, FieldType::INT );
  fieldTypeNameByValue.emplace( 323, "INT" );

  tagNameByRaw.emplace( tag_as_raw<324>(), FixSecurityStatusReqID );
  tagNameByValue.emplace( 324, FixSecurityStatusReqID );
  tagByName.emplace( FixSecurityStatusReqID, 324 );
  fieldTypeByValue.emplace( 324, FieldType::STRING );
  fieldTypeNameByValue.emplace( 324, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<325>(), FixUnsolicitedIndicator );
  tagNameByValue.emplace( 325, FixUnsolicitedIndicator );
  tagByName.emplace( FixUnsolicitedIndicator, 325 );
  fieldTypeByValue.emplace( 325, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 325, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<326>(), FixSecurityTradingStatus );
  tagNameByValue.emplace( 326, FixSecurityTradingStatus );
  tagByName.emplace( FixSecurityTradingStatus, 326 );
  fieldTypeByValue.emplace( 326, FieldType::INT );
  fieldTypeNameByValue.emplace( 326, "INT" );

  tagNameByRaw.emplace( tag_as_raw<327>(), FixHaltReasonChar );
  tagNameByValue.emplace( 327, FixHaltReasonChar );
  tagByName.emplace( FixHaltReasonChar, 327 );
  fieldTypeByValue.emplace( 327, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 327, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<328>(), FixInViewOfCommon );
  tagNameByValue.emplace( 328, FixInViewOfCommon );
  tagByName.emplace( FixInViewOfCommon, 328 );
  fieldTypeByValue.emplace( 328, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 328, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<329>(), FixDueToRelated );
  tagNameByValue.emplace( 329, FixDueToRelated );
  tagByName.emplace( FixDueToRelated, 329 );
  fieldTypeByValue.emplace( 329, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 329, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<330>(), FixBuyVolume );
  tagNameByValue.emplace( 330, FixBuyVolume );
  tagByName.emplace( FixBuyVolume, 330 );
  fieldTypeByValue.emplace( 330, FieldType::QTY );
  fieldTypeNameByValue.emplace( 330, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<331>(), FixSellVolume );
  tagNameByValue.emplace( 331, FixSellVolume );
  tagByName.emplace( FixSellVolume, 331 );
  fieldTypeByValue.emplace( 331, FieldType::QTY );
  fieldTypeNameByValue.emplace( 331, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<332>(), FixHighPx );
  tagNameByValue.emplace( 332, FixHighPx );
  tagByName.emplace( FixHighPx, 332 );
  fieldTypeByValue.emplace( 332, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 332, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<333>(), FixLowPx );
  tagNameByValue.emplace( 333, FixLowPx );
  tagByName.emplace( FixLowPx, 333 );
  fieldTypeByValue.emplace( 333, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 333, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<334>(), FixAdjustment );
  tagNameByValue.emplace( 334, FixAdjustment );
  tagByName.emplace( FixAdjustment, 334 );
  fieldTypeByValue.emplace( 334, FieldType::INT );
  fieldTypeNameByValue.emplace( 334, "INT" );

  tagNameByRaw.emplace( tag_as_raw<335>(), FixTradSesReqID );
  tagNameByValue.emplace( 335, FixTradSesReqID );
  tagByName.emplace( FixTradSesReqID, 335 );
  fieldTypeByValue.emplace( 335, FieldType::STRING );
  fieldTypeNameByValue.emplace( 335, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<336>(), FixTradingSessionID );
  tagNameByValue.emplace( 336, FixTradingSessionID );
  tagByName.emplace( FixTradingSessionID, 336 );
  fieldTypeByValue.emplace( 336, FieldType::STRING );
  fieldTypeNameByValue.emplace( 336, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<337>(), FixContraTrader );
  tagNameByValue.emplace( 337, FixContraTrader );
  tagByName.emplace( FixContraTrader, 337 );
  fieldTypeByValue.emplace( 337, FieldType::STRING );
  fieldTypeNameByValue.emplace( 337, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<338>(), FixTradSesMethod );
  tagNameByValue.emplace( 338, FixTradSesMethod );
  tagByName.emplace( FixTradSesMethod, 338 );
  fieldTypeByValue.emplace( 338, FieldType::INT );
  fieldTypeNameByValue.emplace( 338, "INT" );

  tagNameByRaw.emplace( tag_as_raw<339>(), FixTradSesMode );
  tagNameByValue.emplace( 339, FixTradSesMode );
  tagByName.emplace( FixTradSesMode, 339 );
  fieldTypeByValue.emplace( 339, FieldType::INT );
  fieldTypeNameByValue.emplace( 339, "INT" );

  tagNameByRaw.emplace( tag_as_raw<340>(), FixTradSesStatus );
  tagNameByValue.emplace( 340, FixTradSesStatus );
  tagByName.emplace( FixTradSesStatus, 340 );
  fieldTypeByValue.emplace( 340, FieldType::INT );
  fieldTypeNameByValue.emplace( 340, "INT" );

  tagNameByRaw.emplace( tag_as_raw<341>(), FixTradSesStartTime );
  tagNameByValue.emplace( 341, FixTradSesStartTime );
  tagByName.emplace( FixTradSesStartTime, 341 );
  fieldTypeByValue.emplace( 341, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 341, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<342>(), FixTradSesOpenTime );
  tagNameByValue.emplace( 342, FixTradSesOpenTime );
  tagByName.emplace( FixTradSesOpenTime, 342 );
  fieldTypeByValue.emplace( 342, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 342, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<343>(), FixTradSesPreCloseTime );
  tagNameByValue.emplace( 343, FixTradSesPreCloseTime );
  tagByName.emplace( FixTradSesPreCloseTime, 343 );
  fieldTypeByValue.emplace( 343, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 343, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<344>(), FixTradSesCloseTime );
  tagNameByValue.emplace( 344, FixTradSesCloseTime );
  tagByName.emplace( FixTradSesCloseTime, 344 );
  fieldTypeByValue.emplace( 344, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 344, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<345>(), FixTradSesEndTime );
  tagNameByValue.emplace( 345, FixTradSesEndTime );
  tagByName.emplace( FixTradSesEndTime, 345 );
  fieldTypeByValue.emplace( 345, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 345, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<346>(), FixNumberOfOrders );
  tagNameByValue.emplace( 346, FixNumberOfOrders );
  tagByName.emplace( FixNumberOfOrders, 346 );
  fieldTypeByValue.emplace( 346, FieldType::INT );
  fieldTypeNameByValue.emplace( 346, "INT" );

  tagNameByRaw.emplace( tag_as_raw<347>(), FixMessageEncoding );
  tagNameByValue.emplace( 347, FixMessageEncoding );
  tagByName.emplace( FixMessageEncoding, 347 );
  fieldTypeByValue.emplace( 347, FieldType::STRING );
  fieldTypeNameByValue.emplace( 347, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<348>(), FixEncodedIssuerLen );
  tagNameByValue.emplace( 348, FixEncodedIssuerLen );
  tagByName.emplace( FixEncodedIssuerLen, 348 );
  fieldTypeByValue.emplace( 348, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 348, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<349>(), FixEncodedIssuer );
  tagNameByValue.emplace( 349, FixEncodedIssuer );
  tagByName.emplace( FixEncodedIssuer, 349 );
  fieldTypeByValue.emplace( 349, FieldType::DATA );
  fieldTypeNameByValue.emplace( 349, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<350>(), FixEncodedSecurityDescLen );
  tagNameByValue.emplace( 350, FixEncodedSecurityDescLen );
  tagByName.emplace( FixEncodedSecurityDescLen, 350 );
  fieldTypeByValue.emplace( 350, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 350, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<351>(), FixEncodedSecurityDesc );
  tagNameByValue.emplace( 351, FixEncodedSecurityDesc );
  tagByName.emplace( FixEncodedSecurityDesc, 351 );
  fieldTypeByValue.emplace( 351, FieldType::DATA );
  fieldTypeNameByValue.emplace( 351, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<352>(), FixEncodedListExecInstLen );
  tagNameByValue.emplace( 352, FixEncodedListExecInstLen );
  tagByName.emplace( FixEncodedListExecInstLen, 352 );
  fieldTypeByValue.emplace( 352, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 352, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<353>(), FixEncodedListExecInst );
  tagNameByValue.emplace( 353, FixEncodedListExecInst );
  tagByName.emplace( FixEncodedListExecInst, 353 );
  fieldTypeByValue.emplace( 353, FieldType::DATA );
  fieldTypeNameByValue.emplace( 353, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<354>(), FixEncodedTextLen );
  tagNameByValue.emplace( 354, FixEncodedTextLen );
  tagByName.emplace( FixEncodedTextLen, 354 );
  fieldTypeByValue.emplace( 354, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 354, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<355>(), FixEncodedText );
  tagNameByValue.emplace( 355, FixEncodedText );
  tagByName.emplace( FixEncodedText, 355 );
  fieldTypeByValue.emplace( 355, FieldType::DATA );
  fieldTypeNameByValue.emplace( 355, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<356>(), FixEncodedSubjectLen );
  tagNameByValue.emplace( 356, FixEncodedSubjectLen );
  tagByName.emplace( FixEncodedSubjectLen, 356 );
  fieldTypeByValue.emplace( 356, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 356, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<357>(), FixEncodedSubject );
  tagNameByValue.emplace( 357, FixEncodedSubject );
  tagByName.emplace( FixEncodedSubject, 357 );
  fieldTypeByValue.emplace( 357, FieldType::DATA );
  fieldTypeNameByValue.emplace( 357, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<358>(), FixEncodedHeadlineLen );
  tagNameByValue.emplace( 358, FixEncodedHeadlineLen );
  tagByName.emplace( FixEncodedHeadlineLen, 358 );
  fieldTypeByValue.emplace( 358, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 358, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<359>(), FixEncodedHeadline );
  tagNameByValue.emplace( 359, FixEncodedHeadline );
  tagByName.emplace( FixEncodedHeadline, 359 );
  fieldTypeByValue.emplace( 359, FieldType::DATA );
  fieldTypeNameByValue.emplace( 359, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<360>(), FixEncodedAllocTextLen );
  tagNameByValue.emplace( 360, FixEncodedAllocTextLen );
  tagByName.emplace( FixEncodedAllocTextLen, 360 );
  fieldTypeByValue.emplace( 360, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 360, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<361>(), FixEncodedAllocText );
  tagNameByValue.emplace( 361, FixEncodedAllocText );
  tagByName.emplace( FixEncodedAllocText, 361 );
  fieldTypeByValue.emplace( 361, FieldType::DATA );
  fieldTypeNameByValue.emplace( 361, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<362>(), FixEncodedUnderlyingIssuerLen );
  tagNameByValue.emplace( 362, FixEncodedUnderlyingIssuerLen );
  tagByName.emplace( FixEncodedUnderlyingIssuerLen, 362 );
  fieldTypeByValue.emplace( 362, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 362, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<363>(), FixEncodedUnderlyingIssuer );
  tagNameByValue.emplace( 363, FixEncodedUnderlyingIssuer );
  tagByName.emplace( FixEncodedUnderlyingIssuer, 363 );
  fieldTypeByValue.emplace( 363, FieldType::DATA );
  fieldTypeNameByValue.emplace( 363, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<364>(), FixEncodedUnderlyingSecurityDescLen );
  tagNameByValue.emplace( 364, FixEncodedUnderlyingSecurityDescLen );
  tagByName.emplace( FixEncodedUnderlyingSecurityDescLen, 364 );
  fieldTypeByValue.emplace( 364, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 364, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<365>(), FixEncodedUnderlyingSecurityDesc );
  tagNameByValue.emplace( 365, FixEncodedUnderlyingSecurityDesc );
  tagByName.emplace( FixEncodedUnderlyingSecurityDesc, 365 );
  fieldTypeByValue.emplace( 365, FieldType::DATA );
  fieldTypeNameByValue.emplace( 365, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<366>(), FixAllocPrice );
  tagNameByValue.emplace( 366, FixAllocPrice );
  tagByName.emplace( FixAllocPrice, 366 );
  fieldTypeByValue.emplace( 366, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 366, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<367>(), FixQuoteSetValidUntilTime );
  tagNameByValue.emplace( 367, FixQuoteSetValidUntilTime );
  tagByName.emplace( FixQuoteSetValidUntilTime, 367 );
  fieldTypeByValue.emplace( 367, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 367, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<368>(), FixQuoteEntryRejectReason );
  tagNameByValue.emplace( 368, FixQuoteEntryRejectReason );
  tagByName.emplace( FixQuoteEntryRejectReason, 368 );
  fieldTypeByValue.emplace( 368, FieldType::INT );
  fieldTypeNameByValue.emplace( 368, "INT" );

  tagNameByRaw.emplace( tag_as_raw<369>(), FixLastMsgSeqNumProcessed );
  tagNameByValue.emplace( 369, FixLastMsgSeqNumProcessed );
  tagByName.emplace( FixLastMsgSeqNumProcessed, 369 );
  fieldTypeByValue.emplace( 369, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 369, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<371>(), FixRefTagID );
  tagNameByValue.emplace( 371, FixRefTagID );
  tagByName.emplace( FixRefTagID, 371 );
  fieldTypeByValue.emplace( 371, FieldType::INT );
  fieldTypeNameByValue.emplace( 371, "INT" );

  tagNameByRaw.emplace( tag_as_raw<372>(), FixRefMsgType );
  tagNameByValue.emplace( 372, FixRefMsgType );
  tagByName.emplace( FixRefMsgType, 372 );
  fieldTypeByValue.emplace( 372, FieldType::STRING );
  fieldTypeNameByValue.emplace( 372, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<373>(), FixSessionRejectReason );
  tagNameByValue.emplace( 373, FixSessionRejectReason );
  tagByName.emplace( FixSessionRejectReason, 373 );
  fieldTypeByValue.emplace( 373, FieldType::INT );
  fieldTypeNameByValue.emplace( 373, "INT" );

  tagNameByRaw.emplace( tag_as_raw<374>(), FixBidRequestTransType );
  tagNameByValue.emplace( 374, FixBidRequestTransType );
  tagByName.emplace( FixBidRequestTransType, 374 );
  fieldTypeByValue.emplace( 374, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 374, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<375>(), FixContraBroker );
  tagNameByValue.emplace( 375, FixContraBroker );
  tagByName.emplace( FixContraBroker, 375 );
  fieldTypeByValue.emplace( 375, FieldType::STRING );
  fieldTypeNameByValue.emplace( 375, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<376>(), FixComplianceID );
  tagNameByValue.emplace( 376, FixComplianceID );
  tagByName.emplace( FixComplianceID, 376 );
  fieldTypeByValue.emplace( 376, FieldType::STRING );
  fieldTypeNameByValue.emplace( 376, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<377>(), FixSolicitedFlag );
  tagNameByValue.emplace( 377, FixSolicitedFlag );
  tagByName.emplace( FixSolicitedFlag, 377 );
  fieldTypeByValue.emplace( 377, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 377, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<378>(), FixExecRestatementReason );
  tagNameByValue.emplace( 378, FixExecRestatementReason );
  tagByName.emplace( FixExecRestatementReason, 378 );
  fieldTypeByValue.emplace( 378, FieldType::INT );
  fieldTypeNameByValue.emplace( 378, "INT" );

  tagNameByRaw.emplace( tag_as_raw<379>(), FixBusinessRejectRefID );
  tagNameByValue.emplace( 379, FixBusinessRejectRefID );
  tagByName.emplace( FixBusinessRejectRefID, 379 );
  fieldTypeByValue.emplace( 379, FieldType::STRING );
  fieldTypeNameByValue.emplace( 379, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<380>(), FixBusinessRejectReason );
  tagNameByValue.emplace( 380, FixBusinessRejectReason );
  tagByName.emplace( FixBusinessRejectReason, 380 );
  fieldTypeByValue.emplace( 380, FieldType::INT );
  fieldTypeNameByValue.emplace( 380, "INT" );

  tagNameByRaw.emplace( tag_as_raw<381>(), FixGrossTradeAmt );
  tagNameByValue.emplace( 381, FixGrossTradeAmt );
  tagByName.emplace( FixGrossTradeAmt, 381 );
  fieldTypeByValue.emplace( 381, FieldType::AMT );
  fieldTypeNameByValue.emplace( 381, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<382>(), FixNoContraBrokers );
  tagNameByValue.emplace( 382, FixNoContraBrokers );
  tagByName.emplace( FixNoContraBrokers, 382 );
  fieldTypeByValue.emplace( 382, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 382, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<383>(), FixMaxMessageSize );
  tagNameByValue.emplace( 383, FixMaxMessageSize );
  tagByName.emplace( FixMaxMessageSize, 383 );
  fieldTypeByValue.emplace( 383, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 383, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<384>(), FixNoMsgTypes );
  tagNameByValue.emplace( 384, FixNoMsgTypes );
  tagByName.emplace( FixNoMsgTypes, 384 );
  fieldTypeByValue.emplace( 384, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 384, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<385>(), FixMsgDirection );
  tagNameByValue.emplace( 385, FixMsgDirection );
  tagByName.emplace( FixMsgDirection, 385 );
  fieldTypeByValue.emplace( 385, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 385, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<386>(), FixNoTradingSessions );
  tagNameByValue.emplace( 386, FixNoTradingSessions );
  tagByName.emplace( FixNoTradingSessions, 386 );
  fieldTypeByValue.emplace( 386, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 386, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<387>(), FixTotalVolumeTraded );
  tagNameByValue.emplace( 387, FixTotalVolumeTraded );
  tagByName.emplace( FixTotalVolumeTraded, 387 );
  fieldTypeByValue.emplace( 387, FieldType::QTY );
  fieldTypeNameByValue.emplace( 387, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<388>(), FixDiscretionInst );
  tagNameByValue.emplace( 388, FixDiscretionInst );
  tagByName.emplace( FixDiscretionInst, 388 );
  fieldTypeByValue.emplace( 388, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 388, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<389>(), FixDiscretionOffsetValue );
  tagNameByValue.emplace( 389, FixDiscretionOffsetValue );
  tagByName.emplace( FixDiscretionOffsetValue, 389 );
  fieldTypeByValue.emplace( 389, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 389, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<390>(), FixBidID );
  tagNameByValue.emplace( 390, FixBidID );
  tagByName.emplace( FixBidID, 390 );
  fieldTypeByValue.emplace( 390, FieldType::STRING );
  fieldTypeNameByValue.emplace( 390, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<391>(), FixClientBidID );
  tagNameByValue.emplace( 391, FixClientBidID );
  tagByName.emplace( FixClientBidID, 391 );
  fieldTypeByValue.emplace( 391, FieldType::STRING );
  fieldTypeNameByValue.emplace( 391, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<392>(), FixListName );
  tagNameByValue.emplace( 392, FixListName );
  tagByName.emplace( FixListName, 392 );
  fieldTypeByValue.emplace( 392, FieldType::STRING );
  fieldTypeNameByValue.emplace( 392, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<393>(), FixTotNoRelatedSym );
  tagNameByValue.emplace( 393, FixTotNoRelatedSym );
  tagByName.emplace( FixTotNoRelatedSym, 393 );
  fieldTypeByValue.emplace( 393, FieldType::INT );
  fieldTypeNameByValue.emplace( 393, "INT" );

  tagNameByRaw.emplace( tag_as_raw<394>(), FixBidType );
  tagNameByValue.emplace( 394, FixBidType );
  tagByName.emplace( FixBidType, 394 );
  fieldTypeByValue.emplace( 394, FieldType::INT );
  fieldTypeNameByValue.emplace( 394, "INT" );

  tagNameByRaw.emplace( tag_as_raw<395>(), FixNumTickets );
  tagNameByValue.emplace( 395, FixNumTickets );
  tagByName.emplace( FixNumTickets, 395 );
  fieldTypeByValue.emplace( 395, FieldType::INT );
  fieldTypeNameByValue.emplace( 395, "INT" );

  tagNameByRaw.emplace( tag_as_raw<396>(), FixSideValue1 );
  tagNameByValue.emplace( 396, FixSideValue1 );
  tagByName.emplace( FixSideValue1, 396 );
  fieldTypeByValue.emplace( 396, FieldType::AMT );
  fieldTypeNameByValue.emplace( 396, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<397>(), FixSideValue2 );
  tagNameByValue.emplace( 397, FixSideValue2 );
  tagByName.emplace( FixSideValue2, 397 );
  fieldTypeByValue.emplace( 397, FieldType::AMT );
  fieldTypeNameByValue.emplace( 397, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<398>(), FixNoBidDescriptors );
  tagNameByValue.emplace( 398, FixNoBidDescriptors );
  tagByName.emplace( FixNoBidDescriptors, 398 );
  fieldTypeByValue.emplace( 398, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 398, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<399>(), FixBidDescriptorType );
  tagNameByValue.emplace( 399, FixBidDescriptorType );
  tagByName.emplace( FixBidDescriptorType, 399 );
  fieldTypeByValue.emplace( 399, FieldType::INT );
  fieldTypeNameByValue.emplace( 399, "INT" );

  tagNameByRaw.emplace( tag_as_raw<400>(), FixBidDescriptor );
  tagNameByValue.emplace( 400, FixBidDescriptor );
  tagByName.emplace( FixBidDescriptor, 400 );
  fieldTypeByValue.emplace( 400, FieldType::STRING );
  fieldTypeNameByValue.emplace( 400, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<401>(), FixSideValueInd );
  tagNameByValue.emplace( 401, FixSideValueInd );
  tagByName.emplace( FixSideValueInd, 401 );
  fieldTypeByValue.emplace( 401, FieldType::INT );
  fieldTypeNameByValue.emplace( 401, "INT" );

  tagNameByRaw.emplace( tag_as_raw<402>(), FixLiquidityPctLow );
  tagNameByValue.emplace( 402, FixLiquidityPctLow );
  tagByName.emplace( FixLiquidityPctLow, 402 );
  fieldTypeByValue.emplace( 402, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 402, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<403>(), FixLiquidityPctHigh );
  tagNameByValue.emplace( 403, FixLiquidityPctHigh );
  tagByName.emplace( FixLiquidityPctHigh, 403 );
  fieldTypeByValue.emplace( 403, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 403, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<404>(), FixLiquidityValue );
  tagNameByValue.emplace( 404, FixLiquidityValue );
  tagByName.emplace( FixLiquidityValue, 404 );
  fieldTypeByValue.emplace( 404, FieldType::AMT );
  fieldTypeNameByValue.emplace( 404, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<405>(), FixEFPTrackingError );
  tagNameByValue.emplace( 405, FixEFPTrackingError );
  tagByName.emplace( FixEFPTrackingError, 405 );
  fieldTypeByValue.emplace( 405, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 405, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<406>(), FixFairValue );
  tagNameByValue.emplace( 406, FixFairValue );
  tagByName.emplace( FixFairValue, 406 );
  fieldTypeByValue.emplace( 406, FieldType::AMT );
  fieldTypeNameByValue.emplace( 406, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<407>(), FixOutsideIndexPct );
  tagNameByValue.emplace( 407, FixOutsideIndexPct );
  tagByName.emplace( FixOutsideIndexPct, 407 );
  fieldTypeByValue.emplace( 407, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 407, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<408>(), FixValueOfFutures );
  tagNameByValue.emplace( 408, FixValueOfFutures );
  tagByName.emplace( FixValueOfFutures, 408 );
  fieldTypeByValue.emplace( 408, FieldType::AMT );
  fieldTypeNameByValue.emplace( 408, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<409>(), FixLiquidityIndType );
  tagNameByValue.emplace( 409, FixLiquidityIndType );
  tagByName.emplace( FixLiquidityIndType, 409 );
  fieldTypeByValue.emplace( 409, FieldType::INT );
  fieldTypeNameByValue.emplace( 409, "INT" );

  tagNameByRaw.emplace( tag_as_raw<410>(), FixWtAverageLiquidity );
  tagNameByValue.emplace( 410, FixWtAverageLiquidity );
  tagByName.emplace( FixWtAverageLiquidity, 410 );
  fieldTypeByValue.emplace( 410, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 410, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<411>(), FixExchangeForPhysical );
  tagNameByValue.emplace( 411, FixExchangeForPhysical );
  tagByName.emplace( FixExchangeForPhysical, 411 );
  fieldTypeByValue.emplace( 411, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 411, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<412>(), FixOutMainCntryUIndex );
  tagNameByValue.emplace( 412, FixOutMainCntryUIndex );
  tagByName.emplace( FixOutMainCntryUIndex, 412 );
  fieldTypeByValue.emplace( 412, FieldType::AMT );
  fieldTypeNameByValue.emplace( 412, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<413>(), FixCrossPercent );
  tagNameByValue.emplace( 413, FixCrossPercent );
  tagByName.emplace( FixCrossPercent, 413 );
  fieldTypeByValue.emplace( 413, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 413, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<414>(), FixProgRptReqs );
  tagNameByValue.emplace( 414, FixProgRptReqs );
  tagByName.emplace( FixProgRptReqs, 414 );
  fieldTypeByValue.emplace( 414, FieldType::INT );
  fieldTypeNameByValue.emplace( 414, "INT" );

  tagNameByRaw.emplace( tag_as_raw<415>(), FixProgPeriodInterval );
  tagNameByValue.emplace( 415, FixProgPeriodInterval );
  tagByName.emplace( FixProgPeriodInterval, 415 );
  fieldTypeByValue.emplace( 415, FieldType::INT );
  fieldTypeNameByValue.emplace( 415, "INT" );

  tagNameByRaw.emplace( tag_as_raw<416>(), FixIncTaxInd );
  tagNameByValue.emplace( 416, FixIncTaxInd );
  tagByName.emplace( FixIncTaxInd, 416 );
  fieldTypeByValue.emplace( 416, FieldType::INT );
  fieldTypeNameByValue.emplace( 416, "INT" );

  tagNameByRaw.emplace( tag_as_raw<417>(), FixNumBidders );
  tagNameByValue.emplace( 417, FixNumBidders );
  tagByName.emplace( FixNumBidders, 417 );
  fieldTypeByValue.emplace( 417, FieldType::INT );
  fieldTypeNameByValue.emplace( 417, "INT" );

  tagNameByRaw.emplace( tag_as_raw<418>(), FixBidTradeType );
  tagNameByValue.emplace( 418, FixBidTradeType );
  tagByName.emplace( FixBidTradeType, 418 );
  fieldTypeByValue.emplace( 418, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 418, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<419>(), FixBasisPxType );
  tagNameByValue.emplace( 419, FixBasisPxType );
  tagByName.emplace( FixBasisPxType, 419 );
  fieldTypeByValue.emplace( 419, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 419, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<420>(), FixNoBidComponents );
  tagNameByValue.emplace( 420, FixNoBidComponents );
  tagByName.emplace( FixNoBidComponents, 420 );
  fieldTypeByValue.emplace( 420, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 420, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<421>(), FixCountry );
  tagNameByValue.emplace( 421, FixCountry );
  tagByName.emplace( FixCountry, 421 );
  fieldTypeByValue.emplace( 421, FieldType::COUNTRY );
  fieldTypeNameByValue.emplace( 421, "COUNTRY" );

  tagNameByRaw.emplace( tag_as_raw<422>(), FixTotNoStrikes );
  tagNameByValue.emplace( 422, FixTotNoStrikes );
  tagByName.emplace( FixTotNoStrikes, 422 );
  fieldTypeByValue.emplace( 422, FieldType::INT );
  fieldTypeNameByValue.emplace( 422, "INT" );

  tagNameByRaw.emplace( tag_as_raw<423>(), FixPriceType );
  tagNameByValue.emplace( 423, FixPriceType );
  tagByName.emplace( FixPriceType, 423 );
  fieldTypeByValue.emplace( 423, FieldType::INT );
  fieldTypeNameByValue.emplace( 423, "INT" );

  tagNameByRaw.emplace( tag_as_raw<424>(), FixDayOrderQty );
  tagNameByValue.emplace( 424, FixDayOrderQty );
  tagByName.emplace( FixDayOrderQty, 424 );
  fieldTypeByValue.emplace( 424, FieldType::QTY );
  fieldTypeNameByValue.emplace( 424, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<425>(), FixDayCumQty );
  tagNameByValue.emplace( 425, FixDayCumQty );
  tagByName.emplace( FixDayCumQty, 425 );
  fieldTypeByValue.emplace( 425, FieldType::QTY );
  fieldTypeNameByValue.emplace( 425, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<426>(), FixDayAvgPx );
  tagNameByValue.emplace( 426, FixDayAvgPx );
  tagByName.emplace( FixDayAvgPx, 426 );
  fieldTypeByValue.emplace( 426, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 426, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<427>(), FixGTBookingInst );
  tagNameByValue.emplace( 427, FixGTBookingInst );
  tagByName.emplace( FixGTBookingInst, 427 );
  fieldTypeByValue.emplace( 427, FieldType::INT );
  fieldTypeNameByValue.emplace( 427, "INT" );

  tagNameByRaw.emplace( tag_as_raw<428>(), FixNoStrikes );
  tagNameByValue.emplace( 428, FixNoStrikes );
  tagByName.emplace( FixNoStrikes, 428 );
  fieldTypeByValue.emplace( 428, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 428, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<429>(), FixListStatusType );
  tagNameByValue.emplace( 429, FixListStatusType );
  tagByName.emplace( FixListStatusType, 429 );
  fieldTypeByValue.emplace( 429, FieldType::INT );
  fieldTypeNameByValue.emplace( 429, "INT" );

  tagNameByRaw.emplace( tag_as_raw<430>(), FixNetGrossInd );
  tagNameByValue.emplace( 430, FixNetGrossInd );
  tagByName.emplace( FixNetGrossInd, 430 );
  fieldTypeByValue.emplace( 430, FieldType::INT );
  fieldTypeNameByValue.emplace( 430, "INT" );

  tagNameByRaw.emplace( tag_as_raw<431>(), FixListOrderStatus );
  tagNameByValue.emplace( 431, FixListOrderStatus );
  tagByName.emplace( FixListOrderStatus, 431 );
  fieldTypeByValue.emplace( 431, FieldType::INT );
  fieldTypeNameByValue.emplace( 431, "INT" );

  tagNameByRaw.emplace( tag_as_raw<432>(), FixExpireDate );
  tagNameByValue.emplace( 432, FixExpireDate );
  tagByName.emplace( FixExpireDate, 432 );
  fieldTypeByValue.emplace( 432, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 432, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<433>(), FixListExecInstType );
  tagNameByValue.emplace( 433, FixListExecInstType );
  tagByName.emplace( FixListExecInstType, 433 );
  fieldTypeByValue.emplace( 433, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 433, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<434>(), FixCxlRejResponseTo );
  tagNameByValue.emplace( 434, FixCxlRejResponseTo );
  tagByName.emplace( FixCxlRejResponseTo, 434 );
  fieldTypeByValue.emplace( 434, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 434, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<435>(), FixUnderlyingCouponRate );
  tagNameByValue.emplace( 435, FixUnderlyingCouponRate );
  tagByName.emplace( FixUnderlyingCouponRate, 435 );
  fieldTypeByValue.emplace( 435, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 435, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<436>(), FixUnderlyingContractMultiplier );
  tagNameByValue.emplace( 436, FixUnderlyingContractMultiplier );
  tagByName.emplace( FixUnderlyingContractMultiplier, 436 );
  fieldTypeByValue.emplace( 436, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 436, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<437>(), FixContraTradeQty );
  tagNameByValue.emplace( 437, FixContraTradeQty );
  tagByName.emplace( FixContraTradeQty, 437 );
  fieldTypeByValue.emplace( 437, FieldType::QTY );
  fieldTypeNameByValue.emplace( 437, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<438>(), FixContraTradeTime );
  tagNameByValue.emplace( 438, FixContraTradeTime );
  tagByName.emplace( FixContraTradeTime, 438 );
  fieldTypeByValue.emplace( 438, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 438, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<441>(), FixLiquidityNumSecurities );
  tagNameByValue.emplace( 441, FixLiquidityNumSecurities );
  tagByName.emplace( FixLiquidityNumSecurities, 441 );
  fieldTypeByValue.emplace( 441, FieldType::INT );
  fieldTypeNameByValue.emplace( 441, "INT" );

  tagNameByRaw.emplace( tag_as_raw<442>(), FixMultiLegReportingType );
  tagNameByValue.emplace( 442, FixMultiLegReportingType );
  tagByName.emplace( FixMultiLegReportingType, 442 );
  fieldTypeByValue.emplace( 442, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 442, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<443>(), FixStrikeTime );
  tagNameByValue.emplace( 443, FixStrikeTime );
  tagByName.emplace( FixStrikeTime, 443 );
  fieldTypeByValue.emplace( 443, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 443, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<444>(), FixListStatusText );
  tagNameByValue.emplace( 444, FixListStatusText );
  tagByName.emplace( FixListStatusText, 444 );
  fieldTypeByValue.emplace( 444, FieldType::STRING );
  fieldTypeNameByValue.emplace( 444, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<445>(), FixEncodedListStatusTextLen );
  tagNameByValue.emplace( 445, FixEncodedListStatusTextLen );
  tagByName.emplace( FixEncodedListStatusTextLen, 445 );
  fieldTypeByValue.emplace( 445, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 445, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<446>(), FixEncodedListStatusText );
  tagNameByValue.emplace( 446, FixEncodedListStatusText );
  tagByName.emplace( FixEncodedListStatusText, 446 );
  fieldTypeByValue.emplace( 446, FieldType::DATA );
  fieldTypeNameByValue.emplace( 446, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<447>(), FixPartyIDSource );
  tagNameByValue.emplace( 447, FixPartyIDSource );
  tagByName.emplace( FixPartyIDSource, 447 );
  fieldTypeByValue.emplace( 447, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 447, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<448>(), FixPartyID );
  tagNameByValue.emplace( 448, FixPartyID );
  tagByName.emplace( FixPartyID, 448 );
  fieldTypeByValue.emplace( 448, FieldType::STRING );
  fieldTypeNameByValue.emplace( 448, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<451>(), FixNetChgPrevDay );
  tagNameByValue.emplace( 451, FixNetChgPrevDay );
  tagByName.emplace( FixNetChgPrevDay, 451 );
  fieldTypeByValue.emplace( 451, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 451, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<452>(), FixPartyRole );
  tagNameByValue.emplace( 452, FixPartyRole );
  tagByName.emplace( FixPartyRole, 452 );
  fieldTypeByValue.emplace( 452, FieldType::INT );
  fieldTypeNameByValue.emplace( 452, "INT" );

  tagNameByRaw.emplace( tag_as_raw<453>(), FixNoPartyIDs );
  tagNameByValue.emplace( 453, FixNoPartyIDs );
  tagByName.emplace( FixNoPartyIDs, 453 );
  fieldTypeByValue.emplace( 453, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 453, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<454>(), FixNoSecurityAltID );
  tagNameByValue.emplace( 454, FixNoSecurityAltID );
  tagByName.emplace( FixNoSecurityAltID, 454 );
  fieldTypeByValue.emplace( 454, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 454, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<455>(), FixSecurityAltID );
  tagNameByValue.emplace( 455, FixSecurityAltID );
  tagByName.emplace( FixSecurityAltID, 455 );
  fieldTypeByValue.emplace( 455, FieldType::STRING );
  fieldTypeNameByValue.emplace( 455, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<456>(), FixSecurityAltIDSource );
  tagNameByValue.emplace( 456, FixSecurityAltIDSource );
  tagByName.emplace( FixSecurityAltIDSource, 456 );
  fieldTypeByValue.emplace( 456, FieldType::STRING );
  fieldTypeNameByValue.emplace( 456, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<457>(), FixNoUnderlyingSecurityAltID );
  tagNameByValue.emplace( 457, FixNoUnderlyingSecurityAltID );
  tagByName.emplace( FixNoUnderlyingSecurityAltID, 457 );
  fieldTypeByValue.emplace( 457, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 457, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<458>(), FixUnderlyingSecurityAltID );
  tagNameByValue.emplace( 458, FixUnderlyingSecurityAltID );
  tagByName.emplace( FixUnderlyingSecurityAltID, 458 );
  fieldTypeByValue.emplace( 458, FieldType::STRING );
  fieldTypeNameByValue.emplace( 458, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<459>(), FixUnderlyingSecurityAltIDSource );
  tagNameByValue.emplace( 459, FixUnderlyingSecurityAltIDSource );
  tagByName.emplace( FixUnderlyingSecurityAltIDSource, 459 );
  fieldTypeByValue.emplace( 459, FieldType::STRING );
  fieldTypeNameByValue.emplace( 459, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<460>(), FixProduct );
  tagNameByValue.emplace( 460, FixProduct );
  tagByName.emplace( FixProduct, 460 );
  fieldTypeByValue.emplace( 460, FieldType::INT );
  fieldTypeNameByValue.emplace( 460, "INT" );

  tagNameByRaw.emplace( tag_as_raw<461>(), FixCFICode );
  tagNameByValue.emplace( 461, FixCFICode );
  tagByName.emplace( FixCFICode, 461 );
  fieldTypeByValue.emplace( 461, FieldType::STRING );
  fieldTypeNameByValue.emplace( 461, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<462>(), FixUnderlyingProduct );
  tagNameByValue.emplace( 462, FixUnderlyingProduct );
  tagByName.emplace( FixUnderlyingProduct, 462 );
  fieldTypeByValue.emplace( 462, FieldType::INT );
  fieldTypeNameByValue.emplace( 462, "INT" );

  tagNameByRaw.emplace( tag_as_raw<463>(), FixUnderlyingCFICode );
  tagNameByValue.emplace( 463, FixUnderlyingCFICode );
  tagByName.emplace( FixUnderlyingCFICode, 463 );
  fieldTypeByValue.emplace( 463, FieldType::STRING );
  fieldTypeNameByValue.emplace( 463, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<464>(), FixTestMessageIndicator );
  tagNameByValue.emplace( 464, FixTestMessageIndicator );
  tagByName.emplace( FixTestMessageIndicator, 464 );
  fieldTypeByValue.emplace( 464, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 464, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<466>(), FixBookingRefID );
  tagNameByValue.emplace( 466, FixBookingRefID );
  tagByName.emplace( FixBookingRefID, 466 );
  fieldTypeByValue.emplace( 466, FieldType::STRING );
  fieldTypeNameByValue.emplace( 466, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<467>(), FixIndividualAllocID );
  tagNameByValue.emplace( 467, FixIndividualAllocID );
  tagByName.emplace( FixIndividualAllocID, 467 );
  fieldTypeByValue.emplace( 467, FieldType::STRING );
  fieldTypeNameByValue.emplace( 467, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<468>(), FixRoundingDirection );
  tagNameByValue.emplace( 468, FixRoundingDirection );
  tagByName.emplace( FixRoundingDirection, 468 );
  fieldTypeByValue.emplace( 468, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 468, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<469>(), FixRoundingModulus );
  tagNameByValue.emplace( 469, FixRoundingModulus );
  tagByName.emplace( FixRoundingModulus, 469 );
  fieldTypeByValue.emplace( 469, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 469, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<470>(), FixCountryOfIssue );
  tagNameByValue.emplace( 470, FixCountryOfIssue );
  tagByName.emplace( FixCountryOfIssue, 470 );
  fieldTypeByValue.emplace( 470, FieldType::COUNTRY );
  fieldTypeNameByValue.emplace( 470, "COUNTRY" );

  tagNameByRaw.emplace( tag_as_raw<471>(), FixStateOrProvinceOfIssue );
  tagNameByValue.emplace( 471, FixStateOrProvinceOfIssue );
  tagByName.emplace( FixStateOrProvinceOfIssue, 471 );
  fieldTypeByValue.emplace( 471, FieldType::STRING );
  fieldTypeNameByValue.emplace( 471, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<472>(), FixLocaleOfIssue );
  tagNameByValue.emplace( 472, FixLocaleOfIssue );
  tagByName.emplace( FixLocaleOfIssue, 472 );
  fieldTypeByValue.emplace( 472, FieldType::STRING );
  fieldTypeNameByValue.emplace( 472, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<473>(), FixNoRegistDtls );
  tagNameByValue.emplace( 473, FixNoRegistDtls );
  tagByName.emplace( FixNoRegistDtls, 473 );
  fieldTypeByValue.emplace( 473, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 473, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<474>(), FixMailingDtls );
  tagNameByValue.emplace( 474, FixMailingDtls );
  tagByName.emplace( FixMailingDtls, 474 );
  fieldTypeByValue.emplace( 474, FieldType::STRING );
  fieldTypeNameByValue.emplace( 474, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<475>(), FixInvestorCountryOfResidence );
  tagNameByValue.emplace( 475, FixInvestorCountryOfResidence );
  tagByName.emplace( FixInvestorCountryOfResidence, 475 );
  fieldTypeByValue.emplace( 475, FieldType::COUNTRY );
  fieldTypeNameByValue.emplace( 475, "COUNTRY" );

  tagNameByRaw.emplace( tag_as_raw<476>(), FixPaymentRef );
  tagNameByValue.emplace( 476, FixPaymentRef );
  tagByName.emplace( FixPaymentRef, 476 );
  fieldTypeByValue.emplace( 476, FieldType::STRING );
  fieldTypeNameByValue.emplace( 476, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<477>(), FixDistribPaymentMethod );
  tagNameByValue.emplace( 477, FixDistribPaymentMethod );
  tagByName.emplace( FixDistribPaymentMethod, 477 );
  fieldTypeByValue.emplace( 477, FieldType::INT );
  fieldTypeNameByValue.emplace( 477, "INT" );

  tagNameByRaw.emplace( tag_as_raw<478>(), FixCashDistribCurr );
  tagNameByValue.emplace( 478, FixCashDistribCurr );
  tagByName.emplace( FixCashDistribCurr, 478 );
  fieldTypeByValue.emplace( 478, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 478, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<479>(), FixCommCurrency );
  tagNameByValue.emplace( 479, FixCommCurrency );
  tagByName.emplace( FixCommCurrency, 479 );
  fieldTypeByValue.emplace( 479, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 479, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<480>(), FixCancellationRights );
  tagNameByValue.emplace( 480, FixCancellationRights );
  tagByName.emplace( FixCancellationRights, 480 );
  fieldTypeByValue.emplace( 480, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 480, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<481>(), FixMoneyLaunderingStatus );
  tagNameByValue.emplace( 481, FixMoneyLaunderingStatus );
  tagByName.emplace( FixMoneyLaunderingStatus, 481 );
  fieldTypeByValue.emplace( 481, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 481, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<482>(), FixMailingInst );
  tagNameByValue.emplace( 482, FixMailingInst );
  tagByName.emplace( FixMailingInst, 482 );
  fieldTypeByValue.emplace( 482, FieldType::STRING );
  fieldTypeNameByValue.emplace( 482, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<483>(), FixTransBkdTime );
  tagNameByValue.emplace( 483, FixTransBkdTime );
  tagByName.emplace( FixTransBkdTime, 483 );
  fieldTypeByValue.emplace( 483, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 483, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<484>(), FixExecPriceType );
  tagNameByValue.emplace( 484, FixExecPriceType );
  tagByName.emplace( FixExecPriceType, 484 );
  fieldTypeByValue.emplace( 484, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 484, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<485>(), FixExecPriceAdjustment );
  tagNameByValue.emplace( 485, FixExecPriceAdjustment );
  tagByName.emplace( FixExecPriceAdjustment, 485 );
  fieldTypeByValue.emplace( 485, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 485, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<486>(), FixDateOfBirth );
  tagNameByValue.emplace( 486, FixDateOfBirth );
  tagByName.emplace( FixDateOfBirth, 486 );
  fieldTypeByValue.emplace( 486, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 486, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<487>(), FixTradeReportTransType );
  tagNameByValue.emplace( 487, FixTradeReportTransType );
  tagByName.emplace( FixTradeReportTransType, 487 );
  fieldTypeByValue.emplace( 487, FieldType::INT );
  fieldTypeNameByValue.emplace( 487, "INT" );

  tagNameByRaw.emplace( tag_as_raw<488>(), FixCardHolderName );
  tagNameByValue.emplace( 488, FixCardHolderName );
  tagByName.emplace( FixCardHolderName, 488 );
  fieldTypeByValue.emplace( 488, FieldType::STRING );
  fieldTypeNameByValue.emplace( 488, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<489>(), FixCardNumber );
  tagNameByValue.emplace( 489, FixCardNumber );
  tagByName.emplace( FixCardNumber, 489 );
  fieldTypeByValue.emplace( 489, FieldType::STRING );
  fieldTypeNameByValue.emplace( 489, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<490>(), FixCardExpDate );
  tagNameByValue.emplace( 490, FixCardExpDate );
  tagByName.emplace( FixCardExpDate, 490 );
  fieldTypeByValue.emplace( 490, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 490, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<491>(), FixCardIssNum );
  tagNameByValue.emplace( 491, FixCardIssNum );
  tagByName.emplace( FixCardIssNum, 491 );
  fieldTypeByValue.emplace( 491, FieldType::STRING );
  fieldTypeNameByValue.emplace( 491, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<492>(), FixPaymentMethod );
  tagNameByValue.emplace( 492, FixPaymentMethod );
  tagByName.emplace( FixPaymentMethod, 492 );
  fieldTypeByValue.emplace( 492, FieldType::INT );
  fieldTypeNameByValue.emplace( 492, "INT" );

  tagNameByRaw.emplace( tag_as_raw<493>(), FixRegistAcctType );
  tagNameByValue.emplace( 493, FixRegistAcctType );
  tagByName.emplace( FixRegistAcctType, 493 );
  fieldTypeByValue.emplace( 493, FieldType::STRING );
  fieldTypeNameByValue.emplace( 493, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<494>(), FixDesignation );
  tagNameByValue.emplace( 494, FixDesignation );
  tagByName.emplace( FixDesignation, 494 );
  fieldTypeByValue.emplace( 494, FieldType::STRING );
  fieldTypeNameByValue.emplace( 494, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<495>(), FixTaxAdvantageType );
  tagNameByValue.emplace( 495, FixTaxAdvantageType );
  tagByName.emplace( FixTaxAdvantageType, 495 );
  fieldTypeByValue.emplace( 495, FieldType::INT );
  fieldTypeNameByValue.emplace( 495, "INT" );

  tagNameByRaw.emplace( tag_as_raw<496>(), FixRegistRejReasonText );
  tagNameByValue.emplace( 496, FixRegistRejReasonText );
  tagByName.emplace( FixRegistRejReasonText, 496 );
  fieldTypeByValue.emplace( 496, FieldType::STRING );
  fieldTypeNameByValue.emplace( 496, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<497>(), FixFundRenewWaiv );
  tagNameByValue.emplace( 497, FixFundRenewWaiv );
  tagByName.emplace( FixFundRenewWaiv, 497 );
  fieldTypeByValue.emplace( 497, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 497, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<498>(), FixCashDistribAgentName );
  tagNameByValue.emplace( 498, FixCashDistribAgentName );
  tagByName.emplace( FixCashDistribAgentName, 498 );
  fieldTypeByValue.emplace( 498, FieldType::STRING );
  fieldTypeNameByValue.emplace( 498, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<499>(), FixCashDistribAgentCode );
  tagNameByValue.emplace( 499, FixCashDistribAgentCode );
  tagByName.emplace( FixCashDistribAgentCode, 499 );
  fieldTypeByValue.emplace( 499, FieldType::STRING );
  fieldTypeNameByValue.emplace( 499, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<500>(), FixCashDistribAgentAcctNumber );
  tagNameByValue.emplace( 500, FixCashDistribAgentAcctNumber );
  tagByName.emplace( FixCashDistribAgentAcctNumber, 500 );
  fieldTypeByValue.emplace( 500, FieldType::STRING );
  fieldTypeNameByValue.emplace( 500, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<501>(), FixCashDistribPayRef );
  tagNameByValue.emplace( 501, FixCashDistribPayRef );
  tagByName.emplace( FixCashDistribPayRef, 501 );
  fieldTypeByValue.emplace( 501, FieldType::STRING );
  fieldTypeNameByValue.emplace( 501, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<502>(), FixCashDistribAgentAcctName );
  tagNameByValue.emplace( 502, FixCashDistribAgentAcctName );
  tagByName.emplace( FixCashDistribAgentAcctName, 502 );
  fieldTypeByValue.emplace( 502, FieldType::STRING );
  fieldTypeNameByValue.emplace( 502, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<503>(), FixCardStartDate );
  tagNameByValue.emplace( 503, FixCardStartDate );
  tagByName.emplace( FixCardStartDate, 503 );
  fieldTypeByValue.emplace( 503, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 503, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<504>(), FixPaymentDate );
  tagNameByValue.emplace( 504, FixPaymentDate );
  tagByName.emplace( FixPaymentDate, 504 );
  fieldTypeByValue.emplace( 504, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 504, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<505>(), FixPaymentRemitterID );
  tagNameByValue.emplace( 505, FixPaymentRemitterID );
  tagByName.emplace( FixPaymentRemitterID, 505 );
  fieldTypeByValue.emplace( 505, FieldType::STRING );
  fieldTypeNameByValue.emplace( 505, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<506>(), FixRegistStatus );
  tagNameByValue.emplace( 506, FixRegistStatus );
  tagByName.emplace( FixRegistStatus, 506 );
  fieldTypeByValue.emplace( 506, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 506, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<507>(), FixRegistRejReasonCode );
  tagNameByValue.emplace( 507, FixRegistRejReasonCode );
  tagByName.emplace( FixRegistRejReasonCode, 507 );
  fieldTypeByValue.emplace( 507, FieldType::INT );
  fieldTypeNameByValue.emplace( 507, "INT" );

  tagNameByRaw.emplace( tag_as_raw<508>(), FixRegistRefID );
  tagNameByValue.emplace( 508, FixRegistRefID );
  tagByName.emplace( FixRegistRefID, 508 );
  fieldTypeByValue.emplace( 508, FieldType::STRING );
  fieldTypeNameByValue.emplace( 508, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<509>(), FixRegistDtls );
  tagNameByValue.emplace( 509, FixRegistDtls );
  tagByName.emplace( FixRegistDtls, 509 );
  fieldTypeByValue.emplace( 509, FieldType::STRING );
  fieldTypeNameByValue.emplace( 509, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<510>(), FixNoDistribInsts );
  tagNameByValue.emplace( 510, FixNoDistribInsts );
  tagByName.emplace( FixNoDistribInsts, 510 );
  fieldTypeByValue.emplace( 510, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 510, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<511>(), FixRegistEmail );
  tagNameByValue.emplace( 511, FixRegistEmail );
  tagByName.emplace( FixRegistEmail, 511 );
  fieldTypeByValue.emplace( 511, FieldType::STRING );
  fieldTypeNameByValue.emplace( 511, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<512>(), FixDistribPercentage );
  tagNameByValue.emplace( 512, FixDistribPercentage );
  tagByName.emplace( FixDistribPercentage, 512 );
  fieldTypeByValue.emplace( 512, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 512, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<513>(), FixRegistID );
  tagNameByValue.emplace( 513, FixRegistID );
  tagByName.emplace( FixRegistID, 513 );
  fieldTypeByValue.emplace( 513, FieldType::STRING );
  fieldTypeNameByValue.emplace( 513, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<514>(), FixRegistTransType );
  tagNameByValue.emplace( 514, FixRegistTransType );
  tagByName.emplace( FixRegistTransType, 514 );
  fieldTypeByValue.emplace( 514, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 514, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<515>(), FixExecValuationPoint );
  tagNameByValue.emplace( 515, FixExecValuationPoint );
  tagByName.emplace( FixExecValuationPoint, 515 );
  fieldTypeByValue.emplace( 515, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 515, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<516>(), FixOrderPercent );
  tagNameByValue.emplace( 516, FixOrderPercent );
  tagByName.emplace( FixOrderPercent, 516 );
  fieldTypeByValue.emplace( 516, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 516, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<517>(), FixOwnershipType );
  tagNameByValue.emplace( 517, FixOwnershipType );
  tagByName.emplace( FixOwnershipType, 517 );
  fieldTypeByValue.emplace( 517, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 517, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<518>(), FixNoContAmts );
  tagNameByValue.emplace( 518, FixNoContAmts );
  tagByName.emplace( FixNoContAmts, 518 );
  fieldTypeByValue.emplace( 518, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 518, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<519>(), FixContAmtType );
  tagNameByValue.emplace( 519, FixContAmtType );
  tagByName.emplace( FixContAmtType, 519 );
  fieldTypeByValue.emplace( 519, FieldType::INT );
  fieldTypeNameByValue.emplace( 519, "INT" );

  tagNameByRaw.emplace( tag_as_raw<520>(), FixContAmtValue );
  tagNameByValue.emplace( 520, FixContAmtValue );
  tagByName.emplace( FixContAmtValue, 520 );
  fieldTypeByValue.emplace( 520, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 520, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<521>(), FixContAmtCurr );
  tagNameByValue.emplace( 521, FixContAmtCurr );
  tagByName.emplace( FixContAmtCurr, 521 );
  fieldTypeByValue.emplace( 521, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 521, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<522>(), FixOwnerType );
  tagNameByValue.emplace( 522, FixOwnerType );
  tagByName.emplace( FixOwnerType, 522 );
  fieldTypeByValue.emplace( 522, FieldType::INT );
  fieldTypeNameByValue.emplace( 522, "INT" );

  tagNameByRaw.emplace( tag_as_raw<523>(), FixPartySubID );
  tagNameByValue.emplace( 523, FixPartySubID );
  tagByName.emplace( FixPartySubID, 523 );
  fieldTypeByValue.emplace( 523, FieldType::STRING );
  fieldTypeNameByValue.emplace( 523, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<524>(), FixNestedPartyID );
  tagNameByValue.emplace( 524, FixNestedPartyID );
  tagByName.emplace( FixNestedPartyID, 524 );
  fieldTypeByValue.emplace( 524, FieldType::STRING );
  fieldTypeNameByValue.emplace( 524, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<525>(), FixNestedPartyIDSource );
  tagNameByValue.emplace( 525, FixNestedPartyIDSource );
  tagByName.emplace( FixNestedPartyIDSource, 525 );
  fieldTypeByValue.emplace( 525, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 525, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<526>(), FixSecondaryClOrdID );
  tagNameByValue.emplace( 526, FixSecondaryClOrdID );
  tagByName.emplace( FixSecondaryClOrdID, 526 );
  fieldTypeByValue.emplace( 526, FieldType::STRING );
  fieldTypeNameByValue.emplace( 526, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<527>(), FixSecondaryExecID );
  tagNameByValue.emplace( 527, FixSecondaryExecID );
  tagByName.emplace( FixSecondaryExecID, 527 );
  fieldTypeByValue.emplace( 527, FieldType::STRING );
  fieldTypeNameByValue.emplace( 527, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<528>(), FixOrderCapacity );
  tagNameByValue.emplace( 528, FixOrderCapacity );
  tagByName.emplace( FixOrderCapacity, 528 );
  fieldTypeByValue.emplace( 528, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 528, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<529>(), FixOrderRestrictions );
  tagNameByValue.emplace( 529, FixOrderRestrictions );
  tagByName.emplace( FixOrderRestrictions, 529 );
  fieldTypeByValue.emplace( 529, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 529, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<530>(), FixMassCancelRequestType );
  tagNameByValue.emplace( 530, FixMassCancelRequestType );
  tagByName.emplace( FixMassCancelRequestType, 530 );
  fieldTypeByValue.emplace( 530, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 530, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<531>(), FixMassCancelResponse );
  tagNameByValue.emplace( 531, FixMassCancelResponse );
  tagByName.emplace( FixMassCancelResponse, 531 );
  fieldTypeByValue.emplace( 531, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 531, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<532>(), FixMassCancelRejectReason );
  tagNameByValue.emplace( 532, FixMassCancelRejectReason );
  tagByName.emplace( FixMassCancelRejectReason, 532 );
  fieldTypeByValue.emplace( 532, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 532, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<533>(), FixTotalAffectedOrders );
  tagNameByValue.emplace( 533, FixTotalAffectedOrders );
  tagByName.emplace( FixTotalAffectedOrders, 533 );
  fieldTypeByValue.emplace( 533, FieldType::INT );
  fieldTypeNameByValue.emplace( 533, "INT" );

  tagNameByRaw.emplace( tag_as_raw<534>(), FixNoAffectedOrders );
  tagNameByValue.emplace( 534, FixNoAffectedOrders );
  tagByName.emplace( FixNoAffectedOrders, 534 );
  fieldTypeByValue.emplace( 534, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 534, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<535>(), FixAffectedOrderID );
  tagNameByValue.emplace( 535, FixAffectedOrderID );
  tagByName.emplace( FixAffectedOrderID, 535 );
  fieldTypeByValue.emplace( 535, FieldType::STRING );
  fieldTypeNameByValue.emplace( 535, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<536>(), FixAffectedSecondaryOrderID );
  tagNameByValue.emplace( 536, FixAffectedSecondaryOrderID );
  tagByName.emplace( FixAffectedSecondaryOrderID, 536 );
  fieldTypeByValue.emplace( 536, FieldType::STRING );
  fieldTypeNameByValue.emplace( 536, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<537>(), FixQuoteType );
  tagNameByValue.emplace( 537, FixQuoteType );
  tagByName.emplace( FixQuoteType, 537 );
  fieldTypeByValue.emplace( 537, FieldType::INT );
  fieldTypeNameByValue.emplace( 537, "INT" );

  tagNameByRaw.emplace( tag_as_raw<538>(), FixNestedPartyRole );
  tagNameByValue.emplace( 538, FixNestedPartyRole );
  tagByName.emplace( FixNestedPartyRole, 538 );
  fieldTypeByValue.emplace( 538, FieldType::INT );
  fieldTypeNameByValue.emplace( 538, "INT" );

  tagNameByRaw.emplace( tag_as_raw<539>(), FixNoNestedPartyIDs );
  tagNameByValue.emplace( 539, FixNoNestedPartyIDs );
  tagByName.emplace( FixNoNestedPartyIDs, 539 );
  fieldTypeByValue.emplace( 539, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 539, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<540>(), FixTotalAccruedInterestAmt );
  tagNameByValue.emplace( 540, FixTotalAccruedInterestAmt );
  tagByName.emplace( FixTotalAccruedInterestAmt, 540 );
  fieldTypeByValue.emplace( 540, FieldType::AMT );
  fieldTypeNameByValue.emplace( 540, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<541>(), FixMaturityDate );
  tagNameByValue.emplace( 541, FixMaturityDate );
  tagByName.emplace( FixMaturityDate, 541 );
  fieldTypeByValue.emplace( 541, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 541, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<542>(), FixUnderlyingMaturityDate );
  tagNameByValue.emplace( 542, FixUnderlyingMaturityDate );
  tagByName.emplace( FixUnderlyingMaturityDate, 542 );
  fieldTypeByValue.emplace( 542, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 542, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<543>(), FixInstrRegistry );
  tagNameByValue.emplace( 543, FixInstrRegistry );
  tagByName.emplace( FixInstrRegistry, 543 );
  fieldTypeByValue.emplace( 543, FieldType::STRING );
  fieldTypeNameByValue.emplace( 543, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<544>(), FixCashMargin );
  tagNameByValue.emplace( 544, FixCashMargin );
  tagByName.emplace( FixCashMargin, 544 );
  fieldTypeByValue.emplace( 544, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 544, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<545>(), FixNestedPartySubID );
  tagNameByValue.emplace( 545, FixNestedPartySubID );
  tagByName.emplace( FixNestedPartySubID, 545 );
  fieldTypeByValue.emplace( 545, FieldType::STRING );
  fieldTypeNameByValue.emplace( 545, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<546>(), FixScope );
  tagNameByValue.emplace( 546, FixScope );
  tagByName.emplace( FixScope, 546 );
  fieldTypeByValue.emplace( 546, FieldType::MULTIPLEVALUESTRING );
  fieldTypeNameByValue.emplace( 546, "MULTIPLEVALUESTRING" );

  tagNameByRaw.emplace( tag_as_raw<547>(), FixMDImplicitDelete );
  tagNameByValue.emplace( 547, FixMDImplicitDelete );
  tagByName.emplace( FixMDImplicitDelete, 547 );
  fieldTypeByValue.emplace( 547, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 547, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<548>(), FixCrossID );
  tagNameByValue.emplace( 548, FixCrossID );
  tagByName.emplace( FixCrossID, 548 );
  fieldTypeByValue.emplace( 548, FieldType::STRING );
  fieldTypeNameByValue.emplace( 548, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<549>(), FixCrossType );
  tagNameByValue.emplace( 549, FixCrossType );
  tagByName.emplace( FixCrossType, 549 );
  fieldTypeByValue.emplace( 549, FieldType::INT );
  fieldTypeNameByValue.emplace( 549, "INT" );

  tagNameByRaw.emplace( tag_as_raw<550>(), FixCrossPrioritization );
  tagNameByValue.emplace( 550, FixCrossPrioritization );
  tagByName.emplace( FixCrossPrioritization, 550 );
  fieldTypeByValue.emplace( 550, FieldType::INT );
  fieldTypeNameByValue.emplace( 550, "INT" );

  tagNameByRaw.emplace( tag_as_raw<551>(), FixOrigCrossID );
  tagNameByValue.emplace( 551, FixOrigCrossID );
  tagByName.emplace( FixOrigCrossID, 551 );
  fieldTypeByValue.emplace( 551, FieldType::STRING );
  fieldTypeNameByValue.emplace( 551, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<552>(), FixNoSides );
  tagNameByValue.emplace( 552, FixNoSides );
  tagByName.emplace( FixNoSides, 552 );
  fieldTypeByValue.emplace( 552, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 552, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<553>(), FixUsername );
  tagNameByValue.emplace( 553, FixUsername );
  tagByName.emplace( FixUsername, 553 );
  fieldTypeByValue.emplace( 553, FieldType::STRING );
  fieldTypeNameByValue.emplace( 553, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<554>(), FixPassword );
  tagNameByValue.emplace( 554, FixPassword );
  tagByName.emplace( FixPassword, 554 );
  fieldTypeByValue.emplace( 554, FieldType::STRING );
  fieldTypeNameByValue.emplace( 554, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<555>(), FixNoLegs );
  tagNameByValue.emplace( 555, FixNoLegs );
  tagByName.emplace( FixNoLegs, 555 );
  fieldTypeByValue.emplace( 555, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 555, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<556>(), FixLegCurrency );
  tagNameByValue.emplace( 556, FixLegCurrency );
  tagByName.emplace( FixLegCurrency, 556 );
  fieldTypeByValue.emplace( 556, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 556, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<557>(), FixTotNoSecurityTypes );
  tagNameByValue.emplace( 557, FixTotNoSecurityTypes );
  tagByName.emplace( FixTotNoSecurityTypes, 557 );
  fieldTypeByValue.emplace( 557, FieldType::INT );
  fieldTypeNameByValue.emplace( 557, "INT" );

  tagNameByRaw.emplace( tag_as_raw<558>(), FixNoSecurityTypes );
  tagNameByValue.emplace( 558, FixNoSecurityTypes );
  tagByName.emplace( FixNoSecurityTypes, 558 );
  fieldTypeByValue.emplace( 558, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 558, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<559>(), FixSecurityListRequestType );
  tagNameByValue.emplace( 559, FixSecurityListRequestType );
  tagByName.emplace( FixSecurityListRequestType, 559 );
  fieldTypeByValue.emplace( 559, FieldType::INT );
  fieldTypeNameByValue.emplace( 559, "INT" );

  tagNameByRaw.emplace( tag_as_raw<560>(), FixSecurityRequestResult );
  tagNameByValue.emplace( 560, FixSecurityRequestResult );
  tagByName.emplace( FixSecurityRequestResult, 560 );
  fieldTypeByValue.emplace( 560, FieldType::INT );
  fieldTypeNameByValue.emplace( 560, "INT" );

  tagNameByRaw.emplace( tag_as_raw<561>(), FixRoundLot );
  tagNameByValue.emplace( 561, FixRoundLot );
  tagByName.emplace( FixRoundLot, 561 );
  fieldTypeByValue.emplace( 561, FieldType::QTY );
  fieldTypeNameByValue.emplace( 561, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<562>(), FixMinTradeVol );
  tagNameByValue.emplace( 562, FixMinTradeVol );
  tagByName.emplace( FixMinTradeVol, 562 );
  fieldTypeByValue.emplace( 562, FieldType::QTY );
  fieldTypeNameByValue.emplace( 562, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<563>(), FixMultiLegRptTypeReq );
  tagNameByValue.emplace( 563, FixMultiLegRptTypeReq );
  tagByName.emplace( FixMultiLegRptTypeReq, 563 );
  fieldTypeByValue.emplace( 563, FieldType::INT );
  fieldTypeNameByValue.emplace( 563, "INT" );

  tagNameByRaw.emplace( tag_as_raw<564>(), FixLegPositionEffect );
  tagNameByValue.emplace( 564, FixLegPositionEffect );
  tagByName.emplace( FixLegPositionEffect, 564 );
  fieldTypeByValue.emplace( 564, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 564, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<565>(), FixLegCoveredOrUncovered );
  tagNameByValue.emplace( 565, FixLegCoveredOrUncovered );
  tagByName.emplace( FixLegCoveredOrUncovered, 565 );
  fieldTypeByValue.emplace( 565, FieldType::INT );
  fieldTypeNameByValue.emplace( 565, "INT" );

  tagNameByRaw.emplace( tag_as_raw<566>(), FixLegPrice );
  tagNameByValue.emplace( 566, FixLegPrice );
  tagByName.emplace( FixLegPrice, 566 );
  fieldTypeByValue.emplace( 566, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 566, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<567>(), FixTradSesStatusRejReason );
  tagNameByValue.emplace( 567, FixTradSesStatusRejReason );
  tagByName.emplace( FixTradSesStatusRejReason, 567 );
  fieldTypeByValue.emplace( 567, FieldType::INT );
  fieldTypeNameByValue.emplace( 567, "INT" );

  tagNameByRaw.emplace( tag_as_raw<568>(), FixTradeRequestID );
  tagNameByValue.emplace( 568, FixTradeRequestID );
  tagByName.emplace( FixTradeRequestID, 568 );
  fieldTypeByValue.emplace( 568, FieldType::STRING );
  fieldTypeNameByValue.emplace( 568, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<569>(), FixTradeRequestType );
  tagNameByValue.emplace( 569, FixTradeRequestType );
  tagByName.emplace( FixTradeRequestType, 569 );
  fieldTypeByValue.emplace( 569, FieldType::INT );
  fieldTypeNameByValue.emplace( 569, "INT" );

  tagNameByRaw.emplace( tag_as_raw<570>(), FixPreviouslyReported );
  tagNameByValue.emplace( 570, FixPreviouslyReported );
  tagByName.emplace( FixPreviouslyReported, 570 );
  fieldTypeByValue.emplace( 570, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 570, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<571>(), FixTradeReportID );
  tagNameByValue.emplace( 571, FixTradeReportID );
  tagByName.emplace( FixTradeReportID, 571 );
  fieldTypeByValue.emplace( 571, FieldType::STRING );
  fieldTypeNameByValue.emplace( 571, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<572>(), FixTradeReportRefID );
  tagNameByValue.emplace( 572, FixTradeReportRefID );
  tagByName.emplace( FixTradeReportRefID, 572 );
  fieldTypeByValue.emplace( 572, FieldType::STRING );
  fieldTypeNameByValue.emplace( 572, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<573>(), FixMatchStatus );
  tagNameByValue.emplace( 573, FixMatchStatus );
  tagByName.emplace( FixMatchStatus, 573 );
  fieldTypeByValue.emplace( 573, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 573, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<574>(), FixMatchType );
  tagNameByValue.emplace( 574, FixMatchType );
  tagByName.emplace( FixMatchType, 574 );
  fieldTypeByValue.emplace( 574, FieldType::STRING );
  fieldTypeNameByValue.emplace( 574, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<575>(), FixOddLot );
  tagNameByValue.emplace( 575, FixOddLot );
  tagByName.emplace( FixOddLot, 575 );
  fieldTypeByValue.emplace( 575, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 575, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<576>(), FixNoClearingInstructions );
  tagNameByValue.emplace( 576, FixNoClearingInstructions );
  tagByName.emplace( FixNoClearingInstructions, 576 );
  fieldTypeByValue.emplace( 576, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 576, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<577>(), FixClearingInstruction );
  tagNameByValue.emplace( 577, FixClearingInstruction );
  tagByName.emplace( FixClearingInstruction, 577 );
  fieldTypeByValue.emplace( 577, FieldType::INT );
  fieldTypeNameByValue.emplace( 577, "INT" );

  tagNameByRaw.emplace( tag_as_raw<578>(), FixTradeInputSource );
  tagNameByValue.emplace( 578, FixTradeInputSource );
  tagByName.emplace( FixTradeInputSource, 578 );
  fieldTypeByValue.emplace( 578, FieldType::STRING );
  fieldTypeNameByValue.emplace( 578, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<579>(), FixTradeInputDevice );
  tagNameByValue.emplace( 579, FixTradeInputDevice );
  tagByName.emplace( FixTradeInputDevice, 579 );
  fieldTypeByValue.emplace( 579, FieldType::STRING );
  fieldTypeNameByValue.emplace( 579, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<580>(), FixNoDates );
  tagNameByValue.emplace( 580, FixNoDates );
  tagByName.emplace( FixNoDates, 580 );
  fieldTypeByValue.emplace( 580, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 580, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<581>(), FixAccountType );
  tagNameByValue.emplace( 581, FixAccountType );
  tagByName.emplace( FixAccountType, 581 );
  fieldTypeByValue.emplace( 581, FieldType::INT );
  fieldTypeNameByValue.emplace( 581, "INT" );

  tagNameByRaw.emplace( tag_as_raw<582>(), FixCustOrderCapacity );
  tagNameByValue.emplace( 582, FixCustOrderCapacity );
  tagByName.emplace( FixCustOrderCapacity, 582 );
  fieldTypeByValue.emplace( 582, FieldType::INT );
  fieldTypeNameByValue.emplace( 582, "INT" );

  tagNameByRaw.emplace( tag_as_raw<583>(), FixClOrdLinkID );
  tagNameByValue.emplace( 583, FixClOrdLinkID );
  tagByName.emplace( FixClOrdLinkID, 583 );
  fieldTypeByValue.emplace( 583, FieldType::STRING );
  fieldTypeNameByValue.emplace( 583, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<584>(), FixMassStatusReqID );
  tagNameByValue.emplace( 584, FixMassStatusReqID );
  tagByName.emplace( FixMassStatusReqID, 584 );
  fieldTypeByValue.emplace( 584, FieldType::STRING );
  fieldTypeNameByValue.emplace( 584, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<585>(), FixMassStatusReqType );
  tagNameByValue.emplace( 585, FixMassStatusReqType );
  tagByName.emplace( FixMassStatusReqType, 585 );
  fieldTypeByValue.emplace( 585, FieldType::INT );
  fieldTypeNameByValue.emplace( 585, "INT" );

  tagNameByRaw.emplace( tag_as_raw<586>(), FixOrigOrdModTime );
  tagNameByValue.emplace( 586, FixOrigOrdModTime );
  tagByName.emplace( FixOrigOrdModTime, 586 );
  fieldTypeByValue.emplace( 586, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 586, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<587>(), FixLegSettlType );
  tagNameByValue.emplace( 587, FixLegSettlType );
  tagByName.emplace( FixLegSettlType, 587 );
  fieldTypeByValue.emplace( 587, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 587, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<588>(), FixLegSettlDate );
  tagNameByValue.emplace( 588, FixLegSettlDate );
  tagByName.emplace( FixLegSettlDate, 588 );
  fieldTypeByValue.emplace( 588, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 588, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<589>(), FixDayBookingInst );
  tagNameByValue.emplace( 589, FixDayBookingInst );
  tagByName.emplace( FixDayBookingInst, 589 );
  fieldTypeByValue.emplace( 589, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 589, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<590>(), FixBookingUnit );
  tagNameByValue.emplace( 590, FixBookingUnit );
  tagByName.emplace( FixBookingUnit, 590 );
  fieldTypeByValue.emplace( 590, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 590, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<591>(), FixPreallocMethod );
  tagNameByValue.emplace( 591, FixPreallocMethod );
  tagByName.emplace( FixPreallocMethod, 591 );
  fieldTypeByValue.emplace( 591, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 591, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<592>(), FixUnderlyingCountryOfIssue );
  tagNameByValue.emplace( 592, FixUnderlyingCountryOfIssue );
  tagByName.emplace( FixUnderlyingCountryOfIssue, 592 );
  fieldTypeByValue.emplace( 592, FieldType::COUNTRY );
  fieldTypeNameByValue.emplace( 592, "COUNTRY" );

  tagNameByRaw.emplace( tag_as_raw<593>(), FixUnderlyingStateOrProvinceOfIssue );
  tagNameByValue.emplace( 593, FixUnderlyingStateOrProvinceOfIssue );
  tagByName.emplace( FixUnderlyingStateOrProvinceOfIssue, 593 );
  fieldTypeByValue.emplace( 593, FieldType::STRING );
  fieldTypeNameByValue.emplace( 593, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<594>(), FixUnderlyingLocaleOfIssue );
  tagNameByValue.emplace( 594, FixUnderlyingLocaleOfIssue );
  tagByName.emplace( FixUnderlyingLocaleOfIssue, 594 );
  fieldTypeByValue.emplace( 594, FieldType::STRING );
  fieldTypeNameByValue.emplace( 594, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<595>(), FixUnderlyingInstrRegistry );
  tagNameByValue.emplace( 595, FixUnderlyingInstrRegistry );
  tagByName.emplace( FixUnderlyingInstrRegistry, 595 );
  fieldTypeByValue.emplace( 595, FieldType::STRING );
  fieldTypeNameByValue.emplace( 595, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<596>(), FixLegCountryOfIssue );
  tagNameByValue.emplace( 596, FixLegCountryOfIssue );
  tagByName.emplace( FixLegCountryOfIssue, 596 );
  fieldTypeByValue.emplace( 596, FieldType::COUNTRY );
  fieldTypeNameByValue.emplace( 596, "COUNTRY" );

  tagNameByRaw.emplace( tag_as_raw<597>(), FixLegStateOrProvinceOfIssue );
  tagNameByValue.emplace( 597, FixLegStateOrProvinceOfIssue );
  tagByName.emplace( FixLegStateOrProvinceOfIssue, 597 );
  fieldTypeByValue.emplace( 597, FieldType::STRING );
  fieldTypeNameByValue.emplace( 597, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<598>(), FixLegLocaleOfIssue );
  tagNameByValue.emplace( 598, FixLegLocaleOfIssue );
  tagByName.emplace( FixLegLocaleOfIssue, 598 );
  fieldTypeByValue.emplace( 598, FieldType::STRING );
  fieldTypeNameByValue.emplace( 598, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<599>(), FixLegInstrRegistry );
  tagNameByValue.emplace( 599, FixLegInstrRegistry );
  tagByName.emplace( FixLegInstrRegistry, 599 );
  fieldTypeByValue.emplace( 599, FieldType::STRING );
  fieldTypeNameByValue.emplace( 599, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<600>(), FixLegSymbol );
  tagNameByValue.emplace( 600, FixLegSymbol );
  tagByName.emplace( FixLegSymbol, 600 );
  fieldTypeByValue.emplace( 600, FieldType::STRING );
  fieldTypeNameByValue.emplace( 600, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<601>(), FixLegSymbolSfx );
  tagNameByValue.emplace( 601, FixLegSymbolSfx );
  tagByName.emplace( FixLegSymbolSfx, 601 );
  fieldTypeByValue.emplace( 601, FieldType::STRING );
  fieldTypeNameByValue.emplace( 601, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<602>(), FixLegSecurityID );
  tagNameByValue.emplace( 602, FixLegSecurityID );
  tagByName.emplace( FixLegSecurityID, 602 );
  fieldTypeByValue.emplace( 602, FieldType::STRING );
  fieldTypeNameByValue.emplace( 602, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<603>(), FixLegSecurityIDSource );
  tagNameByValue.emplace( 603, FixLegSecurityIDSource );
  tagByName.emplace( FixLegSecurityIDSource, 603 );
  fieldTypeByValue.emplace( 603, FieldType::STRING );
  fieldTypeNameByValue.emplace( 603, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<604>(), FixNoLegSecurityAltID );
  tagNameByValue.emplace( 604, FixNoLegSecurityAltID );
  tagByName.emplace( FixNoLegSecurityAltID, 604 );
  fieldTypeByValue.emplace( 604, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 604, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<605>(), FixLegSecurityAltID );
  tagNameByValue.emplace( 605, FixLegSecurityAltID );
  tagByName.emplace( FixLegSecurityAltID, 605 );
  fieldTypeByValue.emplace( 605, FieldType::STRING );
  fieldTypeNameByValue.emplace( 605, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<606>(), FixLegSecurityAltIDSource );
  tagNameByValue.emplace( 606, FixLegSecurityAltIDSource );
  tagByName.emplace( FixLegSecurityAltIDSource, 606 );
  fieldTypeByValue.emplace( 606, FieldType::STRING );
  fieldTypeNameByValue.emplace( 606, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<607>(), FixLegProduct );
  tagNameByValue.emplace( 607, FixLegProduct );
  tagByName.emplace( FixLegProduct, 607 );
  fieldTypeByValue.emplace( 607, FieldType::INT );
  fieldTypeNameByValue.emplace( 607, "INT" );

  tagNameByRaw.emplace( tag_as_raw<608>(), FixLegCFICode );
  tagNameByValue.emplace( 608, FixLegCFICode );
  tagByName.emplace( FixLegCFICode, 608 );
  fieldTypeByValue.emplace( 608, FieldType::STRING );
  fieldTypeNameByValue.emplace( 608, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<609>(), FixLegSecurityType );
  tagNameByValue.emplace( 609, FixLegSecurityType );
  tagByName.emplace( FixLegSecurityType, 609 );
  fieldTypeByValue.emplace( 609, FieldType::STRING );
  fieldTypeNameByValue.emplace( 609, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<610>(), FixLegMaturityMonthYear );
  tagNameByValue.emplace( 610, FixLegMaturityMonthYear );
  tagByName.emplace( FixLegMaturityMonthYear, 610 );
  fieldTypeByValue.emplace( 610, FieldType::MONTHYEAR );
  fieldTypeNameByValue.emplace( 610, "MONTHYEAR" );

  tagNameByRaw.emplace( tag_as_raw<611>(), FixLegMaturityDate );
  tagNameByValue.emplace( 611, FixLegMaturityDate );
  tagByName.emplace( FixLegMaturityDate, 611 );
  fieldTypeByValue.emplace( 611, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 611, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<612>(), FixLegStrikePrice );
  tagNameByValue.emplace( 612, FixLegStrikePrice );
  tagByName.emplace( FixLegStrikePrice, 612 );
  fieldTypeByValue.emplace( 612, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 612, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<613>(), FixLegOptAttribute );
  tagNameByValue.emplace( 613, FixLegOptAttribute );
  tagByName.emplace( FixLegOptAttribute, 613 );
  fieldTypeByValue.emplace( 613, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 613, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<614>(), FixLegContractMultiplier );
  tagNameByValue.emplace( 614, FixLegContractMultiplier );
  tagByName.emplace( FixLegContractMultiplier, 614 );
  fieldTypeByValue.emplace( 614, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 614, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<615>(), FixLegCouponRate );
  tagNameByValue.emplace( 615, FixLegCouponRate );
  tagByName.emplace( FixLegCouponRate, 615 );
  fieldTypeByValue.emplace( 615, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 615, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<616>(), FixLegSecurityExchange );
  tagNameByValue.emplace( 616, FixLegSecurityExchange );
  tagByName.emplace( FixLegSecurityExchange, 616 );
  fieldTypeByValue.emplace( 616, FieldType::EXCHANGE );
  fieldTypeNameByValue.emplace( 616, "EXCHANGE" );

  tagNameByRaw.emplace( tag_as_raw<617>(), FixLegIssuer );
  tagNameByValue.emplace( 617, FixLegIssuer );
  tagByName.emplace( FixLegIssuer, 617 );
  fieldTypeByValue.emplace( 617, FieldType::STRING );
  fieldTypeNameByValue.emplace( 617, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<618>(), FixEncodedLegIssuerLen );
  tagNameByValue.emplace( 618, FixEncodedLegIssuerLen );
  tagByName.emplace( FixEncodedLegIssuerLen, 618 );
  fieldTypeByValue.emplace( 618, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 618, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<619>(), FixEncodedLegIssuer );
  tagNameByValue.emplace( 619, FixEncodedLegIssuer );
  tagByName.emplace( FixEncodedLegIssuer, 619 );
  fieldTypeByValue.emplace( 619, FieldType::DATA );
  fieldTypeNameByValue.emplace( 619, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<620>(), FixLegSecurityDesc );
  tagNameByValue.emplace( 620, FixLegSecurityDesc );
  tagByName.emplace( FixLegSecurityDesc, 620 );
  fieldTypeByValue.emplace( 620, FieldType::STRING );
  fieldTypeNameByValue.emplace( 620, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<621>(), FixEncodedLegSecurityDescLen );
  tagNameByValue.emplace( 621, FixEncodedLegSecurityDescLen );
  tagByName.emplace( FixEncodedLegSecurityDescLen, 621 );
  fieldTypeByValue.emplace( 621, FieldType::LENGTH );
  fieldTypeNameByValue.emplace( 621, "LENGTH" );

  tagNameByRaw.emplace( tag_as_raw<622>(), FixEncodedLegSecurityDesc );
  tagNameByValue.emplace( 622, FixEncodedLegSecurityDesc );
  tagByName.emplace( FixEncodedLegSecurityDesc, 622 );
  fieldTypeByValue.emplace( 622, FieldType::DATA );
  fieldTypeNameByValue.emplace( 622, "DATA" );

  tagNameByRaw.emplace( tag_as_raw<623>(), FixLegRatioQty );
  tagNameByValue.emplace( 623, FixLegRatioQty );
  tagByName.emplace( FixLegRatioQty, 623 );
  fieldTypeByValue.emplace( 623, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 623, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<624>(), FixLegSide );
  tagNameByValue.emplace( 624, FixLegSide );
  tagByName.emplace( FixLegSide, 624 );
  fieldTypeByValue.emplace( 624, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 624, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<625>(), FixTradingSessionSubID );
  tagNameByValue.emplace( 625, FixTradingSessionSubID );
  tagByName.emplace( FixTradingSessionSubID, 625 );
  fieldTypeByValue.emplace( 625, FieldType::STRING );
  fieldTypeNameByValue.emplace( 625, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<626>(), FixAllocType );
  tagNameByValue.emplace( 626, FixAllocType );
  tagByName.emplace( FixAllocType, 626 );
  fieldTypeByValue.emplace( 626, FieldType::INT );
  fieldTypeNameByValue.emplace( 626, "INT" );

  tagNameByRaw.emplace( tag_as_raw<627>(), FixNoHops );
  tagNameByValue.emplace( 627, FixNoHops );
  tagByName.emplace( FixNoHops, 627 );
  fieldTypeByValue.emplace( 627, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 627, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<628>(), FixHopCompID );
  tagNameByValue.emplace( 628, FixHopCompID );
  tagByName.emplace( FixHopCompID, 628 );
  fieldTypeByValue.emplace( 628, FieldType::STRING );
  fieldTypeNameByValue.emplace( 628, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<629>(), FixHopSendingTime );
  tagNameByValue.emplace( 629, FixHopSendingTime );
  tagByName.emplace( FixHopSendingTime, 629 );
  fieldTypeByValue.emplace( 629, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 629, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<630>(), FixHopRefID );
  tagNameByValue.emplace( 630, FixHopRefID );
  tagByName.emplace( FixHopRefID, 630 );
  fieldTypeByValue.emplace( 630, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 630, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<631>(), FixMidPx );
  tagNameByValue.emplace( 631, FixMidPx );
  tagByName.emplace( FixMidPx, 631 );
  fieldTypeByValue.emplace( 631, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 631, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<632>(), FixBidYield );
  tagNameByValue.emplace( 632, FixBidYield );
  tagByName.emplace( FixBidYield, 632 );
  fieldTypeByValue.emplace( 632, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 632, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<633>(), FixMidYield );
  tagNameByValue.emplace( 633, FixMidYield );
  tagByName.emplace( FixMidYield, 633 );
  fieldTypeByValue.emplace( 633, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 633, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<634>(), FixOfferYield );
  tagNameByValue.emplace( 634, FixOfferYield );
  tagByName.emplace( FixOfferYield, 634 );
  fieldTypeByValue.emplace( 634, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 634, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<635>(), FixClearingFeeIndicator );
  tagNameByValue.emplace( 635, FixClearingFeeIndicator );
  tagByName.emplace( FixClearingFeeIndicator, 635 );
  fieldTypeByValue.emplace( 635, FieldType::STRING );
  fieldTypeNameByValue.emplace( 635, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<636>(), FixWorkingIndicator );
  tagNameByValue.emplace( 636, FixWorkingIndicator );
  tagByName.emplace( FixWorkingIndicator, 636 );
  fieldTypeByValue.emplace( 636, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 636, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<637>(), FixLegLastPx );
  tagNameByValue.emplace( 637, FixLegLastPx );
  tagByName.emplace( FixLegLastPx, 637 );
  fieldTypeByValue.emplace( 637, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 637, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<638>(), FixPriorityIndicator );
  tagNameByValue.emplace( 638, FixPriorityIndicator );
  tagByName.emplace( FixPriorityIndicator, 638 );
  fieldTypeByValue.emplace( 638, FieldType::INT );
  fieldTypeNameByValue.emplace( 638, "INT" );

  tagNameByRaw.emplace( tag_as_raw<639>(), FixPriceImprovement );
  tagNameByValue.emplace( 639, FixPriceImprovement );
  tagByName.emplace( FixPriceImprovement, 639 );
  fieldTypeByValue.emplace( 639, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 639, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<640>(), FixPrice2 );
  tagNameByValue.emplace( 640, FixPrice2 );
  tagByName.emplace( FixPrice2, 640 );
  fieldTypeByValue.emplace( 640, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 640, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<641>(), FixLastForwardPoints2 );
  tagNameByValue.emplace( 641, FixLastForwardPoints2 );
  tagByName.emplace( FixLastForwardPoints2, 641 );
  fieldTypeByValue.emplace( 641, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 641, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<642>(), FixBidForwardPoints2 );
  tagNameByValue.emplace( 642, FixBidForwardPoints2 );
  tagByName.emplace( FixBidForwardPoints2, 642 );
  fieldTypeByValue.emplace( 642, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 642, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<643>(), FixOfferForwardPoints2 );
  tagNameByValue.emplace( 643, FixOfferForwardPoints2 );
  tagByName.emplace( FixOfferForwardPoints2, 643 );
  fieldTypeByValue.emplace( 643, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 643, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<644>(), FixRFQReqID );
  tagNameByValue.emplace( 644, FixRFQReqID );
  tagByName.emplace( FixRFQReqID, 644 );
  fieldTypeByValue.emplace( 644, FieldType::STRING );
  fieldTypeNameByValue.emplace( 644, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<645>(), FixMktBidPx );
  tagNameByValue.emplace( 645, FixMktBidPx );
  tagByName.emplace( FixMktBidPx, 645 );
  fieldTypeByValue.emplace( 645, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 645, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<646>(), FixMktOfferPx );
  tagNameByValue.emplace( 646, FixMktOfferPx );
  tagByName.emplace( FixMktOfferPx, 646 );
  fieldTypeByValue.emplace( 646, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 646, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<647>(), FixMinBidSize );
  tagNameByValue.emplace( 647, FixMinBidSize );
  tagByName.emplace( FixMinBidSize, 647 );
  fieldTypeByValue.emplace( 647, FieldType::QTY );
  fieldTypeNameByValue.emplace( 647, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<648>(), FixMinOfferSize );
  tagNameByValue.emplace( 648, FixMinOfferSize );
  tagByName.emplace( FixMinOfferSize, 648 );
  fieldTypeByValue.emplace( 648, FieldType::QTY );
  fieldTypeNameByValue.emplace( 648, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<649>(), FixQuoteStatusReqID );
  tagNameByValue.emplace( 649, FixQuoteStatusReqID );
  tagByName.emplace( FixQuoteStatusReqID, 649 );
  fieldTypeByValue.emplace( 649, FieldType::STRING );
  fieldTypeNameByValue.emplace( 649, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<650>(), FixLegalConfirm );
  tagNameByValue.emplace( 650, FixLegalConfirm );
  tagByName.emplace( FixLegalConfirm, 650 );
  fieldTypeByValue.emplace( 650, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 650, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<651>(), FixUnderlyingLastPx );
  tagNameByValue.emplace( 651, FixUnderlyingLastPx );
  tagByName.emplace( FixUnderlyingLastPx, 651 );
  fieldTypeByValue.emplace( 651, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 651, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<652>(), FixUnderlyingLastQty );
  tagNameByValue.emplace( 652, FixUnderlyingLastQty );
  tagByName.emplace( FixUnderlyingLastQty, 652 );
  fieldTypeByValue.emplace( 652, FieldType::QTY );
  fieldTypeNameByValue.emplace( 652, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<654>(), FixLegRefID );
  tagNameByValue.emplace( 654, FixLegRefID );
  tagByName.emplace( FixLegRefID, 654 );
  fieldTypeByValue.emplace( 654, FieldType::STRING );
  fieldTypeNameByValue.emplace( 654, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<655>(), FixContraLegRefID );
  tagNameByValue.emplace( 655, FixContraLegRefID );
  tagByName.emplace( FixContraLegRefID, 655 );
  fieldTypeByValue.emplace( 655, FieldType::STRING );
  fieldTypeNameByValue.emplace( 655, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<656>(), FixSettlCurrBidFxRate );
  tagNameByValue.emplace( 656, FixSettlCurrBidFxRate );
  tagByName.emplace( FixSettlCurrBidFxRate, 656 );
  fieldTypeByValue.emplace( 656, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 656, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<657>(), FixSettlCurrOfferFxRate );
  tagNameByValue.emplace( 657, FixSettlCurrOfferFxRate );
  tagByName.emplace( FixSettlCurrOfferFxRate, 657 );
  fieldTypeByValue.emplace( 657, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 657, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<658>(), FixQuoteRequestRejectReason );
  tagNameByValue.emplace( 658, FixQuoteRequestRejectReason );
  tagByName.emplace( FixQuoteRequestRejectReason, 658 );
  fieldTypeByValue.emplace( 658, FieldType::INT );
  fieldTypeNameByValue.emplace( 658, "INT" );

  tagNameByRaw.emplace( tag_as_raw<659>(), FixSideComplianceID );
  tagNameByValue.emplace( 659, FixSideComplianceID );
  tagByName.emplace( FixSideComplianceID, 659 );
  fieldTypeByValue.emplace( 659, FieldType::STRING );
  fieldTypeNameByValue.emplace( 659, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<660>(), FixAcctIDSource );
  tagNameByValue.emplace( 660, FixAcctIDSource );
  tagByName.emplace( FixAcctIDSource, 660 );
  fieldTypeByValue.emplace( 660, FieldType::INT );
  fieldTypeNameByValue.emplace( 660, "INT" );

  tagNameByRaw.emplace( tag_as_raw<661>(), FixAllocAcctIDSource );
  tagNameByValue.emplace( 661, FixAllocAcctIDSource );
  tagByName.emplace( FixAllocAcctIDSource, 661 );
  fieldTypeByValue.emplace( 661, FieldType::INT );
  fieldTypeNameByValue.emplace( 661, "INT" );

  tagNameByRaw.emplace( tag_as_raw<662>(), FixBenchmarkPrice );
  tagNameByValue.emplace( 662, FixBenchmarkPrice );
  tagByName.emplace( FixBenchmarkPrice, 662 );
  fieldTypeByValue.emplace( 662, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 662, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<663>(), FixBenchmarkPriceType );
  tagNameByValue.emplace( 663, FixBenchmarkPriceType );
  tagByName.emplace( FixBenchmarkPriceType, 663 );
  fieldTypeByValue.emplace( 663, FieldType::INT );
  fieldTypeNameByValue.emplace( 663, "INT" );

  tagNameByRaw.emplace( tag_as_raw<664>(), FixConfirmID );
  tagNameByValue.emplace( 664, FixConfirmID );
  tagByName.emplace( FixConfirmID, 664 );
  fieldTypeByValue.emplace( 664, FieldType::STRING );
  fieldTypeNameByValue.emplace( 664, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<665>(), FixConfirmStatus );
  tagNameByValue.emplace( 665, FixConfirmStatus );
  tagByName.emplace( FixConfirmStatus, 665 );
  fieldTypeByValue.emplace( 665, FieldType::INT );
  fieldTypeNameByValue.emplace( 665, "INT" );

  tagNameByRaw.emplace( tag_as_raw<666>(), FixConfirmTransType );
  tagNameByValue.emplace( 666, FixConfirmTransType );
  tagByName.emplace( FixConfirmTransType, 666 );
  fieldTypeByValue.emplace( 666, FieldType::INT );
  fieldTypeNameByValue.emplace( 666, "INT" );

  tagNameByRaw.emplace( tag_as_raw<667>(), FixContractSettlMonth );
  tagNameByValue.emplace( 667, FixContractSettlMonth );
  tagByName.emplace( FixContractSettlMonth, 667 );
  fieldTypeByValue.emplace( 667, FieldType::MONTHYEAR );
  fieldTypeNameByValue.emplace( 667, "MONTHYEAR" );

  tagNameByRaw.emplace( tag_as_raw<668>(), FixDeliveryForm );
  tagNameByValue.emplace( 668, FixDeliveryForm );
  tagByName.emplace( FixDeliveryForm, 668 );
  fieldTypeByValue.emplace( 668, FieldType::INT );
  fieldTypeNameByValue.emplace( 668, "INT" );

  tagNameByRaw.emplace( tag_as_raw<669>(), FixLastParPx );
  tagNameByValue.emplace( 669, FixLastParPx );
  tagByName.emplace( FixLastParPx, 669 );
  fieldTypeByValue.emplace( 669, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 669, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<670>(), FixNoLegAllocs );
  tagNameByValue.emplace( 670, FixNoLegAllocs );
  tagByName.emplace( FixNoLegAllocs, 670 );
  fieldTypeByValue.emplace( 670, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 670, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<671>(), FixLegAllocAccount );
  tagNameByValue.emplace( 671, FixLegAllocAccount );
  tagByName.emplace( FixLegAllocAccount, 671 );
  fieldTypeByValue.emplace( 671, FieldType::STRING );
  fieldTypeNameByValue.emplace( 671, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<672>(), FixLegIndividualAllocID );
  tagNameByValue.emplace( 672, FixLegIndividualAllocID );
  tagByName.emplace( FixLegIndividualAllocID, 672 );
  fieldTypeByValue.emplace( 672, FieldType::STRING );
  fieldTypeNameByValue.emplace( 672, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<673>(), FixLegAllocQty );
  tagNameByValue.emplace( 673, FixLegAllocQty );
  tagByName.emplace( FixLegAllocQty, 673 );
  fieldTypeByValue.emplace( 673, FieldType::QTY );
  fieldTypeNameByValue.emplace( 673, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<674>(), FixLegAllocAcctIDSource );
  tagNameByValue.emplace( 674, FixLegAllocAcctIDSource );
  tagByName.emplace( FixLegAllocAcctIDSource, 674 );
  fieldTypeByValue.emplace( 674, FieldType::STRING );
  fieldTypeNameByValue.emplace( 674, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<675>(), FixLegSettlCurrency );
  tagNameByValue.emplace( 675, FixLegSettlCurrency );
  tagByName.emplace( FixLegSettlCurrency, 675 );
  fieldTypeByValue.emplace( 675, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 675, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<676>(), FixLegBenchmarkCurveCurrency );
  tagNameByValue.emplace( 676, FixLegBenchmarkCurveCurrency );
  tagByName.emplace( FixLegBenchmarkCurveCurrency, 676 );
  fieldTypeByValue.emplace( 676, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 676, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<677>(), FixLegBenchmarkCurveName );
  tagNameByValue.emplace( 677, FixLegBenchmarkCurveName );
  tagByName.emplace( FixLegBenchmarkCurveName, 677 );
  fieldTypeByValue.emplace( 677, FieldType::STRING );
  fieldTypeNameByValue.emplace( 677, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<678>(), FixLegBenchmarkCurvePoint );
  tagNameByValue.emplace( 678, FixLegBenchmarkCurvePoint );
  tagByName.emplace( FixLegBenchmarkCurvePoint, 678 );
  fieldTypeByValue.emplace( 678, FieldType::STRING );
  fieldTypeNameByValue.emplace( 678, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<679>(), FixLegBenchmarkPrice );
  tagNameByValue.emplace( 679, FixLegBenchmarkPrice );
  tagByName.emplace( FixLegBenchmarkPrice, 679 );
  fieldTypeByValue.emplace( 679, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 679, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<680>(), FixLegBenchmarkPriceType );
  tagNameByValue.emplace( 680, FixLegBenchmarkPriceType );
  tagByName.emplace( FixLegBenchmarkPriceType, 680 );
  fieldTypeByValue.emplace( 680, FieldType::INT );
  fieldTypeNameByValue.emplace( 680, "INT" );

  tagNameByRaw.emplace( tag_as_raw<681>(), FixLegBidPx );
  tagNameByValue.emplace( 681, FixLegBidPx );
  tagByName.emplace( FixLegBidPx, 681 );
  fieldTypeByValue.emplace( 681, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 681, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<682>(), FixLegIOIQty );
  tagNameByValue.emplace( 682, FixLegIOIQty );
  tagByName.emplace( FixLegIOIQty, 682 );
  fieldTypeByValue.emplace( 682, FieldType::STRING );
  fieldTypeNameByValue.emplace( 682, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<683>(), FixNoLegStipulations );
  tagNameByValue.emplace( 683, FixNoLegStipulations );
  tagByName.emplace( FixNoLegStipulations, 683 );
  fieldTypeByValue.emplace( 683, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 683, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<684>(), FixLegOfferPx );
  tagNameByValue.emplace( 684, FixLegOfferPx );
  tagByName.emplace( FixLegOfferPx, 684 );
  fieldTypeByValue.emplace( 684, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 684, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<686>(), FixLegPriceType );
  tagNameByValue.emplace( 686, FixLegPriceType );
  tagByName.emplace( FixLegPriceType, 686 );
  fieldTypeByValue.emplace( 686, FieldType::INT );
  fieldTypeNameByValue.emplace( 686, "INT" );

  tagNameByRaw.emplace( tag_as_raw<687>(), FixLegQty );
  tagNameByValue.emplace( 687, FixLegQty );
  tagByName.emplace( FixLegQty, 687 );
  fieldTypeByValue.emplace( 687, FieldType::QTY );
  fieldTypeNameByValue.emplace( 687, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<688>(), FixLegStipulationType );
  tagNameByValue.emplace( 688, FixLegStipulationType );
  tagByName.emplace( FixLegStipulationType, 688 );
  fieldTypeByValue.emplace( 688, FieldType::STRING );
  fieldTypeNameByValue.emplace( 688, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<689>(), FixLegStipulationValue );
  tagNameByValue.emplace( 689, FixLegStipulationValue );
  tagByName.emplace( FixLegStipulationValue, 689 );
  fieldTypeByValue.emplace( 689, FieldType::STRING );
  fieldTypeNameByValue.emplace( 689, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<690>(), FixLegSwapType );
  tagNameByValue.emplace( 690, FixLegSwapType );
  tagByName.emplace( FixLegSwapType, 690 );
  fieldTypeByValue.emplace( 690, FieldType::INT );
  fieldTypeNameByValue.emplace( 690, "INT" );

  tagNameByRaw.emplace( tag_as_raw<691>(), FixPool );
  tagNameByValue.emplace( 691, FixPool );
  tagByName.emplace( FixPool, 691 );
  fieldTypeByValue.emplace( 691, FieldType::STRING );
  fieldTypeNameByValue.emplace( 691, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<692>(), FixQuotePriceType );
  tagNameByValue.emplace( 692, FixQuotePriceType );
  tagByName.emplace( FixQuotePriceType, 692 );
  fieldTypeByValue.emplace( 692, FieldType::INT );
  fieldTypeNameByValue.emplace( 692, "INT" );

  tagNameByRaw.emplace( tag_as_raw<693>(), FixQuoteRespID );
  tagNameByValue.emplace( 693, FixQuoteRespID );
  tagByName.emplace( FixQuoteRespID, 693 );
  fieldTypeByValue.emplace( 693, FieldType::STRING );
  fieldTypeNameByValue.emplace( 693, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<694>(), FixQuoteRespType );
  tagNameByValue.emplace( 694, FixQuoteRespType );
  tagByName.emplace( FixQuoteRespType, 694 );
  fieldTypeByValue.emplace( 694, FieldType::INT );
  fieldTypeNameByValue.emplace( 694, "INT" );

  tagNameByRaw.emplace( tag_as_raw<695>(), FixQuoteQualifier );
  tagNameByValue.emplace( 695, FixQuoteQualifier );
  tagByName.emplace( FixQuoteQualifier, 695 );
  fieldTypeByValue.emplace( 695, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 695, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<696>(), FixYieldRedemptionDate );
  tagNameByValue.emplace( 696, FixYieldRedemptionDate );
  tagByName.emplace( FixYieldRedemptionDate, 696 );
  fieldTypeByValue.emplace( 696, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 696, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<697>(), FixYieldRedemptionPrice );
  tagNameByValue.emplace( 697, FixYieldRedemptionPrice );
  tagByName.emplace( FixYieldRedemptionPrice, 697 );
  fieldTypeByValue.emplace( 697, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 697, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<698>(), FixYieldRedemptionPriceType );
  tagNameByValue.emplace( 698, FixYieldRedemptionPriceType );
  tagByName.emplace( FixYieldRedemptionPriceType, 698 );
  fieldTypeByValue.emplace( 698, FieldType::INT );
  fieldTypeNameByValue.emplace( 698, "INT" );

  tagNameByRaw.emplace( tag_as_raw<699>(), FixBenchmarkSecurityID );
  tagNameByValue.emplace( 699, FixBenchmarkSecurityID );
  tagByName.emplace( FixBenchmarkSecurityID, 699 );
  fieldTypeByValue.emplace( 699, FieldType::STRING );
  fieldTypeNameByValue.emplace( 699, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<700>(), FixReversalIndicator );
  tagNameByValue.emplace( 700, FixReversalIndicator );
  tagByName.emplace( FixReversalIndicator, 700 );
  fieldTypeByValue.emplace( 700, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 700, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<701>(), FixYieldCalcDate );
  tagNameByValue.emplace( 701, FixYieldCalcDate );
  tagByName.emplace( FixYieldCalcDate, 701 );
  fieldTypeByValue.emplace( 701, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 701, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<702>(), FixNoPositions );
  tagNameByValue.emplace( 702, FixNoPositions );
  tagByName.emplace( FixNoPositions, 702 );
  fieldTypeByValue.emplace( 702, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 702, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<703>(), FixPosType );
  tagNameByValue.emplace( 703, FixPosType );
  tagByName.emplace( FixPosType, 703 );
  fieldTypeByValue.emplace( 703, FieldType::STRING );
  fieldTypeNameByValue.emplace( 703, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<704>(), FixLongQty );
  tagNameByValue.emplace( 704, FixLongQty );
  tagByName.emplace( FixLongQty, 704 );
  fieldTypeByValue.emplace( 704, FieldType::QTY );
  fieldTypeNameByValue.emplace( 704, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<705>(), FixShortQty );
  tagNameByValue.emplace( 705, FixShortQty );
  tagByName.emplace( FixShortQty, 705 );
  fieldTypeByValue.emplace( 705, FieldType::QTY );
  fieldTypeNameByValue.emplace( 705, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<706>(), FixPosQtyStatus );
  tagNameByValue.emplace( 706, FixPosQtyStatus );
  tagByName.emplace( FixPosQtyStatus, 706 );
  fieldTypeByValue.emplace( 706, FieldType::INT );
  fieldTypeNameByValue.emplace( 706, "INT" );

  tagNameByRaw.emplace( tag_as_raw<707>(), FixPosAmtType );
  tagNameByValue.emplace( 707, FixPosAmtType );
  tagByName.emplace( FixPosAmtType, 707 );
  fieldTypeByValue.emplace( 707, FieldType::STRING );
  fieldTypeNameByValue.emplace( 707, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<708>(), FixPosAmt );
  tagNameByValue.emplace( 708, FixPosAmt );
  tagByName.emplace( FixPosAmt, 708 );
  fieldTypeByValue.emplace( 708, FieldType::AMT );
  fieldTypeNameByValue.emplace( 708, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<709>(), FixPosTransType );
  tagNameByValue.emplace( 709, FixPosTransType );
  tagByName.emplace( FixPosTransType, 709 );
  fieldTypeByValue.emplace( 709, FieldType::INT );
  fieldTypeNameByValue.emplace( 709, "INT" );

  tagNameByRaw.emplace( tag_as_raw<710>(), FixPosReqID );
  tagNameByValue.emplace( 710, FixPosReqID );
  tagByName.emplace( FixPosReqID, 710 );
  fieldTypeByValue.emplace( 710, FieldType::STRING );
  fieldTypeNameByValue.emplace( 710, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<711>(), FixNoUnderlyings );
  tagNameByValue.emplace( 711, FixNoUnderlyings );
  tagByName.emplace( FixNoUnderlyings, 711 );
  fieldTypeByValue.emplace( 711, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 711, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<712>(), FixPosMaintAction );
  tagNameByValue.emplace( 712, FixPosMaintAction );
  tagByName.emplace( FixPosMaintAction, 712 );
  fieldTypeByValue.emplace( 712, FieldType::INT );
  fieldTypeNameByValue.emplace( 712, "INT" );

  tagNameByRaw.emplace( tag_as_raw<713>(), FixOrigPosReqRefID );
  tagNameByValue.emplace( 713, FixOrigPosReqRefID );
  tagByName.emplace( FixOrigPosReqRefID, 713 );
  fieldTypeByValue.emplace( 713, FieldType::STRING );
  fieldTypeNameByValue.emplace( 713, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<714>(), FixPosMaintRptRefID );
  tagNameByValue.emplace( 714, FixPosMaintRptRefID );
  tagByName.emplace( FixPosMaintRptRefID, 714 );
  fieldTypeByValue.emplace( 714, FieldType::STRING );
  fieldTypeNameByValue.emplace( 714, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<715>(), FixClearingBusinessDate );
  tagNameByValue.emplace( 715, FixClearingBusinessDate );
  tagByName.emplace( FixClearingBusinessDate, 715 );
  fieldTypeByValue.emplace( 715, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 715, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<716>(), FixSettlSessID );
  tagNameByValue.emplace( 716, FixSettlSessID );
  tagByName.emplace( FixSettlSessID, 716 );
  fieldTypeByValue.emplace( 716, FieldType::STRING );
  fieldTypeNameByValue.emplace( 716, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<717>(), FixSettlSessSubID );
  tagNameByValue.emplace( 717, FixSettlSessSubID );
  tagByName.emplace( FixSettlSessSubID, 717 );
  fieldTypeByValue.emplace( 717, FieldType::STRING );
  fieldTypeNameByValue.emplace( 717, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<718>(), FixAdjustmentType );
  tagNameByValue.emplace( 718, FixAdjustmentType );
  tagByName.emplace( FixAdjustmentType, 718 );
  fieldTypeByValue.emplace( 718, FieldType::INT );
  fieldTypeNameByValue.emplace( 718, "INT" );

  tagNameByRaw.emplace( tag_as_raw<719>(), FixContraryInstructionIndicator );
  tagNameByValue.emplace( 719, FixContraryInstructionIndicator );
  tagByName.emplace( FixContraryInstructionIndicator, 719 );
  fieldTypeByValue.emplace( 719, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 719, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<720>(), FixPriorSpreadIndicator );
  tagNameByValue.emplace( 720, FixPriorSpreadIndicator );
  tagByName.emplace( FixPriorSpreadIndicator, 720 );
  fieldTypeByValue.emplace( 720, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 720, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<721>(), FixPosMaintRptID );
  tagNameByValue.emplace( 721, FixPosMaintRptID );
  tagByName.emplace( FixPosMaintRptID, 721 );
  fieldTypeByValue.emplace( 721, FieldType::STRING );
  fieldTypeNameByValue.emplace( 721, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<722>(), FixPosMaintStatus );
  tagNameByValue.emplace( 722, FixPosMaintStatus );
  tagByName.emplace( FixPosMaintStatus, 722 );
  fieldTypeByValue.emplace( 722, FieldType::INT );
  fieldTypeNameByValue.emplace( 722, "INT" );

  tagNameByRaw.emplace( tag_as_raw<723>(), FixPosMaintResult );
  tagNameByValue.emplace( 723, FixPosMaintResult );
  tagByName.emplace( FixPosMaintResult, 723 );
  fieldTypeByValue.emplace( 723, FieldType::INT );
  fieldTypeNameByValue.emplace( 723, "INT" );

  tagNameByRaw.emplace( tag_as_raw<724>(), FixPosReqType );
  tagNameByValue.emplace( 724, FixPosReqType );
  tagByName.emplace( FixPosReqType, 724 );
  fieldTypeByValue.emplace( 724, FieldType::INT );
  fieldTypeNameByValue.emplace( 724, "INT" );

  tagNameByRaw.emplace( tag_as_raw<725>(), FixResponseTransportType );
  tagNameByValue.emplace( 725, FixResponseTransportType );
  tagByName.emplace( FixResponseTransportType, 725 );
  fieldTypeByValue.emplace( 725, FieldType::INT );
  fieldTypeNameByValue.emplace( 725, "INT" );

  tagNameByRaw.emplace( tag_as_raw<726>(), FixResponseDestination );
  tagNameByValue.emplace( 726, FixResponseDestination );
  tagByName.emplace( FixResponseDestination, 726 );
  fieldTypeByValue.emplace( 726, FieldType::STRING );
  fieldTypeNameByValue.emplace( 726, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<727>(), FixTotalNumPosReports );
  tagNameByValue.emplace( 727, FixTotalNumPosReports );
  tagByName.emplace( FixTotalNumPosReports, 727 );
  fieldTypeByValue.emplace( 727, FieldType::INT );
  fieldTypeNameByValue.emplace( 727, "INT" );

  tagNameByRaw.emplace( tag_as_raw<728>(), FixPosReqResult );
  tagNameByValue.emplace( 728, FixPosReqResult );
  tagByName.emplace( FixPosReqResult, 728 );
  fieldTypeByValue.emplace( 728, FieldType::INT );
  fieldTypeNameByValue.emplace( 728, "INT" );

  tagNameByRaw.emplace( tag_as_raw<729>(), FixPosReqStatus );
  tagNameByValue.emplace( 729, FixPosReqStatus );
  tagByName.emplace( FixPosReqStatus, 729 );
  fieldTypeByValue.emplace( 729, FieldType::INT );
  fieldTypeNameByValue.emplace( 729, "INT" );

  tagNameByRaw.emplace( tag_as_raw<730>(), FixSettlPrice );
  tagNameByValue.emplace( 730, FixSettlPrice );
  tagByName.emplace( FixSettlPrice, 730 );
  fieldTypeByValue.emplace( 730, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 730, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<731>(), FixSettlPriceType );
  tagNameByValue.emplace( 731, FixSettlPriceType );
  tagByName.emplace( FixSettlPriceType, 731 );
  fieldTypeByValue.emplace( 731, FieldType::INT );
  fieldTypeNameByValue.emplace( 731, "INT" );

  tagNameByRaw.emplace( tag_as_raw<732>(), FixUnderlyingSettlPrice );
  tagNameByValue.emplace( 732, FixUnderlyingSettlPrice );
  tagByName.emplace( FixUnderlyingSettlPrice, 732 );
  fieldTypeByValue.emplace( 732, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 732, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<733>(), FixUnderlyingSettlPriceType );
  tagNameByValue.emplace( 733, FixUnderlyingSettlPriceType );
  tagByName.emplace( FixUnderlyingSettlPriceType, 733 );
  fieldTypeByValue.emplace( 733, FieldType::INT );
  fieldTypeNameByValue.emplace( 733, "INT" );

  tagNameByRaw.emplace( tag_as_raw<734>(), FixPriorSettlPrice );
  tagNameByValue.emplace( 734, FixPriorSettlPrice );
  tagByName.emplace( FixPriorSettlPrice, 734 );
  fieldTypeByValue.emplace( 734, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 734, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<735>(), FixNoQuoteQualifiers );
  tagNameByValue.emplace( 735, FixNoQuoteQualifiers );
  tagByName.emplace( FixNoQuoteQualifiers, 735 );
  fieldTypeByValue.emplace( 735, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 735, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<736>(), FixAllocSettlCurrency );
  tagNameByValue.emplace( 736, FixAllocSettlCurrency );
  tagByName.emplace( FixAllocSettlCurrency, 736 );
  fieldTypeByValue.emplace( 736, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 736, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<737>(), FixAllocSettlCurrAmt );
  tagNameByValue.emplace( 737, FixAllocSettlCurrAmt );
  tagByName.emplace( FixAllocSettlCurrAmt, 737 );
  fieldTypeByValue.emplace( 737, FieldType::AMT );
  fieldTypeNameByValue.emplace( 737, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<738>(), FixInterestAtMaturity );
  tagNameByValue.emplace( 738, FixInterestAtMaturity );
  tagByName.emplace( FixInterestAtMaturity, 738 );
  fieldTypeByValue.emplace( 738, FieldType::AMT );
  fieldTypeNameByValue.emplace( 738, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<739>(), FixLegDatedDate );
  tagNameByValue.emplace( 739, FixLegDatedDate );
  tagByName.emplace( FixLegDatedDate, 739 );
  fieldTypeByValue.emplace( 739, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 739, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<740>(), FixLegPool );
  tagNameByValue.emplace( 740, FixLegPool );
  tagByName.emplace( FixLegPool, 740 );
  fieldTypeByValue.emplace( 740, FieldType::STRING );
  fieldTypeNameByValue.emplace( 740, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<741>(), FixAllocInterestAtMaturity );
  tagNameByValue.emplace( 741, FixAllocInterestAtMaturity );
  tagByName.emplace( FixAllocInterestAtMaturity, 741 );
  fieldTypeByValue.emplace( 741, FieldType::AMT );
  fieldTypeNameByValue.emplace( 741, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<742>(), FixAllocAccruedInterestAmt );
  tagNameByValue.emplace( 742, FixAllocAccruedInterestAmt );
  tagByName.emplace( FixAllocAccruedInterestAmt, 742 );
  fieldTypeByValue.emplace( 742, FieldType::AMT );
  fieldTypeNameByValue.emplace( 742, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<743>(), FixDeliveryDate );
  tagNameByValue.emplace( 743, FixDeliveryDate );
  tagByName.emplace( FixDeliveryDate, 743 );
  fieldTypeByValue.emplace( 743, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 743, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<744>(), FixAssignmentMethod );
  tagNameByValue.emplace( 744, FixAssignmentMethod );
  tagByName.emplace( FixAssignmentMethod, 744 );
  fieldTypeByValue.emplace( 744, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 744, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<745>(), FixAssignmentUnit );
  tagNameByValue.emplace( 745, FixAssignmentUnit );
  tagByName.emplace( FixAssignmentUnit, 745 );
  fieldTypeByValue.emplace( 745, FieldType::QTY );
  fieldTypeNameByValue.emplace( 745, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<746>(), FixOpenInterest );
  tagNameByValue.emplace( 746, FixOpenInterest );
  tagByName.emplace( FixOpenInterest, 746 );
  fieldTypeByValue.emplace( 746, FieldType::AMT );
  fieldTypeNameByValue.emplace( 746, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<747>(), FixExerciseMethod );
  tagNameByValue.emplace( 747, FixExerciseMethod );
  tagByName.emplace( FixExerciseMethod, 747 );
  fieldTypeByValue.emplace( 747, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 747, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<748>(), FixTotNumTradeReports );
  tagNameByValue.emplace( 748, FixTotNumTradeReports );
  tagByName.emplace( FixTotNumTradeReports, 748 );
  fieldTypeByValue.emplace( 748, FieldType::INT );
  fieldTypeNameByValue.emplace( 748, "INT" );

  tagNameByRaw.emplace( tag_as_raw<749>(), FixTradeRequestResult );
  tagNameByValue.emplace( 749, FixTradeRequestResult );
  tagByName.emplace( FixTradeRequestResult, 749 );
  fieldTypeByValue.emplace( 749, FieldType::INT );
  fieldTypeNameByValue.emplace( 749, "INT" );

  tagNameByRaw.emplace( tag_as_raw<750>(), FixTradeRequestStatus );
  tagNameByValue.emplace( 750, FixTradeRequestStatus );
  tagByName.emplace( FixTradeRequestStatus, 750 );
  fieldTypeByValue.emplace( 750, FieldType::INT );
  fieldTypeNameByValue.emplace( 750, "INT" );

  tagNameByRaw.emplace( tag_as_raw<751>(), FixTradeReportRejectReason );
  tagNameByValue.emplace( 751, FixTradeReportRejectReason );
  tagByName.emplace( FixTradeReportRejectReason, 751 );
  fieldTypeByValue.emplace( 751, FieldType::INT );
  fieldTypeNameByValue.emplace( 751, "INT" );

  tagNameByRaw.emplace( tag_as_raw<752>(), FixSideMultiLegReportingType );
  tagNameByValue.emplace( 752, FixSideMultiLegReportingType );
  tagByName.emplace( FixSideMultiLegReportingType, 752 );
  fieldTypeByValue.emplace( 752, FieldType::INT );
  fieldTypeNameByValue.emplace( 752, "INT" );

  tagNameByRaw.emplace( tag_as_raw<753>(), FixNoPosAmt );
  tagNameByValue.emplace( 753, FixNoPosAmt );
  tagByName.emplace( FixNoPosAmt, 753 );
  fieldTypeByValue.emplace( 753, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 753, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<754>(), FixAutoAcceptIndicator );
  tagNameByValue.emplace( 754, FixAutoAcceptIndicator );
  tagByName.emplace( FixAutoAcceptIndicator, 754 );
  fieldTypeByValue.emplace( 754, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 754, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<755>(), FixAllocReportID );
  tagNameByValue.emplace( 755, FixAllocReportID );
  tagByName.emplace( FixAllocReportID, 755 );
  fieldTypeByValue.emplace( 755, FieldType::STRING );
  fieldTypeNameByValue.emplace( 755, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<756>(), FixNoNested2PartyIDs );
  tagNameByValue.emplace( 756, FixNoNested2PartyIDs );
  tagByName.emplace( FixNoNested2PartyIDs, 756 );
  fieldTypeByValue.emplace( 756, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 756, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<757>(), FixNested2PartyID );
  tagNameByValue.emplace( 757, FixNested2PartyID );
  tagByName.emplace( FixNested2PartyID, 757 );
  fieldTypeByValue.emplace( 757, FieldType::STRING );
  fieldTypeNameByValue.emplace( 757, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<758>(), FixNested2PartyIDSource );
  tagNameByValue.emplace( 758, FixNested2PartyIDSource );
  tagByName.emplace( FixNested2PartyIDSource, 758 );
  fieldTypeByValue.emplace( 758, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 758, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<759>(), FixNested2PartyRole );
  tagNameByValue.emplace( 759, FixNested2PartyRole );
  tagByName.emplace( FixNested2PartyRole, 759 );
  fieldTypeByValue.emplace( 759, FieldType::INT );
  fieldTypeNameByValue.emplace( 759, "INT" );

  tagNameByRaw.emplace( tag_as_raw<760>(), FixNested2PartySubID );
  tagNameByValue.emplace( 760, FixNested2PartySubID );
  tagByName.emplace( FixNested2PartySubID, 760 );
  fieldTypeByValue.emplace( 760, FieldType::STRING );
  fieldTypeNameByValue.emplace( 760, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<761>(), FixBenchmarkSecurityIDSource );
  tagNameByValue.emplace( 761, FixBenchmarkSecurityIDSource );
  tagByName.emplace( FixBenchmarkSecurityIDSource, 761 );
  fieldTypeByValue.emplace( 761, FieldType::STRING );
  fieldTypeNameByValue.emplace( 761, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<762>(), FixSecuritySubType );
  tagNameByValue.emplace( 762, FixSecuritySubType );
  tagByName.emplace( FixSecuritySubType, 762 );
  fieldTypeByValue.emplace( 762, FieldType::STRING );
  fieldTypeNameByValue.emplace( 762, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<763>(), FixUnderlyingSecuritySubType );
  tagNameByValue.emplace( 763, FixUnderlyingSecuritySubType );
  tagByName.emplace( FixUnderlyingSecuritySubType, 763 );
  fieldTypeByValue.emplace( 763, FieldType::STRING );
  fieldTypeNameByValue.emplace( 763, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<764>(), FixLegSecuritySubType );
  tagNameByValue.emplace( 764, FixLegSecuritySubType );
  tagByName.emplace( FixLegSecuritySubType, 764 );
  fieldTypeByValue.emplace( 764, FieldType::STRING );
  fieldTypeNameByValue.emplace( 764, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<765>(), FixAllowableOneSidednessPct );
  tagNameByValue.emplace( 765, FixAllowableOneSidednessPct );
  tagByName.emplace( FixAllowableOneSidednessPct, 765 );
  fieldTypeByValue.emplace( 765, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 765, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<766>(), FixAllowableOneSidednessValue );
  tagNameByValue.emplace( 766, FixAllowableOneSidednessValue );
  tagByName.emplace( FixAllowableOneSidednessValue, 766 );
  fieldTypeByValue.emplace( 766, FieldType::AMT );
  fieldTypeNameByValue.emplace( 766, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<767>(), FixAllowableOneSidednessCurr );
  tagNameByValue.emplace( 767, FixAllowableOneSidednessCurr );
  tagByName.emplace( FixAllowableOneSidednessCurr, 767 );
  fieldTypeByValue.emplace( 767, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 767, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<768>(), FixNoTrdRegTimestamps );
  tagNameByValue.emplace( 768, FixNoTrdRegTimestamps );
  tagByName.emplace( FixNoTrdRegTimestamps, 768 );
  fieldTypeByValue.emplace( 768, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 768, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<769>(), FixTrdRegTimestamp );
  tagNameByValue.emplace( 769, FixTrdRegTimestamp );
  tagByName.emplace( FixTrdRegTimestamp, 769 );
  fieldTypeByValue.emplace( 769, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 769, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<770>(), FixTrdRegTimestampType );
  tagNameByValue.emplace( 770, FixTrdRegTimestampType );
  tagByName.emplace( FixTrdRegTimestampType, 770 );
  fieldTypeByValue.emplace( 770, FieldType::INT );
  fieldTypeNameByValue.emplace( 770, "INT" );

  tagNameByRaw.emplace( tag_as_raw<771>(), FixTrdRegTimestampOrigin );
  tagNameByValue.emplace( 771, FixTrdRegTimestampOrigin );
  tagByName.emplace( FixTrdRegTimestampOrigin, 771 );
  fieldTypeByValue.emplace( 771, FieldType::STRING );
  fieldTypeNameByValue.emplace( 771, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<772>(), FixConfirmRefID );
  tagNameByValue.emplace( 772, FixConfirmRefID );
  tagByName.emplace( FixConfirmRefID, 772 );
  fieldTypeByValue.emplace( 772, FieldType::STRING );
  fieldTypeNameByValue.emplace( 772, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<773>(), FixConfirmType );
  tagNameByValue.emplace( 773, FixConfirmType );
  tagByName.emplace( FixConfirmType, 773 );
  fieldTypeByValue.emplace( 773, FieldType::INT );
  fieldTypeNameByValue.emplace( 773, "INT" );

  tagNameByRaw.emplace( tag_as_raw<774>(), FixConfirmRejReason );
  tagNameByValue.emplace( 774, FixConfirmRejReason );
  tagByName.emplace( FixConfirmRejReason, 774 );
  fieldTypeByValue.emplace( 774, FieldType::INT );
  fieldTypeNameByValue.emplace( 774, "INT" );

  tagNameByRaw.emplace( tag_as_raw<775>(), FixBookingType );
  tagNameByValue.emplace( 775, FixBookingType );
  tagByName.emplace( FixBookingType, 775 );
  fieldTypeByValue.emplace( 775, FieldType::INT );
  fieldTypeNameByValue.emplace( 775, "INT" );

  tagNameByRaw.emplace( tag_as_raw<776>(), FixIndividualAllocRejCode );
  tagNameByValue.emplace( 776, FixIndividualAllocRejCode );
  tagByName.emplace( FixIndividualAllocRejCode, 776 );
  fieldTypeByValue.emplace( 776, FieldType::INT );
  fieldTypeNameByValue.emplace( 776, "INT" );

  tagNameByRaw.emplace( tag_as_raw<777>(), FixSettlInstMsgID );
  tagNameByValue.emplace( 777, FixSettlInstMsgID );
  tagByName.emplace( FixSettlInstMsgID, 777 );
  fieldTypeByValue.emplace( 777, FieldType::STRING );
  fieldTypeNameByValue.emplace( 777, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<778>(), FixNoSettlInst );
  tagNameByValue.emplace( 778, FixNoSettlInst );
  tagByName.emplace( FixNoSettlInst, 778 );
  fieldTypeByValue.emplace( 778, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 778, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<779>(), FixLastUpdateTime );
  tagNameByValue.emplace( 779, FixLastUpdateTime );
  tagByName.emplace( FixLastUpdateTime, 779 );
  fieldTypeByValue.emplace( 779, FieldType::UTCTIMESTAMP );
  fieldTypeNameByValue.emplace( 779, "UTCTIMESTAMP" );

  tagNameByRaw.emplace( tag_as_raw<780>(), FixAllocSettlInstType );
  tagNameByValue.emplace( 780, FixAllocSettlInstType );
  tagByName.emplace( FixAllocSettlInstType, 780 );
  fieldTypeByValue.emplace( 780, FieldType::INT );
  fieldTypeNameByValue.emplace( 780, "INT" );

  tagNameByRaw.emplace( tag_as_raw<781>(), FixNoSettlPartyIDs );
  tagNameByValue.emplace( 781, FixNoSettlPartyIDs );
  tagByName.emplace( FixNoSettlPartyIDs, 781 );
  fieldTypeByValue.emplace( 781, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 781, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<782>(), FixSettlPartyID );
  tagNameByValue.emplace( 782, FixSettlPartyID );
  tagByName.emplace( FixSettlPartyID, 782 );
  fieldTypeByValue.emplace( 782, FieldType::STRING );
  fieldTypeNameByValue.emplace( 782, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<783>(), FixSettlPartyIDSource );
  tagNameByValue.emplace( 783, FixSettlPartyIDSource );
  tagByName.emplace( FixSettlPartyIDSource, 783 );
  fieldTypeByValue.emplace( 783, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 783, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<784>(), FixSettlPartyRole );
  tagNameByValue.emplace( 784, FixSettlPartyRole );
  tagByName.emplace( FixSettlPartyRole, 784 );
  fieldTypeByValue.emplace( 784, FieldType::INT );
  fieldTypeNameByValue.emplace( 784, "INT" );

  tagNameByRaw.emplace( tag_as_raw<785>(), FixSettlPartySubID );
  tagNameByValue.emplace( 785, FixSettlPartySubID );
  tagByName.emplace( FixSettlPartySubID, 785 );
  fieldTypeByValue.emplace( 785, FieldType::STRING );
  fieldTypeNameByValue.emplace( 785, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<786>(), FixSettlPartySubIDType );
  tagNameByValue.emplace( 786, FixSettlPartySubIDType );
  tagByName.emplace( FixSettlPartySubIDType, 786 );
  fieldTypeByValue.emplace( 786, FieldType::INT );
  fieldTypeNameByValue.emplace( 786, "INT" );

  tagNameByRaw.emplace( tag_as_raw<787>(), FixDlvyInstType );
  tagNameByValue.emplace( 787, FixDlvyInstType );
  tagByName.emplace( FixDlvyInstType, 787 );
  fieldTypeByValue.emplace( 787, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 787, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<788>(), FixTerminationType );
  tagNameByValue.emplace( 788, FixTerminationType );
  tagByName.emplace( FixTerminationType, 788 );
  fieldTypeByValue.emplace( 788, FieldType::INT );
  fieldTypeNameByValue.emplace( 788, "INT" );

  tagNameByRaw.emplace( tag_as_raw<789>(), FixNextExpectedMsgSeqNum );
  tagNameByValue.emplace( 789, FixNextExpectedMsgSeqNum );
  tagByName.emplace( FixNextExpectedMsgSeqNum, 789 );
  fieldTypeByValue.emplace( 789, FieldType::SEQNUM );
  fieldTypeNameByValue.emplace( 789, "SEQNUM" );

  tagNameByRaw.emplace( tag_as_raw<790>(), FixOrdStatusReqID );
  tagNameByValue.emplace( 790, FixOrdStatusReqID );
  tagByName.emplace( FixOrdStatusReqID, 790 );
  fieldTypeByValue.emplace( 790, FieldType::STRING );
  fieldTypeNameByValue.emplace( 790, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<791>(), FixSettlInstReqID );
  tagNameByValue.emplace( 791, FixSettlInstReqID );
  tagByName.emplace( FixSettlInstReqID, 791 );
  fieldTypeByValue.emplace( 791, FieldType::STRING );
  fieldTypeNameByValue.emplace( 791, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<792>(), FixSettlInstReqRejCode );
  tagNameByValue.emplace( 792, FixSettlInstReqRejCode );
  tagByName.emplace( FixSettlInstReqRejCode, 792 );
  fieldTypeByValue.emplace( 792, FieldType::INT );
  fieldTypeNameByValue.emplace( 792, "INT" );

  tagNameByRaw.emplace( tag_as_raw<793>(), FixSecondaryAllocID );
  tagNameByValue.emplace( 793, FixSecondaryAllocID );
  tagByName.emplace( FixSecondaryAllocID, 793 );
  fieldTypeByValue.emplace( 793, FieldType::STRING );
  fieldTypeNameByValue.emplace( 793, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<794>(), FixAllocReportType );
  tagNameByValue.emplace( 794, FixAllocReportType );
  tagByName.emplace( FixAllocReportType, 794 );
  fieldTypeByValue.emplace( 794, FieldType::INT );
  fieldTypeNameByValue.emplace( 794, "INT" );

  tagNameByRaw.emplace( tag_as_raw<795>(), FixAllocReportRefID );
  tagNameByValue.emplace( 795, FixAllocReportRefID );
  tagByName.emplace( FixAllocReportRefID, 795 );
  fieldTypeByValue.emplace( 795, FieldType::STRING );
  fieldTypeNameByValue.emplace( 795, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<796>(), FixAllocCancReplaceReason );
  tagNameByValue.emplace( 796, FixAllocCancReplaceReason );
  tagByName.emplace( FixAllocCancReplaceReason, 796 );
  fieldTypeByValue.emplace( 796, FieldType::INT );
  fieldTypeNameByValue.emplace( 796, "INT" );

  tagNameByRaw.emplace( tag_as_raw<797>(), FixCopyMsgIndicator );
  tagNameByValue.emplace( 797, FixCopyMsgIndicator );
  tagByName.emplace( FixCopyMsgIndicator, 797 );
  fieldTypeByValue.emplace( 797, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 797, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<798>(), FixAllocAccountType );
  tagNameByValue.emplace( 798, FixAllocAccountType );
  tagByName.emplace( FixAllocAccountType, 798 );
  fieldTypeByValue.emplace( 798, FieldType::INT );
  fieldTypeNameByValue.emplace( 798, "INT" );

  tagNameByRaw.emplace( tag_as_raw<799>(), FixOrderAvgPx );
  tagNameByValue.emplace( 799, FixOrderAvgPx );
  tagByName.emplace( FixOrderAvgPx, 799 );
  fieldTypeByValue.emplace( 799, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 799, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<800>(), FixOrderBookingQty );
  tagNameByValue.emplace( 800, FixOrderBookingQty );
  tagByName.emplace( FixOrderBookingQty, 800 );
  fieldTypeByValue.emplace( 800, FieldType::QTY );
  fieldTypeNameByValue.emplace( 800, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<801>(), FixNoSettlPartySubIDs );
  tagNameByValue.emplace( 801, FixNoSettlPartySubIDs );
  tagByName.emplace( FixNoSettlPartySubIDs, 801 );
  fieldTypeByValue.emplace( 801, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 801, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<802>(), FixNoPartySubIDs );
  tagNameByValue.emplace( 802, FixNoPartySubIDs );
  tagByName.emplace( FixNoPartySubIDs, 802 );
  fieldTypeByValue.emplace( 802, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 802, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<803>(), FixPartySubIDType );
  tagNameByValue.emplace( 803, FixPartySubIDType );
  tagByName.emplace( FixPartySubIDType, 803 );
  fieldTypeByValue.emplace( 803, FieldType::INT );
  fieldTypeNameByValue.emplace( 803, "INT" );

  tagNameByRaw.emplace( tag_as_raw<804>(), FixNoNestedPartySubIDs );
  tagNameByValue.emplace( 804, FixNoNestedPartySubIDs );
  tagByName.emplace( FixNoNestedPartySubIDs, 804 );
  fieldTypeByValue.emplace( 804, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 804, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<805>(), FixNestedPartySubIDType );
  tagNameByValue.emplace( 805, FixNestedPartySubIDType );
  tagByName.emplace( FixNestedPartySubIDType, 805 );
  fieldTypeByValue.emplace( 805, FieldType::INT );
  fieldTypeNameByValue.emplace( 805, "INT" );

  tagNameByRaw.emplace( tag_as_raw<806>(), FixNoNested2PartySubIDs );
  tagNameByValue.emplace( 806, FixNoNested2PartySubIDs );
  tagByName.emplace( FixNoNested2PartySubIDs, 806 );
  fieldTypeByValue.emplace( 806, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 806, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<807>(), FixNested2PartySubIDType );
  tagNameByValue.emplace( 807, FixNested2PartySubIDType );
  tagByName.emplace( FixNested2PartySubIDType, 807 );
  fieldTypeByValue.emplace( 807, FieldType::INT );
  fieldTypeNameByValue.emplace( 807, "INT" );

  tagNameByRaw.emplace( tag_as_raw<808>(), FixAllocIntermedReqType );
  tagNameByValue.emplace( 808, FixAllocIntermedReqType );
  tagByName.emplace( FixAllocIntermedReqType, 808 );
  fieldTypeByValue.emplace( 808, FieldType::INT );
  fieldTypeNameByValue.emplace( 808, "INT" );

  tagNameByRaw.emplace( tag_as_raw<810>(), FixUnderlyingPx );
  tagNameByValue.emplace( 810, FixUnderlyingPx );
  tagByName.emplace( FixUnderlyingPx, 810 );
  fieldTypeByValue.emplace( 810, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 810, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<811>(), FixPriceDelta );
  tagNameByValue.emplace( 811, FixPriceDelta );
  tagByName.emplace( FixPriceDelta, 811 );
  fieldTypeByValue.emplace( 811, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 811, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<812>(), FixApplQueueMax );
  tagNameByValue.emplace( 812, FixApplQueueMax );
  tagByName.emplace( FixApplQueueMax, 812 );
  fieldTypeByValue.emplace( 812, FieldType::INT );
  fieldTypeNameByValue.emplace( 812, "INT" );

  tagNameByRaw.emplace( tag_as_raw<813>(), FixApplQueueDepth );
  tagNameByValue.emplace( 813, FixApplQueueDepth );
  tagByName.emplace( FixApplQueueDepth, 813 );
  fieldTypeByValue.emplace( 813, FieldType::INT );
  fieldTypeNameByValue.emplace( 813, "INT" );

  tagNameByRaw.emplace( tag_as_raw<814>(), FixApplQueueResolution );
  tagNameByValue.emplace( 814, FixApplQueueResolution );
  tagByName.emplace( FixApplQueueResolution, 814 );
  fieldTypeByValue.emplace( 814, FieldType::INT );
  fieldTypeNameByValue.emplace( 814, "INT" );

  tagNameByRaw.emplace( tag_as_raw<815>(), FixApplQueueAction );
  tagNameByValue.emplace( 815, FixApplQueueAction );
  tagByName.emplace( FixApplQueueAction, 815 );
  fieldTypeByValue.emplace( 815, FieldType::INT );
  fieldTypeNameByValue.emplace( 815, "INT" );

  tagNameByRaw.emplace( tag_as_raw<816>(), FixNoAltMDSource );
  tagNameByValue.emplace( 816, FixNoAltMDSource );
  tagByName.emplace( FixNoAltMDSource, 816 );
  fieldTypeByValue.emplace( 816, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 816, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<817>(), FixAltMDSourceID );
  tagNameByValue.emplace( 817, FixAltMDSourceID );
  tagByName.emplace( FixAltMDSourceID, 817 );
  fieldTypeByValue.emplace( 817, FieldType::STRING );
  fieldTypeNameByValue.emplace( 817, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<818>(), FixSecondaryTradeReportID );
  tagNameByValue.emplace( 818, FixSecondaryTradeReportID );
  tagByName.emplace( FixSecondaryTradeReportID, 818 );
  fieldTypeByValue.emplace( 818, FieldType::STRING );
  fieldTypeNameByValue.emplace( 818, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<819>(), FixAvgPxIndicator );
  tagNameByValue.emplace( 819, FixAvgPxIndicator );
  tagByName.emplace( FixAvgPxIndicator, 819 );
  fieldTypeByValue.emplace( 819, FieldType::INT );
  fieldTypeNameByValue.emplace( 819, "INT" );

  tagNameByRaw.emplace( tag_as_raw<820>(), FixTradeLinkID );
  tagNameByValue.emplace( 820, FixTradeLinkID );
  tagByName.emplace( FixTradeLinkID, 820 );
  fieldTypeByValue.emplace( 820, FieldType::STRING );
  fieldTypeNameByValue.emplace( 820, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<821>(), FixOrderInputDevice );
  tagNameByValue.emplace( 821, FixOrderInputDevice );
  tagByName.emplace( FixOrderInputDevice, 821 );
  fieldTypeByValue.emplace( 821, FieldType::STRING );
  fieldTypeNameByValue.emplace( 821, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<822>(), FixUnderlyingTradingSessionID );
  tagNameByValue.emplace( 822, FixUnderlyingTradingSessionID );
  tagByName.emplace( FixUnderlyingTradingSessionID, 822 );
  fieldTypeByValue.emplace( 822, FieldType::STRING );
  fieldTypeNameByValue.emplace( 822, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<823>(), FixUnderlyingTradingSessionSubID );
  tagNameByValue.emplace( 823, FixUnderlyingTradingSessionSubID );
  tagByName.emplace( FixUnderlyingTradingSessionSubID, 823 );
  fieldTypeByValue.emplace( 823, FieldType::STRING );
  fieldTypeNameByValue.emplace( 823, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<824>(), FixTradeLegRefID );
  tagNameByValue.emplace( 824, FixTradeLegRefID );
  tagByName.emplace( FixTradeLegRefID, 824 );
  fieldTypeByValue.emplace( 824, FieldType::STRING );
  fieldTypeNameByValue.emplace( 824, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<825>(), FixExchangeRule );
  tagNameByValue.emplace( 825, FixExchangeRule );
  tagByName.emplace( FixExchangeRule, 825 );
  fieldTypeByValue.emplace( 825, FieldType::STRING );
  fieldTypeNameByValue.emplace( 825, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<826>(), FixTradeAllocIndicator );
  tagNameByValue.emplace( 826, FixTradeAllocIndicator );
  tagByName.emplace( FixTradeAllocIndicator, 826 );
  fieldTypeByValue.emplace( 826, FieldType::INT );
  fieldTypeNameByValue.emplace( 826, "INT" );

  tagNameByRaw.emplace( tag_as_raw<827>(), FixExpirationCycle );
  tagNameByValue.emplace( 827, FixExpirationCycle );
  tagByName.emplace( FixExpirationCycle, 827 );
  fieldTypeByValue.emplace( 827, FieldType::INT );
  fieldTypeNameByValue.emplace( 827, "INT" );

  tagNameByRaw.emplace( tag_as_raw<828>(), FixTrdType );
  tagNameByValue.emplace( 828, FixTrdType );
  tagByName.emplace( FixTrdType, 828 );
  fieldTypeByValue.emplace( 828, FieldType::INT );
  fieldTypeNameByValue.emplace( 828, "INT" );

  tagNameByRaw.emplace( tag_as_raw<829>(), FixTrdSubType );
  tagNameByValue.emplace( 829, FixTrdSubType );
  tagByName.emplace( FixTrdSubType, 829 );
  fieldTypeByValue.emplace( 829, FieldType::INT );
  fieldTypeNameByValue.emplace( 829, "INT" );

  tagNameByRaw.emplace( tag_as_raw<830>(), FixTransferReason );
  tagNameByValue.emplace( 830, FixTransferReason );
  tagByName.emplace( FixTransferReason, 830 );
  fieldTypeByValue.emplace( 830, FieldType::STRING );
  fieldTypeNameByValue.emplace( 830, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<832>(), FixTotNumAssignmentReports );
  tagNameByValue.emplace( 832, FixTotNumAssignmentReports );
  tagByName.emplace( FixTotNumAssignmentReports, 832 );
  fieldTypeByValue.emplace( 832, FieldType::INT );
  fieldTypeNameByValue.emplace( 832, "INT" );

  tagNameByRaw.emplace( tag_as_raw<833>(), FixAsgnRptID );
  tagNameByValue.emplace( 833, FixAsgnRptID );
  tagByName.emplace( FixAsgnRptID, 833 );
  fieldTypeByValue.emplace( 833, FieldType::STRING );
  fieldTypeNameByValue.emplace( 833, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<834>(), FixThresholdAmount );
  tagNameByValue.emplace( 834, FixThresholdAmount );
  tagByName.emplace( FixThresholdAmount, 834 );
  fieldTypeByValue.emplace( 834, FieldType::PRICEOFFSET );
  fieldTypeNameByValue.emplace( 834, "PRICEOFFSET" );

  tagNameByRaw.emplace( tag_as_raw<835>(), FixPegMoveType );
  tagNameByValue.emplace( 835, FixPegMoveType );
  tagByName.emplace( FixPegMoveType, 835 );
  fieldTypeByValue.emplace( 835, FieldType::INT );
  fieldTypeNameByValue.emplace( 835, "INT" );

  tagNameByRaw.emplace( tag_as_raw<836>(), FixPegOffsetType );
  tagNameByValue.emplace( 836, FixPegOffsetType );
  tagByName.emplace( FixPegOffsetType, 836 );
  fieldTypeByValue.emplace( 836, FieldType::INT );
  fieldTypeNameByValue.emplace( 836, "INT" );

  tagNameByRaw.emplace( tag_as_raw<837>(), FixPegLimitType );
  tagNameByValue.emplace( 837, FixPegLimitType );
  tagByName.emplace( FixPegLimitType, 837 );
  fieldTypeByValue.emplace( 837, FieldType::INT );
  fieldTypeNameByValue.emplace( 837, "INT" );

  tagNameByRaw.emplace( tag_as_raw<838>(), FixPegRoundDirection );
  tagNameByValue.emplace( 838, FixPegRoundDirection );
  tagByName.emplace( FixPegRoundDirection, 838 );
  fieldTypeByValue.emplace( 838, FieldType::INT );
  fieldTypeNameByValue.emplace( 838, "INT" );

  tagNameByRaw.emplace( tag_as_raw<839>(), FixPeggedPrice );
  tagNameByValue.emplace( 839, FixPeggedPrice );
  tagByName.emplace( FixPeggedPrice, 839 );
  fieldTypeByValue.emplace( 839, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 839, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<840>(), FixPegScope );
  tagNameByValue.emplace( 840, FixPegScope );
  tagByName.emplace( FixPegScope, 840 );
  fieldTypeByValue.emplace( 840, FieldType::INT );
  fieldTypeNameByValue.emplace( 840, "INT" );

  tagNameByRaw.emplace( tag_as_raw<841>(), FixDiscretionMoveType );
  tagNameByValue.emplace( 841, FixDiscretionMoveType );
  tagByName.emplace( FixDiscretionMoveType, 841 );
  fieldTypeByValue.emplace( 841, FieldType::INT );
  fieldTypeNameByValue.emplace( 841, "INT" );

  tagNameByRaw.emplace( tag_as_raw<842>(), FixDiscretionOffsetType );
  tagNameByValue.emplace( 842, FixDiscretionOffsetType );
  tagByName.emplace( FixDiscretionOffsetType, 842 );
  fieldTypeByValue.emplace( 842, FieldType::INT );
  fieldTypeNameByValue.emplace( 842, "INT" );

  tagNameByRaw.emplace( tag_as_raw<843>(), FixDiscretionLimitType );
  tagNameByValue.emplace( 843, FixDiscretionLimitType );
  tagByName.emplace( FixDiscretionLimitType, 843 );
  fieldTypeByValue.emplace( 843, FieldType::INT );
  fieldTypeNameByValue.emplace( 843, "INT" );

  tagNameByRaw.emplace( tag_as_raw<844>(), FixDiscretionRoundDirection );
  tagNameByValue.emplace( 844, FixDiscretionRoundDirection );
  tagByName.emplace( FixDiscretionRoundDirection, 844 );
  fieldTypeByValue.emplace( 844, FieldType::INT );
  fieldTypeNameByValue.emplace( 844, "INT" );

  tagNameByRaw.emplace( tag_as_raw<845>(), FixDiscretionPrice );
  tagNameByValue.emplace( 845, FixDiscretionPrice );
  tagByName.emplace( FixDiscretionPrice, 845 );
  fieldTypeByValue.emplace( 845, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 845, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<846>(), FixDiscretionScope );
  tagNameByValue.emplace( 846, FixDiscretionScope );
  tagByName.emplace( FixDiscretionScope, 846 );
  fieldTypeByValue.emplace( 846, FieldType::INT );
  fieldTypeNameByValue.emplace( 846, "INT" );

  tagNameByRaw.emplace( tag_as_raw<847>(), FixTargetStrategy );
  tagNameByValue.emplace( 847, FixTargetStrategy );
  tagByName.emplace( FixTargetStrategy, 847 );
  fieldTypeByValue.emplace( 847, FieldType::INT );
  fieldTypeNameByValue.emplace( 847, "INT" );

  tagNameByRaw.emplace( tag_as_raw<848>(), FixTargetStrategyParameters );
  tagNameByValue.emplace( 848, FixTargetStrategyParameters );
  tagByName.emplace( FixTargetStrategyParameters, 848 );
  fieldTypeByValue.emplace( 848, FieldType::STRING );
  fieldTypeNameByValue.emplace( 848, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<849>(), FixParticipationRate );
  tagNameByValue.emplace( 849, FixParticipationRate );
  tagByName.emplace( FixParticipationRate, 849 );
  fieldTypeByValue.emplace( 849, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 849, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<850>(), FixTargetStrategyPerformance );
  tagNameByValue.emplace( 850, FixTargetStrategyPerformance );
  tagByName.emplace( FixTargetStrategyPerformance, 850 );
  fieldTypeByValue.emplace( 850, FieldType::FLOAT );
  fieldTypeNameByValue.emplace( 850, "FLOAT" );

  tagNameByRaw.emplace( tag_as_raw<851>(), FixLastLiquidityInd );
  tagNameByValue.emplace( 851, FixLastLiquidityInd );
  tagByName.emplace( FixLastLiquidityInd, 851 );
  fieldTypeByValue.emplace( 851, FieldType::INT );
  fieldTypeNameByValue.emplace( 851, "INT" );

  tagNameByRaw.emplace( tag_as_raw<852>(), FixPublishTrdIndicator );
  tagNameByValue.emplace( 852, FixPublishTrdIndicator );
  tagByName.emplace( FixPublishTrdIndicator, 852 );
  fieldTypeByValue.emplace( 852, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 852, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<853>(), FixShortSaleReason );
  tagNameByValue.emplace( 853, FixShortSaleReason );
  tagByName.emplace( FixShortSaleReason, 853 );
  fieldTypeByValue.emplace( 853, FieldType::INT );
  fieldTypeNameByValue.emplace( 853, "INT" );

  tagNameByRaw.emplace( tag_as_raw<854>(), FixQtyType );
  tagNameByValue.emplace( 854, FixQtyType );
  tagByName.emplace( FixQtyType, 854 );
  fieldTypeByValue.emplace( 854, FieldType::INT );
  fieldTypeNameByValue.emplace( 854, "INT" );

  tagNameByRaw.emplace( tag_as_raw<855>(), FixSecondaryTrdType );
  tagNameByValue.emplace( 855, FixSecondaryTrdType );
  tagByName.emplace( FixSecondaryTrdType, 855 );
  fieldTypeByValue.emplace( 855, FieldType::INT );
  fieldTypeNameByValue.emplace( 855, "INT" );

  tagNameByRaw.emplace( tag_as_raw<856>(), FixTradeReportType );
  tagNameByValue.emplace( 856, FixTradeReportType );
  tagByName.emplace( FixTradeReportType, 856 );
  fieldTypeByValue.emplace( 856, FieldType::INT );
  fieldTypeNameByValue.emplace( 856, "INT" );

  tagNameByRaw.emplace( tag_as_raw<857>(), FixAllocNoOrdersType );
  tagNameByValue.emplace( 857, FixAllocNoOrdersType );
  tagByName.emplace( FixAllocNoOrdersType, 857 );
  fieldTypeByValue.emplace( 857, FieldType::INT );
  fieldTypeNameByValue.emplace( 857, "INT" );

  tagNameByRaw.emplace( tag_as_raw<858>(), FixSharedCommission );
  tagNameByValue.emplace( 858, FixSharedCommission );
  tagByName.emplace( FixSharedCommission, 858 );
  fieldTypeByValue.emplace( 858, FieldType::AMT );
  fieldTypeNameByValue.emplace( 858, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<859>(), FixConfirmReqID );
  tagNameByValue.emplace( 859, FixConfirmReqID );
  tagByName.emplace( FixConfirmReqID, 859 );
  fieldTypeByValue.emplace( 859, FieldType::STRING );
  fieldTypeNameByValue.emplace( 859, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<860>(), FixAvgParPx );
  tagNameByValue.emplace( 860, FixAvgParPx );
  tagByName.emplace( FixAvgParPx, 860 );
  fieldTypeByValue.emplace( 860, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 860, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<861>(), FixReportedPx );
  tagNameByValue.emplace( 861, FixReportedPx );
  tagByName.emplace( FixReportedPx, 861 );
  fieldTypeByValue.emplace( 861, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 861, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<862>(), FixNoCapacities );
  tagNameByValue.emplace( 862, FixNoCapacities );
  tagByName.emplace( FixNoCapacities, 862 );
  fieldTypeByValue.emplace( 862, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 862, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<863>(), FixOrderCapacityQty );
  tagNameByValue.emplace( 863, FixOrderCapacityQty );
  tagByName.emplace( FixOrderCapacityQty, 863 );
  fieldTypeByValue.emplace( 863, FieldType::QTY );
  fieldTypeNameByValue.emplace( 863, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<864>(), FixNoEvents );
  tagNameByValue.emplace( 864, FixNoEvents );
  tagByName.emplace( FixNoEvents, 864 );
  fieldTypeByValue.emplace( 864, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 864, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<865>(), FixEventType );
  tagNameByValue.emplace( 865, FixEventType );
  tagByName.emplace( FixEventType, 865 );
  fieldTypeByValue.emplace( 865, FieldType::INT );
  fieldTypeNameByValue.emplace( 865, "INT" );

  tagNameByRaw.emplace( tag_as_raw<866>(), FixEventDate );
  tagNameByValue.emplace( 866, FixEventDate );
  tagByName.emplace( FixEventDate, 866 );
  fieldTypeByValue.emplace( 866, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 866, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<867>(), FixEventPx );
  tagNameByValue.emplace( 867, FixEventPx );
  tagByName.emplace( FixEventPx, 867 );
  fieldTypeByValue.emplace( 867, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 867, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<868>(), FixEventText );
  tagNameByValue.emplace( 868, FixEventText );
  tagByName.emplace( FixEventText, 868 );
  fieldTypeByValue.emplace( 868, FieldType::STRING );
  fieldTypeNameByValue.emplace( 868, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<869>(), FixPctAtRisk );
  tagNameByValue.emplace( 869, FixPctAtRisk );
  tagByName.emplace( FixPctAtRisk, 869 );
  fieldTypeByValue.emplace( 869, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 869, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<870>(), FixNoInstrAttrib );
  tagNameByValue.emplace( 870, FixNoInstrAttrib );
  tagByName.emplace( FixNoInstrAttrib, 870 );
  fieldTypeByValue.emplace( 870, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 870, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<871>(), FixInstrAttribType );
  tagNameByValue.emplace( 871, FixInstrAttribType );
  tagByName.emplace( FixInstrAttribType, 871 );
  fieldTypeByValue.emplace( 871, FieldType::INT );
  fieldTypeNameByValue.emplace( 871, "INT" );

  tagNameByRaw.emplace( tag_as_raw<872>(), FixInstrAttribValue );
  tagNameByValue.emplace( 872, FixInstrAttribValue );
  tagByName.emplace( FixInstrAttribValue, 872 );
  fieldTypeByValue.emplace( 872, FieldType::STRING );
  fieldTypeNameByValue.emplace( 872, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<873>(), FixDatedDate );
  tagNameByValue.emplace( 873, FixDatedDate );
  tagByName.emplace( FixDatedDate, 873 );
  fieldTypeByValue.emplace( 873, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 873, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<874>(), FixInterestAccrualDate );
  tagNameByValue.emplace( 874, FixInterestAccrualDate );
  tagByName.emplace( FixInterestAccrualDate, 874 );
  fieldTypeByValue.emplace( 874, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 874, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<875>(), FixCPProgram );
  tagNameByValue.emplace( 875, FixCPProgram );
  tagByName.emplace( FixCPProgram, 875 );
  fieldTypeByValue.emplace( 875, FieldType::INT );
  fieldTypeNameByValue.emplace( 875, "INT" );

  tagNameByRaw.emplace( tag_as_raw<876>(), FixCPRegType );
  tagNameByValue.emplace( 876, FixCPRegType );
  tagByName.emplace( FixCPRegType, 876 );
  fieldTypeByValue.emplace( 876, FieldType::STRING );
  fieldTypeNameByValue.emplace( 876, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<877>(), FixUnderlyingCPProgram );
  tagNameByValue.emplace( 877, FixUnderlyingCPProgram );
  tagByName.emplace( FixUnderlyingCPProgram, 877 );
  fieldTypeByValue.emplace( 877, FieldType::STRING );
  fieldTypeNameByValue.emplace( 877, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<878>(), FixUnderlyingCPRegType );
  tagNameByValue.emplace( 878, FixUnderlyingCPRegType );
  tagByName.emplace( FixUnderlyingCPRegType, 878 );
  fieldTypeByValue.emplace( 878, FieldType::STRING );
  fieldTypeNameByValue.emplace( 878, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<879>(), FixUnderlyingQty );
  tagNameByValue.emplace( 879, FixUnderlyingQty );
  tagByName.emplace( FixUnderlyingQty, 879 );
  fieldTypeByValue.emplace( 879, FieldType::QTY );
  fieldTypeNameByValue.emplace( 879, "QTY" );

  tagNameByRaw.emplace( tag_as_raw<880>(), FixTrdMatchID );
  tagNameByValue.emplace( 880, FixTrdMatchID );
  tagByName.emplace( FixTrdMatchID, 880 );
  fieldTypeByValue.emplace( 880, FieldType::STRING );
  fieldTypeNameByValue.emplace( 880, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<881>(), FixSecondaryTradeReportRefID );
  tagNameByValue.emplace( 881, FixSecondaryTradeReportRefID );
  tagByName.emplace( FixSecondaryTradeReportRefID, 881 );
  fieldTypeByValue.emplace( 881, FieldType::STRING );
  fieldTypeNameByValue.emplace( 881, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<882>(), FixUnderlyingDirtyPrice );
  tagNameByValue.emplace( 882, FixUnderlyingDirtyPrice );
  tagByName.emplace( FixUnderlyingDirtyPrice, 882 );
  fieldTypeByValue.emplace( 882, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 882, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<883>(), FixUnderlyingEndPrice );
  tagNameByValue.emplace( 883, FixUnderlyingEndPrice );
  tagByName.emplace( FixUnderlyingEndPrice, 883 );
  fieldTypeByValue.emplace( 883, FieldType::PRICE );
  fieldTypeNameByValue.emplace( 883, "PRICE" );

  tagNameByRaw.emplace( tag_as_raw<884>(), FixUnderlyingStartValue );
  tagNameByValue.emplace( 884, FixUnderlyingStartValue );
  tagByName.emplace( FixUnderlyingStartValue, 884 );
  fieldTypeByValue.emplace( 884, FieldType::AMT );
  fieldTypeNameByValue.emplace( 884, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<885>(), FixUnderlyingCurrentValue );
  tagNameByValue.emplace( 885, FixUnderlyingCurrentValue );
  tagByName.emplace( FixUnderlyingCurrentValue, 885 );
  fieldTypeByValue.emplace( 885, FieldType::AMT );
  fieldTypeNameByValue.emplace( 885, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<886>(), FixUnderlyingEndValue );
  tagNameByValue.emplace( 886, FixUnderlyingEndValue );
  tagByName.emplace( FixUnderlyingEndValue, 886 );
  fieldTypeByValue.emplace( 886, FieldType::AMT );
  fieldTypeNameByValue.emplace( 886, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<887>(), FixNoUnderlyingStips );
  tagNameByValue.emplace( 887, FixNoUnderlyingStips );
  tagByName.emplace( FixNoUnderlyingStips, 887 );
  fieldTypeByValue.emplace( 887, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 887, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<888>(), FixUnderlyingStipType );
  tagNameByValue.emplace( 888, FixUnderlyingStipType );
  tagByName.emplace( FixUnderlyingStipType, 888 );
  fieldTypeByValue.emplace( 888, FieldType::STRING );
  fieldTypeNameByValue.emplace( 888, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<889>(), FixUnderlyingStipValue );
  tagNameByValue.emplace( 889, FixUnderlyingStipValue );
  tagByName.emplace( FixUnderlyingStipValue, 889 );
  fieldTypeByValue.emplace( 889, FieldType::STRING );
  fieldTypeNameByValue.emplace( 889, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<890>(), FixMaturityNetMoney );
  tagNameByValue.emplace( 890, FixMaturityNetMoney );
  tagByName.emplace( FixMaturityNetMoney, 890 );
  fieldTypeByValue.emplace( 890, FieldType::AMT );
  fieldTypeNameByValue.emplace( 890, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<891>(), FixMiscFeeBasis );
  tagNameByValue.emplace( 891, FixMiscFeeBasis );
  tagByName.emplace( FixMiscFeeBasis, 891 );
  fieldTypeByValue.emplace( 891, FieldType::INT );
  fieldTypeNameByValue.emplace( 891, "INT" );

  tagNameByRaw.emplace( tag_as_raw<892>(), FixTotNoAllocs );
  tagNameByValue.emplace( 892, FixTotNoAllocs );
  tagByName.emplace( FixTotNoAllocs, 892 );
  fieldTypeByValue.emplace( 892, FieldType::INT );
  fieldTypeNameByValue.emplace( 892, "INT" );

  tagNameByRaw.emplace( tag_as_raw<893>(), FixLastFragment );
  tagNameByValue.emplace( 893, FixLastFragment );
  tagByName.emplace( FixLastFragment, 893 );
  fieldTypeByValue.emplace( 893, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 893, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<894>(), FixCollReqID );
  tagNameByValue.emplace( 894, FixCollReqID );
  tagByName.emplace( FixCollReqID, 894 );
  fieldTypeByValue.emplace( 894, FieldType::STRING );
  fieldTypeNameByValue.emplace( 894, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<895>(), FixCollAsgnReason );
  tagNameByValue.emplace( 895, FixCollAsgnReason );
  tagByName.emplace( FixCollAsgnReason, 895 );
  fieldTypeByValue.emplace( 895, FieldType::INT );
  fieldTypeNameByValue.emplace( 895, "INT" );

  tagNameByRaw.emplace( tag_as_raw<896>(), FixCollInquiryQualifier );
  tagNameByValue.emplace( 896, FixCollInquiryQualifier );
  tagByName.emplace( FixCollInquiryQualifier, 896 );
  fieldTypeByValue.emplace( 896, FieldType::INT );
  fieldTypeNameByValue.emplace( 896, "INT" );

  tagNameByRaw.emplace( tag_as_raw<897>(), FixNoTrades );
  tagNameByValue.emplace( 897, FixNoTrades );
  tagByName.emplace( FixNoTrades, 897 );
  fieldTypeByValue.emplace( 897, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 897, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<898>(), FixMarginRatio );
  tagNameByValue.emplace( 898, FixMarginRatio );
  tagByName.emplace( FixMarginRatio, 898 );
  fieldTypeByValue.emplace( 898, FieldType::PERCENTAGE );
  fieldTypeNameByValue.emplace( 898, "PERCENTAGE" );

  tagNameByRaw.emplace( tag_as_raw<899>(), FixMarginExcess );
  tagNameByValue.emplace( 899, FixMarginExcess );
  tagByName.emplace( FixMarginExcess, 899 );
  fieldTypeByValue.emplace( 899, FieldType::AMT );
  fieldTypeNameByValue.emplace( 899, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<900>(), FixTotalNetValue );
  tagNameByValue.emplace( 900, FixTotalNetValue );
  tagByName.emplace( FixTotalNetValue, 900 );
  fieldTypeByValue.emplace( 900, FieldType::AMT );
  fieldTypeNameByValue.emplace( 900, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<901>(), FixCashOutstanding );
  tagNameByValue.emplace( 901, FixCashOutstanding );
  tagByName.emplace( FixCashOutstanding, 901 );
  fieldTypeByValue.emplace( 901, FieldType::AMT );
  fieldTypeNameByValue.emplace( 901, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<902>(), FixCollAsgnID );
  tagNameByValue.emplace( 902, FixCollAsgnID );
  tagByName.emplace( FixCollAsgnID, 902 );
  fieldTypeByValue.emplace( 902, FieldType::STRING );
  fieldTypeNameByValue.emplace( 902, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<903>(), FixCollAsgnTransType );
  tagNameByValue.emplace( 903, FixCollAsgnTransType );
  tagByName.emplace( FixCollAsgnTransType, 903 );
  fieldTypeByValue.emplace( 903, FieldType::INT );
  fieldTypeNameByValue.emplace( 903, "INT" );

  tagNameByRaw.emplace( tag_as_raw<904>(), FixCollRespID );
  tagNameByValue.emplace( 904, FixCollRespID );
  tagByName.emplace( FixCollRespID, 904 );
  fieldTypeByValue.emplace( 904, FieldType::STRING );
  fieldTypeNameByValue.emplace( 904, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<905>(), FixCollAsgnRespType );
  tagNameByValue.emplace( 905, FixCollAsgnRespType );
  tagByName.emplace( FixCollAsgnRespType, 905 );
  fieldTypeByValue.emplace( 905, FieldType::INT );
  fieldTypeNameByValue.emplace( 905, "INT" );

  tagNameByRaw.emplace( tag_as_raw<906>(), FixCollAsgnRejectReason );
  tagNameByValue.emplace( 906, FixCollAsgnRejectReason );
  tagByName.emplace( FixCollAsgnRejectReason, 906 );
  fieldTypeByValue.emplace( 906, FieldType::INT );
  fieldTypeNameByValue.emplace( 906, "INT" );

  tagNameByRaw.emplace( tag_as_raw<907>(), FixCollAsgnRefID );
  tagNameByValue.emplace( 907, FixCollAsgnRefID );
  tagByName.emplace( FixCollAsgnRefID, 907 );
  fieldTypeByValue.emplace( 907, FieldType::STRING );
  fieldTypeNameByValue.emplace( 907, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<908>(), FixCollRptID );
  tagNameByValue.emplace( 908, FixCollRptID );
  tagByName.emplace( FixCollRptID, 908 );
  fieldTypeByValue.emplace( 908, FieldType::STRING );
  fieldTypeNameByValue.emplace( 908, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<909>(), FixCollInquiryID );
  tagNameByValue.emplace( 909, FixCollInquiryID );
  tagByName.emplace( FixCollInquiryID, 909 );
  fieldTypeByValue.emplace( 909, FieldType::STRING );
  fieldTypeNameByValue.emplace( 909, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<910>(), FixCollStatus );
  tagNameByValue.emplace( 910, FixCollStatus );
  tagByName.emplace( FixCollStatus, 910 );
  fieldTypeByValue.emplace( 910, FieldType::INT );
  fieldTypeNameByValue.emplace( 910, "INT" );

  tagNameByRaw.emplace( tag_as_raw<911>(), FixTotNumReports );
  tagNameByValue.emplace( 911, FixTotNumReports );
  tagByName.emplace( FixTotNumReports, 911 );
  fieldTypeByValue.emplace( 911, FieldType::INT );
  fieldTypeNameByValue.emplace( 911, "INT" );

  tagNameByRaw.emplace( tag_as_raw<912>(), FixLastRptRequested );
  tagNameByValue.emplace( 912, FixLastRptRequested );
  tagByName.emplace( FixLastRptRequested, 912 );
  fieldTypeByValue.emplace( 912, FieldType::BOOLEAN );
  fieldTypeNameByValue.emplace( 912, "BOOLEAN" );

  tagNameByRaw.emplace( tag_as_raw<913>(), FixAgreementDesc );
  tagNameByValue.emplace( 913, FixAgreementDesc );
  tagByName.emplace( FixAgreementDesc, 913 );
  fieldTypeByValue.emplace( 913, FieldType::STRING );
  fieldTypeNameByValue.emplace( 913, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<914>(), FixAgreementID );
  tagNameByValue.emplace( 914, FixAgreementID );
  tagByName.emplace( FixAgreementID, 914 );
  fieldTypeByValue.emplace( 914, FieldType::STRING );
  fieldTypeNameByValue.emplace( 914, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<915>(), FixAgreementDate );
  tagNameByValue.emplace( 915, FixAgreementDate );
  tagByName.emplace( FixAgreementDate, 915 );
  fieldTypeByValue.emplace( 915, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 915, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<916>(), FixStartDate );
  tagNameByValue.emplace( 916, FixStartDate );
  tagByName.emplace( FixStartDate, 916 );
  fieldTypeByValue.emplace( 916, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 916, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<917>(), FixEndDate );
  tagNameByValue.emplace( 917, FixEndDate );
  tagByName.emplace( FixEndDate, 917 );
  fieldTypeByValue.emplace( 917, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 917, "LOCALMKTDATE" );

  tagNameByRaw.emplace( tag_as_raw<918>(), FixAgreementCurrency );
  tagNameByValue.emplace( 918, FixAgreementCurrency );
  tagByName.emplace( FixAgreementCurrency, 918 );
  fieldTypeByValue.emplace( 918, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 918, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<919>(), FixDeliveryType );
  tagNameByValue.emplace( 919, FixDeliveryType );
  tagByName.emplace( FixDeliveryType, 919 );
  fieldTypeByValue.emplace( 919, FieldType::INT );
  fieldTypeNameByValue.emplace( 919, "INT" );

  tagNameByRaw.emplace( tag_as_raw<920>(), FixEndAccruedInterestAmt );
  tagNameByValue.emplace( 920, FixEndAccruedInterestAmt );
  tagByName.emplace( FixEndAccruedInterestAmt, 920 );
  fieldTypeByValue.emplace( 920, FieldType::AMT );
  fieldTypeNameByValue.emplace( 920, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<921>(), FixStartCash );
  tagNameByValue.emplace( 921, FixStartCash );
  tagByName.emplace( FixStartCash, 921 );
  fieldTypeByValue.emplace( 921, FieldType::AMT );
  fieldTypeNameByValue.emplace( 921, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<922>(), FixEndCash );
  tagNameByValue.emplace( 922, FixEndCash );
  tagByName.emplace( FixEndCash, 922 );
  fieldTypeByValue.emplace( 922, FieldType::AMT );
  fieldTypeNameByValue.emplace( 922, "AMT" );

  tagNameByRaw.emplace( tag_as_raw<923>(), FixUserRequestID );
  tagNameByValue.emplace( 923, FixUserRequestID );
  tagByName.emplace( FixUserRequestID, 923 );
  fieldTypeByValue.emplace( 923, FieldType::STRING );
  fieldTypeNameByValue.emplace( 923, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<924>(), FixUserRequestType );
  tagNameByValue.emplace( 924, FixUserRequestType );
  tagByName.emplace( FixUserRequestType, 924 );
  fieldTypeByValue.emplace( 924, FieldType::INT );
  fieldTypeNameByValue.emplace( 924, "INT" );

  tagNameByRaw.emplace( tag_as_raw<925>(), FixNewPassword );
  tagNameByValue.emplace( 925, FixNewPassword );
  tagByName.emplace( FixNewPassword, 925 );
  fieldTypeByValue.emplace( 925, FieldType::STRING );
  fieldTypeNameByValue.emplace( 925, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<926>(), FixUserStatus );
  tagNameByValue.emplace( 926, FixUserStatus );
  tagByName.emplace( FixUserStatus, 926 );
  fieldTypeByValue.emplace( 926, FieldType::INT );
  fieldTypeNameByValue.emplace( 926, "INT" );

  tagNameByRaw.emplace( tag_as_raw<927>(), FixUserStatusText );
  tagNameByValue.emplace( 927, FixUserStatusText );
  tagByName.emplace( FixUserStatusText, 927 );
  fieldTypeByValue.emplace( 927, FieldType::STRING );
  fieldTypeNameByValue.emplace( 927, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<928>(), FixStatusValue );
  tagNameByValue.emplace( 928, FixStatusValue );
  tagByName.emplace( FixStatusValue, 928 );
  fieldTypeByValue.emplace( 928, FieldType::INT );
  fieldTypeNameByValue.emplace( 928, "INT" );

  tagNameByRaw.emplace( tag_as_raw<929>(), FixStatusText );
  tagNameByValue.emplace( 929, FixStatusText );
  tagByName.emplace( FixStatusText, 929 );
  fieldTypeByValue.emplace( 929, FieldType::STRING );
  fieldTypeNameByValue.emplace( 929, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<930>(), FixRefCompID );
  tagNameByValue.emplace( 930, FixRefCompID );
  tagByName.emplace( FixRefCompID, 930 );
  fieldTypeByValue.emplace( 930, FieldType::STRING );
  fieldTypeNameByValue.emplace( 930, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<931>(), FixRefSubID );
  tagNameByValue.emplace( 931, FixRefSubID );
  tagByName.emplace( FixRefSubID, 931 );
  fieldTypeByValue.emplace( 931, FieldType::STRING );
  fieldTypeNameByValue.emplace( 931, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<932>(), FixNetworkResponseID );
  tagNameByValue.emplace( 932, FixNetworkResponseID );
  tagByName.emplace( FixNetworkResponseID, 932 );
  fieldTypeByValue.emplace( 932, FieldType::STRING );
  fieldTypeNameByValue.emplace( 932, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<933>(), FixNetworkRequestID );
  tagNameByValue.emplace( 933, FixNetworkRequestID );
  tagByName.emplace( FixNetworkRequestID, 933 );
  fieldTypeByValue.emplace( 933, FieldType::STRING );
  fieldTypeNameByValue.emplace( 933, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<934>(), FixLastNetworkResponseID );
  tagNameByValue.emplace( 934, FixLastNetworkResponseID );
  tagByName.emplace( FixLastNetworkResponseID, 934 );
  fieldTypeByValue.emplace( 934, FieldType::STRING );
  fieldTypeNameByValue.emplace( 934, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<935>(), FixNetworkRequestType );
  tagNameByValue.emplace( 935, FixNetworkRequestType );
  tagByName.emplace( FixNetworkRequestType, 935 );
  fieldTypeByValue.emplace( 935, FieldType::INT );
  fieldTypeNameByValue.emplace( 935, "INT" );

  tagNameByRaw.emplace( tag_as_raw<936>(), FixNoCompIDs );
  tagNameByValue.emplace( 936, FixNoCompIDs );
  tagByName.emplace( FixNoCompIDs, 936 );
  fieldTypeByValue.emplace( 936, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 936, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<937>(), FixNetworkStatusResponseType );
  tagNameByValue.emplace( 937, FixNetworkStatusResponseType );
  tagByName.emplace( FixNetworkStatusResponseType, 937 );
  fieldTypeByValue.emplace( 937, FieldType::INT );
  fieldTypeNameByValue.emplace( 937, "INT" );

  tagNameByRaw.emplace( tag_as_raw<938>(), FixNoCollInquiryQualifier );
  tagNameByValue.emplace( 938, FixNoCollInquiryQualifier );
  tagByName.emplace( FixNoCollInquiryQualifier, 938 );
  fieldTypeByValue.emplace( 938, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 938, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<939>(), FixTrdRptStatus );
  tagNameByValue.emplace( 939, FixTrdRptStatus );
  tagByName.emplace( FixTrdRptStatus, 939 );
  fieldTypeByValue.emplace( 939, FieldType::INT );
  fieldTypeNameByValue.emplace( 939, "INT" );

  tagNameByRaw.emplace( tag_as_raw<940>(), FixAffirmStatus );
  tagNameByValue.emplace( 940, FixAffirmStatus );
  tagByName.emplace( FixAffirmStatus, 940 );
  fieldTypeByValue.emplace( 940, FieldType::INT );
  fieldTypeNameByValue.emplace( 940, "INT" );

  tagNameByRaw.emplace( tag_as_raw<941>(), FixUnderlyingStrikeCurrency );
  tagNameByValue.emplace( 941, FixUnderlyingStrikeCurrency );
  tagByName.emplace( FixUnderlyingStrikeCurrency, 941 );
  fieldTypeByValue.emplace( 941, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 941, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<942>(), FixLegStrikeCurrency );
  tagNameByValue.emplace( 942, FixLegStrikeCurrency );
  tagByName.emplace( FixLegStrikeCurrency, 942 );
  fieldTypeByValue.emplace( 942, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 942, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<943>(), FixTimeBracket );
  tagNameByValue.emplace( 943, FixTimeBracket );
  tagByName.emplace( FixTimeBracket, 943 );
  fieldTypeByValue.emplace( 943, FieldType::STRING );
  fieldTypeNameByValue.emplace( 943, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<944>(), FixCollAction );
  tagNameByValue.emplace( 944, FixCollAction );
  tagByName.emplace( FixCollAction, 944 );
  fieldTypeByValue.emplace( 944, FieldType::INT );
  fieldTypeNameByValue.emplace( 944, "INT" );

  tagNameByRaw.emplace( tag_as_raw<945>(), FixCollInquiryStatus );
  tagNameByValue.emplace( 945, FixCollInquiryStatus );
  tagByName.emplace( FixCollInquiryStatus, 945 );
  fieldTypeByValue.emplace( 945, FieldType::INT );
  fieldTypeNameByValue.emplace( 945, "INT" );

  tagNameByRaw.emplace( tag_as_raw<946>(), FixCollInquiryResult );
  tagNameByValue.emplace( 946, FixCollInquiryResult );
  tagByName.emplace( FixCollInquiryResult, 946 );
  fieldTypeByValue.emplace( 946, FieldType::INT );
  fieldTypeNameByValue.emplace( 946, "INT" );

  tagNameByRaw.emplace( tag_as_raw<947>(), FixStrikeCurrency );
  tagNameByValue.emplace( 947, FixStrikeCurrency );
  tagByName.emplace( FixStrikeCurrency, 947 );
  fieldTypeByValue.emplace( 947, FieldType::CURRENCY );
  fieldTypeNameByValue.emplace( 947, "CURRENCY" );

  tagNameByRaw.emplace( tag_as_raw<948>(), FixNoNested3PartyIDs );
  tagNameByValue.emplace( 948, FixNoNested3PartyIDs );
  tagByName.emplace( FixNoNested3PartyIDs, 948 );
  fieldTypeByValue.emplace( 948, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 948, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<949>(), FixNested3PartyID );
  tagNameByValue.emplace( 949, FixNested3PartyID );
  tagByName.emplace( FixNested3PartyID, 949 );
  fieldTypeByValue.emplace( 949, FieldType::STRING );
  fieldTypeNameByValue.emplace( 949, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<950>(), FixNested3PartyIDSource );
  tagNameByValue.emplace( 950, FixNested3PartyIDSource );
  tagByName.emplace( FixNested3PartyIDSource, 950 );
  fieldTypeByValue.emplace( 950, FieldType::CHAR );
  fieldTypeNameByValue.emplace( 950, "CHAR" );

  tagNameByRaw.emplace( tag_as_raw<951>(), FixNested3PartyRole );
  tagNameByValue.emplace( 951, FixNested3PartyRole );
  tagByName.emplace( FixNested3PartyRole, 951 );
  fieldTypeByValue.emplace( 951, FieldType::INT );
  fieldTypeNameByValue.emplace( 951, "INT" );

  tagNameByRaw.emplace( tag_as_raw<952>(), FixNoNested3PartySubIDs );
  tagNameByValue.emplace( 952, FixNoNested3PartySubIDs );
  tagByName.emplace( FixNoNested3PartySubIDs, 952 );
  fieldTypeByValue.emplace( 952, FieldType::NUMINGROUP );
  fieldTypeNameByValue.emplace( 952, "NUMINGROUP" );

  tagNameByRaw.emplace( tag_as_raw<953>(), FixNested3PartySubID );
  tagNameByValue.emplace( 953, FixNested3PartySubID );
  tagByName.emplace( FixNested3PartySubID, 953 );
  fieldTypeByValue.emplace( 953, FieldType::STRING );
  fieldTypeNameByValue.emplace( 953, "STRING" );

  tagNameByRaw.emplace( tag_as_raw<954>(), FixNested3PartySubIDType );
  tagNameByValue.emplace( 954, FixNested3PartySubIDType );
  tagByName.emplace( FixNested3PartySubIDType, 954 );
  fieldTypeByValue.emplace( 954, FieldType::INT );
  fieldTypeNameByValue.emplace( 954, "INT" );

  tagNameByRaw.emplace( tag_as_raw<955>(), FixLegContractSettlMonth );
  tagNameByValue.emplace( 955, FixLegContractSettlMonth );
  tagByName.emplace( FixLegContractSettlMonth, 955 );
  fieldTypeByValue.emplace( 955, FieldType::MONTHYEAR );
  fieldTypeNameByValue.emplace( 955, "MONTHYEAR" );

  tagNameByRaw.emplace( tag_as_raw<956>(), FixLegInterestAccrualDate );
  tagNameByValue.emplace( 956, FixLegInterestAccrualDate );
  tagByName.emplace( FixLegInterestAccrualDate, 956 );
  fieldTypeByValue.emplace( 956, FieldType::LOCALMKTDATE );
  fieldTypeNameByValue.emplace( 956, "LOCALMKTDATE" );

  FieldAdvSide::enumItems = AdvSideEnums::items;
  enumsByRaw.emplace( FieldAdvSide::RAW_TAG, & AdvSideEnums::instance );
  enumsByTag.emplace( FieldAdvSide::TAG, & AdvSideEnums::instance );

  FieldAdvTransType::enumItems = AdvTransTypeEnums::items;
  enumsByRaw.emplace( FieldAdvTransType::RAW_TAG, & AdvTransTypeEnums::instance );
  enumsByTag.emplace( FieldAdvTransType::TAG, & AdvTransTypeEnums::instance );

  FieldCommType::enumItems = CommTypeEnums::items;
  enumsByRaw.emplace( FieldCommType::RAW_TAG, & CommTypeEnums::instance );
  enumsByTag.emplace( FieldCommType::TAG, & CommTypeEnums::instance );

  FieldExecInst::enumItems = ExecInstEnums::items;
  enumsByRaw.emplace( FieldExecInst::RAW_TAG, & ExecInstEnums::instance );
  enumsByTag.emplace( FieldExecInst::TAG, & ExecInstEnums::instance );

  FieldHandlInst::enumItems = HandlInstEnums::items;
  enumsByRaw.emplace( FieldHandlInst::RAW_TAG, & HandlInstEnums::instance );
  enumsByTag.emplace( FieldHandlInst::TAG, & HandlInstEnums::instance );

  FieldSecurityIDSource::enumItems = SecurityIDSourceEnums::items;
  enumsByRaw.emplace( FieldSecurityIDSource::RAW_TAG, & SecurityIDSourceEnums::instance );
  enumsByTag.emplace( FieldSecurityIDSource::TAG, & SecurityIDSourceEnums::instance );

  FieldIOIQltyInd::enumItems = IOIQltyIndEnums::items;
  enumsByRaw.emplace( FieldIOIQltyInd::RAW_TAG, & IOIQltyIndEnums::instance );
  enumsByTag.emplace( FieldIOIQltyInd::TAG, & IOIQltyIndEnums::instance );

  FieldIOIQty::enumItems = IOIQtyEnums::items;
  enumsByRaw.emplace( FieldIOIQty::RAW_TAG, & IOIQtyEnums::instance );
  enumsByTag.emplace( FieldIOIQty::TAG, & IOIQtyEnums::instance );

  FieldIOITransType::enumItems = IOITransTypeEnums::items;
  enumsByRaw.emplace( FieldIOITransType::RAW_TAG, & IOITransTypeEnums::instance );
  enumsByTag.emplace( FieldIOITransType::TAG, & IOITransTypeEnums::instance );

  FieldLastCapacity::enumItems = LastCapacityEnums::items;
  enumsByRaw.emplace( FieldLastCapacity::RAW_TAG, & LastCapacityEnums::instance );
  enumsByTag.emplace( FieldLastCapacity::TAG, & LastCapacityEnums::instance );

  FieldMsgType::enumItems = MsgTypeEnums::items;
  enumsByRaw.emplace( FieldMsgType::RAW_TAG, & MsgTypeEnums::instance );
  enumsByTag.emplace( FieldMsgType::TAG, & MsgTypeEnums::instance );

  FieldOrdStatus::enumItems = OrdStatusEnums::items;
  enumsByRaw.emplace( FieldOrdStatus::RAW_TAG, & OrdStatusEnums::instance );
  enumsByTag.emplace( FieldOrdStatus::TAG, & OrdStatusEnums::instance );

  FieldOrdType::enumItems = OrdTypeEnums::items;
  enumsByRaw.emplace( FieldOrdType::RAW_TAG, & OrdTypeEnums::instance );
  enumsByTag.emplace( FieldOrdType::TAG, & OrdTypeEnums::instance );

  FieldPossDupFlag::enumItems = PossDupFlagEnums::items;
  enumsByRaw.emplace( FieldPossDupFlag::RAW_TAG, & PossDupFlagEnums::instance );
  enumsByTag.emplace( FieldPossDupFlag::TAG, & PossDupFlagEnums::instance );

  FieldSide::enumItems = SideEnums::items;
  enumsByRaw.emplace( FieldSide::RAW_TAG, & SideEnums::instance );
  enumsByTag.emplace( FieldSide::TAG, & SideEnums::instance );

  FieldTimeInForce::enumItems = TimeInForceEnums::items;
  enumsByRaw.emplace( FieldTimeInForce::RAW_TAG, & TimeInForceEnums::instance );
  enumsByTag.emplace( FieldTimeInForce::TAG, & TimeInForceEnums::instance );

  FieldUrgency::enumItems = UrgencyEnums::items;
  enumsByRaw.emplace( FieldUrgency::RAW_TAG, & UrgencyEnums::instance );
  enumsByTag.emplace( FieldUrgency::TAG, & UrgencyEnums::instance );

  FieldSettlType::enumItems = SettlTypeEnums::items;
  enumsByRaw.emplace( FieldSettlType::RAW_TAG, & SettlTypeEnums::instance );
  enumsByTag.emplace( FieldSettlType::TAG, & SettlTypeEnums::instance );

  FieldAllocTransType::enumItems = AllocTransTypeEnums::items;
  enumsByRaw.emplace( FieldAllocTransType::RAW_TAG, & AllocTransTypeEnums::instance );
  enumsByTag.emplace( FieldAllocTransType::TAG, & AllocTransTypeEnums::instance );

  FieldPositionEffect::enumItems = PositionEffectEnums::items;
  enumsByRaw.emplace( FieldPositionEffect::RAW_TAG, & PositionEffectEnums::instance );
  enumsByTag.emplace( FieldPositionEffect::TAG, & PositionEffectEnums::instance );

  FieldProcessCode::enumItems = ProcessCodeEnums::items;
  enumsByRaw.emplace( FieldProcessCode::RAW_TAG, & ProcessCodeEnums::instance );
  enumsByTag.emplace( FieldProcessCode::TAG, & ProcessCodeEnums::instance );

  FieldAllocStatus::enumItems = AllocStatusEnums::items;
  enumsByRaw.emplace( FieldAllocStatus::RAW_TAG, & AllocStatusEnums::instance );
  enumsByTag.emplace( FieldAllocStatus::TAG, & AllocStatusEnums::instance );

  FieldAllocRejCode::enumItems = AllocRejCodeEnums::items;
  enumsByRaw.emplace( FieldAllocRejCode::RAW_TAG, & AllocRejCodeEnums::instance );
  enumsByTag.emplace( FieldAllocRejCode::TAG, & AllocRejCodeEnums::instance );

  FieldEmailType::enumItems = EmailTypeEnums::items;
  enumsByRaw.emplace( FieldEmailType::RAW_TAG, & EmailTypeEnums::instance );
  enumsByTag.emplace( FieldEmailType::TAG, & EmailTypeEnums::instance );

  FieldPossResend::enumItems = PossResendEnums::items;
  enumsByRaw.emplace( FieldPossResend::RAW_TAG, & PossResendEnums::instance );
  enumsByTag.emplace( FieldPossResend::TAG, & PossResendEnums::instance );

  FieldEncryptMethod::enumItems = EncryptMethodEnums::items;
  enumsByRaw.emplace( FieldEncryptMethod::RAW_TAG, & EncryptMethodEnums::instance );
  enumsByTag.emplace( FieldEncryptMethod::TAG, & EncryptMethodEnums::instance );

  FieldCxlRejReason::enumItems = CxlRejReasonEnums::items;
  enumsByRaw.emplace( FieldCxlRejReason::RAW_TAG, & CxlRejReasonEnums::instance );
  enumsByTag.emplace( FieldCxlRejReason::TAG, & CxlRejReasonEnums::instance );

  FieldOrdRejReason::enumItems = OrdRejReasonEnums::items;
  enumsByRaw.emplace( FieldOrdRejReason::RAW_TAG, & OrdRejReasonEnums::instance );
  enumsByTag.emplace( FieldOrdRejReason::TAG, & OrdRejReasonEnums::instance );

  FieldIOIQualifier::enumItems = IOIQualifierEnums::items;
  enumsByRaw.emplace( FieldIOIQualifier::RAW_TAG, & IOIQualifierEnums::instance );
  enumsByTag.emplace( FieldIOIQualifier::TAG, & IOIQualifierEnums::instance );

  FieldReportToExch::enumItems = ReportToExchEnums::items;
  enumsByRaw.emplace( FieldReportToExch::RAW_TAG, & ReportToExchEnums::instance );
  enumsByTag.emplace( FieldReportToExch::TAG, & ReportToExchEnums::instance );

  FieldLocateReqd::enumItems = LocateReqdEnums::items;
  enumsByRaw.emplace( FieldLocateReqd::RAW_TAG, & LocateReqdEnums::instance );
  enumsByTag.emplace( FieldLocateReqd::TAG, & LocateReqdEnums::instance );

  FieldForexReq::enumItems = ForexReqEnums::items;
  enumsByRaw.emplace( FieldForexReq::RAW_TAG, & ForexReqEnums::instance );
  enumsByTag.emplace( FieldForexReq::TAG, & ForexReqEnums::instance );

  FieldGapFillFlag::enumItems = GapFillFlagEnums::items;
  enumsByRaw.emplace( FieldGapFillFlag::RAW_TAG, & GapFillFlagEnums::instance );
  enumsByTag.emplace( FieldGapFillFlag::TAG, & GapFillFlagEnums::instance );

  FieldDKReason::enumItems = DKReasonEnums::items;
  enumsByRaw.emplace( FieldDKReason::RAW_TAG, & DKReasonEnums::instance );
  enumsByTag.emplace( FieldDKReason::TAG, & DKReasonEnums::instance );

  FieldIOINaturalFlag::enumItems = IOINaturalFlagEnums::items;
  enumsByRaw.emplace( FieldIOINaturalFlag::RAW_TAG, & IOINaturalFlagEnums::instance );
  enumsByTag.emplace( FieldIOINaturalFlag::TAG, & IOINaturalFlagEnums::instance );

  FieldMiscFeeType::enumItems = MiscFeeTypeEnums::items;
  enumsByRaw.emplace( FieldMiscFeeType::RAW_TAG, & MiscFeeTypeEnums::instance );
  enumsByTag.emplace( FieldMiscFeeType::TAG, & MiscFeeTypeEnums::instance );

  FieldResetSeqNumFlag::enumItems = ResetSeqNumFlagEnums::items;
  enumsByRaw.emplace( FieldResetSeqNumFlag::RAW_TAG, & ResetSeqNumFlagEnums::instance );
  enumsByTag.emplace( FieldResetSeqNumFlag::TAG, & ResetSeqNumFlagEnums::instance );

  FieldExecType::enumItems = ExecTypeEnums::items;
  enumsByRaw.emplace( FieldExecType::RAW_TAG, & ExecTypeEnums::instance );
  enumsByTag.emplace( FieldExecType::TAG, & ExecTypeEnums::instance );

  FieldSettlCurrFxRateCalc::enumItems = SettlCurrFxRateCalcEnums::items;
  enumsByRaw.emplace( FieldSettlCurrFxRateCalc::RAW_TAG, & SettlCurrFxRateCalcEnums::instance );
  enumsByTag.emplace( FieldSettlCurrFxRateCalc::TAG, & SettlCurrFxRateCalcEnums::instance );

  FieldSettlInstMode::enumItems = SettlInstModeEnums::items;
  enumsByRaw.emplace( FieldSettlInstMode::RAW_TAG, & SettlInstModeEnums::instance );
  enumsByTag.emplace( FieldSettlInstMode::TAG, & SettlInstModeEnums::instance );

  FieldSettlInstTransType::enumItems = SettlInstTransTypeEnums::items;
  enumsByRaw.emplace( FieldSettlInstTransType::RAW_TAG, & SettlInstTransTypeEnums::instance );
  enumsByTag.emplace( FieldSettlInstTransType::TAG, & SettlInstTransTypeEnums::instance );

  FieldSettlInstSource::enumItems = SettlInstSourceEnums::items;
  enumsByRaw.emplace( FieldSettlInstSource::RAW_TAG, & SettlInstSourceEnums::instance );
  enumsByTag.emplace( FieldSettlInstSource::TAG, & SettlInstSourceEnums::instance );

  FieldSecurityType::enumItems = SecurityTypeEnums::items;
  enumsByRaw.emplace( FieldSecurityType::RAW_TAG, & SecurityTypeEnums::instance );
  enumsByTag.emplace( FieldSecurityType::TAG, & SecurityTypeEnums::instance );

  FieldStandInstDbType::enumItems = StandInstDbTypeEnums::items;
  enumsByRaw.emplace( FieldStandInstDbType::RAW_TAG, & StandInstDbTypeEnums::instance );
  enumsByTag.emplace( FieldStandInstDbType::TAG, & StandInstDbTypeEnums::instance );

  FieldSettlDeliveryType::enumItems = SettlDeliveryTypeEnums::items;
  enumsByRaw.emplace( FieldSettlDeliveryType::RAW_TAG, & SettlDeliveryTypeEnums::instance );
  enumsByTag.emplace( FieldSettlDeliveryType::TAG, & SettlDeliveryTypeEnums::instance );

  FieldAllocLinkType::enumItems = AllocLinkTypeEnums::items;
  enumsByRaw.emplace( FieldAllocLinkType::RAW_TAG, & AllocLinkTypeEnums::instance );
  enumsByTag.emplace( FieldAllocLinkType::TAG, & AllocLinkTypeEnums::instance );

  FieldPutOrCall::enumItems = PutOrCallEnums::items;
  enumsByRaw.emplace( FieldPutOrCall::RAW_TAG, & PutOrCallEnums::instance );
  enumsByTag.emplace( FieldPutOrCall::TAG, & PutOrCallEnums::instance );

  FieldCoveredOrUncovered::enumItems = CoveredOrUncoveredEnums::items;
  enumsByRaw.emplace( FieldCoveredOrUncovered::RAW_TAG, & CoveredOrUncoveredEnums::instance );
  enumsByTag.emplace( FieldCoveredOrUncovered::TAG, & CoveredOrUncoveredEnums::instance );

  FieldNotifyBrokerOfCredit::enumItems = NotifyBrokerOfCreditEnums::items;
  enumsByRaw.emplace( FieldNotifyBrokerOfCredit::RAW_TAG, & NotifyBrokerOfCreditEnums::instance );
  enumsByTag.emplace( FieldNotifyBrokerOfCredit::TAG, & NotifyBrokerOfCreditEnums::instance );

  FieldAllocHandlInst::enumItems = AllocHandlInstEnums::items;
  enumsByRaw.emplace( FieldAllocHandlInst::RAW_TAG, & AllocHandlInstEnums::instance );
  enumsByTag.emplace( FieldAllocHandlInst::TAG, & AllocHandlInstEnums::instance );

  FieldRoutingType::enumItems = RoutingTypeEnums::items;
  enumsByRaw.emplace( FieldRoutingType::RAW_TAG, & RoutingTypeEnums::instance );
  enumsByTag.emplace( FieldRoutingType::TAG, & RoutingTypeEnums::instance );

  FieldStipulationType::enumItems = StipulationTypeEnums::items;
  enumsByRaw.emplace( FieldStipulationType::RAW_TAG, & StipulationTypeEnums::instance );
  enumsByTag.emplace( FieldStipulationType::TAG, & StipulationTypeEnums::instance );

  FieldYieldType::enumItems = YieldTypeEnums::items;
  enumsByRaw.emplace( FieldYieldType::RAW_TAG, & YieldTypeEnums::instance );
  enumsByTag.emplace( FieldYieldType::TAG, & YieldTypeEnums::instance );

  FieldTradedFlatSwitch::enumItems = TradedFlatSwitchEnums::items;
  enumsByRaw.emplace( FieldTradedFlatSwitch::RAW_TAG, & TradedFlatSwitchEnums::instance );
  enumsByTag.emplace( FieldTradedFlatSwitch::TAG, & TradedFlatSwitchEnums::instance );

  FieldSubscriptionRequestType::enumItems = SubscriptionRequestTypeEnums::items;
  enumsByRaw.emplace( FieldSubscriptionRequestType::RAW_TAG, & SubscriptionRequestTypeEnums::instance );
  enumsByTag.emplace( FieldSubscriptionRequestType::TAG, & SubscriptionRequestTypeEnums::instance );

  FieldMDUpdateType::enumItems = MDUpdateTypeEnums::items;
  enumsByRaw.emplace( FieldMDUpdateType::RAW_TAG, & MDUpdateTypeEnums::instance );
  enumsByTag.emplace( FieldMDUpdateType::TAG, & MDUpdateTypeEnums::instance );

  FieldAggregatedBook::enumItems = AggregatedBookEnums::items;
  enumsByRaw.emplace( FieldAggregatedBook::RAW_TAG, & AggregatedBookEnums::instance );
  enumsByTag.emplace( FieldAggregatedBook::TAG, & AggregatedBookEnums::instance );

  FieldMDEntryType::enumItems = MDEntryTypeEnums::items;
  enumsByRaw.emplace( FieldMDEntryType::RAW_TAG, & MDEntryTypeEnums::instance );
  enumsByTag.emplace( FieldMDEntryType::TAG, & MDEntryTypeEnums::instance );

  FieldTickDirection::enumItems = TickDirectionEnums::items;
  enumsByRaw.emplace( FieldTickDirection::RAW_TAG, & TickDirectionEnums::instance );
  enumsByTag.emplace( FieldTickDirection::TAG, & TickDirectionEnums::instance );

  FieldQuoteCondition::enumItems = QuoteConditionEnums::items;
  enumsByRaw.emplace( FieldQuoteCondition::RAW_TAG, & QuoteConditionEnums::instance );
  enumsByTag.emplace( FieldQuoteCondition::TAG, & QuoteConditionEnums::instance );

  FieldTradeCondition::enumItems = TradeConditionEnums::items;
  enumsByRaw.emplace( FieldTradeCondition::RAW_TAG, & TradeConditionEnums::instance );
  enumsByTag.emplace( FieldTradeCondition::TAG, & TradeConditionEnums::instance );

  FieldMDUpdateAction::enumItems = MDUpdateActionEnums::items;
  enumsByRaw.emplace( FieldMDUpdateAction::RAW_TAG, & MDUpdateActionEnums::instance );
  enumsByTag.emplace( FieldMDUpdateAction::TAG, & MDUpdateActionEnums::instance );

  FieldMDReqRejReason::enumItems = MDReqRejReasonEnums::items;
  enumsByRaw.emplace( FieldMDReqRejReason::RAW_TAG, & MDReqRejReasonEnums::instance );
  enumsByTag.emplace( FieldMDReqRejReason::TAG, & MDReqRejReasonEnums::instance );

  FieldDeleteReason::enumItems = DeleteReasonEnums::items;
  enumsByRaw.emplace( FieldDeleteReason::RAW_TAG, & DeleteReasonEnums::instance );
  enumsByTag.emplace( FieldDeleteReason::TAG, & DeleteReasonEnums::instance );

  FieldOpenCloseSettlFlag::enumItems = OpenCloseSettlFlagEnums::items;
  enumsByRaw.emplace( FieldOpenCloseSettlFlag::RAW_TAG, & OpenCloseSettlFlagEnums::instance );
  enumsByTag.emplace( FieldOpenCloseSettlFlag::TAG, & OpenCloseSettlFlagEnums::instance );

  FieldFinancialStatus::enumItems = FinancialStatusEnums::items;
  enumsByRaw.emplace( FieldFinancialStatus::RAW_TAG, & FinancialStatusEnums::instance );
  enumsByTag.emplace( FieldFinancialStatus::TAG, & FinancialStatusEnums::instance );

  FieldCorporateAction::enumItems = CorporateActionEnums::items;
  enumsByRaw.emplace( FieldCorporateAction::RAW_TAG, & CorporateActionEnums::instance );
  enumsByTag.emplace( FieldCorporateAction::TAG, & CorporateActionEnums::instance );

  FieldQuoteStatus::enumItems = QuoteStatusEnums::items;
  enumsByRaw.emplace( FieldQuoteStatus::RAW_TAG, & QuoteStatusEnums::instance );
  enumsByTag.emplace( FieldQuoteStatus::TAG, & QuoteStatusEnums::instance );

  FieldQuoteCancelType::enumItems = QuoteCancelTypeEnums::items;
  enumsByRaw.emplace( FieldQuoteCancelType::RAW_TAG, & QuoteCancelTypeEnums::instance );
  enumsByTag.emplace( FieldQuoteCancelType::TAG, & QuoteCancelTypeEnums::instance );

  FieldQuoteRejectReason::enumItems = QuoteRejectReasonEnums::items;
  enumsByRaw.emplace( FieldQuoteRejectReason::RAW_TAG, & QuoteRejectReasonEnums::instance );
  enumsByTag.emplace( FieldQuoteRejectReason::TAG, & QuoteRejectReasonEnums::instance );

  FieldQuoteResponseLevel::enumItems = QuoteResponseLevelEnums::items;
  enumsByRaw.emplace( FieldQuoteResponseLevel::RAW_TAG, & QuoteResponseLevelEnums::instance );
  enumsByTag.emplace( FieldQuoteResponseLevel::TAG, & QuoteResponseLevelEnums::instance );

  FieldQuoteRequestType::enumItems = QuoteRequestTypeEnums::items;
  enumsByRaw.emplace( FieldQuoteRequestType::RAW_TAG, & QuoteRequestTypeEnums::instance );
  enumsByTag.emplace( FieldQuoteRequestType::TAG, & QuoteRequestTypeEnums::instance );

  FieldSecurityRequestType::enumItems = SecurityRequestTypeEnums::items;
  enumsByRaw.emplace( FieldSecurityRequestType::RAW_TAG, & SecurityRequestTypeEnums::instance );
  enumsByTag.emplace( FieldSecurityRequestType::TAG, & SecurityRequestTypeEnums::instance );

  FieldSecurityResponseType::enumItems = SecurityResponseTypeEnums::items;
  enumsByRaw.emplace( FieldSecurityResponseType::RAW_TAG, & SecurityResponseTypeEnums::instance );
  enumsByTag.emplace( FieldSecurityResponseType::TAG, & SecurityResponseTypeEnums::instance );

  FieldUnsolicitedIndicator::enumItems = UnsolicitedIndicatorEnums::items;
  enumsByRaw.emplace( FieldUnsolicitedIndicator::RAW_TAG, & UnsolicitedIndicatorEnums::instance );
  enumsByTag.emplace( FieldUnsolicitedIndicator::TAG, & UnsolicitedIndicatorEnums::instance );

  FieldSecurityTradingStatus::enumItems = SecurityTradingStatusEnums::items;
  enumsByRaw.emplace( FieldSecurityTradingStatus::RAW_TAG, & SecurityTradingStatusEnums::instance );
  enumsByTag.emplace( FieldSecurityTradingStatus::TAG, & SecurityTradingStatusEnums::instance );

  FieldHaltReasonChar::enumItems = HaltReasonCharEnums::items;
  enumsByRaw.emplace( FieldHaltReasonChar::RAW_TAG, & HaltReasonCharEnums::instance );
  enumsByTag.emplace( FieldHaltReasonChar::TAG, & HaltReasonCharEnums::instance );

  FieldInViewOfCommon::enumItems = InViewOfCommonEnums::items;
  enumsByRaw.emplace( FieldInViewOfCommon::RAW_TAG, & InViewOfCommonEnums::instance );
  enumsByTag.emplace( FieldInViewOfCommon::TAG, & InViewOfCommonEnums::instance );

  FieldDueToRelated::enumItems = DueToRelatedEnums::items;
  enumsByRaw.emplace( FieldDueToRelated::RAW_TAG, & DueToRelatedEnums::instance );
  enumsByTag.emplace( FieldDueToRelated::TAG, & DueToRelatedEnums::instance );

  FieldAdjustment::enumItems = AdjustmentEnums::items;
  enumsByRaw.emplace( FieldAdjustment::RAW_TAG, & AdjustmentEnums::instance );
  enumsByTag.emplace( FieldAdjustment::TAG, & AdjustmentEnums::instance );

  FieldTradSesMethod::enumItems = TradSesMethodEnums::items;
  enumsByRaw.emplace( FieldTradSesMethod::RAW_TAG, & TradSesMethodEnums::instance );
  enumsByTag.emplace( FieldTradSesMethod::TAG, & TradSesMethodEnums::instance );

  FieldTradSesMode::enumItems = TradSesModeEnums::items;
  enumsByRaw.emplace( FieldTradSesMode::RAW_TAG, & TradSesModeEnums::instance );
  enumsByTag.emplace( FieldTradSesMode::TAG, & TradSesModeEnums::instance );

  FieldTradSesStatus::enumItems = TradSesStatusEnums::items;
  enumsByRaw.emplace( FieldTradSesStatus::RAW_TAG, & TradSesStatusEnums::instance );
  enumsByTag.emplace( FieldTradSesStatus::TAG, & TradSesStatusEnums::instance );

  FieldMessageEncoding::enumItems = MessageEncodingEnums::items;
  enumsByRaw.emplace( FieldMessageEncoding::RAW_TAG, & MessageEncodingEnums::instance );
  enumsByTag.emplace( FieldMessageEncoding::TAG, & MessageEncodingEnums::instance );

  FieldSessionRejectReason::enumItems = SessionRejectReasonEnums::items;
  enumsByRaw.emplace( FieldSessionRejectReason::RAW_TAG, & SessionRejectReasonEnums::instance );
  enumsByTag.emplace( FieldSessionRejectReason::TAG, & SessionRejectReasonEnums::instance );

  FieldBidRequestTransType::enumItems = BidRequestTransTypeEnums::items;
  enumsByRaw.emplace( FieldBidRequestTransType::RAW_TAG, & BidRequestTransTypeEnums::instance );
  enumsByTag.emplace( FieldBidRequestTransType::TAG, & BidRequestTransTypeEnums::instance );

  FieldSolicitedFlag::enumItems = SolicitedFlagEnums::items;
  enumsByRaw.emplace( FieldSolicitedFlag::RAW_TAG, & SolicitedFlagEnums::instance );
  enumsByTag.emplace( FieldSolicitedFlag::TAG, & SolicitedFlagEnums::instance );

  FieldExecRestatementReason::enumItems = ExecRestatementReasonEnums::items;
  enumsByRaw.emplace( FieldExecRestatementReason::RAW_TAG, & ExecRestatementReasonEnums::instance );
  enumsByTag.emplace( FieldExecRestatementReason::TAG, & ExecRestatementReasonEnums::instance );

  FieldBusinessRejectReason::enumItems = BusinessRejectReasonEnums::items;
  enumsByRaw.emplace( FieldBusinessRejectReason::RAW_TAG, & BusinessRejectReasonEnums::instance );
  enumsByTag.emplace( FieldBusinessRejectReason::TAG, & BusinessRejectReasonEnums::instance );

  FieldMsgDirection::enumItems = MsgDirectionEnums::items;
  enumsByRaw.emplace( FieldMsgDirection::RAW_TAG, & MsgDirectionEnums::instance );
  enumsByTag.emplace( FieldMsgDirection::TAG, & MsgDirectionEnums::instance );

  FieldDiscretionInst::enumItems = DiscretionInstEnums::items;
  enumsByRaw.emplace( FieldDiscretionInst::RAW_TAG, & DiscretionInstEnums::instance );
  enumsByTag.emplace( FieldDiscretionInst::TAG, & DiscretionInstEnums::instance );

  FieldBidType::enumItems = BidTypeEnums::items;
  enumsByRaw.emplace( FieldBidType::RAW_TAG, & BidTypeEnums::instance );
  enumsByTag.emplace( FieldBidType::TAG, & BidTypeEnums::instance );

  FieldBidDescriptorType::enumItems = BidDescriptorTypeEnums::items;
  enumsByRaw.emplace( FieldBidDescriptorType::RAW_TAG, & BidDescriptorTypeEnums::instance );
  enumsByTag.emplace( FieldBidDescriptorType::TAG, & BidDescriptorTypeEnums::instance );

  FieldSideValueInd::enumItems = SideValueIndEnums::items;
  enumsByRaw.emplace( FieldSideValueInd::RAW_TAG, & SideValueIndEnums::instance );
  enumsByTag.emplace( FieldSideValueInd::TAG, & SideValueIndEnums::instance );

  FieldLiquidityIndType::enumItems = LiquidityIndTypeEnums::items;
  enumsByRaw.emplace( FieldLiquidityIndType::RAW_TAG, & LiquidityIndTypeEnums::instance );
  enumsByTag.emplace( FieldLiquidityIndType::TAG, & LiquidityIndTypeEnums::instance );

  FieldExchangeForPhysical::enumItems = ExchangeForPhysicalEnums::items;
  enumsByRaw.emplace( FieldExchangeForPhysical::RAW_TAG, & ExchangeForPhysicalEnums::instance );
  enumsByTag.emplace( FieldExchangeForPhysical::TAG, & ExchangeForPhysicalEnums::instance );

  FieldProgRptReqs::enumItems = ProgRptReqsEnums::items;
  enumsByRaw.emplace( FieldProgRptReqs::RAW_TAG, & ProgRptReqsEnums::instance );
  enumsByTag.emplace( FieldProgRptReqs::TAG, & ProgRptReqsEnums::instance );

  FieldIncTaxInd::enumItems = IncTaxIndEnums::items;
  enumsByRaw.emplace( FieldIncTaxInd::RAW_TAG, & IncTaxIndEnums::instance );
  enumsByTag.emplace( FieldIncTaxInd::TAG, & IncTaxIndEnums::instance );

  FieldBidTradeType::enumItems = BidTradeTypeEnums::items;
  enumsByRaw.emplace( FieldBidTradeType::RAW_TAG, & BidTradeTypeEnums::instance );
  enumsByTag.emplace( FieldBidTradeType::TAG, & BidTradeTypeEnums::instance );

  FieldBasisPxType::enumItems = BasisPxTypeEnums::items;
  enumsByRaw.emplace( FieldBasisPxType::RAW_TAG, & BasisPxTypeEnums::instance );
  enumsByTag.emplace( FieldBasisPxType::TAG, & BasisPxTypeEnums::instance );

  FieldPriceType::enumItems = PriceTypeEnums::items;
  enumsByRaw.emplace( FieldPriceType::RAW_TAG, & PriceTypeEnums::instance );
  enumsByTag.emplace( FieldPriceType::TAG, & PriceTypeEnums::instance );

  FieldGTBookingInst::enumItems = GTBookingInstEnums::items;
  enumsByRaw.emplace( FieldGTBookingInst::RAW_TAG, & GTBookingInstEnums::instance );
  enumsByTag.emplace( FieldGTBookingInst::TAG, & GTBookingInstEnums::instance );

  FieldListStatusType::enumItems = ListStatusTypeEnums::items;
  enumsByRaw.emplace( FieldListStatusType::RAW_TAG, & ListStatusTypeEnums::instance );
  enumsByTag.emplace( FieldListStatusType::TAG, & ListStatusTypeEnums::instance );

  FieldNetGrossInd::enumItems = NetGrossIndEnums::items;
  enumsByRaw.emplace( FieldNetGrossInd::RAW_TAG, & NetGrossIndEnums::instance );
  enumsByTag.emplace( FieldNetGrossInd::TAG, & NetGrossIndEnums::instance );

  FieldListOrderStatus::enumItems = ListOrderStatusEnums::items;
  enumsByRaw.emplace( FieldListOrderStatus::RAW_TAG, & ListOrderStatusEnums::instance );
  enumsByTag.emplace( FieldListOrderStatus::TAG, & ListOrderStatusEnums::instance );

  FieldListExecInstType::enumItems = ListExecInstTypeEnums::items;
  enumsByRaw.emplace( FieldListExecInstType::RAW_TAG, & ListExecInstTypeEnums::instance );
  enumsByTag.emplace( FieldListExecInstType::TAG, & ListExecInstTypeEnums::instance );

  FieldCxlRejResponseTo::enumItems = CxlRejResponseToEnums::items;
  enumsByRaw.emplace( FieldCxlRejResponseTo::RAW_TAG, & CxlRejResponseToEnums::instance );
  enumsByTag.emplace( FieldCxlRejResponseTo::TAG, & CxlRejResponseToEnums::instance );

  FieldMultiLegReportingType::enumItems = MultiLegReportingTypeEnums::items;
  enumsByRaw.emplace( FieldMultiLegReportingType::RAW_TAG, & MultiLegReportingTypeEnums::instance );
  enumsByTag.emplace( FieldMultiLegReportingType::TAG, & MultiLegReportingTypeEnums::instance );

  FieldPartyIDSource::enumItems = PartyIDSourceEnums::items;
  enumsByRaw.emplace( FieldPartyIDSource::RAW_TAG, & PartyIDSourceEnums::instance );
  enumsByTag.emplace( FieldPartyIDSource::TAG, & PartyIDSourceEnums::instance );

  FieldPartyRole::enumItems = PartyRoleEnums::items;
  enumsByRaw.emplace( FieldPartyRole::RAW_TAG, & PartyRoleEnums::instance );
  enumsByTag.emplace( FieldPartyRole::TAG, & PartyRoleEnums::instance );

  FieldProduct::enumItems = ProductEnums::items;
  enumsByRaw.emplace( FieldProduct::RAW_TAG, & ProductEnums::instance );
  enumsByTag.emplace( FieldProduct::TAG, & ProductEnums::instance );

  FieldTestMessageIndicator::enumItems = TestMessageIndicatorEnums::items;
  enumsByRaw.emplace( FieldTestMessageIndicator::RAW_TAG, & TestMessageIndicatorEnums::instance );
  enumsByTag.emplace( FieldTestMessageIndicator::TAG, & TestMessageIndicatorEnums::instance );

  FieldRoundingDirection::enumItems = RoundingDirectionEnums::items;
  enumsByRaw.emplace( FieldRoundingDirection::RAW_TAG, & RoundingDirectionEnums::instance );
  enumsByTag.emplace( FieldRoundingDirection::TAG, & RoundingDirectionEnums::instance );

  FieldDistribPaymentMethod::enumItems = DistribPaymentMethodEnums::items;
  enumsByRaw.emplace( FieldDistribPaymentMethod::RAW_TAG, & DistribPaymentMethodEnums::instance );
  enumsByTag.emplace( FieldDistribPaymentMethod::TAG, & DistribPaymentMethodEnums::instance );

  FieldCancellationRights::enumItems = CancellationRightsEnums::items;
  enumsByRaw.emplace( FieldCancellationRights::RAW_TAG, & CancellationRightsEnums::instance );
  enumsByTag.emplace( FieldCancellationRights::TAG, & CancellationRightsEnums::instance );

  FieldMoneyLaunderingStatus::enumItems = MoneyLaunderingStatusEnums::items;
  enumsByRaw.emplace( FieldMoneyLaunderingStatus::RAW_TAG, & MoneyLaunderingStatusEnums::instance );
  enumsByTag.emplace( FieldMoneyLaunderingStatus::TAG, & MoneyLaunderingStatusEnums::instance );

  FieldExecPriceType::enumItems = ExecPriceTypeEnums::items;
  enumsByRaw.emplace( FieldExecPriceType::RAW_TAG, & ExecPriceTypeEnums::instance );
  enumsByTag.emplace( FieldExecPriceType::TAG, & ExecPriceTypeEnums::instance );

  FieldPaymentMethod::enumItems = PaymentMethodEnums::items;
  enumsByRaw.emplace( FieldPaymentMethod::RAW_TAG, & PaymentMethodEnums::instance );
  enumsByTag.emplace( FieldPaymentMethod::TAG, & PaymentMethodEnums::instance );

  FieldTaxAdvantageType::enumItems = TaxAdvantageTypeEnums::items;
  enumsByRaw.emplace( FieldTaxAdvantageType::RAW_TAG, & TaxAdvantageTypeEnums::instance );
  enumsByTag.emplace( FieldTaxAdvantageType::TAG, & TaxAdvantageTypeEnums::instance );

  FieldFundRenewWaiv::enumItems = FundRenewWaivEnums::items;
  enumsByRaw.emplace( FieldFundRenewWaiv::RAW_TAG, & FundRenewWaivEnums::instance );
  enumsByTag.emplace( FieldFundRenewWaiv::TAG, & FundRenewWaivEnums::instance );

  FieldRegistStatus::enumItems = RegistStatusEnums::items;
  enumsByRaw.emplace( FieldRegistStatus::RAW_TAG, & RegistStatusEnums::instance );
  enumsByTag.emplace( FieldRegistStatus::TAG, & RegistStatusEnums::instance );

  FieldRegistRejReasonCode::enumItems = RegistRejReasonCodeEnums::items;
  enumsByRaw.emplace( FieldRegistRejReasonCode::RAW_TAG, & RegistRejReasonCodeEnums::instance );
  enumsByTag.emplace( FieldRegistRejReasonCode::TAG, & RegistRejReasonCodeEnums::instance );

  FieldRegistTransType::enumItems = RegistTransTypeEnums::items;
  enumsByRaw.emplace( FieldRegistTransType::RAW_TAG, & RegistTransTypeEnums::instance );
  enumsByTag.emplace( FieldRegistTransType::TAG, & RegistTransTypeEnums::instance );

  FieldOwnershipType::enumItems = OwnershipTypeEnums::items;
  enumsByRaw.emplace( FieldOwnershipType::RAW_TAG, & OwnershipTypeEnums::instance );
  enumsByTag.emplace( FieldOwnershipType::TAG, & OwnershipTypeEnums::instance );

  FieldContAmtType::enumItems = ContAmtTypeEnums::items;
  enumsByRaw.emplace( FieldContAmtType::RAW_TAG, & ContAmtTypeEnums::instance );
  enumsByTag.emplace( FieldContAmtType::TAG, & ContAmtTypeEnums::instance );

  FieldOwnerType::enumItems = OwnerTypeEnums::items;
  enumsByRaw.emplace( FieldOwnerType::RAW_TAG, & OwnerTypeEnums::instance );
  enumsByTag.emplace( FieldOwnerType::TAG, & OwnerTypeEnums::instance );

  FieldOrderCapacity::enumItems = OrderCapacityEnums::items;
  enumsByRaw.emplace( FieldOrderCapacity::RAW_TAG, & OrderCapacityEnums::instance );
  enumsByTag.emplace( FieldOrderCapacity::TAG, & OrderCapacityEnums::instance );

  FieldOrderRestrictions::enumItems = OrderRestrictionsEnums::items;
  enumsByRaw.emplace( FieldOrderRestrictions::RAW_TAG, & OrderRestrictionsEnums::instance );
  enumsByTag.emplace( FieldOrderRestrictions::TAG, & OrderRestrictionsEnums::instance );

  FieldMassCancelRequestType::enumItems = MassCancelRequestTypeEnums::items;
  enumsByRaw.emplace( FieldMassCancelRequestType::RAW_TAG, & MassCancelRequestTypeEnums::instance );
  enumsByTag.emplace( FieldMassCancelRequestType::TAG, & MassCancelRequestTypeEnums::instance );

  FieldMassCancelResponse::enumItems = MassCancelResponseEnums::items;
  enumsByRaw.emplace( FieldMassCancelResponse::RAW_TAG, & MassCancelResponseEnums::instance );
  enumsByTag.emplace( FieldMassCancelResponse::TAG, & MassCancelResponseEnums::instance );

  FieldMassCancelRejectReason::enumItems = MassCancelRejectReasonEnums::items;
  enumsByRaw.emplace( FieldMassCancelRejectReason::RAW_TAG, & MassCancelRejectReasonEnums::instance );
  enumsByTag.emplace( FieldMassCancelRejectReason::TAG, & MassCancelRejectReasonEnums::instance );

  FieldQuoteType::enumItems = QuoteTypeEnums::items;
  enumsByRaw.emplace( FieldQuoteType::RAW_TAG, & QuoteTypeEnums::instance );
  enumsByTag.emplace( FieldQuoteType::TAG, & QuoteTypeEnums::instance );

  FieldCashMargin::enumItems = CashMarginEnums::items;
  enumsByRaw.emplace( FieldCashMargin::RAW_TAG, & CashMarginEnums::instance );
  enumsByTag.emplace( FieldCashMargin::TAG, & CashMarginEnums::instance );

  FieldScope::enumItems = ScopeEnums::items;
  enumsByRaw.emplace( FieldScope::RAW_TAG, & ScopeEnums::instance );
  enumsByTag.emplace( FieldScope::TAG, & ScopeEnums::instance );

  FieldMDImplicitDelete::enumItems = MDImplicitDeleteEnums::items;
  enumsByRaw.emplace( FieldMDImplicitDelete::RAW_TAG, & MDImplicitDeleteEnums::instance );
  enumsByTag.emplace( FieldMDImplicitDelete::TAG, & MDImplicitDeleteEnums::instance );

  FieldCrossType::enumItems = CrossTypeEnums::items;
  enumsByRaw.emplace( FieldCrossType::RAW_TAG, & CrossTypeEnums::instance );
  enumsByTag.emplace( FieldCrossType::TAG, & CrossTypeEnums::instance );

  FieldCrossPrioritization::enumItems = CrossPrioritizationEnums::items;
  enumsByRaw.emplace( FieldCrossPrioritization::RAW_TAG, & CrossPrioritizationEnums::instance );
  enumsByTag.emplace( FieldCrossPrioritization::TAG, & CrossPrioritizationEnums::instance );

  FieldNoSides::enumItems = NoSidesEnums::items;
  enumsByRaw.emplace( FieldNoSides::RAW_TAG, & NoSidesEnums::instance );
  enumsByTag.emplace( FieldNoSides::TAG, & NoSidesEnums::instance );

  FieldSecurityListRequestType::enumItems = SecurityListRequestTypeEnums::items;
  enumsByRaw.emplace( FieldSecurityListRequestType::RAW_TAG, & SecurityListRequestTypeEnums::instance );
  enumsByTag.emplace( FieldSecurityListRequestType::TAG, & SecurityListRequestTypeEnums::instance );

  FieldSecurityRequestResult::enumItems = SecurityRequestResultEnums::items;
  enumsByRaw.emplace( FieldSecurityRequestResult::RAW_TAG, & SecurityRequestResultEnums::instance );
  enumsByTag.emplace( FieldSecurityRequestResult::TAG, & SecurityRequestResultEnums::instance );

  FieldMultiLegRptTypeReq::enumItems = MultiLegRptTypeReqEnums::items;
  enumsByRaw.emplace( FieldMultiLegRptTypeReq::RAW_TAG, & MultiLegRptTypeReqEnums::instance );
  enumsByTag.emplace( FieldMultiLegRptTypeReq::TAG, & MultiLegRptTypeReqEnums::instance );

  FieldTradSesStatusRejReason::enumItems = TradSesStatusRejReasonEnums::items;
  enumsByRaw.emplace( FieldTradSesStatusRejReason::RAW_TAG, & TradSesStatusRejReasonEnums::instance );
  enumsByTag.emplace( FieldTradSesStatusRejReason::TAG, & TradSesStatusRejReasonEnums::instance );

  FieldTradeRequestType::enumItems = TradeRequestTypeEnums::items;
  enumsByRaw.emplace( FieldTradeRequestType::RAW_TAG, & TradeRequestTypeEnums::instance );
  enumsByTag.emplace( FieldTradeRequestType::TAG, & TradeRequestTypeEnums::instance );

  FieldPreviouslyReported::enumItems = PreviouslyReportedEnums::items;
  enumsByRaw.emplace( FieldPreviouslyReported::RAW_TAG, & PreviouslyReportedEnums::instance );
  enumsByTag.emplace( FieldPreviouslyReported::TAG, & PreviouslyReportedEnums::instance );

  FieldMatchStatus::enumItems = MatchStatusEnums::items;
  enumsByRaw.emplace( FieldMatchStatus::RAW_TAG, & MatchStatusEnums::instance );
  enumsByTag.emplace( FieldMatchStatus::TAG, & MatchStatusEnums::instance );

  FieldMatchType::enumItems = MatchTypeEnums::items;
  enumsByRaw.emplace( FieldMatchType::RAW_TAG, & MatchTypeEnums::instance );
  enumsByTag.emplace( FieldMatchType::TAG, & MatchTypeEnums::instance );

  FieldOddLot::enumItems = OddLotEnums::items;
  enumsByRaw.emplace( FieldOddLot::RAW_TAG, & OddLotEnums::instance );
  enumsByTag.emplace( FieldOddLot::TAG, & OddLotEnums::instance );

  FieldClearingInstruction::enumItems = ClearingInstructionEnums::items;
  enumsByRaw.emplace( FieldClearingInstruction::RAW_TAG, & ClearingInstructionEnums::instance );
  enumsByTag.emplace( FieldClearingInstruction::TAG, & ClearingInstructionEnums::instance );

  FieldAccountType::enumItems = AccountTypeEnums::items;
  enumsByRaw.emplace( FieldAccountType::RAW_TAG, & AccountTypeEnums::instance );
  enumsByTag.emplace( FieldAccountType::TAG, & AccountTypeEnums::instance );

  FieldCustOrderCapacity::enumItems = CustOrderCapacityEnums::items;
  enumsByRaw.emplace( FieldCustOrderCapacity::RAW_TAG, & CustOrderCapacityEnums::instance );
  enumsByTag.emplace( FieldCustOrderCapacity::TAG, & CustOrderCapacityEnums::instance );

  FieldMassStatusReqType::enumItems = MassStatusReqTypeEnums::items;
  enumsByRaw.emplace( FieldMassStatusReqType::RAW_TAG, & MassStatusReqTypeEnums::instance );
  enumsByTag.emplace( FieldMassStatusReqType::TAG, & MassStatusReqTypeEnums::instance );

  FieldDayBookingInst::enumItems = DayBookingInstEnums::items;
  enumsByRaw.emplace( FieldDayBookingInst::RAW_TAG, & DayBookingInstEnums::instance );
  enumsByTag.emplace( FieldDayBookingInst::TAG, & DayBookingInstEnums::instance );

  FieldBookingUnit::enumItems = BookingUnitEnums::items;
  enumsByRaw.emplace( FieldBookingUnit::RAW_TAG, & BookingUnitEnums::instance );
  enumsByTag.emplace( FieldBookingUnit::TAG, & BookingUnitEnums::instance );

  FieldPreallocMethod::enumItems = PreallocMethodEnums::items;
  enumsByRaw.emplace( FieldPreallocMethod::RAW_TAG, & PreallocMethodEnums::instance );
  enumsByTag.emplace( FieldPreallocMethod::TAG, & PreallocMethodEnums::instance );

  FieldAllocType::enumItems = AllocTypeEnums::items;
  enumsByRaw.emplace( FieldAllocType::RAW_TAG, & AllocTypeEnums::instance );
  enumsByTag.emplace( FieldAllocType::TAG, & AllocTypeEnums::instance );

  FieldClearingFeeIndicator::enumItems = ClearingFeeIndicatorEnums::items;
  enumsByRaw.emplace( FieldClearingFeeIndicator::RAW_TAG, & ClearingFeeIndicatorEnums::instance );
  enumsByTag.emplace( FieldClearingFeeIndicator::TAG, & ClearingFeeIndicatorEnums::instance );

  FieldWorkingIndicator::enumItems = WorkingIndicatorEnums::items;
  enumsByRaw.emplace( FieldWorkingIndicator::RAW_TAG, & WorkingIndicatorEnums::instance );
  enumsByTag.emplace( FieldWorkingIndicator::TAG, & WorkingIndicatorEnums::instance );

  FieldPriorityIndicator::enumItems = PriorityIndicatorEnums::items;
  enumsByRaw.emplace( FieldPriorityIndicator::RAW_TAG, & PriorityIndicatorEnums::instance );
  enumsByTag.emplace( FieldPriorityIndicator::TAG, & PriorityIndicatorEnums::instance );

  FieldLegalConfirm::enumItems = LegalConfirmEnums::items;
  enumsByRaw.emplace( FieldLegalConfirm::RAW_TAG, & LegalConfirmEnums::instance );
  enumsByTag.emplace( FieldLegalConfirm::TAG, & LegalConfirmEnums::instance );

  FieldQuoteRequestRejectReason::enumItems = QuoteRequestRejectReasonEnums::items;
  enumsByRaw.emplace( FieldQuoteRequestRejectReason::RAW_TAG, & QuoteRequestRejectReasonEnums::instance );
  enumsByTag.emplace( FieldQuoteRequestRejectReason::TAG, & QuoteRequestRejectReasonEnums::instance );

  FieldAcctIDSource::enumItems = AcctIDSourceEnums::items;
  enumsByRaw.emplace( FieldAcctIDSource::RAW_TAG, & AcctIDSourceEnums::instance );
  enumsByTag.emplace( FieldAcctIDSource::TAG, & AcctIDSourceEnums::instance );

  FieldConfirmStatus::enumItems = ConfirmStatusEnums::items;
  enumsByRaw.emplace( FieldConfirmStatus::RAW_TAG, & ConfirmStatusEnums::instance );
  enumsByTag.emplace( FieldConfirmStatus::TAG, & ConfirmStatusEnums::instance );

  FieldConfirmTransType::enumItems = ConfirmTransTypeEnums::items;
  enumsByRaw.emplace( FieldConfirmTransType::RAW_TAG, & ConfirmTransTypeEnums::instance );
  enumsByTag.emplace( FieldConfirmTransType::TAG, & ConfirmTransTypeEnums::instance );

  FieldDeliveryForm::enumItems = DeliveryFormEnums::items;
  enumsByRaw.emplace( FieldDeliveryForm::RAW_TAG, & DeliveryFormEnums::instance );
  enumsByTag.emplace( FieldDeliveryForm::TAG, & DeliveryFormEnums::instance );

  FieldLegSwapType::enumItems = LegSwapTypeEnums::items;
  enumsByRaw.emplace( FieldLegSwapType::RAW_TAG, & LegSwapTypeEnums::instance );
  enumsByTag.emplace( FieldLegSwapType::TAG, & LegSwapTypeEnums::instance );

  FieldQuotePriceType::enumItems = QuotePriceTypeEnums::items;
  enumsByRaw.emplace( FieldQuotePriceType::RAW_TAG, & QuotePriceTypeEnums::instance );
  enumsByTag.emplace( FieldQuotePriceType::TAG, & QuotePriceTypeEnums::instance );

  FieldQuoteRespType::enumItems = QuoteRespTypeEnums::items;
  enumsByRaw.emplace( FieldQuoteRespType::RAW_TAG, & QuoteRespTypeEnums::instance );
  enumsByTag.emplace( FieldQuoteRespType::TAG, & QuoteRespTypeEnums::instance );

  FieldPosType::enumItems = PosTypeEnums::items;
  enumsByRaw.emplace( FieldPosType::RAW_TAG, & PosTypeEnums::instance );
  enumsByTag.emplace( FieldPosType::TAG, & PosTypeEnums::instance );

  FieldPosQtyStatus::enumItems = PosQtyStatusEnums::items;
  enumsByRaw.emplace( FieldPosQtyStatus::RAW_TAG, & PosQtyStatusEnums::instance );
  enumsByTag.emplace( FieldPosQtyStatus::TAG, & PosQtyStatusEnums::instance );

  FieldPosAmtType::enumItems = PosAmtTypeEnums::items;
  enumsByRaw.emplace( FieldPosAmtType::RAW_TAG, & PosAmtTypeEnums::instance );
  enumsByTag.emplace( FieldPosAmtType::TAG, & PosAmtTypeEnums::instance );

  FieldPosTransType::enumItems = PosTransTypeEnums::items;
  enumsByRaw.emplace( FieldPosTransType::RAW_TAG, & PosTransTypeEnums::instance );
  enumsByTag.emplace( FieldPosTransType::TAG, & PosTransTypeEnums::instance );

  FieldPosMaintAction::enumItems = PosMaintActionEnums::items;
  enumsByRaw.emplace( FieldPosMaintAction::RAW_TAG, & PosMaintActionEnums::instance );
  enumsByTag.emplace( FieldPosMaintAction::TAG, & PosMaintActionEnums::instance );

  FieldSettlSessID::enumItems = SettlSessIDEnums::items;
  enumsByRaw.emplace( FieldSettlSessID::RAW_TAG, & SettlSessIDEnums::instance );
  enumsByTag.emplace( FieldSettlSessID::TAG, & SettlSessIDEnums::instance );

  FieldAdjustmentType::enumItems = AdjustmentTypeEnums::items;
  enumsByRaw.emplace( FieldAdjustmentType::RAW_TAG, & AdjustmentTypeEnums::instance );
  enumsByTag.emplace( FieldAdjustmentType::TAG, & AdjustmentTypeEnums::instance );

  FieldPosMaintStatus::enumItems = PosMaintStatusEnums::items;
  enumsByRaw.emplace( FieldPosMaintStatus::RAW_TAG, & PosMaintStatusEnums::instance );
  enumsByTag.emplace( FieldPosMaintStatus::TAG, & PosMaintStatusEnums::instance );

  FieldPosMaintResult::enumItems = PosMaintResultEnums::items;
  enumsByRaw.emplace( FieldPosMaintResult::RAW_TAG, & PosMaintResultEnums::instance );
  enumsByTag.emplace( FieldPosMaintResult::TAG, & PosMaintResultEnums::instance );

  FieldPosReqType::enumItems = PosReqTypeEnums::items;
  enumsByRaw.emplace( FieldPosReqType::RAW_TAG, & PosReqTypeEnums::instance );
  enumsByTag.emplace( FieldPosReqType::TAG, & PosReqTypeEnums::instance );

  FieldResponseTransportType::enumItems = ResponseTransportTypeEnums::items;
  enumsByRaw.emplace( FieldResponseTransportType::RAW_TAG, & ResponseTransportTypeEnums::instance );
  enumsByTag.emplace( FieldResponseTransportType::TAG, & ResponseTransportTypeEnums::instance );

  FieldPosReqResult::enumItems = PosReqResultEnums::items;
  enumsByRaw.emplace( FieldPosReqResult::RAW_TAG, & PosReqResultEnums::instance );
  enumsByTag.emplace( FieldPosReqResult::TAG, & PosReqResultEnums::instance );

  FieldPosReqStatus::enumItems = PosReqStatusEnums::items;
  enumsByRaw.emplace( FieldPosReqStatus::RAW_TAG, & PosReqStatusEnums::instance );
  enumsByTag.emplace( FieldPosReqStatus::TAG, & PosReqStatusEnums::instance );

  FieldSettlPriceType::enumItems = SettlPriceTypeEnums::items;
  enumsByRaw.emplace( FieldSettlPriceType::RAW_TAG, & SettlPriceTypeEnums::instance );
  enumsByTag.emplace( FieldSettlPriceType::TAG, & SettlPriceTypeEnums::instance );

  FieldAssignmentMethod::enumItems = AssignmentMethodEnums::items;
  enumsByRaw.emplace( FieldAssignmentMethod::RAW_TAG, & AssignmentMethodEnums::instance );
  enumsByTag.emplace( FieldAssignmentMethod::TAG, & AssignmentMethodEnums::instance );

  FieldExerciseMethod::enumItems = ExerciseMethodEnums::items;
  enumsByRaw.emplace( FieldExerciseMethod::RAW_TAG, & ExerciseMethodEnums::instance );
  enumsByTag.emplace( FieldExerciseMethod::TAG, & ExerciseMethodEnums::instance );

  FieldTradeRequestResult::enumItems = TradeRequestResultEnums::items;
  enumsByRaw.emplace( FieldTradeRequestResult::RAW_TAG, & TradeRequestResultEnums::instance );
  enumsByTag.emplace( FieldTradeRequestResult::TAG, & TradeRequestResultEnums::instance );

  FieldTradeRequestStatus::enumItems = TradeRequestStatusEnums::items;
  enumsByRaw.emplace( FieldTradeRequestStatus::RAW_TAG, & TradeRequestStatusEnums::instance );
  enumsByTag.emplace( FieldTradeRequestStatus::TAG, & TradeRequestStatusEnums::instance );

  FieldTradeReportRejectReason::enumItems = TradeReportRejectReasonEnums::items;
  enumsByRaw.emplace( FieldTradeReportRejectReason::RAW_TAG, & TradeReportRejectReasonEnums::instance );
  enumsByTag.emplace( FieldTradeReportRejectReason::TAG, & TradeReportRejectReasonEnums::instance );

  FieldSideMultiLegReportingType::enumItems = SideMultiLegReportingTypeEnums::items;
  enumsByRaw.emplace( FieldSideMultiLegReportingType::RAW_TAG, & SideMultiLegReportingTypeEnums::instance );
  enumsByTag.emplace( FieldSideMultiLegReportingType::TAG, & SideMultiLegReportingTypeEnums::instance );

  FieldTrdRegTimestampType::enumItems = TrdRegTimestampTypeEnums::items;
  enumsByRaw.emplace( FieldTrdRegTimestampType::RAW_TAG, & TrdRegTimestampTypeEnums::instance );
  enumsByTag.emplace( FieldTrdRegTimestampType::TAG, & TrdRegTimestampTypeEnums::instance );

  FieldConfirmType::enumItems = ConfirmTypeEnums::items;
  enumsByRaw.emplace( FieldConfirmType::RAW_TAG, & ConfirmTypeEnums::instance );
  enumsByTag.emplace( FieldConfirmType::TAG, & ConfirmTypeEnums::instance );

  FieldConfirmRejReason::enumItems = ConfirmRejReasonEnums::items;
  enumsByRaw.emplace( FieldConfirmRejReason::RAW_TAG, & ConfirmRejReasonEnums::instance );
  enumsByTag.emplace( FieldConfirmRejReason::TAG, & ConfirmRejReasonEnums::instance );

  FieldBookingType::enumItems = BookingTypeEnums::items;
  enumsByRaw.emplace( FieldBookingType::RAW_TAG, & BookingTypeEnums::instance );
  enumsByTag.emplace( FieldBookingType::TAG, & BookingTypeEnums::instance );

  FieldAllocSettlInstType::enumItems = AllocSettlInstTypeEnums::items;
  enumsByRaw.emplace( FieldAllocSettlInstType::RAW_TAG, & AllocSettlInstTypeEnums::instance );
  enumsByTag.emplace( FieldAllocSettlInstType::TAG, & AllocSettlInstTypeEnums::instance );

  FieldDlvyInstType::enumItems = DlvyInstTypeEnums::items;
  enumsByRaw.emplace( FieldDlvyInstType::RAW_TAG, & DlvyInstTypeEnums::instance );
  enumsByTag.emplace( FieldDlvyInstType::TAG, & DlvyInstTypeEnums::instance );

  FieldTerminationType::enumItems = TerminationTypeEnums::items;
  enumsByRaw.emplace( FieldTerminationType::RAW_TAG, & TerminationTypeEnums::instance );
  enumsByTag.emplace( FieldTerminationType::TAG, & TerminationTypeEnums::instance );

  FieldSettlInstReqRejCode::enumItems = SettlInstReqRejCodeEnums::items;
  enumsByRaw.emplace( FieldSettlInstReqRejCode::RAW_TAG, & SettlInstReqRejCodeEnums::instance );
  enumsByTag.emplace( FieldSettlInstReqRejCode::TAG, & SettlInstReqRejCodeEnums::instance );

  FieldAllocReportType::enumItems = AllocReportTypeEnums::items;
  enumsByRaw.emplace( FieldAllocReportType::RAW_TAG, & AllocReportTypeEnums::instance );
  enumsByTag.emplace( FieldAllocReportType::TAG, & AllocReportTypeEnums::instance );

  FieldAllocCancReplaceReason::enumItems = AllocCancReplaceReasonEnums::items;
  enumsByRaw.emplace( FieldAllocCancReplaceReason::RAW_TAG, & AllocCancReplaceReasonEnums::instance );
  enumsByTag.emplace( FieldAllocCancReplaceReason::TAG, & AllocCancReplaceReasonEnums::instance );

  FieldAllocAccountType::enumItems = AllocAccountTypeEnums::items;
  enumsByRaw.emplace( FieldAllocAccountType::RAW_TAG, & AllocAccountTypeEnums::instance );
  enumsByTag.emplace( FieldAllocAccountType::TAG, & AllocAccountTypeEnums::instance );

  FieldPartySubIDType::enumItems = PartySubIDTypeEnums::items;
  enumsByRaw.emplace( FieldPartySubIDType::RAW_TAG, & PartySubIDTypeEnums::instance );
  enumsByTag.emplace( FieldPartySubIDType::TAG, & PartySubIDTypeEnums::instance );

  FieldAllocIntermedReqType::enumItems = AllocIntermedReqTypeEnums::items;
  enumsByRaw.emplace( FieldAllocIntermedReqType::RAW_TAG, & AllocIntermedReqTypeEnums::instance );
  enumsByTag.emplace( FieldAllocIntermedReqType::TAG, & AllocIntermedReqTypeEnums::instance );

  FieldApplQueueResolution::enumItems = ApplQueueResolutionEnums::items;
  enumsByRaw.emplace( FieldApplQueueResolution::RAW_TAG, & ApplQueueResolutionEnums::instance );
  enumsByTag.emplace( FieldApplQueueResolution::TAG, & ApplQueueResolutionEnums::instance );

  FieldApplQueueAction::enumItems = ApplQueueActionEnums::items;
  enumsByRaw.emplace( FieldApplQueueAction::RAW_TAG, & ApplQueueActionEnums::instance );
  enumsByTag.emplace( FieldApplQueueAction::TAG, & ApplQueueActionEnums::instance );

  FieldAvgPxIndicator::enumItems = AvgPxIndicatorEnums::items;
  enumsByRaw.emplace( FieldAvgPxIndicator::RAW_TAG, & AvgPxIndicatorEnums::instance );
  enumsByTag.emplace( FieldAvgPxIndicator::TAG, & AvgPxIndicatorEnums::instance );

  FieldTradeAllocIndicator::enumItems = TradeAllocIndicatorEnums::items;
  enumsByRaw.emplace( FieldTradeAllocIndicator::RAW_TAG, & TradeAllocIndicatorEnums::instance );
  enumsByTag.emplace( FieldTradeAllocIndicator::TAG, & TradeAllocIndicatorEnums::instance );

  FieldExpirationCycle::enumItems = ExpirationCycleEnums::items;
  enumsByRaw.emplace( FieldExpirationCycle::RAW_TAG, & ExpirationCycleEnums::instance );
  enumsByTag.emplace( FieldExpirationCycle::TAG, & ExpirationCycleEnums::instance );

  FieldTrdType::enumItems = TrdTypeEnums::items;
  enumsByRaw.emplace( FieldTrdType::RAW_TAG, & TrdTypeEnums::instance );
  enumsByTag.emplace( FieldTrdType::TAG, & TrdTypeEnums::instance );

  FieldPegMoveType::enumItems = PegMoveTypeEnums::items;
  enumsByRaw.emplace( FieldPegMoveType::RAW_TAG, & PegMoveTypeEnums::instance );
  enumsByTag.emplace( FieldPegMoveType::TAG, & PegMoveTypeEnums::instance );

  FieldPegOffsetType::enumItems = PegOffsetTypeEnums::items;
  enumsByRaw.emplace( FieldPegOffsetType::RAW_TAG, & PegOffsetTypeEnums::instance );
  enumsByTag.emplace( FieldPegOffsetType::TAG, & PegOffsetTypeEnums::instance );

  FieldPegLimitType::enumItems = PegLimitTypeEnums::items;
  enumsByRaw.emplace( FieldPegLimitType::RAW_TAG, & PegLimitTypeEnums::instance );
  enumsByTag.emplace( FieldPegLimitType::TAG, & PegLimitTypeEnums::instance );

  FieldPegRoundDirection::enumItems = PegRoundDirectionEnums::items;
  enumsByRaw.emplace( FieldPegRoundDirection::RAW_TAG, & PegRoundDirectionEnums::instance );
  enumsByTag.emplace( FieldPegRoundDirection::TAG, & PegRoundDirectionEnums::instance );

  FieldPegScope::enumItems = PegScopeEnums::items;
  enumsByRaw.emplace( FieldPegScope::RAW_TAG, & PegScopeEnums::instance );
  enumsByTag.emplace( FieldPegScope::TAG, & PegScopeEnums::instance );

  FieldDiscretionMoveType::enumItems = DiscretionMoveTypeEnums::items;
  enumsByRaw.emplace( FieldDiscretionMoveType::RAW_TAG, & DiscretionMoveTypeEnums::instance );
  enumsByTag.emplace( FieldDiscretionMoveType::TAG, & DiscretionMoveTypeEnums::instance );

  FieldDiscretionOffsetType::enumItems = DiscretionOffsetTypeEnums::items;
  enumsByRaw.emplace( FieldDiscretionOffsetType::RAW_TAG, & DiscretionOffsetTypeEnums::instance );
  enumsByTag.emplace( FieldDiscretionOffsetType::TAG, & DiscretionOffsetTypeEnums::instance );

  FieldDiscretionLimitType::enumItems = DiscretionLimitTypeEnums::items;
  enumsByRaw.emplace( FieldDiscretionLimitType::RAW_TAG, & DiscretionLimitTypeEnums::instance );
  enumsByTag.emplace( FieldDiscretionLimitType::TAG, & DiscretionLimitTypeEnums::instance );

  FieldDiscretionRoundDirection::enumItems = DiscretionRoundDirectionEnums::items;
  enumsByRaw.emplace( FieldDiscretionRoundDirection::RAW_TAG, & DiscretionRoundDirectionEnums::instance );
  enumsByTag.emplace( FieldDiscretionRoundDirection::TAG, & DiscretionRoundDirectionEnums::instance );

  FieldDiscretionScope::enumItems = DiscretionScopeEnums::items;
  enumsByRaw.emplace( FieldDiscretionScope::RAW_TAG, & DiscretionScopeEnums::instance );
  enumsByTag.emplace( FieldDiscretionScope::TAG, & DiscretionScopeEnums::instance );

  FieldTargetStrategy::enumItems = TargetStrategyEnums::items;
  enumsByRaw.emplace( FieldTargetStrategy::RAW_TAG, & TargetStrategyEnums::instance );
  enumsByTag.emplace( FieldTargetStrategy::TAG, & TargetStrategyEnums::instance );

  FieldLastLiquidityInd::enumItems = LastLiquidityIndEnums::items;
  enumsByRaw.emplace( FieldLastLiquidityInd::RAW_TAG, & LastLiquidityIndEnums::instance );
  enumsByTag.emplace( FieldLastLiquidityInd::TAG, & LastLiquidityIndEnums::instance );

  FieldPublishTrdIndicator::enumItems = PublishTrdIndicatorEnums::items;
  enumsByRaw.emplace( FieldPublishTrdIndicator::RAW_TAG, & PublishTrdIndicatorEnums::instance );
  enumsByTag.emplace( FieldPublishTrdIndicator::TAG, & PublishTrdIndicatorEnums::instance );

  FieldShortSaleReason::enumItems = ShortSaleReasonEnums::items;
  enumsByRaw.emplace( FieldShortSaleReason::RAW_TAG, & ShortSaleReasonEnums::instance );
  enumsByTag.emplace( FieldShortSaleReason::TAG, & ShortSaleReasonEnums::instance );

  FieldQtyType::enumItems = QtyTypeEnums::items;
  enumsByRaw.emplace( FieldQtyType::RAW_TAG, & QtyTypeEnums::instance );
  enumsByTag.emplace( FieldQtyType::TAG, & QtyTypeEnums::instance );

  FieldTradeReportType::enumItems = TradeReportTypeEnums::items;
  enumsByRaw.emplace( FieldTradeReportType::RAW_TAG, & TradeReportTypeEnums::instance );
  enumsByTag.emplace( FieldTradeReportType::TAG, & TradeReportTypeEnums::instance );

  FieldAllocNoOrdersType::enumItems = AllocNoOrdersTypeEnums::items;
  enumsByRaw.emplace( FieldAllocNoOrdersType::RAW_TAG, & AllocNoOrdersTypeEnums::instance );
  enumsByTag.emplace( FieldAllocNoOrdersType::TAG, & AllocNoOrdersTypeEnums::instance );

  FieldEventType::enumItems = EventTypeEnums::items;
  enumsByRaw.emplace( FieldEventType::RAW_TAG, & EventTypeEnums::instance );
  enumsByTag.emplace( FieldEventType::TAG, & EventTypeEnums::instance );

  FieldInstrAttribType::enumItems = InstrAttribTypeEnums::items;
  enumsByRaw.emplace( FieldInstrAttribType::RAW_TAG, & InstrAttribTypeEnums::instance );
  enumsByTag.emplace( FieldInstrAttribType::TAG, & InstrAttribTypeEnums::instance );

  FieldCPProgram::enumItems = CPProgramEnums::items;
  enumsByRaw.emplace( FieldCPProgram::RAW_TAG, & CPProgramEnums::instance );
  enumsByTag.emplace( FieldCPProgram::TAG, & CPProgramEnums::instance );

  FieldMiscFeeBasis::enumItems = MiscFeeBasisEnums::items;
  enumsByRaw.emplace( FieldMiscFeeBasis::RAW_TAG, & MiscFeeBasisEnums::instance );
  enumsByTag.emplace( FieldMiscFeeBasis::TAG, & MiscFeeBasisEnums::instance );

  FieldLastFragment::enumItems = LastFragmentEnums::items;
  enumsByRaw.emplace( FieldLastFragment::RAW_TAG, & LastFragmentEnums::instance );
  enumsByTag.emplace( FieldLastFragment::TAG, & LastFragmentEnums::instance );

  FieldCollAsgnReason::enumItems = CollAsgnReasonEnums::items;
  enumsByRaw.emplace( FieldCollAsgnReason::RAW_TAG, & CollAsgnReasonEnums::instance );
  enumsByTag.emplace( FieldCollAsgnReason::TAG, & CollAsgnReasonEnums::instance );

  FieldCollInquiryQualifier::enumItems = CollInquiryQualifierEnums::items;
  enumsByRaw.emplace( FieldCollInquiryQualifier::RAW_TAG, & CollInquiryQualifierEnums::instance );
  enumsByTag.emplace( FieldCollInquiryQualifier::TAG, & CollInquiryQualifierEnums::instance );

  FieldCollAsgnTransType::enumItems = CollAsgnTransTypeEnums::items;
  enumsByRaw.emplace( FieldCollAsgnTransType::RAW_TAG, & CollAsgnTransTypeEnums::instance );
  enumsByTag.emplace( FieldCollAsgnTransType::TAG, & CollAsgnTransTypeEnums::instance );

  FieldCollAsgnRespType::enumItems = CollAsgnRespTypeEnums::items;
  enumsByRaw.emplace( FieldCollAsgnRespType::RAW_TAG, & CollAsgnRespTypeEnums::instance );
  enumsByTag.emplace( FieldCollAsgnRespType::TAG, & CollAsgnRespTypeEnums::instance );

  FieldCollAsgnRejectReason::enumItems = CollAsgnRejectReasonEnums::items;
  enumsByRaw.emplace( FieldCollAsgnRejectReason::RAW_TAG, & CollAsgnRejectReasonEnums::instance );
  enumsByTag.emplace( FieldCollAsgnRejectReason::TAG, & CollAsgnRejectReasonEnums::instance );

  FieldCollStatus::enumItems = CollStatusEnums::items;
  enumsByRaw.emplace( FieldCollStatus::RAW_TAG, & CollStatusEnums::instance );
  enumsByTag.emplace( FieldCollStatus::TAG, & CollStatusEnums::instance );

  FieldDeliveryType::enumItems = DeliveryTypeEnums::items;
  enumsByRaw.emplace( FieldDeliveryType::RAW_TAG, & DeliveryTypeEnums::instance );
  enumsByTag.emplace( FieldDeliveryType::TAG, & DeliveryTypeEnums::instance );

  FieldUserRequestType::enumItems = UserRequestTypeEnums::items;
  enumsByRaw.emplace( FieldUserRequestType::RAW_TAG, & UserRequestTypeEnums::instance );
  enumsByTag.emplace( FieldUserRequestType::TAG, & UserRequestTypeEnums::instance );

  FieldUserStatus::enumItems = UserStatusEnums::items;
  enumsByRaw.emplace( FieldUserStatus::RAW_TAG, & UserStatusEnums::instance );
  enumsByTag.emplace( FieldUserStatus::TAG, & UserStatusEnums::instance );

  FieldStatusValue::enumItems = StatusValueEnums::items;
  enumsByRaw.emplace( FieldStatusValue::RAW_TAG, & StatusValueEnums::instance );
  enumsByTag.emplace( FieldStatusValue::TAG, & StatusValueEnums::instance );

  FieldNetworkRequestType::enumItems = NetworkRequestTypeEnums::items;
  enumsByRaw.emplace( FieldNetworkRequestType::RAW_TAG, & NetworkRequestTypeEnums::instance );
  enumsByTag.emplace( FieldNetworkRequestType::TAG, & NetworkRequestTypeEnums::instance );

  FieldNetworkStatusResponseType::enumItems = NetworkStatusResponseTypeEnums::items;
  enumsByRaw.emplace( FieldNetworkStatusResponseType::RAW_TAG, & NetworkStatusResponseTypeEnums::instance );
  enumsByTag.emplace( FieldNetworkStatusResponseType::TAG, & NetworkStatusResponseTypeEnums::instance );

  FieldTrdRptStatus::enumItems = TrdRptStatusEnums::items;
  enumsByRaw.emplace( FieldTrdRptStatus::RAW_TAG, & TrdRptStatusEnums::instance );
  enumsByTag.emplace( FieldTrdRptStatus::TAG, & TrdRptStatusEnums::instance );

  FieldAffirmStatus::enumItems = AffirmStatusEnums::items;
  enumsByRaw.emplace( FieldAffirmStatus::RAW_TAG, & AffirmStatusEnums::instance );
  enumsByTag.emplace( FieldAffirmStatus::TAG, & AffirmStatusEnums::instance );

  FieldCollAction::enumItems = CollActionEnums::items;
  enumsByRaw.emplace( FieldCollAction::RAW_TAG, & CollActionEnums::instance );
  enumsByTag.emplace( FieldCollAction::TAG, & CollActionEnums::instance );

  FieldCollInquiryStatus::enumItems = CollInquiryStatusEnums::items;
  enumsByRaw.emplace( FieldCollInquiryStatus::RAW_TAG, & CollInquiryStatusEnums::instance );
  enumsByTag.emplace( FieldCollInquiryStatus::TAG, & CollInquiryStatusEnums::instance );

  FieldCollInquiryResult::enumItems = CollInquiryResultEnums::items;
  enumsByRaw.emplace( FieldCollInquiryResult::RAW_TAG, & CollInquiryResultEnums::instance );
  enumsByTag.emplace( FieldCollInquiryResult::TAG, & CollInquiryResultEnums::instance );
  return 1;
}

volatile int initIndicator = initStatics();
#pragma GCC pop_options
// end of Fields.cxx

// May be used to check whther raw_enum_t to hold uniquely all enum items for each enum field.
void checkEnums()
{
    for( auto it : enumsByRaw )
    {
        const FieldEnumsBase * enums = it.second;
        const FieldEnumMap & emap =  enums->getEnumMapByRaw();
        auto mapSz = emap.size();
        std::size_t enumCount = 0;
        for( const FieldEnumBase * const * eptr = enums->getEnums(); eptr && *eptr; ++eptr )
        {
            ++enumCount;
        }
        
        if( enumCount != mapSz )
        {
            std::cerr << "Enum size mismatch " << enums->getFieldName() << " no.items=" << enumCount << " map.size=" << mapSz << std::endl;
            FieldEnumMap knownEnums;
            for( const FieldEnumBase * const * eptr = enums->getEnums(); eptr && *eptr; ++eptr )
            {
                auto it = knownEnums.find( (*eptr)->raw );
                if( it == knownEnums.end() )
                {
                    knownEnums[ (*eptr)->raw ] = *eptr; 
                }
                else
                {
                    std::cerr << " - " << (*eptr)->name << " : " << (*eptr)->raw << "    |    " << it->second->name << " : " << it->second->raw << std::endl;
                }
            }
        }
    }
}

} // namespace fix44
