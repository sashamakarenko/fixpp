
// Generated by https://github.com/sashamakarenko/fixpp
// Copyright (c) 2021 sashamakarenko
// https://github.com/sashamakarenko/fixpp/blob/main/LICENSE

#include <order/Groups.h>

namespace order
{

// start of GroupSanity.cxx

// Generated

// ---------------------------------- findBadGroup ---------------------------------
const char * GroupLegStipulations::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartySubIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth(); }
   }
   return nullptr;
}

const char * GroupLegs::findBadGroup( unsigned & noExpected, unsigned & noReceived ) const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoLegStipulations.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoLegStipulations.offset );
     unsigned received = 0;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth(); }
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     unsigned expected = fromString<unsigned>( _fixPtr + fieldNoNestedPartyIDs.offset );
     unsigned received = 0;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * badSubgroup = g.findBadGroup( noExpected, noReceived );
       if( badSubgroup ) return badSubgroup;
       ++received;
     }
     if( expected != received ) { noExpected = expected; noReceived = received; return _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth(); }
   }
   return nullptr;
}

// ---------------------------------- findBadField ---------------------------------
const char * GroupLegStipulations::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegStipulationValue.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegStipulationValue.offset - 1 - FieldLegStipulationValue::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegStipulationValue.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartySubIDType.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartySubIDType.offset - 1 - FieldNestedPartySubIDType::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartySubIDType.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNestedPartyIDSource.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyIDSource.offset - 1 - FieldNestedPartyIDSource::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyIDSource.offset] == 1 ) return tagPtr;
   }
   if( fieldNestedPartyRole.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldNestedPartyRole.offset - 1 - FieldNestedPartyRole::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldNestedPartyRole.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartySubIDs.offset - 1 - FieldNoNestedPartySubIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartySubIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupLegs::findBadField() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldLegSide.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegSide.offset - 1 - FieldLegSide::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegSide.offset] == 1 ) return tagPtr;
   }
   if( fieldLegQty.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegQty.offset - 1 - FieldLegQty::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegQty.offset] == 1 ) return tagPtr;
   }
   if( fieldNoLegStipulations.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoLegStipulations.offset - 1 - FieldNoLegStipulations::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoLegStipulations.offset] == 1 ) return tagPtr;
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegPositionEffect.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPositionEffect.offset - 1 - FieldLegPositionEffect::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPositionEffect.offset] == 1 ) return tagPtr;
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     const char * tagPtr = _fixPtr + fieldNoNestedPartyIDs.offset - 1 - FieldNoNestedPartyIDs::tagWidth();
     if( not isGoodTag( tagPtr ) or _fixPtr[fieldNoNestedPartyIDs.offset] == 1 ) return tagPtr;
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       tagPtr = g.findBadField();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldLegRefID.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegRefID.offset - 1 - FieldLegRefID::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegRefID.offset] == 1 ) return tagPtr;
   }
   if( fieldLegPrice.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegPrice.offset - 1 - FieldLegPrice::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegPrice.offset] == 1 ) return tagPtr;
   }
   if( fieldLegLastPx.offset > 0 ){
       const char * tagPtr = _fixPtr + fieldLegLastPx.offset - 1 - FieldLegLastPx::tagWidth();
       if( not isGoodTag( tagPtr ) or _fixPtr[fieldLegLastPx.offset] == 1 ) return tagPtr;
   }
   return nullptr;
}

// ---------------------------------- findBadEnum ---------------------------------
const char * GroupLegStipulations::findBadEnum() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartySubIDs::findBadEnum() const {
   if( _fixPtr == nullptr ) return nullptr;
   return nullptr;
}

const char * GroupNestedPartyIDs::findBadEnum() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoNestedPartySubIDs.offset > 0 ){
     for( auto & g : groupsNestedPartySubIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * tagPtr = g.findBadEnum();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}

const char * GroupLegs::findBadEnum() const {
   if( _fixPtr == nullptr ) return nullptr;
   if( fieldNoLegStipulations.offset > 0 ){
     for( auto & g : groupsLegStipulations ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * tagPtr = g.findBadEnum();
       if( tagPtr ) return tagPtr;
     }
   }
   if( fieldNoNestedPartyIDs.offset > 0 ){
     for( auto & g : groupsNestedPartyIDs ){
       if( g.getMessageBuffer() == nullptr ) break;
       const char * tagPtr = g.findBadEnum();
       if( tagPtr ) return tagPtr;
     }
   }
   return nullptr;
}
// end of GroupSanity.cxx

} // namespace order
